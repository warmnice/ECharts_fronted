/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@vue/devtools-api/lib/esm/const.js":
/*!*********************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/const.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HOOK_PLUGIN_SETTINGS_SET: () => (/* binding */ HOOK_PLUGIN_SETTINGS_SET),
/* harmony export */   HOOK_SETUP: () => (/* binding */ HOOK_SETUP)
/* harmony export */ });
const HOOK_SETUP = 'devtools-plugin:setup';
const HOOK_PLUGIN_SETTINGS_SET = 'plugin:settings:set';

/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/env.js":
/*!*******************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/env.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getDevtoolsGlobalHook: () => (/* binding */ getDevtoolsGlobalHook),
/* harmony export */   getTarget: () => (/* binding */ getTarget),
/* harmony export */   isProxyAvailable: () => (/* binding */ isProxyAvailable)
/* harmony export */ });
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
  // @ts-ignore
  return typeof navigator !== 'undefined' && typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : {};
}
const isProxyAvailable = typeof Proxy === 'function';

/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isPerformanceSupported: () => (/* reexport safe */ _time_js__WEBPACK_IMPORTED_MODULE_0__.isPerformanceSupported),
/* harmony export */   now: () => (/* reexport safe */ _time_js__WEBPACK_IMPORTED_MODULE_0__.now),
/* harmony export */   setupDevtoolsPlugin: () => (/* binding */ setupDevtoolsPlugin)
/* harmony export */ });
/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./env.js */ "./node_modules/@vue/devtools-api/lib/esm/env.js");
/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./const.js */ "./node_modules/@vue/devtools-api/lib/esm/const.js");
/* harmony import */ var _proxy_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proxy.js */ "./node_modules/@vue/devtools-api/lib/esm/proxy.js");
/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time.js */ "./node_modules/@vue/devtools-api/lib/esm/time.js");






function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const descriptor = pluginDescriptor;
  const target = (0,_env_js__WEBPACK_IMPORTED_MODULE_1__.getTarget)();
  const hook = (0,_env_js__WEBPACK_IMPORTED_MODULE_1__.getDevtoolsGlobalHook)();
  const enableProxy = _env_js__WEBPACK_IMPORTED_MODULE_1__.isProxyAvailable && descriptor.enableEarlyProxy;
  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
    hook.emit(_const_js__WEBPACK_IMPORTED_MODULE_2__.HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const proxy = enableProxy ? new _proxy_js__WEBPACK_IMPORTED_MODULE_3__.ApiProxy(descriptor, hook) : null;
    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
    list.push({
      pluginDescriptor: descriptor,
      setupFn,
      proxy
    });
    if (proxy) setupFn(proxy.proxiedTarget);
  }
}

/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/proxy.js":
/*!*********************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/proxy.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ApiProxy: () => (/* binding */ ApiProxy)
/* harmony export */ });
/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./const.js */ "./node_modules/@vue/devtools-api/lib/esm/const.js");
/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time.js */ "./node_modules/@vue/devtools-api/lib/esm/time.js");


class ApiProxy {
  constructor(plugin, hook) {
    this.target = null;
    this.targetQueue = [];
    this.onQueue = [];
    this.plugin = plugin;
    this.hook = hook;
    const defaultSettings = {};
    if (plugin.settings) {
      for (const id in plugin.settings) {
        const item = plugin.settings[id];
        defaultSettings[id] = item.defaultValue;
      }
    }
    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
    let currentSettings = Object.assign({}, defaultSettings);
    try {
      const raw = localStorage.getItem(localSettingsSaveId);
      const data = JSON.parse(raw);
      Object.assign(currentSettings, data);
    } catch (e) {
      // noop
    }
    this.fallbacks = {
      getSettings() {
        return currentSettings;
      },
      setSettings(value) {
        try {
          localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
        } catch (e) {
          // noop
        }
        currentSettings = value;
      },
      now() {
        return (0,_time_js__WEBPACK_IMPORTED_MODULE_0__.now)();
      }
    };
    if (hook) {
      hook.on(_const_js__WEBPACK_IMPORTED_MODULE_1__.HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
        if (pluginId === this.plugin.id) {
          this.fallbacks.setSettings(value);
        }
      });
    }
    this.proxiedOn = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target.on[prop];
        } else {
          return (...args) => {
            this.onQueue.push({
              method: prop,
              args
            });
          };
        }
      }
    });
    this.proxiedTarget = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target[prop];
        } else if (prop === 'on') {
          return this.proxiedOn;
        } else if (Object.keys(this.fallbacks).includes(prop)) {
          return (...args) => {
            this.targetQueue.push({
              method: prop,
              args,
              resolve: () => {}
            });
            return this.fallbacks[prop](...args);
          };
        } else {
          return (...args) => {
            return new Promise(resolve => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve
              });
            });
          };
        }
      }
    });
  }
  async setRealTarget(target) {
    this.target = target;
    for (const item of this.onQueue) {
      this.target.on[item.method](...item.args);
    }
    for (const item of this.targetQueue) {
      item.resolve(await this.target[item.method](...item.args));
    }
  }
}

/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/time.js":
/*!********************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/time.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isPerformanceSupported: () => (/* binding */ isPerformanceSupported),
/* harmony export */   now: () => (/* binding */ now)
/* harmony export */ });
let supported;
let perf;
function isPerformanceSupported() {
  var _a;
  if (supported !== undefined) {
    return supported;
  }
  if (typeof window !== 'undefined' && window.performance) {
    supported = true;
    perf = window.performance;
  } else if (typeof __webpack_require__.g !== 'undefined' && ((_a = __webpack_require__.g.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
    supported = true;
    perf = __webpack_require__.g.perf_hooks.performance;
  } else {
    supported = false;
  }
  return supported;
}
function now() {
  return isPerformanceSupported() ? perf.now() : Date.now();
}

/***/ }),

/***/ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EffectScope: () => (/* binding */ EffectScope),
/* harmony export */   ITERATE_KEY: () => (/* binding */ ITERATE_KEY),
/* harmony export */   ReactiveEffect: () => (/* binding */ ReactiveEffect),
/* harmony export */   computed: () => (/* binding */ computed),
/* harmony export */   customRef: () => (/* binding */ customRef),
/* harmony export */   deferredComputed: () => (/* binding */ deferredComputed),
/* harmony export */   effect: () => (/* binding */ effect),
/* harmony export */   effectScope: () => (/* binding */ effectScope),
/* harmony export */   enableTracking: () => (/* binding */ enableTracking),
/* harmony export */   getCurrentScope: () => (/* binding */ getCurrentScope),
/* harmony export */   isProxy: () => (/* binding */ isProxy),
/* harmony export */   isReactive: () => (/* binding */ isReactive),
/* harmony export */   isReadonly: () => (/* binding */ isReadonly),
/* harmony export */   isRef: () => (/* binding */ isRef),
/* harmony export */   isShallow: () => (/* binding */ isShallow),
/* harmony export */   markRaw: () => (/* binding */ markRaw),
/* harmony export */   onScopeDispose: () => (/* binding */ onScopeDispose),
/* harmony export */   pauseTracking: () => (/* binding */ pauseTracking),
/* harmony export */   proxyRefs: () => (/* binding */ proxyRefs),
/* harmony export */   reactive: () => (/* binding */ reactive),
/* harmony export */   readonly: () => (/* binding */ readonly),
/* harmony export */   ref: () => (/* binding */ ref),
/* harmony export */   resetTracking: () => (/* binding */ resetTracking),
/* harmony export */   shallowReactive: () => (/* binding */ shallowReactive),
/* harmony export */   shallowReadonly: () => (/* binding */ shallowReadonly),
/* harmony export */   shallowRef: () => (/* binding */ shallowRef),
/* harmony export */   stop: () => (/* binding */ stop),
/* harmony export */   toRaw: () => (/* binding */ toRaw),
/* harmony export */   toRef: () => (/* binding */ toRef),
/* harmony export */   toRefs: () => (/* binding */ toRefs),
/* harmony export */   toValue: () => (/* binding */ toValue),
/* harmony export */   track: () => (/* binding */ track),
/* harmony export */   trigger: () => (/* binding */ trigger),
/* harmony export */   triggerRef: () => (/* binding */ triggerRef),
/* harmony export */   unref: () => (/* binding */ unref)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");

function warn(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    /**
     * @internal
     */
    this._active = true;
    /**
     * @internal
     */
    this.effects = [];
    /**
     * @internal
     */
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else if (true) {
      warn(`cannot run an inactive effect scope.`);
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  } else if (true) {
    warn(`onScopeDispose() is called when there is no active effect scope to be associated with.`);
  }
}
const createDep = effects => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = dep => (dep.w & trackOpBit) > 0;
const newTracked = dep => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({
  deps
}) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = effect => {
  const {
    deps
  } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol( true ? "iterate" : 0);
const MAP_KEY_ITERATE_KEY = Symbol( true ? "Map key iterate" : 0);
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect2) {
  const {
    deps
  } = effect2;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect2);
    }
    deps.length = 0;
  }
}
function effect(fn, options) {
  if (fn.effect instanceof ReactiveEffect) {
    fn = fn.effect.fn;
  }
  const _effect = new ReactiveEffect(fn);
  if (options) {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(_effect, options);
    if (options.scope) recordEffectScope(_effect, options.scope);
  }
  if (!options || !options.lazy) {
    _effect.run();
  }
  const runner = _effect.run.bind(_effect);
  runner.effect = _effect;
  return runner;
}
function stop(runner) {
  runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    const eventInfo =  true ? {
      effect: activeEffect,
      target,
      type,
      key
    } : 0;
    trackEffects(dep, eventInfo);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
    if ( true && activeEffect.onTrack) {
      activeEffect.onTrack((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({
        effect: activeEffect
      }, debuggerEventExtraInfo));
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key2) && key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  const eventInfo =  true ? {
    target,
    type,
    key,
    newValue,
    oldValue,
    oldTarget
  } : 0;
  if (deps.length === 1) {
    if (deps[0]) {
      if (true) {
        triggerEffects(deps[0], eventInfo);
      } else {}
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    if (true) {
      triggerEffects(createDep(effects), eventInfo);
    } else {}
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(dep) ? dep : [...dep];
  for (const effect2 of effects) {
    if (effect2.computed) {
      triggerEffect(effect2, debuggerEventExtraInfo);
    }
  }
  for (const effect2 of effects) {
    if (!effect2.computed) {
      triggerEffect(effect2, debuggerEventExtraInfo);
    }
  }
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
  if (effect2 !== activeEffect || effect2.allowRecurse) {
    if ( true && effect2.onTrigger) {
      effect2.onTrigger((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({
        effect: effect2
      }, debuggerEventExtraInfo));
    }
    if (effect2.scheduler) {
      effect2.scheduler();
    } else {
      effect2.run();
    }
  }
}
function getDepFromReactive(object, key) {
  var _a;
  return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);
}
const isNonTrackableKeys = /* @__PURE__ */(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set( /* @__PURE__ */Object.getOwnPropertyNames(Symbol).filter(key => key !== "arguments" && key !== "caller").map(key => Symbol[key]).filter(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol));
const arrayInstrumentations = /* @__PURE__ */createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach(key => {
    instrumentations[key] = function (...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach(key => {
    instrumentations[key] = function (...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _shallow = false) {
    this._isReadonly = _isReadonly;
    this._shallow = _shallow;
  }
  get(target, key, receiver) {
    const isReadonly2 = this._isReadonly,
      shallow = this._shallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target);
    if (!isReadonly2) {
      if (targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key) ? res : res.value;
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(shallow = false) {
    super(false, shallow);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!this._shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key) ? Number(key) < target.length : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(target, "iterate", (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) ? "length" : ITERATE_KEY);
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(shallow = false) {
    super(true, shallow);
  }
  set(target, key) {
    if (true) {
      warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  }
  deleteProperty(target, key) {
    if (true) {
      warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */new ReadonlyReactiveHandler(true);
const toShallow = value => value;
const getProto = v => Reflect.getPrototypeOf(v);
function get(target, key, isReadonly = false, isShallow = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(key, rawKey)) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const {
    has: has2
  } = getProto(rawTarget);
  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(key, rawKey)) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly = false) {
  target = target["__v_raw"];
  !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const {
    has: has2,
    get: get2
  } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (true) {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
    trigger(target, "set", key, value, oldValue);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const {
    has: has2,
    get: get2
  } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (true) {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget =  true ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target) ? new Map(target) : new Set(target) : 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach(isReadonly, isShallow) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly, isShallow) {
  return function (...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      // iterator protocol
      next() {
        const {
          value,
          done
        } = innerIterator.next();
        return done ? {
          value,
          done
        } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function (...args) {
    if (true) {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      console.warn(`${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)(type)} operation ${key}failed: target is readonly.`, toRaw(this));
    }
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach(method => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [mutableInstrumentations2, readonlyInstrumentations2, shallowInstrumentations2, shallowReadonlyInstrumentations2];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */createInstrumentations();
function createInstrumentationGetter(isReadonly, shallow) {
  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly;
    } else if (key === "__v_isReadonly") {
      return isReadonly;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has2, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has2.call(target, rawKey)) {
    const type = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(target);
    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
const reactiveMap = /* @__PURE__ */new WeakMap();
const shallowReactiveMap = /* @__PURE__ */new WeakMap();
const readonlyMap = /* @__PURE__ */new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1 /* COMMON */;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2 /* COLLECTION */;
    default:
      return 0 /* INVALID */;
  }
}

function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function shallowReadonly(target) {
  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {
    if (true) {
      console.warn(`value cannot be made reactive: ${String(target)}`);
    }
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0 /* INVALID */) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.def)(value, "__v_skip", true);
  return value;
}
const toReactive = value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? reactive(value) : value;
const toReadonly = value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    if (true) {
      trackEffects(ref2.dep || (ref2.dep = createDep()), {
        target: ref2,
        type: "get",
        key: "value"
      });
    } else {}
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    if (true) {
      triggerEffects(dep, {
        target: ref2,
        type: "set",
        key: "value",
        newValue: newVal
      });
    } else {}
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this, newVal);
    }
  }
}
function triggerRef(ref2) {
  triggerRefValue(ref2,  true ? ref2.value : 0);
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
function toValue(source) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(source) ? source() : unref(source);
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this.dep = void 0;
    this.__v_isRef = true;
    const {
      get,
      set
    } = factory(() => trackRefValue(this), () => triggerRefValue(this));
    this._get = get;
    this._set = set;
  }
  get value() {
    return this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object) {
  if ( true && !isProxy(object)) {
    console.warn(`toRefs() expects a reactive object but received a plain one.`);
  }
  const ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this.__v_isRef = true;
    this.__v_isReadonly = true;
  }
  get value() {
    return this._getter();
  }
}
function toRef(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(source)) {
    return new GetterRefImpl(source);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly;
  }
  get value() {
    const self = toRaw(this);
    trackRefValue(self);
    if (self._dirty || !self._cacheable) {
      self._dirty = false;
      self._value = self.effect.run();
    }
    return self._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter =  true ? () => {
      console.warn("Write operation failed: computed value is readonly");
    } : 0;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  if ( true && debugOptions && !isSSR) {
    cRef.effect.onTrack = debugOptions.onTrack;
    cRef.effect.onTrigger = debugOptions.onTrigger;
  }
  return cRef;
}
const tick = /* @__PURE__ */Promise.resolve();
const queue = [];
let queued = false;
const scheduler = fn => {
  queue.push(fn);
  if (!queued) {
    queued = true;
    tick.then(flush);
  }
};
const flush = () => {
  for (let i = 0; i < queue.length; i++) {
    queue[i]();
  }
  queue.length = 0;
  queued = false;
};
class DeferredComputedRefImpl {
  constructor(getter) {
    this.dep = void 0;
    this._dirty = true;
    this.__v_isRef = true;
    this["__v_isReadonly"] = true;
    let compareTarget;
    let hasCompareTarget = false;
    let scheduled = false;
    this.effect = new ReactiveEffect(getter, computedTrigger => {
      if (this.dep) {
        if (computedTrigger) {
          compareTarget = this._value;
          hasCompareTarget = true;
        } else if (!scheduled) {
          const valueToCompare = hasCompareTarget ? compareTarget : this._value;
          scheduled = true;
          hasCompareTarget = false;
          scheduler(() => {
            if (this.effect.active && this._get() !== valueToCompare) {
              triggerRefValue(this);
            }
            scheduled = false;
          });
        }
        for (const e of this.dep) {
          if (e.computed instanceof DeferredComputedRefImpl) {
            e.scheduler(true
            /* computedTrigger */);
          }
        }
      }

      this._dirty = true;
    });
    this.effect.computed = this;
  }
  _get() {
    if (this._dirty) {
      this._dirty = false;
      return this._value = this.effect.run();
    }
    return this._value;
  }
  get value() {
    trackRefValue(this);
    return toRaw(this)._get();
  }
}
function deferredComputed(getter) {
  return new DeferredComputedRefImpl(getter);
}


/***/ }),

/***/ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseTransition: () => (/* binding */ BaseTransition),
/* harmony export */   BaseTransitionPropsValidators: () => (/* binding */ BaseTransitionPropsValidators),
/* harmony export */   Comment: () => (/* binding */ Comment),
/* harmony export */   EffectScope: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   Fragment: () => (/* binding */ Fragment),
/* harmony export */   KeepAlive: () => (/* binding */ KeepAlive),
/* harmony export */   ReactiveEffect: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   Static: () => (/* binding */ Static),
/* harmony export */   Suspense: () => (/* binding */ Suspense),
/* harmony export */   Teleport: () => (/* binding */ Teleport),
/* harmony export */   Text: () => (/* binding */ Text),
/* harmony export */   assertNumber: () => (/* binding */ assertNumber),
/* harmony export */   callWithAsyncErrorHandling: () => (/* binding */ callWithAsyncErrorHandling),
/* harmony export */   callWithErrorHandling: () => (/* binding */ callWithErrorHandling),
/* harmony export */   camelize: () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize),
/* harmony export */   capitalize: () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize),
/* harmony export */   cloneVNode: () => (/* binding */ cloneVNode),
/* harmony export */   compatUtils: () => (/* binding */ compatUtils),
/* harmony export */   computed: () => (/* binding */ computed),
/* harmony export */   createBlock: () => (/* binding */ createBlock),
/* harmony export */   createCommentVNode: () => (/* binding */ createCommentVNode),
/* harmony export */   createElementBlock: () => (/* binding */ createElementBlock),
/* harmony export */   createElementVNode: () => (/* binding */ createBaseVNode),
/* harmony export */   createHydrationRenderer: () => (/* binding */ createHydrationRenderer),
/* harmony export */   createPropsRestProxy: () => (/* binding */ createPropsRestProxy),
/* harmony export */   createRenderer: () => (/* binding */ createRenderer),
/* harmony export */   createSlots: () => (/* binding */ createSlots),
/* harmony export */   createStaticVNode: () => (/* binding */ createStaticVNode),
/* harmony export */   createTextVNode: () => (/* binding */ createTextVNode),
/* harmony export */   createVNode: () => (/* binding */ createVNode),
/* harmony export */   customRef: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   defineAsyncComponent: () => (/* binding */ defineAsyncComponent),
/* harmony export */   defineComponent: () => (/* binding */ defineComponent),
/* harmony export */   defineEmits: () => (/* binding */ defineEmits),
/* harmony export */   defineExpose: () => (/* binding */ defineExpose),
/* harmony export */   defineModel: () => (/* binding */ defineModel),
/* harmony export */   defineOptions: () => (/* binding */ defineOptions),
/* harmony export */   defineProps: () => (/* binding */ defineProps),
/* harmony export */   defineSlots: () => (/* binding */ defineSlots),
/* harmony export */   devtools: () => (/* binding */ devtools),
/* harmony export */   effect: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   effectScope: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   getCurrentInstance: () => (/* binding */ getCurrentInstance),
/* harmony export */   getCurrentScope: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   getTransitionRawChildren: () => (/* binding */ getTransitionRawChildren),
/* harmony export */   guardReactiveProps: () => (/* binding */ guardReactiveProps),
/* harmony export */   h: () => (/* binding */ h),
/* harmony export */   handleError: () => (/* binding */ handleError),
/* harmony export */   hasInjectionContext: () => (/* binding */ hasInjectionContext),
/* harmony export */   initCustomFormatter: () => (/* binding */ initCustomFormatter),
/* harmony export */   inject: () => (/* binding */ inject),
/* harmony export */   isMemoSame: () => (/* binding */ isMemoSame),
/* harmony export */   isProxy: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   isReactive: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   isReadonly: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   isRef: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   isRuntimeOnly: () => (/* binding */ isRuntimeOnly),
/* harmony export */   isShallow: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   isVNode: () => (/* binding */ isVNode),
/* harmony export */   markRaw: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   mergeDefaults: () => (/* binding */ mergeDefaults),
/* harmony export */   mergeModels: () => (/* binding */ mergeModels),
/* harmony export */   mergeProps: () => (/* binding */ mergeProps),
/* harmony export */   nextTick: () => (/* binding */ nextTick),
/* harmony export */   normalizeClass: () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass),
/* harmony export */   normalizeProps: () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeProps),
/* harmony export */   normalizeStyle: () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle),
/* harmony export */   onActivated: () => (/* binding */ onActivated),
/* harmony export */   onBeforeMount: () => (/* binding */ onBeforeMount),
/* harmony export */   onBeforeUnmount: () => (/* binding */ onBeforeUnmount),
/* harmony export */   onBeforeUpdate: () => (/* binding */ onBeforeUpdate),
/* harmony export */   onDeactivated: () => (/* binding */ onDeactivated),
/* harmony export */   onErrorCaptured: () => (/* binding */ onErrorCaptured),
/* harmony export */   onMounted: () => (/* binding */ onMounted),
/* harmony export */   onRenderTracked: () => (/* binding */ onRenderTracked),
/* harmony export */   onRenderTriggered: () => (/* binding */ onRenderTriggered),
/* harmony export */   onScopeDispose: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   onServerPrefetch: () => (/* binding */ onServerPrefetch),
/* harmony export */   onUnmounted: () => (/* binding */ onUnmounted),
/* harmony export */   onUpdated: () => (/* binding */ onUpdated),
/* harmony export */   openBlock: () => (/* binding */ openBlock),
/* harmony export */   popScopeId: () => (/* binding */ popScopeId),
/* harmony export */   provide: () => (/* binding */ provide),
/* harmony export */   proxyRefs: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   pushScopeId: () => (/* binding */ pushScopeId),
/* harmony export */   queuePostFlushCb: () => (/* binding */ queuePostFlushCb),
/* harmony export */   reactive: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   readonly: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   ref: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   registerRuntimeCompiler: () => (/* binding */ registerRuntimeCompiler),
/* harmony export */   renderList: () => (/* binding */ renderList),
/* harmony export */   renderSlot: () => (/* binding */ renderSlot),
/* harmony export */   resolveComponent: () => (/* binding */ resolveComponent),
/* harmony export */   resolveDirective: () => (/* binding */ resolveDirective),
/* harmony export */   resolveDynamicComponent: () => (/* binding */ resolveDynamicComponent),
/* harmony export */   resolveFilter: () => (/* binding */ resolveFilter),
/* harmony export */   resolveTransitionHooks: () => (/* binding */ resolveTransitionHooks),
/* harmony export */   setBlockTracking: () => (/* binding */ setBlockTracking),
/* harmony export */   setDevtoolsHook: () => (/* binding */ setDevtoolsHook),
/* harmony export */   setTransitionHooks: () => (/* binding */ setTransitionHooks),
/* harmony export */   shallowReactive: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   shallowReadonly: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   shallowRef: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   ssrContextKey: () => (/* binding */ ssrContextKey),
/* harmony export */   ssrUtils: () => (/* binding */ ssrUtils),
/* harmony export */   stop: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   toDisplayString: () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toDisplayString),
/* harmony export */   toHandlerKey: () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey),
/* harmony export */   toHandlers: () => (/* binding */ toHandlers),
/* harmony export */   toRaw: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   toRef: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   toRefs: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   toValue: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toValue),
/* harmony export */   transformVNodeArgs: () => (/* binding */ transformVNodeArgs),
/* harmony export */   triggerRef: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   unref: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   useAttrs: () => (/* binding */ useAttrs),
/* harmony export */   useModel: () => (/* binding */ useModel),
/* harmony export */   useSSRContext: () => (/* binding */ useSSRContext),
/* harmony export */   useSlots: () => (/* binding */ useSlots),
/* harmony export */   useTransitionState: () => (/* binding */ useTransitionState),
/* harmony export */   version: () => (/* binding */ version),
/* harmony export */   warn: () => (/* binding */ warn),
/* harmony export */   watch: () => (/* binding */ watch),
/* harmony export */   watchEffect: () => (/* binding */ watchEffect),
/* harmony export */   watchPostEffect: () => (/* binding */ watchPostEffect),
/* harmony export */   watchSyncEffect: () => (/* binding */ watchSyncEffect),
/* harmony export */   withAsyncContext: () => (/* binding */ withAsyncContext),
/* harmony export */   withCtx: () => (/* binding */ withCtx),
/* harmony export */   withDefaults: () => (/* binding */ withDefaults),
/* harmony export */   withDirectives: () => (/* binding */ withDirectives),
/* harmony export */   withMemo: () => (/* binding */ withMemo),
/* harmony export */   withScopeId: () => (/* binding */ withScopeId)
/* harmony export */ });
/* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/reactivity */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");




const stack = [];
function pushWarningContext(vnode) {
  stack.push(vnode);
}
function popWarningContext() {
  stack.pop();
}
function warn(msg, ...args) {
  if (false) {}
  (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(appWarnHandler, instance, 11, [msg + args.join(""), instance && instance.proxy, trace.map(({
      vnode
    }) => `at <${formatComponentName(instance, vnode.type)}>`).join("\n"), trace]);
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length &&
    // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...(i === 0 ? [] : [`
`]), ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({
  vnode,
  recurseCount
}) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach(key => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
    value = formatProp(key, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value);
    return raw ? value : [`${key}=`, value];
  }
}
function assertNumber(val, type) {
  if (false) {}
  if (val === void 0) {
    return;
  } else if (typeof val !== "number") {
    warn(`${type} is not a valid number - got ${JSON.stringify(val)}.`);
  } else if (isNaN(val)) {
    warn(`${type} is NaN - the duration expression might be incorrect.`);
  }
}
const ErrorTypeStrings = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(res)) {
      res.catch(err => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo =  true ? ErrorTypeStrings[type] : 0;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  if (true) {
    const info = ErrorTypeStrings[type];
    if (contextVNode) {
      pushWarningContext(contextVNode);
    }
    warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
    if (contextVNode) {
      popWarningContext();
    }
    if (throwInDev) {
      throw err;
    } else {
      console.error(err);
    }
  } else {}
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */Promise.resolve();
let currentFlushPromise = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
  const p = currentFlushPromise || resolvedPromise;
  return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.pre) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {
  if (true) {
    seen = seen || /* @__PURE__ */new Map();
  }
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.pre) {
      if ( true && checkRecursiveUpdates(seen, cb)) {
        continue;
      }
      queue.splice(i, 1);
      i--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    if (true) {
      seen = seen || /* @__PURE__ */new Map();
    }
    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      if ( true && checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
        continue;
      }
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = job => job.id == null ? Infinity : job.id;
const comparator = (a, b) => {
  const diff = getId(a) - getId(b);
  if (diff === 0) {
    if (a.pre && !b.pre) return -1;
    if (b.pre && !a.pre) return 1;
  }
  return diff;
};
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  if (true) {
    seen = seen || /* @__PURE__ */new Map();
  }
  queue.sort(comparator);
  const check =  true ? job => checkRecursiveUpdates(seen, job) : 0;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if ( true && check(job)) {
          continue;
        }
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs(seen);
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
function checkRecursiveUpdates(seen, fn) {
  if (!seen.has(fn)) {
    seen.set(fn, 1);
  } else {
    const count = seen.get(fn);
    if (count > RECURSION_LIMIT) {
      const instance = fn.ownerInstance;
      const componentName = instance && getComponentName(instance.type);
      warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`);
      return true;
    } else {
      seen.set(fn, count + 1);
    }
  }
}
let isHmrUpdating = false;
const hmrDirtyComponents = /* @__PURE__ */new Set();
if (true) {
  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
  };
}
const map = /* @__PURE__ */new Map();
function registerHMR(instance) {
  const id = instance.type.__hmrId;
  let record = map.get(id);
  if (!record) {
    createRecord(id, instance.type);
    record = map.get(id);
  }
  record.instances.add(instance);
}
function unregisterHMR(instance) {
  map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, initialDef) {
  if (map.has(id)) {
    return false;
  }
  map.set(id, {
    initialDef: normalizeClassComponent(initialDef),
    instances: /* @__PURE__ */new Set()
  });
  return true;
}
function normalizeClassComponent(component) {
  return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
  const record = map.get(id);
  if (!record) {
    return;
  }
  record.initialDef.render = newRender;
  [...record.instances].forEach(instance => {
    if (newRender) {
      instance.render = newRender;
      normalizeClassComponent(instance.type).render = newRender;
    }
    instance.renderCache = [];
    isHmrUpdating = true;
    instance.update();
    isHmrUpdating = false;
  });
}
function reload(id, newComp) {
  const record = map.get(id);
  if (!record) return;
  newComp = normalizeClassComponent(newComp);
  updateComponentDef(record.initialDef, newComp);
  const instances = [...record.instances];
  for (const instance of instances) {
    const oldComp = normalizeClassComponent(instance.type);
    if (!hmrDirtyComponents.has(oldComp)) {
      if (oldComp !== record.initialDef) {
        updateComponentDef(oldComp, newComp);
      }
      hmrDirtyComponents.add(oldComp);
    }
    instance.appContext.propsCache.delete(instance.type);
    instance.appContext.emitsCache.delete(instance.type);
    instance.appContext.optionsCache.delete(instance.type);
    if (instance.ceReload) {
      hmrDirtyComponents.add(oldComp);
      instance.ceReload(newComp.styles);
      hmrDirtyComponents.delete(oldComp);
    } else if (instance.parent) {
      queueJob(instance.parent.update);
    } else if (instance.appContext.reload) {
      instance.appContext.reload();
    } else if (typeof window !== "undefined") {
      window.location.reload();
    } else {
      console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
    }
  }
  queuePostFlushCb(() => {
    for (const instance of instances) {
      hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
    }
  });
}
function updateComponentDef(oldComp, newComp) {
  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(oldComp, newComp);
  for (const key in oldComp) {
    if (key !== "__file" && !(key in newComp)) {
      delete oldComp[key];
    }
  }
}
function tryWrap(fn) {
  return (id, arg) => {
    try {
      return fn(id, arg);
    } catch (e) {
      console.error(e);
      console.warn(`[HMR] Something went wrong during Vue component hot-reload. Full reload required.`);
    }
  };
}
let devtools;
let buffer = [];
let devtoolsNotInstalled = false;
function emit$1(event, ...args) {
  if (devtools) {
    devtools.emit(event, ...args);
  } else if (!devtoolsNotInstalled) {
    buffer.push({
      event,
      args
    });
  }
}
function setDevtoolsHook(hook, target) {
  var _a, _b;
  devtools = hook;
  if (devtools) {
    devtools.enabled = true;
    buffer.forEach(({
      event,
      args
    }) => devtools.emit(event, ...args));
    buffer = [];
  } else if (
  // handle late devtools injection - only do this if we are in an actual
  // browser environment to avoid the timer handle stalling test runner exit
  // (#4815)
  typeof window !== "undefined" &&
  // some envs mock window but not fully
  window.HTMLElement &&
  // also exclude jsdom
  !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push(newHook => {
      setDevtoolsHook(newHook, target);
    });
    setTimeout(() => {
      if (!devtools) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }, 3e3);
  } else {
    devtoolsNotInstalled = true;
    buffer = [];
  }
}
function devtoolsInitApp(app, version) {
  emit$1("app:init" /* APP_INIT */, app, version, {
    Fragment,
    Text,
    Comment,
    Static
  });
}
function devtoolsUnmountApp(app) {
  emit$1("app:unmount" /* APP_UNMOUNT */, app);
}
const devtoolsComponentAdded = /* @__PURE__ */createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */);

const devtoolsComponentUpdated = /* @__PURE__ */createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */);
const _devtoolsComponentRemoved = /* @__PURE__ */createDevtoolsComponentHook("component:removed" /* COMPONENT_REMOVED */);

const devtoolsComponentRemoved = component => {
  if (devtools && typeof devtools.cleanupBuffer === "function" &&
  // remove the component if it wasn't buffered
  !devtools.cleanupBuffer(component)) {
    _devtoolsComponentRemoved(component);
  }
};
function createDevtoolsComponentHook(hook) {
  return component => {
    emit$1(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : void 0, component);
  };
}
const devtoolsPerfStart = /* @__PURE__ */createDevtoolsPerformanceHook("perf:start" /* PERFORMANCE_START */);

const devtoolsPerfEnd = /* @__PURE__ */createDevtoolsPerformanceHook("perf:end" /* PERFORMANCE_END */);

function createDevtoolsPerformanceHook(hook) {
  return (component, type, time) => {
    emit$1(hook, component.appContext.app, component.uid, component, type, time);
  };
}
function devtoolsComponentEmit(component, event, params) {
  emit$1("component:emit" /* COMPONENT_EMIT */, component.appContext.app, component, event, params);
}
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted) return;
  const props = instance.vnode.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
  if (true) {
    const {
      emitsOptions,
      propsOptions: [propsOptions]
    } = instance;
    if (emitsOptions) {
      if (!(event in emitsOptions) && true) {
        if (!propsOptions || !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event) in propsOptions)) {
          warn(`Component emitted event "${event}" but it is neither declared in the emits option nor as an "${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event)}" prop.`);
        }
      } else {
        const validator = emitsOptions[event];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(validator)) {
          const isValid = validator(...rawArgs);
          if (!isValid) {
            warn(`Invalid event arguments: event validation failed for event "${event}".`);
          }
        }
      }
    }
  }
  let args = rawArgs;
  const isModelListener = event.startsWith("update:");
  const modelArg = isModelListener && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const {
      number,
      trim
    } = props[modifiersKey] || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map(a => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(a) ? a.trim() : a);
    }
    if (number) {
      args = rawArgs.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseToNumber);
    }
  }
  if (true) {
    devtoolsComponentEmit(instance, event, args);
  }
  if (true) {
    const lowerCaseEvent = event.toLowerCase();
    if (lowerCaseEvent !== event && props[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(lowerCaseEvent)]) {
      warn(`Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event)}" instead of "${event}".`);
    }
  }
  let handlerName;
  let handler = props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event)] ||
  // also try camelCase event handler (#2249)
  props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(event))];
  if (!handler && isModelListener) {
    handler = props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (__VUE_OPTIONS_API__ && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
    const extendEmits = raw2 => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
    raw.forEach(key => normalized[key] = null);
  } else {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, raw);
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = _id => withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    if (true) {
      devtoolsComponentUpdated(ctx);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
let accessedAttrs = false;
function markAttrsAccessed() {
  accessedAttrs = true;
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    props,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit,
    render,
    renderCache,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  if (true) {
    accessedAttrs = false;
  }
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if ( true && attrs === props) {
        markAttrsAccessed();
      }
      result = normalizeVNode(render2.length > 1 ? render2(props,  true ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },
        slots,
        emit
      } : 0) : render2(props, null
      /* we know it doesn't need it */));

      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  let setRoot = void 0;
  if ( true && result.patchFlag > 0 && result.patchFlag & 2048) {
    [root, setRoot] = getChildRoot(result);
  }
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const {
      shapeFlag
    } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root = cloneVNode(root, fallthroughAttrs);
      } else if ( true && !accessedAttrs && root.type !== Comment) {
        const allAttrs = Object.keys(attrs);
        const eventAttrs = [];
        const extraAttrs = [];
        for (let i = 0, l = allAttrs.length; i < l; i++) {
          const key = allAttrs[i];
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
              eventAttrs.push(key[2].toLowerCase() + key.slice(3));
            }
          } else {
            extraAttrs.push(key);
          }
        }
        if (extraAttrs.length) {
          warn(`Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`);
        }
        if (eventAttrs.length) {
          warn(`Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
        }
      }
    }
  }
  if (vnode.dirs) {
    if ( true && !isElementRoot(root)) {
      warn(`Runtime directive used on component with non-element root node. The directives will not function as intended.`);
    }
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    if ( true && !isElementRoot(root)) {
      warn(`Component inside <Transition> renders non-element root node that cannot be animated.`);
    }
    root.transition = vnode.transition;
  }
  if ( true && setRoot) {
    setRoot(root);
  } else {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getChildRoot = vnode => {
  const rawChildren = vnode.children;
  const dynamicChildren = vnode.dynamicChildren;
  const childRoot = filterSingleRoot(rawChildren);
  if (!childRoot) {
    return [vnode, void 0];
  }
  const index = rawChildren.indexOf(childRoot);
  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
  const setRoot = updatedRoot => {
    rawChildren[index] = updatedRoot;
    if (dynamicChildren) {
      if (dynamicIndex > -1) {
        dynamicChildren[dynamicIndex] = updatedRoot;
      } else if (updatedRoot.patchFlag > 0) {
        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
      }
    }
  };
  return [normalizeVNode(childRoot), setRoot];
};
function filterSingleRoot(children) {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = attrs => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
const isElementRoot = vnode => {
  return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const {
    props: prevProps,
    children: prevChildren,
    component
  } = prevVNode;
  const {
    props: nextProps,
    children: nextChildren,
    patchFlag
  } = nextVNode;
  const emits = component.emitsOptions;
  if ( true && (prevChildren || nextChildren) && isHmrUpdating) {
    return true;
  }
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({
  vnode,
  parent
}, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const isSuspense = type => type.__isSuspense;
const SuspenseImpl = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
    } else {
      patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
    }
  },
  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
  const {
    p: patch,
    o: {
      createElement
    }
  } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals);
  patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(null, vnode.ssFallback, container, anchor, parentComponent, null,
    // fallback tree will not have suspense context
    isSVG, slotScopeIds);
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve(false, true);
  }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, {
  p: patch,
  um: unmount,
  o: {
    createElement
  }
}) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const {
    activeBranch,
    pendingBranch,
    isInFallback,
    isHydrating
  } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        patch(activeBranch, newFallback, container, anchor, parentComponent, null,
        // fallback tree will not have suspense context
        isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, newFallback);
      }
    } else {
      suspense.pendingId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement("div");
      if (isInFallback) {
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(activeBranch, newFallback, container, anchor, parentComponent, null,
          // fallback tree will not have suspense context
          isSVG, slotScopeIds, optimized);
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        suspense.resolve(true);
      } else {
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      suspense.pendingId++;
      patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const {
          timeout,
          pendingId
        } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  if ( true && !hasWarned) {
    hasWarned = true;
    console[console.info ? "info" : "log"](`<Suspense> is an experimental feature and its API will likely change.`);
  }
  const {
    p: patch,
    m: move,
    um: unmount,
    n: next,
    o: {
      parentNode,
      remove
    }
  } = rendererInternals;
  let parentSuspenseId;
  const isSuspensible = isVNodeSuspensible(vnode);
  if (isSuspensible) {
    if (parentSuspense == null ? void 0 : parentSuspense.pendingBranch) {
      parentSuspenseId = parentSuspense.pendingId;
      parentSuspense.deps++;
    }
  }
  const timeout = vnode.props ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(vnode.props.timeout) : void 0;
  if (true) {
    assertNumber(timeout, `Suspense timeout`);
  }
  const suspense = {
    vnode,
    parent: parentSuspense,
    parentComponent,
    isSVG,
    container,
    hiddenContainer,
    anchor,
    deps: 0,
    pendingId: 0,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: true,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false, sync = false) {
      if (true) {
        if (!resume && !suspense.pendingBranch) {
          throw new Error(`suspense.resolve() is called without a pending branch.`);
        }
        if (suspense.isUnmounted) {
          throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);
        }
      }
      const {
        vnode: vnode2,
        activeBranch,
        pendingBranch,
        pendingId,
        effects,
        parentComponent: parentComponent2,
        container: container2
      } = suspense;
      let delayEnter = false;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(pendingBranch, container2, anchor2, 0);
              queuePostFlushCb(effects);
            }
          };
        }
        let {
          anchor: anchor2
        } = suspense;
        if (activeBranch) {
          anchor2 = next(activeBranch);
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor2, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent) {
        if (parent.pendingBranch) {
          parent.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent = parent.parent;
      }
      if (!hasUnresolvedAncestor && !delayEnter) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0 && !sync) {
            parentSuspense.resolve();
          }
        }
      }
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const {
        vnode: vnode2,
        activeBranch,
        parentComponent: parentComponent2,
        container: container2,
        isSVG: isSVG2
      } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(null, fallbackVNode, container2, anchor2, parentComponent2, null,
        // fallback tree will not have suspense context
        isSVG2, slotScopeIds, optimized);
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(activeBranch, parentComponent2, null,
      // no suspense so unmount hooks fire now
      true
      // shouldRemove
      );

      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch(err => {
        handleError(err, instance, 0);
      }).then(asyncSetupResult => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const {
          vnode: vnode2
        } = instance;
        if (true) {
          pushWarningContext(vnode2);
        }
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(instance, vnode2,
        // component may have been moved before resolve.
        // if this is not a hydration, instance.subTree will be the comment
        // placeholder.
        parentNode(hydratedEl || instance.subTree.el),
        // anchor will not be used if this is hydration, so only need to
        // consider the comment placeholder case.
        hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
        if (placeholder) {
          remove(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (true) {
          popWarningContext();
        }
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense2, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(suspense.activeBranch, parentComponent, parentSuspense2, doRemove);
      }
      if (suspense.pendingBranch) {
        unmount(suspense.pendingBranch, parentComponent, parentSuspense2, doRemove);
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement("div"), null, isSVG, slotScopeIds, optimized, rendererInternals, true
  /* hydrating */);

  const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);
  if (suspense.deps === 0) {
    suspense.resolve(false, true);
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const {
    shapeFlag,
    children
  } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
  let block;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(s)) {
    const singleChild = filterSingleRoot(s);
    if ( true && !singleChild) {
      warn(`<Suspense> slots expect a single root node.`);
    }
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block && !s.dynamicChildren) {
    s.dynamicChildren = block.filter(c => c !== s);
  }
  return s;
}
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const {
    vnode,
    parentComponent
  } = suspense;
  const el = vnode.el = branch.el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
function isVNodeSuspensible(vnode) {
  var _a;
  return ((_a = vnode.props) == null ? void 0 : _a.suspensible) != null && vnode.props.suspensible !== false;
}
function watchEffect(effect, options) {
  return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
  return doWatch(effect, null,  true ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, options, {
    flush: "post"
  }) : 0);
}
function watchSyncEffect(effect, options) {
  return doWatch(effect, null,  true ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, options, {
    flush: "sync"
  }) : 0);
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(cb)) {
    warn(`\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`);
  }
  return doWatch(source, cb, options);
}
function doWatch(source, cb, {
  immediate,
  deep,
  flush,
  onTrack,
  onTrigger
} = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
  var _a;
  if ( true && !cb) {
    if (immediate !== void 0) {
      warn(`watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`);
    }
    if (deep !== void 0) {
      warn(`watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`);
    }
  }
  const warnInvalidSource = s => {
    warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
  };
  const instance = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope)() === ((_a = currentInstance) == null ? void 0 : _a.scope) ? currentInstance : null;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(source)) {
    getter = () => source.value;
    forceTrigger = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(source);
  } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(source)) {
    getter = () => source;
    deep = true;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source)) {
    isMultiSource = true;
    forceTrigger = source.some(s => (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(s) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(s));
    getter = () => source.map(s => {
      if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(s)) {
        return s.value;
      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(s)) {
        return traverse(s);
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else {
         true && warnInvalidSource(s);
      }
    });
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
      };
    }
  } else {
    getter = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
     true && warnInvalidSource(source);
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = fn => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [getter(), isMultiSource ? [] : void 0, onCleanup]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(v, oldValue[i])) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [newValue,
        // pass undefined as the old value when it's changed for the first time
        oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue, onCleanup]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance) job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect(getter, scheduler);
  if (true) {
    effect.onTrack = onTrack;
    effect.onTrigger = onTrigger;
  }
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
  } else {
    effect.run();
  }
  const unwatch = () => {
    effect.stop();
    if (instance && instance.scope) {
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(instance.scope.effects, effect);
    }
  };
  if (ssrCleanup) ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, seen) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
    traverse(value.value, seen);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isMap)(value)) {
    value.forEach(v => {
      traverse(v, seen);
    });
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(value)) {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }
  return value;
}
function validateDirectiveName(name) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isBuiltInDirective)(name)) {
    warn("Do not use built-in directive ids as custom directive id: " + name);
  }
}
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
     true && warn(`withDirectives can only be used inside render functions.`);
    return vnode;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ] = directives[i];
    if (dir) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
      callWithAsyncErrorHandling(hook, instance, 8, [vnode.el, binding, vnode, prevVNode]);
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    }
  }
}
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, {
    slots
  }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        let hasFound = false;
        for (const c of children) {
          if (c.type !== Comment) {
            if ( true && hasFound) {
              warn("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
              break;
            }
            child = c;
            hasFound = true;
            if (false) {}
          }
        }
      }
      const rawProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
      const {
        mode
      } = rawProps;
      if ( true && mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") {
        warn(`invalid <transition> mode: ${mode}`);
      }
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const {
        getTransitionKey
      } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (instance.update.active !== false) {
              instance.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const {
    leavingVNodes
  } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook = (hook, args) => {
    hook && callWithAsyncErrorHandling(hook, instance, 9, args);
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook(hook, args);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
      if (hook.every(hook2 => hook2.length <= 1)) done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](true
        /* cancelled */);
      }

      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey] = cancelled => {
        if (called) return;
        called = true;
        if (cancelled) {
          callHook(cancelHook, [el]);
        } else {
          callHook(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove) {
      const key2 = String(vnode.key);
      if (el[enterCbKey]) {
        el[enterCbKey](true
        /* cancelled */);
      }

      if (state.isUnmounting) {
        return remove();
      }
      callHook(onBeforeLeave, [el]);
      let called = false;
      const done = el[leaveCbKey] = cancelled => {
        if (called) return;
        called = true;
        remove();
        if (cancelled) {
          callHook(onLeaveCancelled, [el]);
        } else {
          callHook(onAfterLeave, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128) keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, {
        key
      }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}

/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options) ?
  // #8326: extend call and options.name access are considered side-effects
  // by Rollup, so we have to wrap it in a pure-annotated IIFE.
  /* @__PURE__ */
  (() => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({
    name: options.name
  }, extraOptions, {
    setup: options
  }))() : options;
}
const isAsyncWrapper = i => !!i.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineAsyncComponent(source) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
    source = {
      loader: source
    };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    timeout,
    // undefined = never times out
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch(err => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve, reject) => {
          const userRetry = () => resolve(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then(comp => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if ( true && !comp) {
        warn(`Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`);
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      if ( true && comp && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
        throw new Error(`Invalid async component load result: ${comp}`);
      }
      resolvedComp = comp;
      return comp;
    }));
  };
  return defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = err => {
        pendingRequest = null;
        handleError(err, instance, 13, !errorComponent
        /* do not throw in dev if user provided error component */);
      };

      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then(comp => {
          return () => createInnerComp(comp, instance);
        }).catch(err => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(false);
      const error = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();
      const delayed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(`Async component timed out after ${timeout}ms.`);
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          queueJob(instance.parent.update);
        }
      }).catch(err => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, parent) {
  const {
    ref: ref2,
    props,
    children,
    ce
  } = parent.vnode;
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref2;
  vnode.ce = ce;
  delete parent.vnode.ce;
  return vnode;
}
const isKeepAlive = vnode => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props, {
    slots
  }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache = /* @__PURE__ */new Map();
    const keys = /* @__PURE__ */new Set();
    let current = null;
    if (true) {
      instance.__v_cache = cache;
    }
    const parentSuspense = instance.suspense;
    const {
      renderer: {
        p: patch,
        m: move,
        um: _unmount,
        o: {
          createElement
        }
      }
    } = sharedContext;
    const storageContainer = createElement("div");
    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
      if (true) {
        devtoolsComponentAdded(instance2);
      }
    };
    sharedContext.deactivate = vnode => {
      const instance2 = vnode.component;
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
      if (true) {
        devtoolsComponentAdded(instance2);
      }
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter) {
      cache.forEach((vnode, key) => {
        const name = getComponentName(vnode.type);
        if (name && (!filter || !filter(name))) {
          pruneCacheEntry(key);
        }
      });
    }
    function pruneCacheEntry(key) {
      const cached = cache.get(key);
      if (!current || !isSameVNodeType(cached, current)) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache.delete(key);
      keys.delete(key);
    }
    watch(() => [props.include, props.exclude], ([include, exclude]) => {
      include && pruneCache(name => matches(include, name));
      exclude && pruneCache(name => !matches(exclude, name));
    },
    // prune post-render after `current` has been updated
    {
      flush: "post",
      deep: true
    });
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        cache.set(pendingCacheKey, getInnerChild(instance.subTree));
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache.forEach(cached => {
        const {
          subTree,
          suspense
        } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type && cached.key === vnode.key) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        if (true) {
          warn(`KeepAlive should contain exactly one component child.`);
        }
        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      const comp = vnode.type;
      const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
      const {
        include,
        exclude,
        max
      } = props;
      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys.delete(key);
        keys.add(key);
      } else {
        keys.add(key);
        if (max && keys.size > parseInt(max, 10)) {
          pruneCacheEntry(keys.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(pattern)) {
    return pattern.some(p => matches(p, name));
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(pattern)) {
    return pattern.split(",").includes(name);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isRegExp)(pattern)) {
    return pattern.test(name);
  }
  return false;
}
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(type, hook, keepAliveRoot, true
  /* prepend */);

  onUnmounted(() => {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(keepAliveRoot[type], injected);
  }, target);
}
function resetShapeFlag(vnode) {
  vnode.shapeFlag &= ~256;
  vnode.shapeFlag &= ~512;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  } else if (true) {
    const apiName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(ErrorTypeStrings[type].replace(/ hook$/, ""));
    warn(`${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup().` + ` If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
  }
}
const createHook = lifecycle => (hook, target = currentInstance) =>
// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
(!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(Component, false
      /* do not include inferred name to avoid breaking existing code */);

      if (selfName && (selfName === name || selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name) || selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)))) {
        return Component;
      }
    }
    const res =
    // local registration
    // check instance[type] first which is resolved for options API
    resolve(instance[type] || Component[type], name) ||
    // global registration
    resolve(instance.appContext[type], name);
    if (!res && maybeSelfReference) {
      return Component;
    }
    if ( true && warnMissing && !res) {
      const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
      warn(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
    }
    return res;
  } else if (true) {
    warn(`resolve${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(type.slice(0, -1))} can only be used in render() or setup().`);
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)] || registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name))]);
}
function renderList(source, renderItem, cache, index) {
  let ret;
  const cached = cache && cache[index];
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)) {
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    }
  } else if (typeof source === "number") {
    if ( true && !Number.isInteger(source)) {
      warn(`The v-for range expect an integer value but got ${source}.`);
    }
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, (item, i) => renderItem(item, i, void 0, cached && cached[i]));
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index] = ret;
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res) res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name !== "default") props.name = name;
    return createVNode("slot", props, fallback && fallback());
  }
  let slot = slots[name];
  if ( true && slot && slot.length > 1) {
    warn(`SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`);
    slot = () => [];
  }
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(Fragment, {
    key: props.key ||
    // slot content array of a dynamic conditional slot may have a branch
    // key attached in the `createSlots` helper, respect that
    validSlotContent && validSlotContent.key || `_${name}`
  }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some(child => {
    if (!isVNode(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children)) return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
    warn(`v-on with no argument expects an object value.`);
    return ret;
  }
  for (const key in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(key)] = obj[key];
  }
  return ret;
}
const getPublicInstance = i => {
  if (!i) return null;
  if (isStatefulComponent(i)) return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap =
// Move PURE marker to new line to workaround compiler discarding it
// due to type annotation
/* @__PURE__ */
(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)( /* @__PURE__ */Object.create(null), {
  $: i => i,
  $el: i => i.vnode.el,
  $data: i => i.data,
  $props: i =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.props) : 0,
  $attrs: i =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.attrs) : 0,
  $slots: i =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.slots) : 0,
  $refs: i =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.refs) : 0,
  $parent: i => getPublicInstance(i.parent),
  $root: i => getPublicInstance(i.root),
  $emit: i => i.emit,
  $options: i => __VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,
  $forceUpdate: i => i.f || (i.f = () => queueJob(i.update)),
  $nextTick: i => i.n || (i.n = nextTick.bind(i.proxy)),
  $watch: i => __VUE_OPTIONS_API__ ? instanceWatch.bind(i) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
});
const isReservedPrefix = key => key === "_" || key === "$";
const hasSetupBinding = (state, key) => state !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && !state.__isScriptSetup && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(state, key);
const PublicInstanceProxyHandlers = {
  get({
    _: instance
  }, key) {
    const {
      ctx,
      setupState,
      data,
      props,
      accessCache,
      type,
      appContext
    } = instance;
    if ( true && key === "__isVue") {
      return true;
    }
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1 /* SETUP */:
            return setupState[key];
          case 2 /* DATA */:
            return data[key];
          case 4 /* CONTEXT */:
            return ctx[key];
          case 3 /* PROPS */:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1 /* SETUP */;
        return setupState[key];
      } else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
        accessCache[key] = 2 /* DATA */;
        return data[key];
      } else if (
      // only cache other properties when instance has declared (thus stable)
      // props
      (normalizedProps = instance.propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key)) {
        accessCache[key] = 3 /* PROPS */;
        return props[key];
      } else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
        accessCache[key] = 4 /* CONTEXT */;
        return ctx[key];
      } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {
        accessCache[key] = 0 /* OTHER */;
      }
    }

    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, "get", key);
         true && markAttrsAccessed();
      } else if ( true && key === "$slots") {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, "get", key);
      }
      return publicGetter(instance);
    } else if (
    // css module (injected by vue-loader)
    (cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
      return cssModule;
    } else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
      accessCache[key] = 4 /* CONTEXT */;
      return ctx[key];
    } else if (
    // global properties
    globalProperties = appContext.config.globalProperties, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(globalProperties, key)) {
      {
        return globalProperties[key];
      }
    } else if ( true && currentRenderingInstance && (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(key) ||
    // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    key.indexOf("__v") !== 0)) {
      if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && isReservedPrefix(key[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
        warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`);
      } else if (instance === currentRenderingInstance) {
        warn(`Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`);
      }
    }
  },
  set({
    _: instance
  }, key, value) {
    const {
      data,
      setupState,
      ctx
    } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if ( true && setupState.__isScriptSetup && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
      warn(`Cannot mutate <script setup> binding "${key}" from Options API.`);
      return false;
    } else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
      data[key] = value;
      return true;
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(instance.props, key)) {
       true && warn(`Attempting to mutate prop "${key}". Props are readonly.`);
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
       true && warn(`Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`);
      return false;
    } else {
      if ( true && key in instance.appContext.config.globalProperties) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          value
        });
      } else {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: {
      data,
      setupState,
      accessCache,
      ctx,
      appContext,
      propsOptions
    }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(publicPropertiesMap, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
if (true) {
  PublicInstanceProxyHandlers.ownKeys = target => {
    warn(`Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`);
    return Reflect.ownKeys(target);
  };
}
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, PublicInstanceProxyHandlers, {
  get(target, key) {
    if (key === Symbol.unscopables) {
      return;
    }
    return PublicInstanceProxyHandlers.get(target, key, target);
  },
  has(_, key) {
    const has = key[0] !== "_" && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isGloballyAllowed)(key);
    if ( true && !has && PublicInstanceProxyHandlers.has(_, key)) {
      warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);
    }
    return has;
  }
});
function createDevRenderContext(instance) {
  const target = {};
  Object.defineProperty(target, `_`, {
    configurable: true,
    enumerable: false,
    get: () => instance
  });
  Object.keys(publicPropertiesMap).forEach(key => {
    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: false,
      get: () => publicPropertiesMap[key](instance),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
    });
  });
  return target;
}
function exposePropsOnRenderContext(instance) {
  const {
    ctx,
    propsOptions: [propsOptions]
  } = instance;
  if (propsOptions) {
    Object.keys(propsOptions).forEach(key => {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => instance.props[key],
        set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
      });
    });
  }
}
function exposeSetupStateOnRenderContext(instance) {
  const {
    ctx,
    setupState
  } = instance;
  Object.keys((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(setupState)).forEach(key => {
    if (!setupState.__isScriptSetup) {
      if (isReservedPrefix(key[0])) {
        warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
        return;
      }
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => setupState[key],
        set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
      });
    }
  });
}
const warnRuntimeUsage = method => warn(`${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`);
function defineProps() {
  if (true) {
    warnRuntimeUsage(`defineProps`);
  }
  return null;
}
function defineEmits() {
  if (true) {
    warnRuntimeUsage(`defineEmits`);
  }
  return null;
}
function defineExpose(exposed) {
  if (true) {
    warnRuntimeUsage(`defineExpose`);
  }
}
function defineOptions(options) {
  if (true) {
    warnRuntimeUsage(`defineOptions`);
  }
}
function defineSlots() {
  if (true) {
    warnRuntimeUsage(`defineSlots`);
  }
  return null;
}
function defineModel() {
  if (true) {
    warnRuntimeUsage("defineModel");
  }
}
function withDefaults(props, defaults) {
  if (true) {
    warnRuntimeUsage(`withDefaults`);
  }
  return null;
}
function useSlots() {
  return getContext().slots;
}
function useAttrs() {
  return getContext().attrs;
}
function useModel(props, name, options) {
  const i = getCurrentInstance();
  if ( true && !i) {
    warn(`useModel() called without active instance.`);
    return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();
  }
  if ( true && !i.propsOptions[0][name]) {
    warn(`useModel() called with prop "${name}" which is not declared.`);
    return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();
  }
  if (options && options.local) {
    const proxy = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(props[name]);
    watch(() => props[name], v => proxy.value = v);
    watch(proxy, value => {
      if (value !== props[name]) {
        i.emit(`update:${name}`, value);
      }
    });
    return proxy;
  } else {
    return {
      __v_isRef: true,
      get value() {
        return props[name];
      },
      set value(value) {
        i.emit(`update:${name}`, value);
      }
    };
  }
}
function getContext() {
  const i = getCurrentInstance();
  if ( true && !i) {
    warn(`useContext() called without active instance.`);
  }
  return i.setupContext || (i.setupContext = createSetupContext(i));
}
function normalizePropsOrEmits(props) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(props) ? props.reduce((normalized, p) => (normalized[p] = null, normalized), {}) : props;
}
function mergeDefaults(raw, defaults) {
  const props = normalizePropsOrEmits(raw);
  for (const key in defaults) {
    if (key.startsWith("__skip")) continue;
    let opt = props[key];
    if (opt) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt)) {
        opt = props[key] = {
          type: opt,
          default: defaults[key]
        };
      } else {
        opt.default = defaults[key];
      }
    } else if (opt === null) {
      opt = props[key] = {
        default: defaults[key]
      };
    } else if (true) {
      warn(`props default key "${key}" has no corresponding declaration.`);
    }
    if (opt && defaults[`__skip_${key}`]) {
      opt.skipFactory = true;
    }
  }
  return props;
}
function mergeModels(a, b) {
  if (!a || !b) return a || b;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(a) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(b)) return a.concat(b);
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
}
function createPropsRestProxy(props, excludedKeys) {
  const ret = {};
  for (const key in props) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: () => props[key]
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  if ( true && !ctx) {
    warn(`withAsyncContext called without active current instance. This is likely a bug.`);
  }
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(awaitable)) {
    awaitable = awaitable.catch(e => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}
function createDuplicateChecker() {
  const cache = /* @__PURE__ */Object.create(null);
  return (type, key) => {
    if (cache[key]) {
      warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
    } else {
      cache[key] = type;
    }
  };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties =  true ? createDuplicateChecker() : 0;
  if (true) {
    const [propsOptions] = instance.propsOptions;
    if (propsOptions) {
      for (const key in propsOptions) {
        checkDuplicateProperties("Props" /* PROPS */, key);
      }
    }
  }
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(methodHandler)) {
        if (true) {
          Object.defineProperty(ctx, key, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          });
        } else {}
        if (true) {
          checkDuplicateProperties("Methods" /* METHODS */, key);
        }
      } else if (true) {
        warn(`Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`);
      }
    }
  }
  if (dataOptions) {
    if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dataOptions)) {
      warn(`The data option must be a function. Plain object usage is no longer supported.`);
    }
    const data = dataOptions.call(publicThis, publicThis);
    if ( true && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(data)) {
      warn(`data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`);
    }
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(data)) {
       true && warn(`data() should return an object.`);
    } else {
      instance.data = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive)(data);
      if (true) {
        for (const key in data) {
          checkDuplicateProperties("Data" /* DATA */, key);
          if (!isReservedPrefix(key[0])) {
            Object.defineProperty(ctx, key, {
              configurable: true,
              enumerable: true,
              get: () => data[key],
              set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
            });
          }
        }
      }
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? opt.bind(publicThis, publicThis) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.get) ? opt.get.bind(publicThis, publicThis) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
      if ( true && get === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
        warn(`Computed property "${key}" has no getter.`);
      }
      const set = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.set) ? opt.set.bind(publicThis) :  true ? () => {
        warn(`Write operation failed: computed property "${key}" is readonly.`);
      } : 0;
      const c = computed({
        get,
        set
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: v => c.value = v
      });
      if (true) {
        checkDuplicateProperties("Computed" /* COMPUTED */, key);
      }
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach(key => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
      hook.forEach(_hook => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach(key => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: val => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components) instance.components = components;
  if (directives) instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opt)) {
      if ("default" in opt) {
        injected = inject(opt.from || key, opt.default, true
        /* treat default function as factory */);
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: v => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
    if (true) {
      checkDuplicateProperties("Inject" /* INJECT */, key);
    }
  }
}
function callHook(hook, instance, type) {
  callWithAsyncErrorHandling((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook) ? hook.map(h => h.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw)) {
    const handler = ctx[raw];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
      watch(getter, handler);
    } else if (true) {
      warn(`Invalid watch handler specified by key "${raw}"`, handler);
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
      raw.forEach(r => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
        watch(getter, handler, raw);
      } else if (true) {
        warn(`Invalid watch handler specified by key "${raw.handler}"`, handler);
      }
    }
  } else if (true) {
    warn(`Invalid watch option: "${key}"`, raw);
  }
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const {
    mixins,
    extends: extendsOptions
  } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: {
      optionMergeStrategies
    }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(m => mergeOptions(resolved, m, optionMergeStrategies, true));
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const {
    mixins,
    extends: extendsOptions
  } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(m => mergeOptions(to, m, strats, true));
  }
  for (const key in from) {
    if (asMixin && key === "expose") {
       true && warn(`"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`);
    } else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(to) ? to.call(this, this) : to, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(from) ? from.call(this, this) : from);
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)( /* @__PURE__ */Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(to) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(from)) {
      return [... /* @__PURE__ */new Set([...to, ...from])];
    }
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)( /* @__PURE__ */Object.create(null), normalizePropsOrEmits(to), normalizePropsOrEmits(from != null ? from : {}));
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)( /* @__PURE__ */Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */Object.create(null),
    optionsCache: /* @__PURE__ */new WeakMap(),
    propsCache: /* @__PURE__ */new WeakMap(),
    emitsCache: /* @__PURE__ */new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp(rootComponent, rootProps = null) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(rootComponent)) {
      rootComponent = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, rootComponent);
    }
    if (rootProps != null && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(rootProps)) {
       true && warn(`root props passed to app.mount() must be an object.`);
      rootProps = null;
    }
    const context = createAppContext();
    if (true) {
      Object.defineProperty(context.config, "unwrapInjectedRef", {
        get() {
          return true;
        },
        set() {
          warn(`app.config.unwrapInjectedRef has been deprecated. 3.3 now always unwraps injected refs in Options API.`);
        }
      });
    }
    const installedPlugins = /* @__PURE__ */new WeakSet();
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
        if (true) {
          warn(`app.config cannot be replaced. Modify individual options instead.`);
        }
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) {
           true && warn(`Plugin has already been applied to target app.`);
        } else if (plugin && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else if (true) {
          warn(`A plugin must either be a function or an object with an "install" function.`);
        }
        return app;
      },
      mixin(mixin) {
        if (__VUE_OPTIONS_API__) {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          } else if (true) {
            warn("Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : ""));
          }
        } else if (true) {
          warn("Mixins are only available in builds supporting Options API");
        }
        return app;
      },
      component(name, component) {
        if (true) {
          validateComponentName(name, context.config);
        }
        if (!component) {
          return context.components[name];
        }
        if ( true && context.components[name]) {
          warn(`Component "${name}" has already been registered in target app.`);
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (true) {
          validateDirectiveName(name);
        }
        if (!directive) {
          return context.directives[name];
        }
        if ( true && context.directives[name]) {
          warn(`Directive "${name}" has already been registered in target app.`);
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          if ( true && rootContainer.__vue_app__) {
            warn(`There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`);
          }
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (true) {
            context.reload = () => {
              render(cloneVNode(vnode), rootContainer, isSVG);
            };
          }
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          if (true) {
            app._instance = vnode.component;
            devtoolsInitApp(app, version);
          }
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        } else if (true) {
          warn(`App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``);
        }
      },
      unmount() {
        if (isMounted) {
          render(null, app._container);
          if (true) {
            app._instance = null;
            devtoolsUnmountApp(app);
          }
          delete app._container.__vue_app__;
        } else if (true) {
          warn(`Cannot unmount an app that is not mounted.`);
        }
      },
      provide(key, value) {
        if ( true && key in context.provides) {
          warn(`App already provides property with key "${String(key)}". It will be overwritten with the new value.`);
        }
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = null;
        }
      }
    };
    return app;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance) {
    if (true) {
      warn(`provide() can only be used inside setup().`);
    }
  } else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else if (true) {
      warn(`injection "${String(key)}" not found.`);
    }
  } else if (true) {
    warn(`inject() can only be used inside setup() or functional components.`);
  }
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (true) {
    validateProps(rawProps || {}, props, instance);
  }
  if (isStateful) {
    instance.props = isSSR ? props : (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive)(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function isInHmrContext(instance) {
  while (instance) {
    if (instance.type.__hmrId) return true;
    instance = instance.parent;
  }
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: {
      patchFlag
    }
  } = instance;
  const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
  // always force full diff in dev
  // - #1942 if hmr is enabled with sfc component
  // - vite#872 non-sfc component used by sfc component
  !( true && isInHmrContext(instance)) && (optimized || patchFlag > 0) && !(patchFlag & 16)) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false
            /* isAbsent */);
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps ||
      // for camelCase
      !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) && (
      // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      (kebabKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) === key || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && (
          // for camelCase
          rawPrevProps[key] !== void 0 ||
          // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true
            /* isAbsent */);
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.trigger)(instance, "set", "$attrs");
  }
  if (true) {
    validateProps(rawProps || {}, props, instance);
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
    const castValues = rawCastValues || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(castValues, key));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)) {
        const {
          propsDefaults
        } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[0 /* shouldCast */]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1 /* shouldCastTrue */] && (value === "" || value === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (__VUE_OPTIONS_API__ && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
    const extendProps = raw2 => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, props);
      if (keys) needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {
      cache.set(comp, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR);
    }
    return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
    for (let i = 0; i < raw.length; i++) {
      if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw[i])) {
        warn(`props must be strings when using array syntax.`, raw[i]);
      }
      const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
      }
    }
  } else if (raw) {
    if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
      warn(`invalid props options`, raw);
    }
    for (const key in raw) {
      const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? {
          type: opt
        } : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[0 /* shouldCast */] = booleanIndex > -1;
          prop[1 /* shouldCastTrue */] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  } else if (true) {
    warn(`Invalid prop name: "${key}" is a reserved property.`);
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
  return match ? match[2] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expectedTypes)) {
    return expectedTypes.findIndex(t => isSameType(t, type));
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
function validateProps(rawProps, props, instance) {
  const resolvedValues = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
  const options = instance.propsOptions[0];
  for (const key in options) {
    let opt = options[key];
    if (opt == null) continue;
    validateProp(key, resolvedValues[key], opt, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)));
  }
}
function validateProp(name, value, prop, isAbsent) {
  const {
    type,
    required,
    validator,
    skipCheck
  } = prop;
  if (required && isAbsent) {
    warn('Missing required prop: "' + name + '"');
    return;
  }
  if (value == null && !required) {
    return;
  }
  if (type != null && type !== true && !skipCheck) {
    let isValid = false;
    const types = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(type) ? type : [type];
    const expectedTypes = [];
    for (let i = 0; i < types.length && !isValid; i++) {
      const {
        valid,
        expectedType
      } = assertType(value, types[i]);
      expectedTypes.push(expectedType || "");
      isValid = valid;
    }
    if (!isValid) {
      warn(getInvalidTypeMessage(name, value, expectedTypes));
      return;
    }
  }
  if (validator && !validator(value)) {
    warn('Invalid prop: custom validator check failed for prop "' + name + '".');
  }
}
const isSimpleType = /* @__PURE__ */(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)("String,Number,Boolean,Function,Symbol,BigInt");
function assertType(value, type) {
  let valid;
  const expectedType = getType(type);
  if (isSimpleType(expectedType)) {
    const t = typeof value;
    valid = t === expectedType.toLowerCase();
    if (!valid && t === "object") {
      valid = value instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value);
  } else if (expectedType === "Array") {
    valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value);
  } else if (expectedType === "null") {
    valid = value === null;
  } else {
    valid = value instanceof type;
  }
  return {
    valid,
    expectedType
  };
}
function getInvalidTypeMessage(name, value, expectedTypes) {
  let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join(" | ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toRawType)(value);
  const expectedValue = styleValue(value, expectedType);
  const receivedValue = styleValue(value, receivedType);
  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += ` with value ${expectedValue}`;
  }
  message += `, got ${receivedType} `;
  if (isExplicable(receivedType)) {
    message += `with value ${receivedValue}.`;
  }
  return message;
}
function styleValue(value, type) {
  if (type === "String") {
    return `"${value}"`;
  } else if (type === "Number") {
    return `${Number(value)}`;
  } else {
    return `${value}`;
  }
}
function isExplicable(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some(elem => type.toLowerCase() === elem);
}
function isBoolean(...args) {
  return args.some(elem => elem.toLowerCase() === "boolean");
}
const isInternalKey = key => key[0] === "_" || key === "$stable";
const normalizeSlotValue = value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if ( true && currentInstance) {
      warn(`Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`);
    }
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value = rawSlots[key];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      if (true) {
        warn(`Non-function value encountered for slot "${key}". Prefer function slots for better performance.`);
      }
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  if ( true && !isKeepAlive(instance.vnode) && true) {
    warn(`Non-function value encountered for default slot. Prefer function slots for better performance.`);
  }
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(children);
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(children, "_", type);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const {
    vnode,
    slots
  } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if ( true && isHmrUpdating) {
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.trigger)(instance, "set", "$slots");
      } else if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = {
      default: 1
    };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(rawRef)) {
    rawRef.forEach((r, i) => setRef(r, oldRawRef && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const {
    i: owner,
    r: ref
  } = rawRef;
  if ( true && !owner) {
    warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`);
    return;
  }
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(oldRef)) {
      refs[oldRef] = null;
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(oldRef)) {
      oldRef.value = null;
    }
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)) {
    callWithErrorHandling(ref, owner, 12, [value, refs]);
  } else {
    const _isString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref);
    const _isRef = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, ref) ? setupState[ref] : refs[ref] : ref.value;
          if (isUnmount) {
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(existing, refValue);
          } else {
            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing)) {
              if (_isString) {
                refs[ref] = [refValue];
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, ref)) {
                  setupState[ref] = refs[ref];
                }
              } else {
                ref.value = [refValue];
                if (rawRef.k) refs[rawRef.k] = ref.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref] = value;
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, ref)) {
            setupState[ref] = value;
          }
        } else if (_isRef) {
          ref.value = value;
          if (rawRef.k) refs[rawRef.k] = value;
        } else if (true) {
          warn("Invalid template ref type:", ref, `(${typeof ref})`);
        }
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else if (true) {
      warn("Invalid template ref type:", ref, `(${typeof ref})`);
    }
  }
}
let hasMismatch = false;
const isSVGContainer = container => /svg/.test(container.namespaceURI) && container.tagName !== "foreignObject";
const isComment = node => node.nodeType === 8 /* COMMENT */;
function createHydrationFunctions(rendererInternals) {
  const {
    mt: mountComponent,
    p: patch,
    o: {
      patchProp,
      createText,
      nextSibling,
      parentNode,
      remove,
      insert,
      createComment
    }
  } = rendererInternals;
  const hydrate = (vnode, container) => {
    if (!container.hasChildNodes()) {
       true && warn(`Attempting to hydrate existing markup but container is empty. Performing full mount instead.`);
      patch(null, vnode, container);
      flushPostFlushCbs();
      container._vnode = vnode;
      return;
    }
    hasMismatch = false;
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    container._vnode = vnode;
    if (hasMismatch && true) {
      console.error(`Hydration completed but contains mismatches.`);
    }
  };
  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    const isFragmentStart = isComment(node) && node.data === "[";
    const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
    const {
      type,
      ref,
      shapeFlag,
      patchFlag
    } = vnode;
    let domType = node.nodeType;
    vnode.el = node;
    if (patchFlag === -2) {
      optimized = false;
      vnode.dynamicChildren = null;
    }
    let nextNode = null;
    switch (type) {
      case Text:
        if (domType !== 3 /* TEXT */) {
          if (vnode.children === "") {
            insert(vnode.el = createText(""), parentNode(node), node);
            nextNode = node;
          } else {
            nextNode = onMismatch();
          }
        } else {
          if (node.data !== vnode.children) {
            hasMismatch = true;
             true && warn(`Hydration text mismatch:
- Server rendered: ${JSON.stringify(node.data)}
- Client rendered: ${JSON.stringify(vnode.children)}`);
            node.data = vnode.children;
          }
          nextNode = nextSibling(node);
        }
        break;
      case Comment:
        if (domType !== 8 /* COMMENT */ || isFragmentStart) {
          if (node.tagName.toLowerCase() === "template") {
            const content = vnode.el.content.firstChild;
            replaceNode(content, node, parentComponent);
            vnode.el = node = content;
            nextNode = nextSibling(node);
          } else {
            nextNode = onMismatch();
          }
        } else {
          nextNode = nextSibling(node);
        }
        break;
      case Static:
        if (isFragmentStart) {
          node = nextSibling(node);
          domType = node.nodeType;
        }
        if (domType === 1 /* ELEMENT */ || domType === 3 /* TEXT */) {
          nextNode = node;
          const needToAdoptContent = !vnode.children.length;
          for (let i = 0; i < vnode.staticCount; i++) {
            if (needToAdoptContent) vnode.children += nextNode.nodeType === 1 /* ELEMENT */ ? nextNode.outerHTML : nextNode.data;
            if (i === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return isFragmentStart ? nextSibling(nextNode) : nextNode;
        } else {
          onMismatch();
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
        }
        break;
      default:
        if (shapeFlag & 1) {
          if ((domType !== 1 /* ELEMENT */ || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode(node)) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node);
          if (isFragmentStart) {
            nextNode = locateClosingAnchor(node);
          } else if (isComment(node) && node.data === "teleport start") {
            nextNode = locateClosingAnchor(node, node.data, "teleport end");
          } else {
            nextNode = nextSibling(node);
          }
          mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
          if (isAsyncWrapper(vnode)) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8 /* COMMENT */) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
        } else if (true) {
          warn("Invalid HostVNode type:", type, `(${typeof type})`);
        }
    }
    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode);
    }
    return nextNode;
  };
  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const {
      type,
      props,
      patchFlag,
      shapeFlag,
      dirs,
      transition
    } = vnode;
    const forcePatchValue = type === "input" && dirs || type === "option";
    if (true) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props) {
        if (forcePatchValue || !optimized || patchFlag & (16 | 32)) {
          for (const key in props) {
            if (forcePatchValue && key.endsWith("value") || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
              patchProp(el, key, null, props[key], false, void 0, parentComponent);
            }
          }
        } else if (props.onClick) {
          patchProp(el, "onClick", null, props.onClick, false, void 0, parentComponent);
        }
      }
      let vnodeHooks;
      if (vnodeHooks = props && props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      let needCallTransitionHooks = false;
      if (isTemplateNode(el)) {
        needCallTransitionHooks = needTransition(parentSuspense, transition) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
        const content = el.content.firstChild;
        if (needCallTransitionHooks) {
          transition.beforeEnter(content);
        }
        replaceNode(content, el, parentComponent);
        vnode.el = el = content;
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
      if (shapeFlag & 16 &&
      // skip if element has innerHTML / textContent
      !(props && (props.innerHTML || props.textContent))) {
        let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
        let hasWarned = false;
        while (next) {
          hasMismatch = true;
          if ( true && !hasWarned) {
            warn(`Hydration children mismatch in <${vnode.type}>: server rendered element contains more child nodes than client vdom.`);
            hasWarned = true;
          }
          const cur = next;
          next = next.nextSibling;
          remove(cur);
        }
      } else if (shapeFlag & 8) {
        if (el.textContent !== vnode.children) {
          hasMismatch = true;
           true && warn(`Hydration text content mismatch in <${vnode.type}>:
- Server rendered: ${el.textContent}
- Client rendered: ${vnode.children}`);
          el.textContent = vnode.children;
        }
      }
    }
    return el.nextSibling;
  };
  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l = children.length;
    let hasWarned = false;
    for (let i = 0; i < l; i++) {
      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
      if (node) {
        node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
      } else if (vnode.type === Text && !vnode.children) {
        continue;
      } else {
        hasMismatch = true;
        if ( true && !hasWarned) {
          warn(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: server rendered element contains fewer child nodes than client vdom.`);
          hasWarned = true;
        }
        patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
      }
    }
    return node;
  };
  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const {
      slotScopeIds: fragmentSlotScopeIds
    } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode(node);
    const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
    if (next && isComment(next) && next.data === "]") {
      return nextSibling(vnode.anchor = next);
    } else {
      hasMismatch = true;
      insert(vnode.anchor = createComment(`]`), container, next);
      return next;
    }
  };
  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    hasMismatch = true;
     true && warn(`Hydration node mismatch:
- Client vnode:`, vnode.type, `
- Server rendered DOM:`, node, node.nodeType === 3 /* TEXT */ ? `(text)` : isComment(node) && node.data === "[" ? `(start of fragment)` : ``);
    vnode.el = null;
    if (isFragment) {
      const end = locateClosingAnchor(node);
      while (true) {
        const next2 = nextSibling(node);
        if (next2 && next2 !== end) {
          remove(next2);
        } else {
          break;
        }
      }
    }
    const next = nextSibling(node);
    const container = parentNode(node);
    remove(node);
    patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
    return next;
  };
  const locateClosingAnchor = (node, open = "[", close = "]") => {
    let match = 0;
    while (node) {
      node = nextSibling(node);
      if (node && isComment(node)) {
        if (node.data === open) match++;
        if (node.data === close) {
          if (match === 0) {
            return nextSibling(node);
          } else {
            match--;
          }
        }
      }
    }
    return node;
  };
  const replaceNode = (newNode, oldNode, parentComponent) => {
    const parentNode2 = oldNode.parentNode;
    if (parentNode2) {
      parentNode2.replaceChild(newNode, oldNode);
    }
    let parent = parentComponent;
    while (parent) {
      if (parent.vnode.el === oldNode) {
        parent.vnode.el = newNode;
        parent.subTree.el = newNode;
      }
      parent = parent.parent;
    }
  };
  const isTemplateNode = node => {
    return node.nodeType === 1 /* ELEMENT */ && node.tagName.toLowerCase() === "template";
  };
  return [hydrate, hydrateNode];
}
let supported;
let perf;
function startMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    perf.mark(`vue-${type}-${instance.uid}`);
  }
  if (true) {
    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
  }
}
function endMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    const startTag = `vue-${type}-${instance.uid}`;
    const endTag = startTag + `:end`;
    perf.mark(endTag);
    perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
    perf.clearMarks(startTag);
    perf.clearMarks(endTag);
  }
  if (true) {
    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
  }
}
function isSupported() {
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else {
    supported = false;
  }
  return supported;
}
function initFeatureFlags() {
  const needWarn = [];
  if (typeof __VUE_OPTIONS_API__ !== "boolean") {
     true && needWarn.push(`__VUE_OPTIONS_API__`);
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_OPTIONS_API__ = true;
  }
  if (typeof __VUE_PROD_DEVTOOLS__ !== "boolean") {
     true && needWarn.push(`__VUE_PROD_DEVTOOLS__`);
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_PROD_DEVTOOLS__ = false;
  }
  if ( true && needWarn.length) {
    const multi = needWarn.length > 1;
    console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`);
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
  {
    initFeatureFlags();
  }
  const target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)();
  target.__VUE__ = true;
  if (true) {
    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
  }
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized =  true && isHmrUpdating ? false : !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const {
      type,
      ref,
      shapeFlag
    } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        } else if (true) {
          patchStaticNode(n1, n2, container, isSVG);
        }
        break;
      case Fragment:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (true) {
          warn("Invalid VNode type:", type, `(${typeof type})`);
        }
    }
    if (ref != null && parentComponent) {
      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
  };
  const patchStaticNode = (n1, n2, container, isSVG) => {
    if (n2.children !== n1.children) {
      const anchor = hostNextSibling(n1.anchor);
      removeStaticNode(n1);
      [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
    } else {
      n2.el = n1.el;
      n2.anchor = n1.anchor;
    }
  };
  const moveStaticNode = ({
    el,
    anchor
  }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({
    el,
    anchor
  }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const {
      type,
      props,
      shapeFlag,
      transition,
      dirs
    } = vnode;
    el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
          hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (true) {
      Object.defineProperty(el, "__vnode", {
        value: vnode,
        enumerable: false
      });
      Object.defineProperty(el, "__vueParentComponent", {
        value: parentComponent,
        enumerable: false
      });
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if ( true && subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
        subTree = filterSingleRoot(subTree.children) || subTree;
      }
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let {
      patchFlag,
      dynamicChildren,
      dirs
    } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    const newProps = n2.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if ( true && isHmrUpdating) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
      if (true) {
        traverseStaticChildren(n1, n2);
      }
    } else if (!optimized) {
      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container =
      // oldVNode may be an errored async setup() component inside Suspense
      // which will not have a mounted element
      oldVNode.el && (
      // - In the case of a Fragment, we need to provide the actual parent
      // of the Fragment itself so it can move its children.
      oldVNode.type === Fragment ||
      // - In the case of different nodes, there is going to be a replacement
      // which also requires the correct parent container
      !isSameVNodeType(oldVNode, newVNode) ||
      // - In the case of a component, it could contain anything.
      oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) :
      // In other cases, the parent container is not actually used so we
      // just pass the block element here to avoid a DOM parentNode call.
      fallbackContainer;
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key) && !(key in newProps)) {
            hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      for (const key in newProps) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let {
      patchFlag,
      dynamicChildren,
      slotScopeIds: fragmentSlotScopeIds
    } = n2;
    if ( true && (
    // #5523 dev root fragment may inherit directives
    isHmrUpdating || patchFlag & 2048)) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren &&
      // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (true) {
          traverseStaticChildren(n1, n2);
        } else {}
      } else {
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if ( true && instance.type.__hmrId) {
      registerHMR(instance);
    }
    if (true) {
      pushWarningContext(initialVNode);
      startMeasure(instance, `mount`);
    }
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      if (true) {
        startMeasure(instance, `init`);
      }
      setupComponent(instance);
      if (true) {
        endMeasure(instance, `init`);
      }
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
    if (true) {
      popWarningContext();
      endMeasure(instance, `mount`);
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        if (true) {
          pushWarningContext(n2);
        }
        updateComponentPreRender(instance, n2, optimized);
        if (true) {
          popWarningContext();
        }
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const {
          el,
          props
        } = initialVNode;
        const {
          bm,
          m,
          parent
        } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            if (true) {
              startMeasure(instance, `render`);
            }
            instance.subTree = renderComponentRoot(instance);
            if (true) {
              endMeasure(instance, `render`);
            }
            if (true) {
              startMeasure(instance, `hydrate`);
            }
            hydrateNode(el, instance.subTree, instance, parentSuspense, null);
            if (true) {
              endMeasure(instance, `hydrate`);
            }
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
            // note: we are moving the render call into an async callback,
            // which means it won't track dependencies - but it's ok because
            // a server-rendered async wrapper is already in resolved state
            // and it will never need to change.
            () => !instance.isUnmounted && hydrateSubTree());
          } else {
            hydrateSubTree();
          }
        } else {
          if (true) {
            startMeasure(instance, `render`);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          if (true) {
            endMeasure(instance, `render`);
          }
          if (true) {
            startMeasure(instance, `patch`);
          }
          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
          if (true) {
            endMeasure(instance, `patch`);
          }
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        if (true) {
          devtoolsComponentAdded(instance);
        }
        initialVNode = container = anchor = null;
      } else {
        let {
          next,
          bu,
          u,
          parent,
          vnode
        } = instance;
        let originNext = next;
        let vnodeHook;
        if (true) {
          pushWarningContext(next || instance.vnode);
        }
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        if (true) {
          startMeasure(instance, `render`);
        }
        const nextTree = renderComponentRoot(instance);
        if (true) {
          endMeasure(instance, `render`);
        }
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        if (true) {
          startMeasure(instance, `patch`);
        }
        patch(prevTree, nextTree,
        // parent may have changed if it's in a teleport
        hostParentNode(prevTree.el),
        // anchor may have changed if it's in a fragment
        getNextHostNode(prevTree), instance, parentSuspense, isSVG);
        if (true) {
          endMeasure(instance, `patch`);
        }
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
        }
        if (true) {
          devtoolsComponentUpdated(instance);
        }
        if (true) {
          popWarningContext();
        }
      }
    };
    const effect = instance.effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect(componentUpdateFn, () => queueJob(update), instance.scope
    // track it in component's effect scope
    );

    const update = instance.update = () => effect.run();
    update.id = instance.uid;
    toggleRecurse(instance, true);
    if (true) {
      effect.onTrack = instance.rtc ? e => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtc, e) : void 0;
      effect.onTrigger = instance.rtg ? e => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtg, e) : void 0;
      update.ownerInstance = instance;
    }
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
    flushPreFlushCbs();
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const {
      patchFlag,
      shapeFlag
    } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
    c2 = c2 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          if ( true && keyToNewIndexMap.has(nextChild.key)) {
            warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
          }
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const {
      el,
      type,
      transition,
      children,
      shapeFlag
    } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const {
          leave,
          delayLeave,
          afterLeave
        } = transition;
        const remove2 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove2();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove2, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs
    } = vnode;
    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && (
      // #1153: fast path should not be taken for non-stable (v-for) fragments
      type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove = vnode => {
    const {
      type,
      el,
      anchor,
      transition
    } = vnode;
    if (type === Fragment) {
      if ( true && vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
        vnode.children.forEach(child => {
          if (child.type === Comment) {
            hostRemove(child.el);
          } else {
            remove(child);
          }
        });
      } else {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const {
        leave,
        delayLeave
      } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    if ( true && instance.type.__hmrId) {
      unregisterHMR(instance);
    }
    const {
      bum,
      scope,
      update,
      subTree,
      um
    } = instance;
    if (bum) {
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
    if (true) {
      devtoolsComponentRemoved(instance);
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = vnode => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function toggleRecurse({
  effect,
  update
}, allowed) {
  effect.allowRecurse = update.allowRecurse = allowed;
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch1) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow) traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
      if ( true && c2.type === Comment && !c2.el) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p[v];
  }
  return result;
}
const isTeleport = type => type.__isTeleport;
const isTeleportDisabled = props => props && (props.disabled || props.disabled === "");
const isTargetSVG = target => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(targetSelector)) {
    if (!select) {
       true && warn(`Current renderer does not support string target for Teleports. (missing querySelector renderer option)`);
      return null;
    } else {
      const target = select(targetSelector);
      if (!target) {
         true && warn(`Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`);
      }
      return target;
    }
  } else {
    if ( true && !targetSelector && !isTeleportDisabled(props)) {
      warn(`Invalid Teleport target: ${targetSelector}`);
    }
    return targetSelector;
  }
};
const TeleportImpl = {
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: {
        insert,
        querySelector,
        createText,
        createComment
      }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let {
      shapeFlag,
      children,
      dynamicChildren
    } = n2;
    if ( true && isHmrUpdating) {
      optimized = false;
      dynamicChildren = null;
    }
    if (n1 == null) {
      const placeholder = n2.el =  true ? createComment("teleport start") : 0;
      const mainAnchor = n2.anchor =  true ? createComment("teleport end") : 0;
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert(targetAnchor, target);
        isSVG = isSVG || isTargetSVG(target);
      } else if ( true && !disabled) {
        warn("Invalid Teleport target on mount:", target, `(${typeof target})`);
      }
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG = isSVG || isTargetSVG(target);
      if (dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(n2, container, mainAnchor, internals, 1);
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
          if (nextTarget) {
            moveTeleport(n2, nextTarget, null, internals, 0);
          } else if (true) {
            warn("Invalid Teleport target on update:", target, `(${typeof target})`);
          }
        } else if (wasDisabled) {
          moveTeleport(n2, target, targetAnchor, internals, 1);
        }
      }
    }
    updateCssVars(n2);
  },
  remove(vnode, parentComponent, parentSuspense, optimized, {
    um: unmount,
    o: {
      remove: hostRemove
    }
  }, doRemove) {
    const {
      shapeFlag,
      children,
      anchor,
      targetAnchor,
      target,
      props
    } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props);
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        unmount(child, parentComponent, parentSuspense, shouldRemove, !!child.dynamicChildren);
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, {
  o: {
    insert
  },
  m: move
}, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const {
    el,
    anchor,
    shapeFlag,
    children,
    props
  } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, parentAnchor, 2);
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: {
    nextSibling,
    parentNode,
    querySelector
  }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(vnode.props, querySelector);
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
      }
    }
    updateCssVars(vnode);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node = vnode.children[0].el;
    while (node && node !== vnode.targetAnchor) {
      if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true
  /* isBlock */));
}

function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true
  /* isBlock: prevent a block from tracking itself */));
}

function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  if ( true && n2.shapeFlag & 6 && hmrDirtyComponents.has(n2.type)) {
    n1.shapeFlag &= ~256;
    n2.shapeFlag &= ~512;
    return false;
  }
  return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
function transformVNodeArgs(transformer) {
  vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args) => {
  return _createVNode(...(vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args));
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({
  key
}) => key != null ? key : null;
const normalizeRef = ({
  ref,
  ref_key,
  ref_for
}) => {
  if (typeof ref === "number") {
    ref = "" + ref;
  }
  return ref != null ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref) ? {
    i: currentRenderingInstance,
    r: ref,
    k: ref_key,
    f: !!ref_for
  } : ref : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(children) ? 8 : 16;
  }
  if ( true && vnode.key !== vnode.key) {
    warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
  }
  if (isBlockTreeEnabled > 0 &&
  // avoid a block node from tracking itself
  !isBlockNode &&
  // has current parent block
  currentBlock && (
  // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  vnode.patchFlag > 0 || shapeFlag & 6) &&
  // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode =  true ? createVNodeWithArgsTransform : 0;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    if ( true && !type) {
      warn(`Invalid vnode type when creating vnode: ${type}.`);
    }
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(type, props, true
    /* mergeRef: true */);

    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let {
      class: klass,
      style
    } = props;
    if (klass && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(klass)) {
      props.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(klass);
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(style)) {
      if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(style) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(style)) {
        style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, style);
      }
      props.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)(style);
    }
  }
  const shapeFlag = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(type) ? 4 : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(type) ? 2 : 0;
  if ( true && shapeFlag & 4 && (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(type)) {
    type = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(type);
    warn(`Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`, `
Component that was made reactive: `, type);
  }
  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
  if (!props) return null;
  return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(props) || InternalObjectKey in props ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const {
    props,
    ref,
    patchFlag,
    children
  } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ?
    // #2078 in the case of <component :is="vnode" ref="extra"/>
    // if the vnode itself already has a ref, cloneVNode will need to merge
    // the refs so the single vnode can be set on multiple refs
    mergeRef && ref ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children:  true && patchFlag === -1 && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children) ? children.map(deepCloneVNode) : children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  return cloned;
}
function deepCloneVNode(vnode) {
  const cloned = cloneVNode(vnode);
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(vnode.children)) {
    cloned.children = vnode.children.map(deepCloneVNode);
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(child)) {
    return createVNode(Fragment, null,
    // #3666, avoid reference pollution when reusing vnode
    child.slice());
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const {
    shapeFlag
  } = vnode;
  if (children == null) {
    children = null;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(children)) {
    children = {
      default: children,
      _ctx: currentRenderingInstance
    };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)([ret.style, toMerge.style]);
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [vnode, prevVNode]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope(true
    /* detached */),

    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    data: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    props: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    attrs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    slots: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    refs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    setupState: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  if (true) {
    instance.ctx = createDevRenderContext(instance);
  } else {}
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let globalCurrentInstanceSetters;
let settersKey = "__VUE_INSTANCE_SETTERS__";
{
  if (!(globalCurrentInstanceSetters = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)()[settersKey])) {
    globalCurrentInstanceSetters = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)()[settersKey] = [];
  }
  globalCurrentInstanceSetters.push(i => currentInstance = i);
  internalSetCurrentInstance = instance => {
    if (globalCurrentInstanceSetters.length > 1) {
      globalCurrentInstanceSetters.forEach(s => s(instance));
    } else {
      globalCurrentInstanceSetters[0](instance);
    }
  };
}
const setCurrentInstance = instance => {
  internalSetCurrentInstance(instance);
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
const isBuiltInTag = /* @__PURE__ */(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)("slot,component");
function validateComponentName(name, config) {
  const appIsNativeTag = config.isNativeTag || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO;
  if (isBuiltInTag(name) || appIsNativeTag(name)) {
    warn("Do not use built-in or reserved HTML elements as component id: " + name);
  }
}
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const {
    props,
    children
  } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  var _a;
  const Component = instance.type;
  if (true) {
    if (Component.name) {
      validateComponentName(Component.name, instance.appContext.config);
    }
    if (Component.components) {
      const names = Object.keys(Component.components);
      for (let i = 0; i < names.length; i++) {
        validateComponentName(names[i], instance.appContext.config);
      }
    }
    if (Component.directives) {
      const names = Object.keys(Component.directives);
      for (let i = 0; i < names.length; i++) {
        validateDirectiveName(names[i]);
      }
    }
    if (Component.compilerOptions && isRuntimeOnly()) {
      warn(`"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`);
    }
  }
  instance.accessCache = /* @__PURE__ */Object.create(null);
  instance.proxy = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  if (true) {
    exposePropsOnRenderContext(instance);
  }
  const {
    setup
  } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
    const setupResult = callWithErrorHandling(setup, instance, 0, [ true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.props) : 0, setupContext]);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    unsetCurrentInstance();
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then(resolvedResult => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch(e => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
        if ( true && !instance.suspense) {
          const name = (_a = Component.name) != null ? _a : "Anonymous";
          warn(`Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);
        }
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(setupResult)) {
    if ( true && isVNode(setupResult)) {
      warn(`setup() should not return VNodes directly - return a render function instead.`);
    }
    if (true) {
      instance.devtoolsRawSetupState = setupResult;
    }
    instance.setupState = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)(setupResult);
    if (true) {
      exposeSetupStateOnRenderContext(instance);
    }
  } else if ( true && setupResult !== void 0) {
    warn(`setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`);
  }
  finishComponentSetup(instance, isSSR);
}
let compile;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile = _compile;
  installWithProxy = i => {
    if (i.render._rc) {
      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
}
const isRuntimeOnly = () => !compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        if (true) {
          startMeasure(instance, `compile`);
        }
        const {
          isCustomElement,
          compilerOptions
        } = instance.appContext.config;
        const {
          delimiters,
          compilerOptions: componentCompilerOptions
        } = Component;
        const finalCompilerOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile(template, finalCompilerOptions);
        if (true) {
          endMeasure(instance, `compile`);
        }
      }
    }
    instance.render = Component.render || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  if (__VUE_OPTIONS_API__ && true) {
    setCurrentInstance(instance);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
    try {
      applyOptions(instance);
    } finally {
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
      unsetCurrentInstance();
    }
  }
  if ( true && !Component.render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP && !isSSR) {
    if (!compile && Component.template) {
      warn(`Component provided template option but runtime compilation is not supported in this build of Vue.` + ` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
      /* should not happen */);
    } else {
      warn(`Component is missing template or render function.`);
    }
  }
}
function getAttrsProxy(instance) {
  return instance.attrsProxy || (instance.attrsProxy = new Proxy(instance.attrs,  true ? {
    get(target, key) {
      markAttrsAccessed();
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, "get", "$attrs");
      return target[key];
    },
    set() {
      warn(`setupContext.attrs is readonly.`);
      return false;
    },
    deleteProperty() {
      warn(`setupContext.attrs is readonly.`);
      return false;
    }
  } : 0));
}
function getSlotsProxy(instance) {
  return instance.slotsProxy || (instance.slotsProxy = new Proxy(instance.slots, {
    get(target, key) {
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, "get", "$slots");
      return target[key];
    }
  }));
}
function createSetupContext(instance) {
  const expose = exposed => {
    if (true) {
      if (instance.exposed) {
        warn(`expose() should be called only once per setup().`);
      }
      if (exposed != null) {
        let exposedType = typeof exposed;
        if (exposedType === "object") {
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(exposed)) {
            exposedType = "array";
          } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(exposed)) {
            exposedType = "ref";
          }
        }
        if (exposedType !== "object") {
          warn(`expose() should be passed a plain object, received ${exposedType}.`);
        }
      }
    }
    instance.exposed = exposed || {};
  };
  if (true) {
    return Object.freeze({
      get attrs() {
        return getAttrsProxy(instance);
      },
      get slots() {
        return getSlotsProxy(instance);
      },
      get emit() {
        return (event, ...args) => instance.emit(event, ...args);
      },
      expose
    });
  } else {}
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = str => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = registry => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.computed)(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(propsOrChildren) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    if (!ctx) {
       true && warn(`Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`);
    }
    return ctx;
  }
};
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function initCustomFormatter() {
  if ( false || typeof window === "undefined") {
    return;
  }
  const vueStyle = {
    style: "color:#3ba776"
  };
  const numberStyle = {
    style: "color:#0b1bc9"
  };
  const stringStyle = {
    style: "color:#b62e24"
  };
  const keywordStyle = {
    style: "color:#9d288c"
  };
  const formatter = {
    header(obj) {
      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
        return null;
      }
      if (obj.__isVue) {
        return ["div", vueStyle, `VueInstance`];
      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(obj)) {
        return ["div", {}, ["span", vueStyle, genRefFlag(obj)], "<", formatValue(obj.value), `>`];
      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(obj)) {
        return ["div", {}, ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"], "<", formatValue(obj), `>${(0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj) ? ` (readonly)` : ``}`];
      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj)) {
        return ["div", {}, ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"], "<", formatValue(obj), ">"];
      }
      return null;
    },
    hasBody(obj) {
      return obj && obj.__isVue;
    },
    body(obj) {
      if (obj && obj.__isVue) {
        return ["div", {}, ...formatInstance(obj.$)];
      }
    }
  };
  function formatInstance(instance) {
    const blocks = [];
    if (instance.type.props && instance.props) {
      blocks.push(createInstanceBlock("props", (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.props)));
    }
    if (instance.setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
      blocks.push(createInstanceBlock("setup", instance.setupState));
    }
    if (instance.data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
      blocks.push(createInstanceBlock("data", (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.data)));
    }
    const computed = extractKeys(instance, "computed");
    if (computed) {
      blocks.push(createInstanceBlock("computed", computed));
    }
    const injected = extractKeys(instance, "inject");
    if (injected) {
      blocks.push(createInstanceBlock("injected", injected));
    }
    blocks.push(["div", {}, ["span", {
      style: keywordStyle.style + ";opacity:0.66"
    }, "$ (internal): "], ["object", {
      object: instance
    }]]);
    return blocks;
  }
  function createInstanceBlock(type, target) {
    target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, target);
    if (!Object.keys(target).length) {
      return ["span", {}];
    }
    return ["div", {
      style: "line-height:1.25em;margin-bottom:0.6em"
    }, ["div", {
      style: "color:#476582"
    }, type], ["div", {
      style: "padding-left:1.25em"
    }, ...Object.keys(target).map(key => {
      return ["div", {}, ["span", keywordStyle, key + ": "], formatValue(target[key], false)];
    })]];
  }
  function formatValue(v, asRaw = true) {
    if (typeof v === "number") {
      return ["span", numberStyle, v];
    } else if (typeof v === "string") {
      return ["span", stringStyle, JSON.stringify(v)];
    } else if (typeof v === "boolean") {
      return ["span", keywordStyle, v];
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(v)) {
      return ["object", {
        object: asRaw ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(v) : v
      }];
    } else {
      return ["span", stringStyle, String(v)];
    }
  }
  function extractKeys(instance, type) {
    const Comp = instance.type;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Comp)) {
      return;
    }
    const extracted = {};
    for (const key in instance.ctx) {
      if (isKeyOfType(Comp, key, type)) {
        extracted[key] = instance.ctx[key];
      }
    }
    return extracted;
  }
  function isKeyOfType(Comp, key, type) {
    const opts = Comp[type];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opts) && opts.includes(key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opts) && key in opts) {
      return true;
    }
    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
      return true;
    }
    if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {
      return true;
    }
  }
  function genRefFlag(v) {
    if (isShallow(v)) {
      return `ShallowRef`;
    }
    if (v.effect) {
      return `ComputedRef`;
    }
    return `Ref`;
  }
  if (window.devtoolsFormatters) {
    window.devtoolsFormatters.push(formatter);
  } else {
    window.devtoolsFormatters = [formatter];
  }
}
function withMemo(memo, render, cache, index) {
  const cached = cache[index];
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }
  const ret = render();
  ret.memo = memo.slice();
  return cache[index] = ret;
}
function isMemoSame(cached, memo) {
  const prev = cached.memo;
  if (prev.length != memo.length) {
    return false;
  }
  for (let i = 0; i < prev.length; i++) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(prev[i], memo[i])) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}
const version = "3.3.7";
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode: isVNode,
  normalizeVNode
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;


/***/ }),

/***/ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseTransition: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   BaseTransitionPropsValidators: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransitionPropsValidators),
/* harmony export */   Comment: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   EffectScope: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   Fragment: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   KeepAlive: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   ReactiveEffect: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   Static: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   Suspense: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   Teleport: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   Text: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   Transition: () => (/* binding */ Transition),
/* harmony export */   TransitionGroup: () => (/* binding */ TransitionGroup),
/* harmony export */   VueElement: () => (/* binding */ VueElement),
/* harmony export */   assertNumber: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.assertNumber),
/* harmony export */   callWithAsyncErrorHandling: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   callWithErrorHandling: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   camelize: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   capitalize: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   cloneVNode: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   compatUtils: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   computed: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   createApp: () => (/* binding */ createApp),
/* harmony export */   createBlock: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   createCommentVNode: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   createElementBlock: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createElementBlock),
/* harmony export */   createElementVNode: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createElementVNode),
/* harmony export */   createHydrationRenderer: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   createPropsRestProxy: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy),
/* harmony export */   createRenderer: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   createSSRApp: () => (/* binding */ createSSRApp),
/* harmony export */   createSlots: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   createStaticVNode: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   createTextVNode: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   createVNode: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   customRef: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   defineAsyncComponent: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   defineComponent: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement),
/* harmony export */   defineEmits: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineEmits),
/* harmony export */   defineExpose: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineExpose),
/* harmony export */   defineModel: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineModel),
/* harmony export */   defineOptions: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineOptions),
/* harmony export */   defineProps: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   defineSSRCustomElement: () => (/* binding */ defineSSRCustomElement),
/* harmony export */   defineSlots: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineSlots),
/* harmony export */   devtools: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   effect: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   effectScope: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   getCurrentInstance: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   getCurrentScope: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   getTransitionRawChildren: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   guardReactiveProps: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps),
/* harmony export */   h: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   handleError: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   hasInjectionContext: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.hasInjectionContext),
/* harmony export */   hydrate: () => (/* binding */ hydrate),
/* harmony export */   initCustomFormatter: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   initDirectivesForSSR: () => (/* binding */ initDirectivesForSSR),
/* harmony export */   inject: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   isMemoSame: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isMemoSame),
/* harmony export */   isProxy: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   isReactive: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   isReadonly: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   isRef: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   isRuntimeOnly: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   isShallow: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   isVNode: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   markRaw: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   mergeDefaults: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),
/* harmony export */   mergeModels: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeModels),
/* harmony export */   mergeProps: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   nextTick: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   normalizeClass: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeClass),
/* harmony export */   normalizeProps: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeProps),
/* harmony export */   normalizeStyle: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle),
/* harmony export */   onActivated: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   onBeforeMount: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   onBeforeUnmount: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   onBeforeUpdate: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   onDeactivated: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   onErrorCaptured: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   onMounted: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   onRenderTracked: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   onRenderTriggered: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   onScopeDispose: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   onServerPrefetch: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   onUnmounted: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   onUpdated: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   openBlock: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   popScopeId: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   provide: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   proxyRefs: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   pushScopeId: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   queuePostFlushCb: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   reactive: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   readonly: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   ref: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   registerRuntimeCompiler: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   render: () => (/* binding */ render),
/* harmony export */   renderList: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   renderSlot: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   resolveComponent: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   resolveDirective: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   resolveDynamicComponent: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   resolveFilter: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   resolveTransitionHooks: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   setBlockTracking: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   setDevtoolsHook: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   setTransitionHooks: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   shallowReactive: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   shallowReadonly: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   shallowRef: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   ssrContextKey: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   ssrUtils: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   stop: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   toDisplayString: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   toHandlerKey: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   toHandlers: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   toRaw: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   toRef: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   toRefs: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   toValue: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toValue),
/* harmony export */   transformVNodeArgs: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   triggerRef: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   unref: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   useAttrs: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useAttrs),
/* harmony export */   useCssModule: () => (/* binding */ useCssModule),
/* harmony export */   useCssVars: () => (/* binding */ useCssVars),
/* harmony export */   useModel: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useModel),
/* harmony export */   useSSRContext: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   useSlots: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSlots),
/* harmony export */   useTransitionState: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   vModelCheckbox: () => (/* binding */ vModelCheckbox),
/* harmony export */   vModelDynamic: () => (/* binding */ vModelDynamic),
/* harmony export */   vModelRadio: () => (/* binding */ vModelRadio),
/* harmony export */   vModelSelect: () => (/* binding */ vModelSelect),
/* harmony export */   vModelText: () => (/* binding */ vModelText),
/* harmony export */   vShow: () => (/* binding */ vShow),
/* harmony export */   version: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   warn: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   watch: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   watchEffect: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   watchPostEffect: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect),
/* harmony export */   watchSyncEffect: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect),
/* harmony export */   withAsyncContext: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),
/* harmony export */   withCtx: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   withDefaults: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDefaults),
/* harmony export */   withDirectives: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   withKeys: () => (/* binding */ withKeys),
/* harmony export */   withMemo: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withMemo),
/* harmony export */   withModifiers: () => (/* binding */ withModifiers),
/* harmony export */   withScopeId: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withScopeId)
/* harmony export */ });
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");



const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: child => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? {
      is
    } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: text => doc.createTextNode(text),
  createComment: text => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: node => node.parentNode,
  nextSibling: node => node.nextSibling,
  querySelector: selector => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling)) break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
    // first
    before ? before.nextSibling : parent.firstChild,
    // last
    anchor ? anchor.previousSibling : parent.lastChild];
  }
};
const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const Transition = (props, {
  slots
}) => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h)(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransitionPropsValidators, DOMTransitionPropsValidators);
const callHook = (hook, args = []) => {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
    hook.forEach(h2 => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = hook => {
  return hook ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook) ? hook.some(h2 => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = isAppear => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve);
        }
      });
    };
  };
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve);
        }
      });
      callHook(onLeave, [el, resolve]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(val);
  if (true) {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.assertNumber)(res, "<transition> explicit duration");
  }
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach(c => c && el.classList.add(c));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach(c => c && el.classList.remove(c));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const {
    type,
    timeout,
    propCount
  } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = e => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = key => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  if (s === "auto") return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
function patchClass(el, value, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
const vShowOldKey = Symbol("_vod");
const vShow = {
  beforeMount(el, {
    value
  }, {
    transition
  }) {
    el[vShowOldKey] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, {
    value
  }, {
    transition
  }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, {
    value,
    oldValue
  }, {
    transition
  }) {
    if (!value === !oldValue) return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, {
    value
  }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el[vShowOldKey] : "none";
}
function initVShowForSSR() {
  vShow.getSSRProps = ({
    value
  }) => {
    if (!value) {
      return {
        style: {
          display: "none"
        }
      };
    }
  };
}
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(next);
  if (next && !isCssString) {
    if (prev && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style, key, "");
        }
      }
    }
    for (const key in next) {
      setStyle(style, key, next[key]);
    }
  } else {
    const currentDisplay = style.display;
    if (isCssString) {
      if (prev !== next) {
        style.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if (vShowOldKey in el) {
      style.display = currentDisplay;
    }
  }
}
const semicolonRE = /[^\\];\s*$/;
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(val)) {
    val.forEach(v => setStyle(style, name, v));
  } else {
    if (val == null) val = "";
    if (true) {
      if (semicolonRE.test(val)) {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Unexpected semicolon at the end of '${name}' style value: '${val}'`);
      }
    }
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSpecialBooleanAttr)(key);
    if (value == null || isBoolean && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" &&
  // custom elements may use _value internally
  !tag.includes("-")) {
    el._value = value;
    const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
    const newValue = value == null ? "" : value;
    if (oldValue !== newValue) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
    if ( true && !needRemove) {
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value} is invalid.`, e);
    }
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = e => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling)(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map(fn => e2 => !e2._stopped && fn && fn(e2));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
    return false;
  }
  return key in el;
}

/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineCustomElement(options, hydrate2) {
  const Comp = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent)(options);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, hydrate2);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
/*! #__NO_SIDE_EFFECTS__ */
const defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */options => {
  return /* @__PURE__ */defineCustomElement(options, hydrate);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, hydrate2) {
    super();
    this._def = _def;
    this._props = _props;
    /**
     * @internal
     */
    this._instance = null;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    this._ob = null;
    if (this.shadowRoot && hydrate2) {
      hydrate2(this._createVNode(), this.shadowRoot);
    } else {
      if ( true && this.shadowRoot) {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \`defineSSRCustomElement\`.`);
      }
      this.attachShadow({
        mode: "open"
      });
      if (!this._def.__asyncLoader) {
        this._resolveProps(this._def);
      }
    }
  }
  connectedCallback() {
    this._connected = true;
    if (!this._instance) {
      if (this._resolved) {
        this._update();
      } else {
        this._resolveDef();
      }
    }
  }
  disconnectedCallback() {
    this._connected = false;
    if (this._ob) {
      this._ob.disconnect();
      this._ob = null;
    }
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {
      if (!this._connected) {
        render(null, this.shadowRoot);
        this._instance = null;
      }
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    this._resolved = true;
    for (let i = 0; i < this.attributes.length; i++) {
      this._setAttr(this.attributes[i].name);
    }
    this._ob = new MutationObserver(mutations => {
      for (const m of mutations) {
        this._setAttr(m.attributeName);
      }
    });
    this._ob.observe(this, {
      attributes: true
    });
    const resolve = (def, isAsync = false) => {
      const {
        props,
        styles
      } = def;
      let numberProps;
      if (props && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(props)) {
        for (const key in props) {
          const opt = props[key];
          if (opt === Number || opt && opt.type === Number) {
            if (key in this._props) {
              this._props[key] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(this._props[key]);
            }
            (numberProps || (numberProps = /* @__PURE__ */Object.create(null)))[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key)] = true;
          }
        }
      }
      this._numberProps = numberProps;
      if (isAsync) {
        this._resolveProps(def);
      }
      this._applyStyles(styles);
      this._update();
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      asyncDef().then(def => resolve(def, true));
    } else {
      resolve(this._def);
    }
  }
  _resolveProps(def) {
    const {
      props
    } = def;
    const declaredPropKeys = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(props) ? props : Object.keys(props || {});
    for (const key of Object.keys(this)) {
      if (key[0] !== "_" && declaredPropKeys.includes(key)) {
        this._setProp(key, this[key], true, false);
      }
    }
    for (const key of declaredPropKeys.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)) {
      Object.defineProperty(this, key, {
        get() {
          return this._getProp(key);
        },
        set(val) {
          this._setProp(key, val);
        }
      });
    }
  }
  _setAttr(key) {
    let value = this.getAttribute(key);
    const camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
    if (this._numberProps && this._numberProps[camelKey]) {
      value = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(value);
    }
    this._setProp(camelKey, value, false);
  }
  /**
   * @internal
   */
  _getProp(key) {
    return this._props[key];
  }
  /**
   * @internal
   */
  _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
    if (val !== this._props[key]) {
      this._props[key] = val;
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        if (val === true) {
          this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key), val + "");
        } else if (!val) {
          this.removeAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key));
        }
      }
    }
  }
  _update() {
    render(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const vnode = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(this._def, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, this._props));
    if (!this._instance) {
      vnode.ce = instance => {
        this._instance = instance;
        instance.isCE = true;
        if (true) {
          instance.ceReload = newStyles => {
            if (this._styles) {
              this._styles.forEach(s => this.shadowRoot.removeChild(s));
              this._styles.length = 0;
            }
            this._applyStyles(newStyles);
            this._instance = null;
            this._update();
          };
        }
        const dispatch = (event, args) => {
          this.dispatchEvent(new CustomEvent(event, {
            detail: args
          }));
        };
        instance.emit = (event, ...args) => {
          dispatch(event, args);
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event) !== event) {
            dispatch((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event), args);
          }
        };
        let parent = this;
        while (parent = parent && (parent.parentNode || parent.host)) {
          if (parent instanceof VueElement) {
            instance.parent = parent._instance;
            instance.provides = parent._instance.provides;
            break;
          }
        }
      };
    }
    return vnode;
  }
  _applyStyles(styles) {
    if (styles) {
      styles.forEach(css => {
        const s = document.createElement("style");
        s.textContent = css;
        this.shadowRoot.appendChild(s);
        if (true) {
          (this._styles || (this._styles = [])).push(s);
        }
      });
    }
  }
}
function useCssModule(name = "$style") {
  {
    const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
    if (!instance) {
       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssModule must be called inside setup()`);
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS modules injected.`);
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    }
    const mod = modules[name];
    if (!mod) {
       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS module named "${name}".`);
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    }
    return mod;
  }
}
function useCssVars(getter) {
  const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
  if (!instance) {
     true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssVars is called without current active component instance.`);
    return;
  }
  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
    Array.from(document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)).forEach(node => setVarsOnNode(node, vars));
  };
  const setVars = () => {
    const vars = getter(instance.proxy);
    setVarsOnVNode(instance.subTree, vars);
    updateTeleports(vars);
  };
  (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect)(setVars);
  (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, {
      childList: true
    });
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment) {
    vnode.children.forEach(c => setVarsOnVNode(c, vars));
  } else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static) {
    let {
      el,
      anchor
    } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor) break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    for (const key in vars) {
      style.setProperty(`--${key}`, vars[key]);
    }
  }
}
const positionMap = /* @__PURE__ */new WeakMap();
const newPositionMap = /* @__PURE__ */new WeakMap();
const moveCbKey = Symbol("_moveCb");
const enterCbKey = Symbol("_enterCb");
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, {
    slots
  }) {
    const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
    const state = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState)();
    let prevChildren;
    let children;
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach(c => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el[moveCbKey] = e => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el[moveCbKey] = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.toRaw)(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment;
      prevChildren = children;
      children = slots.default ? (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren)(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
        } else if (true) {
          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<TransitionGroup> children must be keyed.`);
        }
      }
      if (prevChildren) {
        for (let i = 0; i < prevChildren.length; i++) {
          const child = prevChildren[i];
          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }
      return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(tag, null, children);
    };
  }
};
const removeMode = props => delete props.mode;
/* @__PURE__ */
removeMode(TransitionGroupImpl.props);
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el = c.el;
  if (el[moveCbKey]) {
    el[moveCbKey]();
  }
  if (el[enterCbKey]) {
    el[enterCbKey]();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone = el.cloneNode();
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.forEach(cls => {
      cls.split(/\s+/).forEach(c => c && clone.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach(c => c && clone.classList.add(c));
  clone.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const {
    hasTransform
  } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}
const getModelAssigner = vnode => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn) ? value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(fn, value) : fn;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const assignKey = Symbol("_assign");
const vModelText = {
  created(el, {
    modifiers: {
      lazy,
      trim,
      number
    }
  }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", e => {
      if (e.target.composing) return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseToNumber)(domValue);
      }
      el[assignKey](domValue);
    });
    if (trim) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, {
    value
  }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, {
    value,
    modifiers: {
      lazy,
      trim,
      number
    }
  }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (el.composing) return;
    if (document.activeElement === el && el.type !== "range") {
      if (lazy) {
        return;
      }
      if (trim && el.value.trim() === value) {
        return;
      }
      if ((number || el.type === "number") && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseToNumber)(el.value) === value) {
        return;
      }
    }
    const newValue = value == null ? "" : value;
    if (el.value !== newValue) {
      el.value = newValue;
    }
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el, _, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign = el[assignKey];
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(modelValue)) {
        const index = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(modelValue, elementValue);
        const found = index !== -1;
        if (checked && !found) {
          assign(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign(filtered);
        }
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign(cloned);
      } else {
        assign(getCheckboxValue(el, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, {
  value,
  oldValue
}, vnode) {
  el._modelValue = value;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
    el.checked = value.has(vnode.props.value);
  } else if (value !== oldValue) {
    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, getCheckboxValue(el, true));
  }
}
const vModelRadio = {
  created(el, {
    value
  }, vnode) {
    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      el[assignKey](getValue(el));
    });
  },
  beforeUpdate(el, {
    value,
    oldValue
  }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, {
    value,
    modifiers: {
      number
    }
  }, vnode) {
    const isSetModel = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, o => o.selected).map(o => number ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseToNumber)(getValue(o)) : getValue(o));
      el[assignKey](el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
    });
    el[assignKey] = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, {
    value
  }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
  },
  updated(el, {
    value
  }) {
    setSelected(el, value);
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  if (isMultiple && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
     true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
    return;
  }
  for (let i = 0, l = el.options.length; i < l; i++) {
    const option = el.options[i];
    const optionValue = getValue(option);
    if (isMultiple) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        option.selected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, optionValue) > -1;
      } else {
        option.selected = value.has(optionValue);
      }
    } else {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(getValue(option), value)) {
        if (el.selectedIndex !== i) el.selectedIndex = i;
        return;
      }
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);
  const fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
  vModelText.getSSRProps = ({
    value
  }) => ({
    value
  });
  vModelRadio.getSSRProps = ({
    value
  }, vnode) => {
    if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(vnode.props.value, value)) {
      return {
        checked: true
      };
    }
  };
  vModelCheckbox.getSSRProps = ({
    value
  }, vnode) => {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
      if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1) {
        return {
          checked: true
        };
      }
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
      if (vnode.props && value.has(vnode.props.value)) {
        return {
          checked: true
        };
      }
    } else if (value) {
      return {
        checked: true
      };
    }
  };
  vModelDynamic.getSSRProps = (binding, vnode) => {
    if (typeof vnode.type !== "string") {
      return;
    }
    const modelToUse = resolveDynamicModel(
    // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
    vnode.type.toUpperCase(), vnode.props && vnode.props.type);
    if (modelToUse.getSSRProps) {
      return modelToUse.getSSRProps(binding, vnode);
    }
  };
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: e => e.stopPropagation(),
  prevent: e => e.preventDefault(),
  self: e => e.target !== e.currentTarget,
  ctrl: e => !e.ctrlKey,
  shift: e => !e.shiftKey,
  alt: e => !e.altKey,
  meta: e => !e.metaKey,
  left: e => "button" in e && e.button !== 0,
  middle: e => "button" in e && e.button !== 1,
  right: e => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  return (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers)) return;
    }
    return fn(event, ...args);
  };
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  return event => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event.key);
    if (modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {
      return fn(event);
    }
  };
};
const rendererOptions = /* @__PURE__ */(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({
  patchProp
}, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
  return renderer || (renderer = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer)(rendererOptions));
}
function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer)(rendererOptions);
  enabledHydration = true;
  return renderer;
}
const render = (...args) => {
  ensureRenderer().render(...args);
};
const hydrate = (...args) => {
  ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  if (true) {
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
  }
  const {
    mount
  } = app;
  app.mount = containerOrSelector => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component = app._component;
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
const createSSRApp = (...args) => {
  const app = ensureHydrationRenderer().createApp(...args);
  if (true) {
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
  }
  const {
    mount
  } = app;
  app.mount = containerOrSelector => {
    const container = normalizeContainer(containerOrSelector);
    if (container) {
      return mount(container, true, container instanceof SVGElement);
    }
  };
  return app;
};
function injectNativeTagCheck(app) {
  Object.defineProperty(app.config, "isNativeTag", {
    value: tag => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag),
    writable: false
  });
}
function injectCompilerOptionsCheck(app) {
  if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly)()) {
    const isCustomElement = app.config.isCustomElement;
    Object.defineProperty(app.config, "isCustomElement", {
      get() {
        return isCustomElement;
      },
      set() {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`);
      }
    });
    const compilerOptions = app.config.compilerOptions;
    const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
    Object.defineProperty(app.config, "compilerOptions", {
      get() {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
        return compilerOptions;
      },
      set() {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
      }
    });
  }
}
function normalizeContainer(container) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(container)) {
    const res = document.querySelector(container);
    if ( true && !res) {
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Failed to mount app: mount target selector "${container}" returned null.`);
    }
    return res;
  }
  if ( true && window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
  }
  return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = () => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
};


/***/ }),

/***/ "./node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!*************************************************************!*\
  !*** ./node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EMPTY_ARR: () => (/* binding */ EMPTY_ARR),
/* harmony export */   EMPTY_OBJ: () => (/* binding */ EMPTY_OBJ),
/* harmony export */   NO: () => (/* binding */ NO),
/* harmony export */   NOOP: () => (/* binding */ NOOP),
/* harmony export */   PatchFlagNames: () => (/* binding */ PatchFlagNames),
/* harmony export */   camelize: () => (/* binding */ camelize),
/* harmony export */   capitalize: () => (/* binding */ capitalize),
/* harmony export */   def: () => (/* binding */ def),
/* harmony export */   escapeHtml: () => (/* binding */ escapeHtml),
/* harmony export */   escapeHtmlComment: () => (/* binding */ escapeHtmlComment),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   genPropsAccessExp: () => (/* binding */ genPropsAccessExp),
/* harmony export */   generateCodeFrame: () => (/* binding */ generateCodeFrame),
/* harmony export */   getGlobalThis: () => (/* binding */ getGlobalThis),
/* harmony export */   hasChanged: () => (/* binding */ hasChanged),
/* harmony export */   hasOwn: () => (/* binding */ hasOwn),
/* harmony export */   hyphenate: () => (/* binding */ hyphenate),
/* harmony export */   includeBooleanAttr: () => (/* binding */ includeBooleanAttr),
/* harmony export */   invokeArrayFns: () => (/* binding */ invokeArrayFns),
/* harmony export */   isArray: () => (/* binding */ isArray),
/* harmony export */   isBooleanAttr: () => (/* binding */ isBooleanAttr),
/* harmony export */   isBuiltInDirective: () => (/* binding */ isBuiltInDirective),
/* harmony export */   isDate: () => (/* binding */ isDate),
/* harmony export */   isFunction: () => (/* binding */ isFunction),
/* harmony export */   isGloballyAllowed: () => (/* binding */ isGloballyAllowed),
/* harmony export */   isGloballyWhitelisted: () => (/* binding */ isGloballyWhitelisted),
/* harmony export */   isHTMLTag: () => (/* binding */ isHTMLTag),
/* harmony export */   isIntegerKey: () => (/* binding */ isIntegerKey),
/* harmony export */   isKnownHtmlAttr: () => (/* binding */ isKnownHtmlAttr),
/* harmony export */   isKnownSvgAttr: () => (/* binding */ isKnownSvgAttr),
/* harmony export */   isMap: () => (/* binding */ isMap),
/* harmony export */   isModelListener: () => (/* binding */ isModelListener),
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   isOn: () => (/* binding */ isOn),
/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),
/* harmony export */   isPromise: () => (/* binding */ isPromise),
/* harmony export */   isRegExp: () => (/* binding */ isRegExp),
/* harmony export */   isReservedProp: () => (/* binding */ isReservedProp),
/* harmony export */   isSSRSafeAttrName: () => (/* binding */ isSSRSafeAttrName),
/* harmony export */   isSVGTag: () => (/* binding */ isSVGTag),
/* harmony export */   isSet: () => (/* binding */ isSet),
/* harmony export */   isSpecialBooleanAttr: () => (/* binding */ isSpecialBooleanAttr),
/* harmony export */   isString: () => (/* binding */ isString),
/* harmony export */   isSymbol: () => (/* binding */ isSymbol),
/* harmony export */   isVoidTag: () => (/* binding */ isVoidTag),
/* harmony export */   looseEqual: () => (/* binding */ looseEqual),
/* harmony export */   looseIndexOf: () => (/* binding */ looseIndexOf),
/* harmony export */   looseToNumber: () => (/* binding */ looseToNumber),
/* harmony export */   makeMap: () => (/* binding */ makeMap),
/* harmony export */   normalizeClass: () => (/* binding */ normalizeClass),
/* harmony export */   normalizeProps: () => (/* binding */ normalizeProps),
/* harmony export */   normalizeStyle: () => (/* binding */ normalizeStyle),
/* harmony export */   objectToString: () => (/* binding */ objectToString),
/* harmony export */   parseStringStyle: () => (/* binding */ parseStringStyle),
/* harmony export */   propsToAttrMap: () => (/* binding */ propsToAttrMap),
/* harmony export */   remove: () => (/* binding */ remove),
/* harmony export */   slotFlagsText: () => (/* binding */ slotFlagsText),
/* harmony export */   stringifyStyle: () => (/* binding */ stringifyStyle),
/* harmony export */   toDisplayString: () => (/* binding */ toDisplayString),
/* harmony export */   toHandlerKey: () => (/* binding */ toHandlerKey),
/* harmony export */   toNumber: () => (/* binding */ toNumber),
/* harmony export */   toRawType: () => (/* binding */ toRawType),
/* harmony export */   toTypeString: () => (/* binding */ toTypeString)
/* harmony export */ });
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
}
const EMPTY_OBJ =  true ? Object.freeze({}) : 0;
const EMPTY_ARR =  true ? Object.freeze([]) : 0;
const NOOP = () => {};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = key => onRE.test(key);
const isModelListener = key => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = val => toTypeString(val) === "[object Map]";
const isSet = val => toTypeString(val) === "[object Set]";
const isDate = val => toTypeString(val) === "[object Date]";
const isRegExp = val => toTypeString(val) === "[object RegExp]";
const isFunction = val => typeof val === "function";
const isString = val => typeof val === "string";
const isSymbol = val => typeof val === "symbol";
const isObject = val => val !== null && typeof val === "object";
const isPromise = val => {
  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = value => objectToString.call(value);
const toRawType = value => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = val => toTypeString(val) === "[object Object]";
const isIntegerKey = key => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */makeMap(
// the leading comma is intentional so empty string "" is also included
",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
const isBuiltInDirective = /* @__PURE__ */makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
const cacheStringFunction = fn => {
  const cache = /* @__PURE__ */Object.create(null);
  return str => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction(str => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(str => str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction(str => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction(str => {
  const s = str ? `on${capitalize(str)}` : ``;
  return s;
});
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = val => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = val => {
  const n = isString(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : {});
};
const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}
const PatchFlagNames = {
  [1]: `TEXT`,
  [2]: `CLASS`,
  [4]: `STYLE`,
  [8]: `PROPS`,
  [16]: `FULL_PROPS`,
  [32]: `HYDRATE_EVENTS`,
  [64]: `STABLE_FRAGMENT`,
  [128]: `KEYED_FRAGMENT`,
  [256]: `UNKEYED_FRAGMENT`,
  [512]: `NEED_PATCH`,
  [1024]: `DYNAMIC_SLOTS`,
  [2048]: `DEV_ROOT_FRAGMENT`,
  [-1]: `HOISTED`,
  [-2]: `BAIL`
};
const slotFlagsText = {
  [1]: "STABLE",
  [2]: "DYNAMIC",
  [3]: "FORWARDED"
};
const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console";
const isGloballyAllowed = /* @__PURE__ */makeMap(GLOBALS_ALLOWED);
const isGloballyWhitelisted = isGloballyAllowed;
const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
  let lines = source.split(/(\r?\n)/);
  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
  lines = lines.filter((_, idx) => idx % 2 === 0);
  let count = 0;
  const res = [];
  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
    if (count >= start) {
      for (let j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) continue;
        const line = j + 1;
        res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
        const lineLength = lines[j].length;
        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
        if (j === i) {
          const pad = start - (count - (lineLength + newLineSeqLength));
          const length = Math.max(1, end > count ? lineLength - pad : end - start);
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + newLineSeqLength;
        }
      }
      break;
    }
  }
  return res.join("\n");
}
function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value) || isObject(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach(item => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function stringifyStyle(styles) {
  let ret = "";
  if (!styles || isString(styles)) {
    return ret;
  }
  for (const key in styles) {
    const value = styles[key];
    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
    if (isString(value) || typeof value === "number") {
      ret += `${normalizedKey}:${value};`;
    }
  }
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props) return null;
  let {
    class: klass,
    style
  } = props;
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */makeMap(SVG_TAGS);
const isVoidTag = /* @__PURE__ */makeMap(VOID_TAGS);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */makeMap(specialBooleanAttrs);
const isBooleanAttr = /* @__PURE__ */makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name];
  }
  const isUnsafe = unsafeAttrCharRE.test(name);
  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name}`);
  }
  return attrValidationCache[name] = !isUnsafe;
}
const propsToAttrMap = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
};
const isKnownHtmlAttr = /* @__PURE__ */makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
const isKnownSvgAttr = /* @__PURE__ */makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);
const escapeRE = /["'&<>]/;
function escapeHtml(string) {
  const str = "" + string;
  const match = escapeRE.exec(str);
  if (!match) {
    return str;
  }
  let html = "";
  let escaped;
  let index;
  let lastIndex = 0;
  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escaped = "&quot;";
        break;
      case 38:
        escaped = "&amp;";
        break;
      case 39:
        escaped = "&#39;";
        break;
      case 60:
        escaped = "&lt;";
        break;
      case 62:
        escaped = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index) {
      html += str.slice(lastIndex, index);
    }
    lastIndex = index + 1;
    html += escaped;
  }
  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
  return src.replace(commentStripRE, "");
}
function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b) return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray(a);
  bValidType = isArray(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject(a);
  bValidType = isObject(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex(item => looseEqual(item, val));
}
const toDisplayString = val => {
  return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};


/***/ }),

/***/ "./node_modules/vue-loader/dist/exportHelper.js":
/*!******************************************************!*\
  !*** ./node_modules/vue-loader/dist/exportHelper.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
// runtime helper for setting properties on components
// in a tree-shakable way
exports["default"] = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[9].use[0]!./src/App.vue?vue&type=template&id=7ba5bd90":
/*!**************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[9].use[0]!./src/App.vue?vue&type=template&id=7ba5bd90 ***!
  \**************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm-bundler.js");

function render(_ctx, _cache) {
  var _component_router_view = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("router-view");
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_router_view)]);
}

/***/ }),

/***/ "./node_modules/vue/dist/vue.runtime.esm-bundler.js":
/*!**********************************************************!*\
  !*** ./node_modules/vue/dist/vue.runtime.esm-bundler.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseTransition: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   BaseTransitionPropsValidators: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.BaseTransitionPropsValidators),
/* harmony export */   Comment: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   EffectScope: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   Fragment: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   KeepAlive: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   ReactiveEffect: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   Static: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   Suspense: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   Teleport: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   Text: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   Transition: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Transition),
/* harmony export */   TransitionGroup: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.TransitionGroup),
/* harmony export */   VueElement: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.VueElement),
/* harmony export */   assertNumber: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.assertNumber),
/* harmony export */   callWithAsyncErrorHandling: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   callWithErrorHandling: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   camelize: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   capitalize: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   cloneVNode: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   compatUtils: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   compile: () => (/* binding */ compile),
/* harmony export */   computed: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   createApp: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createApp),
/* harmony export */   createBlock: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   createCommentVNode: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   createElementBlock: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementBlock),
/* harmony export */   createElementVNode: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementVNode),
/* harmony export */   createHydrationRenderer: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   createPropsRestProxy: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy),
/* harmony export */   createRenderer: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   createSSRApp: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSSRApp),
/* harmony export */   createSlots: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   createStaticVNode: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   createTextVNode: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   createVNode: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   customRef: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   defineAsyncComponent: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   defineComponent: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   defineCustomElement: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineCustomElement),
/* harmony export */   defineEmits: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineEmits),
/* harmony export */   defineExpose: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineExpose),
/* harmony export */   defineModel: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineModel),
/* harmony export */   defineOptions: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineOptions),
/* harmony export */   defineProps: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   defineSSRCustomElement: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineSSRCustomElement),
/* harmony export */   defineSlots: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineSlots),
/* harmony export */   devtools: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   effect: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   effectScope: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   getCurrentInstance: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   getCurrentScope: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   getTransitionRawChildren: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   guardReactiveProps: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps),
/* harmony export */   h: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   handleError: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   hasInjectionContext: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hasInjectionContext),
/* harmony export */   hydrate: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrate),
/* harmony export */   initCustomFormatter: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   initDirectivesForSSR: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initDirectivesForSSR),
/* harmony export */   inject: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   isMemoSame: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isMemoSame),
/* harmony export */   isProxy: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   isReactive: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   isReadonly: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   isRef: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   isRuntimeOnly: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   isShallow: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   isVNode: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   markRaw: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   mergeDefaults: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),
/* harmony export */   mergeModels: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeModels),
/* harmony export */   mergeProps: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   nextTick: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   normalizeClass: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeClass),
/* harmony export */   normalizeProps: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeProps),
/* harmony export */   normalizeStyle: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle),
/* harmony export */   onActivated: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   onBeforeMount: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   onBeforeUnmount: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   onBeforeUpdate: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   onDeactivated: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   onErrorCaptured: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   onMounted: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   onRenderTracked: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   onRenderTriggered: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   onScopeDispose: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   onServerPrefetch: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   onUnmounted: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   onUpdated: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   openBlock: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   popScopeId: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   provide: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   proxyRefs: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   pushScopeId: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   queuePostFlushCb: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   reactive: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   readonly: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   ref: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   registerRuntimeCompiler: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   render: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   renderList: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   renderSlot: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   resolveComponent: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   resolveDirective: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   resolveDynamicComponent: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   resolveFilter: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   resolveTransitionHooks: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   setBlockTracking: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   setDevtoolsHook: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   setTransitionHooks: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   shallowReactive: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   shallowReadonly: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   shallowRef: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   ssrContextKey: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   ssrUtils: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   stop: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   toDisplayString: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   toHandlerKey: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   toHandlers: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   toRaw: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   toRef: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   toRefs: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   toValue: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toValue),
/* harmony export */   transformVNodeArgs: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   triggerRef: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   unref: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   useAttrs: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useAttrs),
/* harmony export */   useCssModule: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssModule),
/* harmony export */   useCssVars: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssVars),
/* harmony export */   useModel: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useModel),
/* harmony export */   useSSRContext: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   useSlots: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSlots),
/* harmony export */   useTransitionState: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   vModelCheckbox: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelCheckbox),
/* harmony export */   vModelDynamic: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelDynamic),
/* harmony export */   vModelRadio: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelRadio),
/* harmony export */   vModelSelect: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelSelect),
/* harmony export */   vModelText: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelText),
/* harmony export */   vShow: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vShow),
/* harmony export */   version: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   warn: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   watch: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   watchEffect: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   watchPostEffect: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect),
/* harmony export */   watchSyncEffect: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect),
/* harmony export */   withAsyncContext: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),
/* harmony export */   withCtx: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   withDefaults: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDefaults),
/* harmony export */   withDirectives: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   withKeys: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withKeys),
/* harmony export */   withMemo: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withMemo),
/* harmony export */   withModifiers: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withModifiers),
/* harmony export */   withScopeId: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withScopeId)
/* harmony export */ });
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js");


function initDev() {
  {
    (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.initCustomFormatter)();
  }
}
if (true) {
  initDev();
}
const compile = () => {
  if (true) {
    (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.warn)(`Runtime compilation is not supported in this build of Vue.` + ` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
    /* should not happen */);
  }
};



/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm-bundler.js");
/* harmony import */ var pinia__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! pinia */ "./node_modules/pinia/dist/pinia.mjs");
/* harmony import */ var _App_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/App.vue */ "./src/App.vue");
/* harmony import */ var _router_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/router/router */ "./src/router/router.ts");


// 导入根组件

// 导入路由实例

// 创建 vue 应用实例
var app = (0,vue__WEBPACK_IMPORTED_MODULE_0__.createApp)(_App_vue__WEBPACK_IMPORTED_MODULE_1__["default"]);
// 创建 pinia 应用实例
var pinia = (0,pinia__WEBPACK_IMPORTED_MODULE_3__.createPinia)();
// 注册路由实例、pinia应用实例
app.use(_router_router__WEBPACK_IMPORTED_MODULE_2__["default"]).use(pinia);
// 挂载 vue 应用实例
app.mount("#app");


/***/ }),

/***/ "./src/router/router.ts":
/*!******************************!*\
  !*** ./src/router/router.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue_router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue-router */ "./node_modules/vue-router/dist/vue-router.mjs");

// 定义路由配置
var routes = [
    { path: '/', component: function () { return Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_echarts_lib_core_echarts_js"), __webpack_require__.e("src_views_Home_vue")]).then(__webpack_require__.bind(__webpack_require__, /*! @/views/Home.vue */ "./src/views/Home.vue")); } }
];
// 创建路由实例
var router = (0,vue_router__WEBPACK_IMPORTED_MODULE_0__.createRouter)({
    history: (0,vue_router__WEBPACK_IMPORTED_MODULE_0__.createWebHistory)(),
    routes: routes // 定义路由配置
});
// 导出路由实例
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (router);


/***/ }),

/***/ "./src/App.vue":
/*!*********************!*\
  !*** ./src/App.vue ***!
  \*********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _App_vue_vue_type_template_id_7ba5bd90__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App.vue?vue&type=template&id=7ba5bd90 */ "./src/App.vue?vue&type=template&id=7ba5bd90");
/* harmony import */ var _node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");

const script = {}

;
const __exports__ = /*#__PURE__*/(0,_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_1__["default"])(script, [['render',_App_vue_vue_type_template_id_7ba5bd90__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"src/App.vue"]])
/* hot reload */
if (true) {
  __exports__.__hmrId = "7ba5bd90"
  const api = __VUE_HMR_RUNTIME__
  module.hot.accept()
  if (!api.createRecord('7ba5bd90', __exports__)) {
    api.reload('7ba5bd90', __exports__)
  }
  
  module.hot.accept(/*! ./App.vue?vue&type=template&id=7ba5bd90 */ "./src/App.vue?vue&type=template&id=7ba5bd90", __WEBPACK_OUTDATED_DEPENDENCIES__ => { /* harmony import */ _App_vue_vue_type_template_id_7ba5bd90__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App.vue?vue&type=template&id=7ba5bd90 */ "./src/App.vue?vue&type=template&id=7ba5bd90");
(() => {
    api.rerender('7ba5bd90', _App_vue_vue_type_template_id_7ba5bd90__WEBPACK_IMPORTED_MODULE_0__.render)
  })(__WEBPACK_OUTDATED_DEPENDENCIES__); })

}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./src/App.vue?vue&type=template&id=7ba5bd90":
/*!***************************************************!*\
  !*** ./src/App.vue?vue&type=template&id=7ba5bd90 ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_3_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_9_use_0_App_vue_vue_type_template_id_7ba5bd90__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_3_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_9_use_0_App_vue_vue_type_template_id_7ba5bd90__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../node_modules/babel-loader/lib/index.js!../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[9].use[0]!./App.vue?vue&type=template&id=7ba5bd90 */ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[9].use[0]!./src/App.vue?vue&type=template&id=7ba5bd90");


/***/ }),

/***/ "./node_modules/pinia/dist/pinia.mjs":
/*!*******************************************!*\
  !*** ./node_modules/pinia/dist/pinia.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MutationType: () => (/* binding */ MutationType),
/* harmony export */   PiniaVuePlugin: () => (/* binding */ PiniaVuePlugin),
/* harmony export */   acceptHMRUpdate: () => (/* binding */ acceptHMRUpdate),
/* harmony export */   createPinia: () => (/* binding */ createPinia),
/* harmony export */   defineStore: () => (/* binding */ defineStore),
/* harmony export */   getActivePinia: () => (/* binding */ getActivePinia),
/* harmony export */   mapActions: () => (/* binding */ mapActions),
/* harmony export */   mapGetters: () => (/* binding */ mapGetters),
/* harmony export */   mapState: () => (/* binding */ mapState),
/* harmony export */   mapStores: () => (/* binding */ mapStores),
/* harmony export */   mapWritableState: () => (/* binding */ mapWritableState),
/* harmony export */   setActivePinia: () => (/* binding */ setActivePinia),
/* harmony export */   setMapStoreSuffix: () => (/* binding */ setMapStoreSuffix),
/* harmony export */   skipHydrate: () => (/* binding */ skipHydrate),
/* harmony export */   storeToRefs: () => (/* binding */ storeToRefs)
/* harmony export */ });
/* harmony import */ var vue_demi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue-demi */ "./node_modules/pinia/node_modules/vue-demi/lib/index.mjs");
/* harmony import */ var _vue_devtools_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/devtools-api */ "./node_modules/@vue/devtools-api/lib/esm/index.js");
/*!
 * pinia v2.1.7
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */



/**
 * setActivePinia must be called to handle SSR at the top of functions like
 * `fetch`, `setup`, `serverPrefetch` and others
 */
let activePinia;
/**
 * Sets or unsets the active pinia. Used in SSR and internally when calling
 * actions and getters
 *
 * @param pinia - Pinia instance
 */
// @ts-expect-error: cannot constrain the type of the return
const setActivePinia = (pinia) => (activePinia = pinia);
/**
 * Get the currently active pinia if there is any.
 */
const getActivePinia = () => ((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.hasInjectionContext)() && (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.inject)(piniaSymbol)) || activePinia;
const piniaSymbol = (( true) ? Symbol('pinia') : /* istanbul ignore next */ 0);

function isPlainObject(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
o) {
    return (o &&
        typeof o === 'object' &&
        Object.prototype.toString.call(o) === '[object Object]' &&
        typeof o.toJSON !== 'function');
}
// type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> }
// TODO: can we change these to numbers?
/**
 * Possible types for SubscriptionCallback
 */
var MutationType;
(function (MutationType) {
    /**
     * Direct mutation of the state:
     *
     * - `store.name = 'new name'`
     * - `store.$state.name = 'new name'`
     * - `store.list.push('new item')`
     */
    MutationType["direct"] = "direct";
    /**
     * Mutated the state with `$patch` and an object
     *
     * - `store.$patch({ name: 'newName' })`
     */
    MutationType["patchObject"] = "patch object";
    /**
     * Mutated the state with `$patch` and a function
     *
     * - `store.$patch(state => state.name = 'newName')`
     */
    MutationType["patchFunction"] = "patch function";
    // maybe reset? for $state = {} and $reset
})(MutationType || (MutationType = {}));

const IS_CLIENT = typeof window !== 'undefined';
/**
 * Should we add the devtools plugins.
 * - only if dev mode or forced through the prod devtools flag
 * - not in test
 * - only if window exists (could change in the future)
 */
const USE_DEVTOOLS =  true && IS_CLIENT;

/*
 * FileSaver.js A saveAs() FileSaver implementation.
 *
 * Originally by Eli Grey, adapted as an ESM module by Eduardo San Martin
 * Morote.
 *
 * License : MIT
 */
// The one and only way of getting global scope in all environments
// https://stackoverflow.com/q/3277182/1008999
const _global = /*#__PURE__*/ (() => typeof window === 'object' && window.window === window
    ? window
    : typeof self === 'object' && self.self === self
        ? self
        : typeof global === 'object' && global.global === global
            ? global
            : typeof globalThis === 'object'
                ? globalThis
                : { HTMLElement: null })();
function bom(blob, { autoBom = false } = {}) {
    // prepend BOM for UTF-8 XML and text/* types (including HTML)
    // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
    if (autoBom &&
        /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
        return new Blob([String.fromCharCode(0xfeff), blob], { type: blob.type });
    }
    return blob;
}
function download(url, name, opts) {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.responseType = 'blob';
    xhr.onload = function () {
        saveAs(xhr.response, name, opts);
    };
    xhr.onerror = function () {
        console.error('could not download file');
    };
    xhr.send();
}
function corsEnabled(url) {
    const xhr = new XMLHttpRequest();
    // use sync to avoid popup blocker
    xhr.open('HEAD', url, false);
    try {
        xhr.send();
    }
    catch (e) { }
    return xhr.status >= 200 && xhr.status <= 299;
}
// `a.click()` doesn't work for all browsers (#465)
function click(node) {
    try {
        node.dispatchEvent(new MouseEvent('click'));
    }
    catch (e) {
        const evt = document.createEvent('MouseEvents');
        evt.initMouseEvent('click', true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
        node.dispatchEvent(evt);
    }
}
const _navigator = 
 typeof navigator === 'object' ? navigator : { userAgent: '' };
// Detect WebView inside a native macOS app by ruling out all browsers
// We just need to check for 'Safari' because all other browsers (besides Firefox) include that too
// https://www.whatismybrowser.com/guides/the-latest-user-agent/macos
const isMacOSWebView = /*#__PURE__*/ (() => /Macintosh/.test(_navigator.userAgent) &&
    /AppleWebKit/.test(_navigator.userAgent) &&
    !/Safari/.test(_navigator.userAgent))();
const saveAs = !IS_CLIENT
    ? () => { } // noop
    : // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program
        typeof HTMLAnchorElement !== 'undefined' &&
            'download' in HTMLAnchorElement.prototype &&
            !isMacOSWebView
            ? downloadSaveAs
            : // Use msSaveOrOpenBlob as a second approach
                'msSaveOrOpenBlob' in _navigator
                    ? msSaveAs
                    : // Fallback to using FileReader and a popup
                        fileSaverSaveAs;
function downloadSaveAs(blob, name = 'download', opts) {
    const a = document.createElement('a');
    a.download = name;
    a.rel = 'noopener'; // tabnabbing
    // TODO: detect chrome extensions & packaged apps
    // a.target = '_blank'
    if (typeof blob === 'string') {
        // Support regular links
        a.href = blob;
        if (a.origin !== location.origin) {
            if (corsEnabled(a.href)) {
                download(blob, name, opts);
            }
            else {
                a.target = '_blank';
                click(a);
            }
        }
        else {
            click(a);
        }
    }
    else {
        // Support blobs
        a.href = URL.createObjectURL(blob);
        setTimeout(function () {
            URL.revokeObjectURL(a.href);
        }, 4e4); // 40s
        setTimeout(function () {
            click(a);
        }, 0);
    }
}
function msSaveAs(blob, name = 'download', opts) {
    if (typeof blob === 'string') {
        if (corsEnabled(blob)) {
            download(blob, name, opts);
        }
        else {
            const a = document.createElement('a');
            a.href = blob;
            a.target = '_blank';
            setTimeout(function () {
                click(a);
            });
        }
    }
    else {
        // @ts-ignore: works on windows
        navigator.msSaveOrOpenBlob(bom(blob, opts), name);
    }
}
function fileSaverSaveAs(blob, name, opts, popup) {
    // Open a popup immediately do go around popup blocker
    // Mostly only available on user interaction and the fileReader is async so...
    popup = popup || open('', '_blank');
    if (popup) {
        popup.document.title = popup.document.body.innerText = 'downloading...';
    }
    if (typeof blob === 'string')
        return download(blob, name, opts);
    const force = blob.type === 'application/octet-stream';
    const isSafari = /constructor/i.test(String(_global.HTMLElement)) || 'safari' in _global;
    const isChromeIOS = /CriOS\/[\d]+/.test(navigator.userAgent);
    if ((isChromeIOS || (force && isSafari) || isMacOSWebView) &&
        typeof FileReader !== 'undefined') {
        // Safari doesn't allow downloading of blob URLs
        const reader = new FileReader();
        reader.onloadend = function () {
            let url = reader.result;
            if (typeof url !== 'string') {
                popup = null;
                throw new Error('Wrong reader.result type');
            }
            url = isChromeIOS
                ? url
                : url.replace(/^data:[^;]*;/, 'data:attachment/file;');
            if (popup) {
                popup.location.href = url;
            }
            else {
                location.assign(url);
            }
            popup = null; // reverse-tabnabbing #460
        };
        reader.readAsDataURL(blob);
    }
    else {
        const url = URL.createObjectURL(blob);
        if (popup)
            popup.location.assign(url);
        else
            location.href = url;
        popup = null; // reverse-tabnabbing #460
        setTimeout(function () {
            URL.revokeObjectURL(url);
        }, 4e4); // 40s
    }
}

/**
 * Shows a toast or console.log
 *
 * @param message - message to log
 * @param type - different color of the tooltip
 */
function toastMessage(message, type) {
    const piniaMessage = '🍍 ' + message;
    if (typeof __VUE_DEVTOOLS_TOAST__ === 'function') {
        // No longer available :(
        __VUE_DEVTOOLS_TOAST__(piniaMessage, type);
    }
    else if (type === 'error') {
        console.error(piniaMessage);
    }
    else if (type === 'warn') {
        console.warn(piniaMessage);
    }
    else {
        console.log(piniaMessage);
    }
}
function isPinia(o) {
    return '_a' in o && 'install' in o;
}

/**
 * This file contain devtools actions, they are not Pinia actions.
 */
// ---
function checkClipboardAccess() {
    if (!('clipboard' in navigator)) {
        toastMessage(`Your browser doesn't support the Clipboard API`, 'error');
        return true;
    }
}
function checkNotFocusedError(error) {
    if (error instanceof Error &&
        error.message.toLowerCase().includes('document is not focused')) {
        toastMessage('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', 'warn');
        return true;
    }
    return false;
}
async function actionGlobalCopyState(pinia) {
    if (checkClipboardAccess())
        return;
    try {
        await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));
        toastMessage('Global state copied to clipboard.');
    }
    catch (error) {
        if (checkNotFocusedError(error))
            return;
        toastMessage(`Failed to serialize the state. Check the console for more details.`, 'error');
        console.error(error);
    }
}
async function actionGlobalPasteState(pinia) {
    if (checkClipboardAccess())
        return;
    try {
        loadStoresState(pinia, JSON.parse(await navigator.clipboard.readText()));
        toastMessage('Global state pasted from clipboard.');
    }
    catch (error) {
        if (checkNotFocusedError(error))
            return;
        toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, 'error');
        console.error(error);
    }
}
async function actionGlobalSaveState(pinia) {
    try {
        saveAs(new Blob([JSON.stringify(pinia.state.value)], {
            type: 'text/plain;charset=utf-8',
        }), 'pinia-state.json');
    }
    catch (error) {
        toastMessage(`Failed to export the state as JSON. Check the console for more details.`, 'error');
        console.error(error);
    }
}
let fileInput;
function getFileOpener() {
    if (!fileInput) {
        fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.json';
    }
    function openFile() {
        return new Promise((resolve, reject) => {
            fileInput.onchange = async () => {
                const files = fileInput.files;
                if (!files)
                    return resolve(null);
                const file = files.item(0);
                if (!file)
                    return resolve(null);
                return resolve({ text: await file.text(), file });
            };
            // @ts-ignore: TODO: changed from 4.3 to 4.4
            fileInput.oncancel = () => resolve(null);
            fileInput.onerror = reject;
            fileInput.click();
        });
    }
    return openFile;
}
async function actionGlobalOpenStateFile(pinia) {
    try {
        const open = getFileOpener();
        const result = await open();
        if (!result)
            return;
        const { text, file } = result;
        loadStoresState(pinia, JSON.parse(text));
        toastMessage(`Global state imported from "${file.name}".`);
    }
    catch (error) {
        toastMessage(`Failed to import the state from JSON. Check the console for more details.`, 'error');
        console.error(error);
    }
}
function loadStoresState(pinia, state) {
    for (const key in state) {
        const storeState = pinia.state.value[key];
        // store is already instantiated, patch it
        if (storeState) {
            Object.assign(storeState, state[key]);
        }
        else {
            // store is not instantiated, set the initial state
            pinia.state.value[key] = state[key];
        }
    }
}

function formatDisplay(display) {
    return {
        _custom: {
            display,
        },
    };
}
const PINIA_ROOT_LABEL = '🍍 Pinia (root)';
const PINIA_ROOT_ID = '_root';
function formatStoreForInspectorTree(store) {
    return isPinia(store)
        ? {
            id: PINIA_ROOT_ID,
            label: PINIA_ROOT_LABEL,
        }
        : {
            id: store.$id,
            label: store.$id,
        };
}
function formatStoreForInspectorState(store) {
    if (isPinia(store)) {
        const storeNames = Array.from(store._s.keys());
        const storeMap = store._s;
        const state = {
            state: storeNames.map((storeId) => ({
                editable: true,
                key: storeId,
                value: store.state.value[storeId],
            })),
            getters: storeNames
                .filter((id) => storeMap.get(id)._getters)
                .map((id) => {
                const store = storeMap.get(id);
                return {
                    editable: false,
                    key: id,
                    value: store._getters.reduce((getters, key) => {
                        getters[key] = store[key];
                        return getters;
                    }, {}),
                };
            }),
        };
        return state;
    }
    const state = {
        state: Object.keys(store.$state).map((key) => ({
            editable: true,
            key,
            value: store.$state[key],
        })),
    };
    // avoid adding empty getters
    if (store._getters && store._getters.length) {
        state.getters = store._getters.map((getterName) => ({
            editable: false,
            key: getterName,
            value: store[getterName],
        }));
    }
    if (store._customProperties.size) {
        state.customProperties = Array.from(store._customProperties).map((key) => ({
            editable: true,
            key,
            value: store[key],
        }));
    }
    return state;
}
function formatEventData(events) {
    if (!events)
        return {};
    if (Array.isArray(events)) {
        // TODO: handle add and delete for arrays and objects
        return events.reduce((data, event) => {
            data.keys.push(event.key);
            data.operations.push(event.type);
            data.oldValue[event.key] = event.oldValue;
            data.newValue[event.key] = event.newValue;
            return data;
        }, {
            oldValue: {},
            keys: [],
            operations: [],
            newValue: {},
        });
    }
    else {
        return {
            operation: formatDisplay(events.type),
            key: formatDisplay(events.key),
            oldValue: events.oldValue,
            newValue: events.newValue,
        };
    }
}
function formatMutationType(type) {
    switch (type) {
        case MutationType.direct:
            return 'mutation';
        case MutationType.patchFunction:
            return '$patch';
        case MutationType.patchObject:
            return '$patch';
        default:
            return 'unknown';
    }
}

// timeline can be paused when directly changing the state
let isTimelineActive = true;
const componentStateTypes = [];
const MUTATIONS_LAYER_ID = 'pinia:mutations';
const INSPECTOR_ID = 'pinia';
const { assign: assign$1 } = Object;
/**
 * Gets the displayed name of a store in devtools
 *
 * @param id - id of the store
 * @returns a formatted string
 */
const getStoreType = (id) => '🍍 ' + id;
/**
 * Add the pinia plugin without any store. Allows displaying a Pinia plugin tab
 * as soon as it is added to the application.
 *
 * @param app - Vue application
 * @param pinia - pinia instance
 */
function registerPiniaDevtools(app, pinia) {
    (0,_vue_devtools_api__WEBPACK_IMPORTED_MODULE_1__.setupDevtoolsPlugin)({
        id: 'dev.esm.pinia',
        label: 'Pinia 🍍',
        logo: 'https://pinia.vuejs.org/logo.svg',
        packageName: 'pinia',
        homepage: 'https://pinia.vuejs.org',
        componentStateTypes,
        app,
    }, (api) => {
        if (typeof api.now !== 'function') {
            toastMessage('You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.');
        }
        api.addTimelineLayer({
            id: MUTATIONS_LAYER_ID,
            label: `Pinia 🍍`,
            color: 0xe5df88,
        });
        api.addInspector({
            id: INSPECTOR_ID,
            label: 'Pinia 🍍',
            icon: 'storage',
            treeFilterPlaceholder: 'Search stores',
            actions: [
                {
                    icon: 'content_copy',
                    action: () => {
                        actionGlobalCopyState(pinia);
                    },
                    tooltip: 'Serialize and copy the state',
                },
                {
                    icon: 'content_paste',
                    action: async () => {
                        await actionGlobalPasteState(pinia);
                        api.sendInspectorTree(INSPECTOR_ID);
                        api.sendInspectorState(INSPECTOR_ID);
                    },
                    tooltip: 'Replace the state with the content of your clipboard',
                },
                {
                    icon: 'save',
                    action: () => {
                        actionGlobalSaveState(pinia);
                    },
                    tooltip: 'Save the state as a JSON file',
                },
                {
                    icon: 'folder_open',
                    action: async () => {
                        await actionGlobalOpenStateFile(pinia);
                        api.sendInspectorTree(INSPECTOR_ID);
                        api.sendInspectorState(INSPECTOR_ID);
                    },
                    tooltip: 'Import the state from a JSON file',
                },
            ],
            nodeActions: [
                {
                    icon: 'restore',
                    tooltip: 'Reset the state (with "$reset")',
                    action: (nodeId) => {
                        const store = pinia._s.get(nodeId);
                        if (!store) {
                            toastMessage(`Cannot reset "${nodeId}" store because it wasn't found.`, 'warn');
                        }
                        else if (typeof store.$reset !== 'function') {
                            toastMessage(`Cannot reset "${nodeId}" store because it doesn't have a "$reset" method implemented.`, 'warn');
                        }
                        else {
                            store.$reset();
                            toastMessage(`Store "${nodeId}" reset.`);
                        }
                    },
                },
            ],
        });
        api.on.inspectComponent((payload, ctx) => {
            const proxy = (payload.componentInstance &&
                payload.componentInstance.proxy);
            if (proxy && proxy._pStores) {
                const piniaStores = payload.componentInstance.proxy._pStores;
                Object.values(piniaStores).forEach((store) => {
                    payload.instanceData.state.push({
                        type: getStoreType(store.$id),
                        key: 'state',
                        editable: true,
                        value: store._isOptionsAPI
                            ? {
                                _custom: {
                                    value: (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.toRaw)(store.$state),
                                    actions: [
                                        {
                                            icon: 'restore',
                                            tooltip: 'Reset the state of this store',
                                            action: () => store.$reset(),
                                        },
                                    ],
                                },
                            }
                            : // NOTE: workaround to unwrap transferred refs
                                Object.keys(store.$state).reduce((state, key) => {
                                    state[key] = store.$state[key];
                                    return state;
                                }, {}),
                    });
                    if (store._getters && store._getters.length) {
                        payload.instanceData.state.push({
                            type: getStoreType(store.$id),
                            key: 'getters',
                            editable: false,
                            value: store._getters.reduce((getters, key) => {
                                try {
                                    getters[key] = store[key];
                                }
                                catch (error) {
                                    // @ts-expect-error: we just want to show it in devtools
                                    getters[key] = error;
                                }
                                return getters;
                            }, {}),
                        });
                    }
                });
            }
        });
        api.on.getInspectorTree((payload) => {
            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
                let stores = [pinia];
                stores = stores.concat(Array.from(pinia._s.values()));
                payload.rootNodes = (payload.filter
                    ? stores.filter((store) => '$id' in store
                        ? store.$id
                            .toLowerCase()
                            .includes(payload.filter.toLowerCase())
                        : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase()))
                    : stores).map(formatStoreForInspectorTree);
            }
        });
        api.on.getInspectorState((payload) => {
            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
                const inspectedStore = payload.nodeId === PINIA_ROOT_ID
                    ? pinia
                    : pinia._s.get(payload.nodeId);
                if (!inspectedStore) {
                    // this could be the selected store restored for a different project
                    // so it's better not to say anything here
                    return;
                }
                if (inspectedStore) {
                    payload.state = formatStoreForInspectorState(inspectedStore);
                }
            }
        });
        api.on.editInspectorState((payload, ctx) => {
            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
                const inspectedStore = payload.nodeId === PINIA_ROOT_ID
                    ? pinia
                    : pinia._s.get(payload.nodeId);
                if (!inspectedStore) {
                    return toastMessage(`store "${payload.nodeId}" not found`, 'error');
                }
                const { path } = payload;
                if (!isPinia(inspectedStore)) {
                    // access only the state
                    if (path.length !== 1 ||
                        !inspectedStore._customProperties.has(path[0]) ||
                        path[0] in inspectedStore.$state) {
                        path.unshift('$state');
                    }
                }
                else {
                    // Root access, we can omit the `.value` because the devtools API does it for us
                    path.unshift('state');
                }
                isTimelineActive = false;
                payload.set(inspectedStore, path, payload.state.value);
                isTimelineActive = true;
            }
        });
        api.on.editComponentState((payload) => {
            if (payload.type.startsWith('🍍')) {
                const storeId = payload.type.replace(/^🍍\s*/, '');
                const store = pinia._s.get(storeId);
                if (!store) {
                    return toastMessage(`store "${storeId}" not found`, 'error');
                }
                const { path } = payload;
                if (path[0] !== 'state') {
                    return toastMessage(`Invalid path for store "${storeId}":\n${path}\nOnly state can be modified.`);
                }
                // rewrite the first entry to be able to directly set the state as
                // well as any other path
                path[0] = '$state';
                isTimelineActive = false;
                payload.set(store, path, payload.state.value);
                isTimelineActive = true;
            }
        });
    });
}
function addStoreToDevtools(app, store) {
    if (!componentStateTypes.includes(getStoreType(store.$id))) {
        componentStateTypes.push(getStoreType(store.$id));
    }
    (0,_vue_devtools_api__WEBPACK_IMPORTED_MODULE_1__.setupDevtoolsPlugin)({
        id: 'dev.esm.pinia',
        label: 'Pinia 🍍',
        logo: 'https://pinia.vuejs.org/logo.svg',
        packageName: 'pinia',
        homepage: 'https://pinia.vuejs.org',
        componentStateTypes,
        app,
        settings: {
            logStoreChanges: {
                label: 'Notify about new/deleted stores',
                type: 'boolean',
                defaultValue: true,
            },
            // useEmojis: {
            //   label: 'Use emojis in messages ⚡️',
            //   type: 'boolean',
            //   defaultValue: true,
            // },
        },
    }, (api) => {
        // gracefully handle errors
        const now = typeof api.now === 'function' ? api.now.bind(api) : Date.now;
        store.$onAction(({ after, onError, name, args }) => {
            const groupId = runningActionId++;
            api.addTimelineEvent({
                layerId: MUTATIONS_LAYER_ID,
                event: {
                    time: now(),
                    title: '🛫 ' + name,
                    subtitle: 'start',
                    data: {
                        store: formatDisplay(store.$id),
                        action: formatDisplay(name),
                        args,
                    },
                    groupId,
                },
            });
            after((result) => {
                activeAction = undefined;
                api.addTimelineEvent({
                    layerId: MUTATIONS_LAYER_ID,
                    event: {
                        time: now(),
                        title: '🛬 ' + name,
                        subtitle: 'end',
                        data: {
                            store: formatDisplay(store.$id),
                            action: formatDisplay(name),
                            args,
                            result,
                        },
                        groupId,
                    },
                });
            });
            onError((error) => {
                activeAction = undefined;
                api.addTimelineEvent({
                    layerId: MUTATIONS_LAYER_ID,
                    event: {
                        time: now(),
                        logType: 'error',
                        title: '💥 ' + name,
                        subtitle: 'end',
                        data: {
                            store: formatDisplay(store.$id),
                            action: formatDisplay(name),
                            args,
                            error,
                        },
                        groupId,
                    },
                });
            });
        }, true);
        store._customProperties.forEach((name) => {
            (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(() => (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(store[name]), (newValue, oldValue) => {
                api.notifyComponentUpdate();
                api.sendInspectorState(INSPECTOR_ID);
                if (isTimelineActive) {
                    api.addTimelineEvent({
                        layerId: MUTATIONS_LAYER_ID,
                        event: {
                            time: now(),
                            title: 'Change',
                            subtitle: name,
                            data: {
                                newValue,
                                oldValue,
                            },
                            groupId: activeAction,
                        },
                    });
                }
            }, { deep: true });
        });
        store.$subscribe(({ events, type }, state) => {
            api.notifyComponentUpdate();
            api.sendInspectorState(INSPECTOR_ID);
            if (!isTimelineActive)
                return;
            // rootStore.state[store.id] = state
            const eventData = {
                time: now(),
                title: formatMutationType(type),
                data: assign$1({ store: formatDisplay(store.$id) }, formatEventData(events)),
                groupId: activeAction,
            };
            if (type === MutationType.patchFunction) {
                eventData.subtitle = '⤵️';
            }
            else if (type === MutationType.patchObject) {
                eventData.subtitle = '🧩';
            }
            else if (events && !Array.isArray(events)) {
                eventData.subtitle = events.type;
            }
            if (events) {
                eventData.data['rawEvent(s)'] = {
                    _custom: {
                        display: 'DebuggerEvent',
                        type: 'object',
                        tooltip: 'raw DebuggerEvent[]',
                        value: events,
                    },
                };
            }
            api.addTimelineEvent({
                layerId: MUTATIONS_LAYER_ID,
                event: eventData,
            });
        }, { detached: true, flush: 'sync' });
        const hotUpdate = store._hotUpdate;
        store._hotUpdate = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.markRaw)((newStore) => {
            hotUpdate(newStore);
            api.addTimelineEvent({
                layerId: MUTATIONS_LAYER_ID,
                event: {
                    time: now(),
                    title: '🔥 ' + store.$id,
                    subtitle: 'HMR update',
                    data: {
                        store: formatDisplay(store.$id),
                        info: formatDisplay(`HMR update`),
                    },
                },
            });
            // update the devtools too
            api.notifyComponentUpdate();
            api.sendInspectorTree(INSPECTOR_ID);
            api.sendInspectorState(INSPECTOR_ID);
        });
        const { $dispose } = store;
        store.$dispose = () => {
            $dispose();
            api.notifyComponentUpdate();
            api.sendInspectorTree(INSPECTOR_ID);
            api.sendInspectorState(INSPECTOR_ID);
            api.getSettings().logStoreChanges &&
                toastMessage(`Disposed "${store.$id}" store 🗑`);
        };
        // trigger an update so it can display new registered stores
        api.notifyComponentUpdate();
        api.sendInspectorTree(INSPECTOR_ID);
        api.sendInspectorState(INSPECTOR_ID);
        api.getSettings().logStoreChanges &&
            toastMessage(`"${store.$id}" store installed 🆕`);
    });
}
let runningActionId = 0;
let activeAction;
/**
 * Patches a store to enable action grouping in devtools by wrapping the store with a Proxy that is passed as the
 * context of all actions, allowing us to set `runningAction` on each access and effectively associating any state
 * mutation to the action.
 *
 * @param store - store to patch
 * @param actionNames - list of actionst to patch
 */
function patchActionForGrouping(store, actionNames, wrapWithProxy) {
    // original actions of the store as they are given by pinia. We are going to override them
    const actions = actionNames.reduce((storeActions, actionName) => {
        // use toRaw to avoid tracking #541
        storeActions[actionName] = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.toRaw)(store)[actionName];
        return storeActions;
    }, {});
    for (const actionName in actions) {
        store[actionName] = function () {
            // the running action id is incremented in a before action hook
            const _actionId = runningActionId;
            const trackedStore = wrapWithProxy
                ? new Proxy(store, {
                    get(...args) {
                        activeAction = _actionId;
                        return Reflect.get(...args);
                    },
                    set(...args) {
                        activeAction = _actionId;
                        return Reflect.set(...args);
                    },
                })
                : store;
            // For Setup Stores we need https://github.com/tc39/proposal-async-context
            activeAction = _actionId;
            const retValue = actions[actionName].apply(trackedStore, arguments);
            // this is safer as async actions in Setup Stores would associate mutations done outside of the action
            activeAction = undefined;
            return retValue;
        };
    }
}
/**
 * pinia.use(devtoolsPlugin)
 */
function devtoolsPlugin({ app, store, options }) {
    // HMR module
    if (store.$id.startsWith('__hot:')) {
        return;
    }
    // detect option api vs setup api
    store._isOptionsAPI = !!options.state;
    patchActionForGrouping(store, Object.keys(options.actions), store._isOptionsAPI);
    // Upgrade the HMR to also update the new actions
    const originalHotUpdate = store._hotUpdate;
    (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.toRaw)(store)._hotUpdate = function (newStore) {
        originalHotUpdate.apply(this, arguments);
        patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions), !!store._isOptionsAPI);
    };
    addStoreToDevtools(app, 
    // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?
    store);
}

/**
 * Creates a Pinia instance to be used by the application
 */
function createPinia() {
    const scope = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.effectScope)(true);
    // NOTE: here we could check the window object for a state and directly set it
    // if there is anything like it with Vue 3 SSR
    const state = scope.run(() => (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)({}));
    let _p = [];
    // plugins added before calling app.use(pinia)
    let toBeInstalled = [];
    const pinia = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.markRaw)({
        install(app) {
            // this allows calling useStore() outside of a component setup after
            // installing pinia's plugin
            setActivePinia(pinia);
            if (!vue_demi__WEBPACK_IMPORTED_MODULE_0__.isVue2) {
                pinia._a = app;
                app.provide(piniaSymbol, pinia);
                app.config.globalProperties.$pinia = pinia;
                /* istanbul ignore else */
                if (USE_DEVTOOLS) {
                    registerPiniaDevtools(app, pinia);
                }
                toBeInstalled.forEach((plugin) => _p.push(plugin));
                toBeInstalled = [];
            }
        },
        use(plugin) {
            if (!this._a && !vue_demi__WEBPACK_IMPORTED_MODULE_0__.isVue2) {
                toBeInstalled.push(plugin);
            }
            else {
                _p.push(plugin);
            }
            return this;
        },
        _p,
        // it's actually undefined here
        // @ts-expect-error
        _a: null,
        _e: scope,
        _s: new Map(),
        state,
    });
    // pinia devtools rely on dev only features so they cannot be forced unless
    // the dev build of Vue is used. Avoid old browsers like IE11.
    if (USE_DEVTOOLS && typeof Proxy !== 'undefined') {
        pinia.use(devtoolsPlugin);
    }
    return pinia;
}

/**
 * Checks if a function is a `StoreDefinition`.
 *
 * @param fn - object to test
 * @returns true if `fn` is a StoreDefinition
 */
const isUseStore = (fn) => {
    return typeof fn === 'function' && typeof fn.$id === 'string';
};
/**
 * Mutates in place `newState` with `oldState` to _hot update_ it. It will
 * remove any key not existing in `newState` and recursively merge plain
 * objects.
 *
 * @param newState - new state object to be patched
 * @param oldState - old state that should be used to patch newState
 * @returns - newState
 */
function patchObject(newState, oldState) {
    // no need to go through symbols because they cannot be serialized anyway
    for (const key in oldState) {
        const subPatch = oldState[key];
        // skip the whole sub tree
        if (!(key in newState)) {
            continue;
        }
        const targetValue = newState[key];
        if (isPlainObject(targetValue) &&
            isPlainObject(subPatch) &&
            !(0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isRef)(subPatch) &&
            !(0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isReactive)(subPatch)) {
            newState[key] = patchObject(targetValue, subPatch);
        }
        else {
            // objects are either a bit more complex (e.g. refs) or primitives, so we
            // just set the whole thing
            if (vue_demi__WEBPACK_IMPORTED_MODULE_0__.isVue2) {
                (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.set)(newState, key, subPatch);
            }
            else {
                newState[key] = subPatch;
            }
        }
    }
    return newState;
}
/**
 * Creates an _accept_ function to pass to `import.meta.hot` in Vite applications.
 *
 * @example
 * ```js
 * const useUser = defineStore(...)
 * if (import.meta.hot) {
 *   import.meta.hot.accept(acceptHMRUpdate(useUser, import.meta.hot))
 * }
 * ```
 *
 * @param initialUseStore - return of the defineStore to hot update
 * @param hot - `import.meta.hot`
 */
function acceptHMRUpdate(initialUseStore, hot) {
    // strip as much as possible from iife.prod
    if (false) {}
    return (newModule) => {
        const pinia = hot.data.pinia || initialUseStore._pinia;
        if (!pinia) {
            // this store is still not used
            return;
        }
        // preserve the pinia instance across loads
        hot.data.pinia = pinia;
        // console.log('got data', newStore)
        for (const exportName in newModule) {
            const useStore = newModule[exportName];
            // console.log('checking for', exportName)
            if (isUseStore(useStore) && pinia._s.has(useStore.$id)) {
                // console.log('Accepting update for', useStore.$id)
                const id = useStore.$id;
                if (id !== initialUseStore.$id) {
                    console.warn(`The id of the store changed from "${initialUseStore.$id}" to "${id}". Reloading.`);
                    // return import.meta.hot.invalidate()
                    return hot.invalidate();
                }
                const existingStore = pinia._s.get(id);
                if (!existingStore) {
                    console.log(`[Pinia]: skipping hmr because store doesn't exist yet`);
                    return;
                }
                useStore(pinia, existingStore);
            }
        }
    };
}

const noop = () => { };
function addSubscription(subscriptions, callback, detached, onCleanup = noop) {
    subscriptions.push(callback);
    const removeSubscription = () => {
        const idx = subscriptions.indexOf(callback);
        if (idx > -1) {
            subscriptions.splice(idx, 1);
            onCleanup();
        }
    };
    if (!detached && (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope)()) {
        (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose)(removeSubscription);
    }
    return removeSubscription;
}
function triggerSubscriptions(subscriptions, ...args) {
    subscriptions.slice().forEach((callback) => {
        callback(...args);
    });
}

const fallbackRunWithContext = (fn) => fn();
function mergeReactiveObjects(target, patchToApply) {
    // Handle Map instances
    if (target instanceof Map && patchToApply instanceof Map) {
        patchToApply.forEach((value, key) => target.set(key, value));
    }
    // Handle Set instances
    if (target instanceof Set && patchToApply instanceof Set) {
        patchToApply.forEach(target.add, target);
    }
    // no need to go through symbols because they cannot be serialized anyway
    for (const key in patchToApply) {
        if (!patchToApply.hasOwnProperty(key))
            continue;
        const subPatch = patchToApply[key];
        const targetValue = target[key];
        if (isPlainObject(targetValue) &&
            isPlainObject(subPatch) &&
            target.hasOwnProperty(key) &&
            !(0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isRef)(subPatch) &&
            !(0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isReactive)(subPatch)) {
            // NOTE: here I wanted to warn about inconsistent types but it's not possible because in setup stores one might
            // start the value of a property as a certain type e.g. a Map, and then for some reason, during SSR, change that
            // to `undefined`. When trying to hydrate, we want to override the Map with `undefined`.
            target[key] = mergeReactiveObjects(targetValue, subPatch);
        }
        else {
            // @ts-expect-error: subPatch is a valid value
            target[key] = subPatch;
        }
    }
    return target;
}
const skipHydrateSymbol = ( true)
    ? Symbol('pinia:skipHydration')
    : /* istanbul ignore next */ 0;
const skipHydrateMap = /*#__PURE__*/ new WeakMap();
/**
 * Tells Pinia to skip the hydration process of a given object. This is useful in setup stores (only) when you return a
 * stateful object in the store but it isn't really state. e.g. returning a router instance in a setup store.
 *
 * @param obj - target object
 * @returns obj
 */
function skipHydrate(obj) {
    return vue_demi__WEBPACK_IMPORTED_MODULE_0__.isVue2
        ? // in @vue/composition-api, the refs are sealed so defineProperty doesn't work...
            /* istanbul ignore next */ skipHydrateMap.set(obj, 1) && obj
        : Object.defineProperty(obj, skipHydrateSymbol, {});
}
/**
 * Returns whether a value should be hydrated
 *
 * @param obj - target variable
 * @returns true if `obj` should be hydrated
 */
function shouldHydrate(obj) {
    return vue_demi__WEBPACK_IMPORTED_MODULE_0__.isVue2
        ? /* istanbul ignore next */ !skipHydrateMap.has(obj)
        : !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
}
const { assign } = Object;
function isComputed(o) {
    return !!((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isRef)(o) && o.effect);
}
function createOptionsStore(id, options, pinia, hot) {
    const { state, actions, getters } = options;
    const initialState = pinia.state.value[id];
    let store;
    function setup() {
        if (!initialState && ( false || !hot)) {
            /* istanbul ignore if */
            if (vue_demi__WEBPACK_IMPORTED_MODULE_0__.isVue2) {
                (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.set)(pinia.state.value, id, state ? state() : {});
            }
            else {
                pinia.state.value[id] = state ? state() : {};
            }
        }
        // avoid creating a state in pinia.state.value
        const localState = ( true) && hot
            ? // use ref() to unwrap refs inside state TODO: check if this is still necessary
                (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.toRefs)((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(state ? state() : {}).value)
            : (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.toRefs)(pinia.state.value[id]);
        return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
            if (( true) && name in localState) {
                console.warn(`[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with "${name}" in store "${id}".`);
            }
            computedGetters[name] = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.markRaw)((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
                setActivePinia(pinia);
                // it was created just before
                const store = pinia._s.get(id);
                // allow cross using stores
                /* istanbul ignore next */
                if (vue_demi__WEBPACK_IMPORTED_MODULE_0__.isVue2 && !store._r)
                    return;
                // @ts-expect-error
                // return getters![name].call(context, context)
                // TODO: avoid reading the getter while assigning with a global variable
                return getters[name].call(store, store);
            }));
            return computedGetters;
        }, {}));
    }
    store = createSetupStore(id, setup, options, pinia, hot, true);
    return store;
}
function createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {
    let scope;
    const optionsForPlugin = assign({ actions: {} }, options);
    /* istanbul ignore if */
    if (( true) && !pinia._e.active) {
        throw new Error('Pinia destroyed');
    }
    // watcher options for $subscribe
    const $subscribeOptions = {
        deep: true,
        // flush: 'post',
    };
    /* istanbul ignore else */
    if (( true) && !vue_demi__WEBPACK_IMPORTED_MODULE_0__.isVue2) {
        $subscribeOptions.onTrigger = (event) => {
            /* istanbul ignore else */
            if (isListening) {
                debuggerEvents = event;
                // avoid triggering this while the store is being built and the state is being set in pinia
            }
            else if (isListening == false && !store._hotUpdating) {
                // let patch send all the events together later
                /* istanbul ignore else */
                if (Array.isArray(debuggerEvents)) {
                    debuggerEvents.push(event);
                }
                else {
                    console.error('🍍 debuggerEvents should be an array. This is most likely an internal Pinia bug.');
                }
            }
        };
    }
    // internal state
    let isListening; // set to true at the end
    let isSyncListening; // set to true at the end
    let subscriptions = [];
    let actionSubscriptions = [];
    let debuggerEvents;
    const initialState = pinia.state.value[$id];
    // avoid setting the state for option stores if it is set
    // by the setup
    if (!isOptionsStore && !initialState && ( false || !hot)) {
        /* istanbul ignore if */
        if (vue_demi__WEBPACK_IMPORTED_MODULE_0__.isVue2) {
            (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.set)(pinia.state.value, $id, {});
        }
        else {
            pinia.state.value[$id] = {};
        }
    }
    const hotState = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)({});
    // avoid triggering too many listeners
    // https://github.com/vuejs/pinia/issues/1129
    let activeListener;
    function $patch(partialStateOrMutator) {
        let subscriptionMutation;
        isListening = isSyncListening = false;
        // reset the debugger events since patches are sync
        /* istanbul ignore else */
        if ((true)) {
            debuggerEvents = [];
        }
        if (typeof partialStateOrMutator === 'function') {
            partialStateOrMutator(pinia.state.value[$id]);
            subscriptionMutation = {
                type: MutationType.patchFunction,
                storeId: $id,
                events: debuggerEvents,
            };
        }
        else {
            mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
            subscriptionMutation = {
                type: MutationType.patchObject,
                payload: partialStateOrMutator,
                storeId: $id,
                events: debuggerEvents,
            };
        }
        const myListenerId = (activeListener = Symbol());
        (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.nextTick)().then(() => {
            if (activeListener === myListenerId) {
                isListening = true;
            }
        });
        isSyncListening = true;
        // because we paused the watcher, we need to manually call the subscriptions
        triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
    }
    const $reset = isOptionsStore
        ? function $reset() {
            const { state } = options;
            const newState = state ? state() : {};
            // we use a patch to group all changes into one single subscription
            this.$patch(($state) => {
                assign($state, newState);
            });
        }
        : /* istanbul ignore next */
            ( true)
                ? () => {
                    throw new Error(`🍍: Store "${$id}" is built using the setup syntax and does not implement $reset().`);
                }
                : 0;
    function $dispose() {
        scope.stop();
        subscriptions = [];
        actionSubscriptions = [];
        pinia._s.delete($id);
    }
    /**
     * Wraps an action to handle subscriptions.
     *
     * @param name - name of the action
     * @param action - action to wrap
     * @returns a wrapped action to handle subscriptions
     */
    function wrapAction(name, action) {
        return function () {
            setActivePinia(pinia);
            const args = Array.from(arguments);
            const afterCallbackList = [];
            const onErrorCallbackList = [];
            function after(callback) {
                afterCallbackList.push(callback);
            }
            function onError(callback) {
                onErrorCallbackList.push(callback);
            }
            // @ts-expect-error
            triggerSubscriptions(actionSubscriptions, {
                args,
                name,
                store,
                after,
                onError,
            });
            let ret;
            try {
                ret = action.apply(this && this.$id === $id ? this : store, args);
                // handle sync errors
            }
            catch (error) {
                triggerSubscriptions(onErrorCallbackList, error);
                throw error;
            }
            if (ret instanceof Promise) {
                return ret
                    .then((value) => {
                    triggerSubscriptions(afterCallbackList, value);
                    return value;
                })
                    .catch((error) => {
                    triggerSubscriptions(onErrorCallbackList, error);
                    return Promise.reject(error);
                });
            }
            // trigger after callbacks
            triggerSubscriptions(afterCallbackList, ret);
            return ret;
        };
    }
    const _hmrPayload = /*#__PURE__*/ (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.markRaw)({
        actions: {},
        getters: {},
        state: [],
        hotState,
    });
    const partialStore = {
        _p: pinia,
        // _s: scope,
        $id,
        $onAction: addSubscription.bind(null, actionSubscriptions),
        $patch,
        $reset,
        $subscribe(callback, options = {}) {
            const removeSubscription = addSubscription(subscriptions, callback, options.detached, () => stopWatcher());
            const stopWatcher = scope.run(() => (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(() => pinia.state.value[$id], (state) => {
                if (options.flush === 'sync' ? isSyncListening : isListening) {
                    callback({
                        storeId: $id,
                        type: MutationType.direct,
                        events: debuggerEvents,
                    }, state);
                }
            }, assign({}, $subscribeOptions, options)));
            return removeSubscription;
        },
        $dispose,
    };
    /* istanbul ignore if */
    if (vue_demi__WEBPACK_IMPORTED_MODULE_0__.isVue2) {
        // start as non ready
        partialStore._r = false;
    }
    const store = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.reactive)( true
        ? assign({
            _hmrPayload,
            _customProperties: (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.markRaw)(new Set()), // devtools custom properties
        }, partialStore
        // must be added later
        // setupStore
        )
        : 0);
    // store the partial store now so the setup of stores can instantiate each other before they are finished without
    // creating infinite loops.
    pinia._s.set($id, store);
    const runWithContext = (pinia._a && pinia._a.runWithContext) || fallbackRunWithContext;
    // TODO: idea create skipSerialize that marks properties as non serializable and they are skipped
    const setupStore = runWithContext(() => pinia._e.run(() => (scope = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.effectScope)()).run(setup)));
    // overwrite existing actions to support $onAction
    for (const key in setupStore) {
        const prop = setupStore[key];
        if (((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isRef)(prop) && !isComputed(prop)) || (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isReactive)(prop)) {
            // mark it as a piece of state to be serialized
            if (( true) && hot) {
                (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.set)(hotState.value, key, (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.toRef)(setupStore, key));
                // createOptionStore directly sets the state in pinia.state.value so we
                // can just skip that
            }
            else if (!isOptionsStore) {
                // in setup stores we must hydrate the state and sync pinia state tree with the refs the user just created
                if (initialState && shouldHydrate(prop)) {
                    if ((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isRef)(prop)) {
                        prop.value = initialState[key];
                    }
                    else {
                        // probably a reactive object, lets recursively assign
                        // @ts-expect-error: prop is unknown
                        mergeReactiveObjects(prop, initialState[key]);
                    }
                }
                // transfer the ref to the pinia state to keep everything in sync
                /* istanbul ignore if */
                if (vue_demi__WEBPACK_IMPORTED_MODULE_0__.isVue2) {
                    (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.set)(pinia.state.value[$id], key, prop);
                }
                else {
                    pinia.state.value[$id][key] = prop;
                }
            }
            /* istanbul ignore else */
            if ((true)) {
                _hmrPayload.state.push(key);
            }
            // action
        }
        else if (typeof prop === 'function') {
            // @ts-expect-error: we are overriding the function we avoid wrapping if
            const actionValue = ( true) && hot ? prop : wrapAction(key, prop);
            // this a hot module replacement store because the hotUpdate method needs
            // to do it with the right context
            /* istanbul ignore if */
            if (vue_demi__WEBPACK_IMPORTED_MODULE_0__.isVue2) {
                (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.set)(setupStore, key, actionValue);
            }
            else {
                // @ts-expect-error
                setupStore[key] = actionValue;
            }
            /* istanbul ignore else */
            if ((true)) {
                _hmrPayload.actions[key] = prop;
            }
            // list actions so they can be used in plugins
            // @ts-expect-error
            optionsForPlugin.actions[key] = prop;
        }
        else if ((true)) {
            // add getters for devtools
            if (isComputed(prop)) {
                _hmrPayload.getters[key] = isOptionsStore
                    ? // @ts-expect-error
                        options.getters[key]
                    : prop;
                if (IS_CLIENT) {
                    const getters = setupStore._getters ||
                        // @ts-expect-error: same
                        (setupStore._getters = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.markRaw)([]));
                    getters.push(key);
                }
            }
        }
    }
    // add the state, getters, and action properties
    /* istanbul ignore if */
    if (vue_demi__WEBPACK_IMPORTED_MODULE_0__.isVue2) {
        Object.keys(setupStore).forEach((key) => {
            (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.set)(store, key, setupStore[key]);
        });
    }
    else {
        assign(store, setupStore);
        // allows retrieving reactive objects with `storeToRefs()`. Must be called after assigning to the reactive object.
        // Make `storeToRefs()` work with `reactive()` #799
        assign((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.toRaw)(store), setupStore);
    }
    // use this instead of a computed with setter to be able to create it anywhere
    // without linking the computed lifespan to wherever the store is first
    // created.
    Object.defineProperty(store, '$state', {
        get: () => (( true) && hot ? hotState.value : pinia.state.value[$id]),
        set: (state) => {
            /* istanbul ignore if */
            if (( true) && hot) {
                throw new Error('cannot set hotState');
            }
            $patch(($state) => {
                assign($state, state);
            });
        },
    });
    // add the hotUpdate before plugins to allow them to override it
    /* istanbul ignore else */
    if ((true)) {
        store._hotUpdate = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.markRaw)((newStore) => {
            store._hotUpdating = true;
            newStore._hmrPayload.state.forEach((stateKey) => {
                if (stateKey in store.$state) {
                    const newStateTarget = newStore.$state[stateKey];
                    const oldStateSource = store.$state[stateKey];
                    if (typeof newStateTarget === 'object' &&
                        isPlainObject(newStateTarget) &&
                        isPlainObject(oldStateSource)) {
                        patchObject(newStateTarget, oldStateSource);
                    }
                    else {
                        // transfer the ref
                        newStore.$state[stateKey] = oldStateSource;
                    }
                }
                // patch direct access properties to allow store.stateProperty to work as
                // store.$state.stateProperty
                (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.set)(store, stateKey, (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.toRef)(newStore.$state, stateKey));
            });
            // remove deleted state properties
            Object.keys(store.$state).forEach((stateKey) => {
                if (!(stateKey in newStore.$state)) {
                    (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.del)(store, stateKey);
                }
            });
            // avoid devtools logging this as a mutation
            isListening = false;
            isSyncListening = false;
            pinia.state.value[$id] = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.toRef)(newStore._hmrPayload, 'hotState');
            isSyncListening = true;
            (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.nextTick)().then(() => {
                isListening = true;
            });
            for (const actionName in newStore._hmrPayload.actions) {
                const action = newStore[actionName];
                (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.set)(store, actionName, wrapAction(actionName, action));
            }
            // TODO: does this work in both setup and option store?
            for (const getterName in newStore._hmrPayload.getters) {
                const getter = newStore._hmrPayload.getters[getterName];
                const getterValue = isOptionsStore
                    ? // special handling of options api
                        (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
                            setActivePinia(pinia);
                            return getter.call(store, store);
                        })
                    : getter;
                (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.set)(store, getterName, getterValue);
            }
            // remove deleted getters
            Object.keys(store._hmrPayload.getters).forEach((key) => {
                if (!(key in newStore._hmrPayload.getters)) {
                    (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.del)(store, key);
                }
            });
            // remove old actions
            Object.keys(store._hmrPayload.actions).forEach((key) => {
                if (!(key in newStore._hmrPayload.actions)) {
                    (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.del)(store, key);
                }
            });
            // update the values used in devtools and to allow deleting new properties later on
            store._hmrPayload = newStore._hmrPayload;
            store._getters = newStore._getters;
            store._hotUpdating = false;
        });
    }
    if (USE_DEVTOOLS) {
        const nonEnumerable = {
            writable: true,
            configurable: true,
            // avoid warning on devtools trying to display this property
            enumerable: false,
        };
        ['_p', '_hmrPayload', '_getters', '_customProperties'].forEach((p) => {
            Object.defineProperty(store, p, assign({ value: store[p] }, nonEnumerable));
        });
    }
    /* istanbul ignore if */
    if (vue_demi__WEBPACK_IMPORTED_MODULE_0__.isVue2) {
        // mark the store as ready before plugins
        store._r = true;
    }
    // apply all plugins
    pinia._p.forEach((extender) => {
        /* istanbul ignore else */
        if (USE_DEVTOOLS) {
            const extensions = scope.run(() => extender({
                store,
                app: pinia._a,
                pinia,
                options: optionsForPlugin,
            }));
            Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));
            assign(store, extensions);
        }
        else {
            assign(store, scope.run(() => extender({
                store,
                app: pinia._a,
                pinia,
                options: optionsForPlugin,
            })));
        }
    });
    if (( true) &&
        store.$state &&
        typeof store.$state === 'object' &&
        typeof store.$state.constructor === 'function' &&
        !store.$state.constructor.toString().includes('[native code]')) {
        console.warn(`[🍍]: The "state" must be a plain object. It cannot be\n` +
            `\tstate: () => new MyClass()\n` +
            `Found in store "${store.$id}".`);
    }
    // only apply hydrate to option stores with an initial state in pinia
    if (initialState &&
        isOptionsStore &&
        options.hydrate) {
        options.hydrate(store.$state, initialState);
    }
    isListening = true;
    isSyncListening = true;
    return store;
}
function defineStore(
// TODO: add proper types from above
idOrOptions, setup, setupOptions) {
    let id;
    let options;
    const isSetupStore = typeof setup === 'function';
    if (typeof idOrOptions === 'string') {
        id = idOrOptions;
        // the option store setup will contain the actual options in this case
        options = isSetupStore ? setupOptions : setup;
    }
    else {
        options = idOrOptions;
        id = idOrOptions.id;
        if (( true) && typeof id !== 'string') {
            throw new Error(`[🍍]: "defineStore()" must be passed a store id as its first argument.`);
        }
    }
    function useStore(pinia, hot) {
        const hasContext = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.hasInjectionContext)();
        pinia =
            // in test mode, ignore the argument provided as we can always retrieve a
            // pinia instance with getActivePinia()
            ( false ? 0 : pinia) ||
                (hasContext ? (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.inject)(piniaSymbol, null) : null);
        if (pinia)
            setActivePinia(pinia);
        if (( true) && !activePinia) {
            throw new Error(`[🍍]: "getActivePinia()" was called but there was no active Pinia. Are you trying to use a store before calling "app.use(pinia)"?\n` +
                `See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.\n` +
                `This will fail in production.`);
        }
        pinia = activePinia;
        if (!pinia._s.has(id)) {
            // creating the store registers it in `pinia._s`
            if (isSetupStore) {
                createSetupStore(id, setup, options, pinia);
            }
            else {
                createOptionsStore(id, options, pinia);
            }
            /* istanbul ignore else */
            if ((true)) {
                // @ts-expect-error: not the right inferred type
                useStore._pinia = pinia;
            }
        }
        const store = pinia._s.get(id);
        if (( true) && hot) {
            const hotId = '__hot:' + id;
            const newStore = isSetupStore
                ? createSetupStore(hotId, setup, options, pinia, true)
                : createOptionsStore(hotId, assign({}, options), pinia, true);
            hot._hotUpdate(newStore);
            // cleanup the state properties and the store from the cache
            delete pinia.state.value[hotId];
            pinia._s.delete(hotId);
        }
        if (( true) && IS_CLIENT) {
            const currentInstance = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
            // save stores in instances to access them devtools
            if (currentInstance &&
                currentInstance.proxy &&
                // avoid adding stores that are just built for hot module replacement
                !hot) {
                const vm = currentInstance.proxy;
                const cache = '_pStores' in vm ? vm._pStores : (vm._pStores = {});
                cache[id] = store;
            }
        }
        // StoreGeneric cannot be casted towards Store
        return store;
    }
    useStore.$id = id;
    return useStore;
}

let mapStoreSuffix = 'Store';
/**
 * Changes the suffix added by `mapStores()`. Can be set to an empty string.
 * Defaults to `"Store"`. Make sure to extend the MapStoresCustomization
 * interface if you are using TypeScript.
 *
 * @param suffix - new suffix
 */
function setMapStoreSuffix(suffix // could be 'Store' but that would be annoying for JS
) {
    mapStoreSuffix = suffix;
}
/**
 * Allows using stores without the composition API (`setup()`) by generating an
 * object to be spread in the `computed` field of a component. It accepts a list
 * of store definitions.
 *
 * @example
 * ```js
 * export default {
 *   computed: {
 *     // other computed properties
 *     ...mapStores(useUserStore, useCartStore)
 *   },
 *
 *   created() {
 *     this.userStore // store with id "user"
 *     this.cartStore // store with id "cart"
 *   }
 * }
 * ```
 *
 * @param stores - list of stores to map to an object
 */
function mapStores(...stores) {
    if (( true) && Array.isArray(stores[0])) {
        console.warn(`[🍍]: Directly pass all stores to "mapStores()" without putting them in an array:\n` +
            `Replace\n` +
            `\tmapStores([useAuthStore, useCartStore])\n` +
            `with\n` +
            `\tmapStores(useAuthStore, useCartStore)\n` +
            `This will fail in production if not fixed.`);
        stores = stores[0];
    }
    return stores.reduce((reduced, useStore) => {
        // @ts-expect-error: $id is added by defineStore
        reduced[useStore.$id + mapStoreSuffix] = function () {
            return useStore(this.$pinia);
        };
        return reduced;
    }, {});
}
/**
 * Allows using state and getters from one store without using the composition
 * API (`setup()`) by generating an object to be spread in the `computed` field
 * of a component.
 *
 * @param useStore - store to map from
 * @param keysOrMapper - array or object
 */
function mapState(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper)
        ? keysOrMapper.reduce((reduced, key) => {
            reduced[key] = function () {
                return useStore(this.$pinia)[key];
            };
            return reduced;
        }, {})
        : Object.keys(keysOrMapper).reduce((reduced, key) => {
            // @ts-expect-error
            reduced[key] = function () {
                const store = useStore(this.$pinia);
                const storeKey = keysOrMapper[key];
                // for some reason TS is unable to infer the type of storeKey to be a
                // function
                return typeof storeKey === 'function'
                    ? storeKey.call(this, store)
                    : store[storeKey];
            };
            return reduced;
        }, {});
}
/**
 * Alias for `mapState()`. You should use `mapState()` instead.
 * @deprecated use `mapState()` instead.
 */
const mapGetters = mapState;
/**
 * Allows directly using actions from your store without using the composition
 * API (`setup()`) by generating an object to be spread in the `methods` field
 * of a component.
 *
 * @param useStore - store to map from
 * @param keysOrMapper - array or object
 */
function mapActions(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper)
        ? keysOrMapper.reduce((reduced, key) => {
            // @ts-expect-error
            reduced[key] = function (...args) {
                return useStore(this.$pinia)[key](...args);
            };
            return reduced;
        }, {})
        : Object.keys(keysOrMapper).reduce((reduced, key) => {
            // @ts-expect-error
            reduced[key] = function (...args) {
                return useStore(this.$pinia)[keysOrMapper[key]](...args);
            };
            return reduced;
        }, {});
}
/**
 * Allows using state and getters from one store without using the composition
 * API (`setup()`) by generating an object to be spread in the `computed` field
 * of a component.
 *
 * @param useStore - store to map from
 * @param keysOrMapper - array or object
 */
function mapWritableState(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper)
        ? keysOrMapper.reduce((reduced, key) => {
            // @ts-ignore
            reduced[key] = {
                get() {
                    return useStore(this.$pinia)[key];
                },
                set(value) {
                    // it's easier to type it here as any
                    return (useStore(this.$pinia)[key] = value);
                },
            };
            return reduced;
        }, {})
        : Object.keys(keysOrMapper).reduce((reduced, key) => {
            // @ts-ignore
            reduced[key] = {
                get() {
                    return useStore(this.$pinia)[keysOrMapper[key]];
                },
                set(value) {
                    // it's easier to type it here as any
                    return (useStore(this.$pinia)[keysOrMapper[key]] = value);
                },
            };
            return reduced;
        }, {});
}

/**
 * Creates an object of references with all the state, getters, and plugin-added
 * state properties of the store. Similar to `toRefs()` but specifically
 * designed for Pinia stores so methods and non reactive properties are
 * completely ignored.
 *
 * @param store - store to extract the refs from
 */
function storeToRefs(store) {
    // See https://github.com/vuejs/pinia/issues/852
    // It's easier to just use toRefs() even if it includes more stuff
    if (vue_demi__WEBPACK_IMPORTED_MODULE_0__.isVue2) {
        // @ts-expect-error: toRefs include methods and others
        return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.toRefs)(store);
    }
    else {
        store = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.toRaw)(store);
        const refs = {};
        for (const key in store) {
            const value = store[key];
            if ((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isRef)(value) || (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isReactive)(value)) {
                // @ts-expect-error: the key is state or getter
                refs[key] =
                    // ---
                    (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.toRef)(store, key);
            }
        }
        return refs;
    }
}

/**
 * Vue 2 Plugin that must be installed for pinia to work. Note **you don't need
 * this plugin if you are using Nuxt.js**. Use the `buildModule` instead:
 * https://pinia.vuejs.org/ssr/nuxt.html.
 *
 * @example
 * ```js
 * import Vue from 'vue'
 * import { PiniaVuePlugin, createPinia } from 'pinia'
 *
 * Vue.use(PiniaVuePlugin)
 * const pinia = createPinia()
 *
 * new Vue({
 *   el: '#app',
 *   // ...
 *   pinia,
 * })
 * ```
 *
 * @param _Vue - `Vue` imported from 'vue'.
 */
const PiniaVuePlugin = function (_Vue) {
    // Equivalent of
    // app.config.globalProperties.$pinia = pinia
    _Vue.mixin({
        beforeCreate() {
            const options = this.$options;
            if (options.pinia) {
                const pinia = options.pinia;
                // HACK: taken from provide(): https://github.com/vuejs/composition-api/blob/main/src/apis/inject.ts#L31
                /* istanbul ignore else */
                if (!this._provided) {
                    const provideCache = {};
                    Object.defineProperty(this, '_provided', {
                        get: () => provideCache,
                        set: (v) => Object.assign(provideCache, v),
                    });
                }
                this._provided[piniaSymbol] = pinia;
                // propagate the pinia instance in an SSR friendly way
                // avoid adding it to nuxt twice
                /* istanbul ignore else */
                if (!this.$pinia) {
                    this.$pinia = pinia;
                }
                pinia._a = this;
                if (IS_CLIENT) {
                    // this allows calling useStore() outside of a component setup after
                    // installing pinia's plugin
                    setActivePinia(pinia);
                }
                if (USE_DEVTOOLS) {
                    registerPiniaDevtools(pinia._a, pinia);
                }
            }
            else if (!this.$pinia && options.parent && options.parent.$pinia) {
                this.$pinia = options.parent.$pinia;
            }
        },
        destroyed() {
            delete this._pStores;
        },
    });
};




/***/ }),

/***/ "./node_modules/pinia/node_modules/vue-demi/lib/index.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/pinia/node_modules/vue-demi/lib/index.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseTransition: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   BaseTransitionPropsValidators: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.BaseTransitionPropsValidators),
/* harmony export */   Comment: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   EffectScope: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   Fragment: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   KeepAlive: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   ReactiveEffect: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   Static: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   Suspense: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   Teleport: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   Text: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   Transition: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.Transition),
/* harmony export */   TransitionGroup: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.TransitionGroup),
/* harmony export */   Vue: () => (/* reexport module object */ vue__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   Vue2: () => (/* binding */ Vue2),
/* harmony export */   VueElement: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.VueElement),
/* harmony export */   assertNumber: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.assertNumber),
/* harmony export */   callWithAsyncErrorHandling: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   callWithErrorHandling: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   camelize: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   capitalize: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   cloneVNode: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   compatUtils: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   compile: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.compile),
/* harmony export */   computed: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   createApp: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createApp),
/* harmony export */   createBlock: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   createCommentVNode: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   createElementBlock: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock),
/* harmony export */   createElementVNode: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode),
/* harmony export */   createHydrationRenderer: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   createPropsRestProxy: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy),
/* harmony export */   createRenderer: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   createSSRApp: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createSSRApp),
/* harmony export */   createSlots: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   createStaticVNode: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   createTextVNode: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   createVNode: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   customRef: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   defineAsyncComponent: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   defineComponent: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   defineCustomElement: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineCustomElement),
/* harmony export */   defineEmits: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineEmits),
/* harmony export */   defineExpose: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineExpose),
/* harmony export */   defineModel: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineModel),
/* harmony export */   defineOptions: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineOptions),
/* harmony export */   defineProps: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   defineSSRCustomElement: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineSSRCustomElement),
/* harmony export */   defineSlots: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineSlots),
/* harmony export */   del: () => (/* binding */ del),
/* harmony export */   devtools: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   effect: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   effectScope: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   getCurrentInstance: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   getCurrentScope: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   getTransitionRawChildren: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   guardReactiveProps: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps),
/* harmony export */   h: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   handleError: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   hasInjectionContext: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.hasInjectionContext),
/* harmony export */   hydrate: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.hydrate),
/* harmony export */   initCustomFormatter: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   initDirectivesForSSR: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.initDirectivesForSSR),
/* harmony export */   inject: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   install: () => (/* binding */ install),
/* harmony export */   isMemoSame: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isMemoSame),
/* harmony export */   isProxy: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   isReactive: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   isReadonly: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   isRef: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   isRuntimeOnly: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   isShallow: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   isVNode: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   isVue2: () => (/* binding */ isVue2),
/* harmony export */   isVue3: () => (/* binding */ isVue3),
/* harmony export */   markRaw: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   mergeDefaults: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),
/* harmony export */   mergeModels: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.mergeModels),
/* harmony export */   mergeProps: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   nextTick: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   normalizeClass: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass),
/* harmony export */   normalizeProps: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.normalizeProps),
/* harmony export */   normalizeStyle: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle),
/* harmony export */   onActivated: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   onBeforeMount: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   onBeforeUnmount: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   onBeforeUpdate: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   onDeactivated: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   onErrorCaptured: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   onMounted: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   onRenderTracked: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   onRenderTriggered: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   onScopeDispose: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   onServerPrefetch: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   onUnmounted: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   onUpdated: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   openBlock: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   popScopeId: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   provide: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   proxyRefs: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   pushScopeId: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   queuePostFlushCb: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   reactive: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   readonly: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   ref: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   registerRuntimeCompiler: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   render: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   renderList: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   renderSlot: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   resolveComponent: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   resolveDirective: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   resolveDynamicComponent: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   resolveFilter: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   resolveTransitionHooks: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   setBlockTracking: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   setDevtoolsHook: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   setTransitionHooks: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   shallowReactive: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   shallowReadonly: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   shallowRef: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   ssrContextKey: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   ssrUtils: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   stop: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   toDisplayString: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   toHandlerKey: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   toHandlers: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   toRaw: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   toRef: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   toRefs: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   toValue: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toValue),
/* harmony export */   transformVNodeArgs: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   triggerRef: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   unref: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   useAttrs: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useAttrs),
/* harmony export */   useCssModule: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useCssModule),
/* harmony export */   useCssVars: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useCssVars),
/* harmony export */   useModel: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useModel),
/* harmony export */   useSSRContext: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   useSlots: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useSlots),
/* harmony export */   useTransitionState: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   vModelCheckbox: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.vModelCheckbox),
/* harmony export */   vModelDynamic: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.vModelDynamic),
/* harmony export */   vModelRadio: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.vModelRadio),
/* harmony export */   vModelSelect: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.vModelSelect),
/* harmony export */   vModelText: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.vModelText),
/* harmony export */   vShow: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.vShow),
/* harmony export */   version: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   warn: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   watch: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   watchEffect: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   watchPostEffect: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect),
/* harmony export */   watchSyncEffect: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect),
/* harmony export */   withAsyncContext: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),
/* harmony export */   withCtx: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   withDefaults: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withDefaults),
/* harmony export */   withDirectives: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   withKeys: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withKeys),
/* harmony export */   withMemo: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withMemo),
/* harmony export */   withModifiers: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withModifiers),
/* harmony export */   withScopeId: () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withScopeId)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm-bundler.js");


var isVue2 = false
var isVue3 = true
var Vue2 = undefined

function install() {}

function set(target, key, val) {
  if (Array.isArray(target)) {
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
  }
  target[key] = val
  return val
}

function del(target, key) {
  if (Array.isArray(target)) {
    target.splice(key, 1)
    return
  }
  delete target[key]
}





/***/ }),

/***/ "./node_modules/vue-router/dist/vue-router.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/vue-router/dist/vue-router.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NavigationFailureType: () => (/* binding */ NavigationFailureType),
/* harmony export */   RouterLink: () => (/* binding */ RouterLink),
/* harmony export */   RouterView: () => (/* binding */ RouterView),
/* harmony export */   START_LOCATION: () => (/* binding */ START_LOCATION_NORMALIZED),
/* harmony export */   createMemoryHistory: () => (/* binding */ createMemoryHistory),
/* harmony export */   createRouter: () => (/* binding */ createRouter),
/* harmony export */   createRouterMatcher: () => (/* binding */ createRouterMatcher),
/* harmony export */   createWebHashHistory: () => (/* binding */ createWebHashHistory),
/* harmony export */   createWebHistory: () => (/* binding */ createWebHistory),
/* harmony export */   isNavigationFailure: () => (/* binding */ isNavigationFailure),
/* harmony export */   loadRouteLocation: () => (/* binding */ loadRouteLocation),
/* harmony export */   matchedRouteKey: () => (/* binding */ matchedRouteKey),
/* harmony export */   onBeforeRouteLeave: () => (/* binding */ onBeforeRouteLeave),
/* harmony export */   onBeforeRouteUpdate: () => (/* binding */ onBeforeRouteUpdate),
/* harmony export */   parseQuery: () => (/* binding */ parseQuery),
/* harmony export */   routeLocationKey: () => (/* binding */ routeLocationKey),
/* harmony export */   routerKey: () => (/* binding */ routerKey),
/* harmony export */   routerViewLocationKey: () => (/* binding */ routerViewLocationKey),
/* harmony export */   stringifyQuery: () => (/* binding */ stringifyQuery),
/* harmony export */   useLink: () => (/* binding */ useLink),
/* harmony export */   useRoute: () => (/* binding */ useRoute),
/* harmony export */   useRouter: () => (/* binding */ useRouter),
/* harmony export */   viewDepthKey: () => (/* binding */ viewDepthKey)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm-bundler.js");
/* harmony import */ var _vue_devtools_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/devtools-api */ "./node_modules/@vue/devtools-api/lib/esm/index.js");
/*!
  * vue-router v4.2.5
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */



const isBrowser = typeof window !== 'undefined';

function isESModule(obj) {
    return obj.__esModule || obj[Symbol.toStringTag] === 'Module';
}
const assign = Object.assign;
function applyToParams(fn, params) {
    const newParams = {};
    for (const key in params) {
        const value = params[key];
        newParams[key] = isArray(value)
            ? value.map(fn)
            : fn(value);
    }
    return newParams;
}
const noop = () => { };
/**
 * Typesafe alternative to Array.isArray
 * https://github.com/microsoft/TypeScript/pull/48228
 */
const isArray = Array.isArray;

function warn(msg) {
    // avoid using ...args as it breaks in older Edge builds
    const args = Array.from(arguments).slice(1);
    console.warn.apply(console, ['[Vue Router warn]: ' + msg].concat(args));
}

const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, '');
/**
 * Transforms a URI into a normalized history location
 *
 * @param parseQuery
 * @param location - URI to normalize
 * @param currentLocation - current absolute location. Allows resolving relative
 * paths. Must start with `/`. Defaults to `/`
 * @returns a normalized history location
 */
function parseURL(parseQuery, location, currentLocation = '/') {
    let path, query = {}, searchString = '', hash = '';
    // Could use URL and URLSearchParams but IE 11 doesn't support it
    // TODO: move to new URL()
    const hashPos = location.indexOf('#');
    let searchPos = location.indexOf('?');
    // the hash appears before the search, so it's not part of the search string
    if (hashPos < searchPos && hashPos >= 0) {
        searchPos = -1;
    }
    if (searchPos > -1) {
        path = location.slice(0, searchPos);
        searchString = location.slice(searchPos + 1, hashPos > -1 ? hashPos : location.length);
        query = parseQuery(searchString);
    }
    if (hashPos > -1) {
        path = path || location.slice(0, hashPos);
        // keep the # character
        hash = location.slice(hashPos, location.length);
    }
    // no search and no query
    path = resolveRelativePath(path != null ? path : location, currentLocation);
    // empty path means a relative query or hash `?foo=f`, `#thing`
    return {
        fullPath: path + (searchString && '?') + searchString + hash,
        path,
        query,
        hash,
    };
}
/**
 * Stringifies a URL object
 *
 * @param stringifyQuery
 * @param location
 */
function stringifyURL(stringifyQuery, location) {
    const query = location.query ? stringifyQuery(location.query) : '';
    return location.path + (query && '?') + query + (location.hash || '');
}
/**
 * Strips off the base from the beginning of a location.pathname in a non-case-sensitive way.
 *
 * @param pathname - location.pathname
 * @param base - base to strip off
 */
function stripBase(pathname, base) {
    // no base or base is not found at the beginning
    if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
        return pathname;
    return pathname.slice(base.length) || '/';
}
/**
 * Checks if two RouteLocation are equal. This means that both locations are
 * pointing towards the same {@link RouteRecord} and that all `params`, `query`
 * parameters and `hash` are the same
 *
 * @param stringifyQuery - A function that takes a query object of type LocationQueryRaw and returns a string representation of it.
 * @param a - first {@link RouteLocation}
 * @param b - second {@link RouteLocation}
 */
function isSameRouteLocation(stringifyQuery, a, b) {
    const aLastIndex = a.matched.length - 1;
    const bLastIndex = b.matched.length - 1;
    return (aLastIndex > -1 &&
        aLastIndex === bLastIndex &&
        isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) &&
        isSameRouteLocationParams(a.params, b.params) &&
        stringifyQuery(a.query) === stringifyQuery(b.query) &&
        a.hash === b.hash);
}
/**
 * Check if two `RouteRecords` are equal. Takes into account aliases: they are
 * considered equal to the `RouteRecord` they are aliasing.
 *
 * @param a - first {@link RouteRecord}
 * @param b - second {@link RouteRecord}
 */
function isSameRouteRecord(a, b) {
    // since the original record has an undefined value for aliasOf
    // but all aliases point to the original record, this will always compare
    // the original record
    return (a.aliasOf || a) === (b.aliasOf || b);
}
function isSameRouteLocationParams(a, b) {
    if (Object.keys(a).length !== Object.keys(b).length)
        return false;
    for (const key in a) {
        if (!isSameRouteLocationParamsValue(a[key], b[key]))
            return false;
    }
    return true;
}
function isSameRouteLocationParamsValue(a, b) {
    return isArray(a)
        ? isEquivalentArray(a, b)
        : isArray(b)
            ? isEquivalentArray(b, a)
            : a === b;
}
/**
 * Check if two arrays are the same or if an array with one single entry is the
 * same as another primitive value. Used to check query and parameters
 *
 * @param a - array of values
 * @param b - array of values or a single value
 */
function isEquivalentArray(a, b) {
    return isArray(b)
        ? a.length === b.length && a.every((value, i) => value === b[i])
        : a.length === 1 && a[0] === b;
}
/**
 * Resolves a relative path that starts with `.`.
 *
 * @param to - path location we are resolving
 * @param from - currentLocation.path, should start with `/`
 */
function resolveRelativePath(to, from) {
    if (to.startsWith('/'))
        return to;
    if (( true) && !from.startsWith('/')) {
        warn(`Cannot resolve a relative location without an absolute path. Trying to resolve "${to}" from "${from}". It should look like "/${from}".`);
        return to;
    }
    if (!to)
        return from;
    const fromSegments = from.split('/');
    const toSegments = to.split('/');
    const lastToSegment = toSegments[toSegments.length - 1];
    // make . and ./ the same (../ === .., ../../ === ../..)
    // this is the same behavior as new URL()
    if (lastToSegment === '..' || lastToSegment === '.') {
        toSegments.push('');
    }
    let position = fromSegments.length - 1;
    let toPosition;
    let segment;
    for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
        segment = toSegments[toPosition];
        // we stay on the same position
        if (segment === '.')
            continue;
        // go up in the from array
        if (segment === '..') {
            // we can't go below zero, but we still need to increment toPosition
            if (position > 1)
                position--;
            // continue
        }
        // we reached a non-relative path, we stop here
        else
            break;
    }
    return (fromSegments.slice(0, position).join('/') +
        '/' +
        toSegments
            // ensure we use at least the last element in the toSegments
            .slice(toPosition - (toPosition === toSegments.length ? 1 : 0))
            .join('/'));
}

var NavigationType;
(function (NavigationType) {
    NavigationType["pop"] = "pop";
    NavigationType["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function (NavigationDirection) {
    NavigationDirection["back"] = "back";
    NavigationDirection["forward"] = "forward";
    NavigationDirection["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
/**
 * Starting location for Histories
 */
const START = '';
// Generic utils
/**
 * Normalizes a base by removing any trailing slash and reading the base tag if
 * present.
 *
 * @param base - base to normalize
 */
function normalizeBase(base) {
    if (!base) {
        if (isBrowser) {
            // respect <base> tag
            const baseEl = document.querySelector('base');
            base = (baseEl && baseEl.getAttribute('href')) || '/';
            // strip full URL origin
            base = base.replace(/^\w+:\/\/[^\/]+/, '');
        }
        else {
            base = '/';
        }
    }
    // ensure leading slash when it was removed by the regex above avoid leading
    // slash with hash because the file could be read from the disk like file://
    // and the leading slash would cause problems
    if (base[0] !== '/' && base[0] !== '#')
        base = '/' + base;
    // remove the trailing slash so all other method can just do `base + fullPath`
    // to build an href
    return removeTrailingSlash(base);
}
// remove any character before the hash
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base, location) {
    return base.replace(BEFORE_HASH_RE, '#') + location;
}

function getElementPosition(el, offset) {
    const docRect = document.documentElement.getBoundingClientRect();
    const elRect = el.getBoundingClientRect();
    return {
        behavior: offset.behavior,
        left: elRect.left - docRect.left - (offset.left || 0),
        top: elRect.top - docRect.top - (offset.top || 0),
    };
}
const computeScrollPosition = () => ({
    left: window.pageXOffset,
    top: window.pageYOffset,
});
function scrollToPosition(position) {
    let scrollToOptions;
    if ('el' in position) {
        const positionEl = position.el;
        const isIdSelector = typeof positionEl === 'string' && positionEl.startsWith('#');
        /**
         * `id`s can accept pretty much any characters, including CSS combinators
         * like `>` or `~`. It's still possible to retrieve elements using
         * `document.getElementById('~')` but it needs to be escaped when using
         * `document.querySelector('#\\~')` for it to be valid. The only
         * requirements for `id`s are them to be unique on the page and to not be
         * empty (`id=""`). Because of that, when passing an id selector, it should
         * be properly escaped for it to work with `querySelector`. We could check
         * for the id selector to be simple (no CSS combinators `+ >~`) but that
         * would make things inconsistent since they are valid characters for an
         * `id` but would need to be escaped when using `querySelector`, breaking
         * their usage and ending up in no selector returned. Selectors need to be
         * escaped:
         *
         * - `#1-thing` becomes `#\31 -thing`
         * - `#with~symbols` becomes `#with\\~symbols`
         *
         * - More information about  the topic can be found at
         *   https://mathiasbynens.be/notes/html5-id-class.
         * - Practical example: https://mathiasbynens.be/demo/html5-id
         */
        if (( true) && typeof position.el === 'string') {
            if (!isIdSelector || !document.getElementById(position.el.slice(1))) {
                try {
                    const foundEl = document.querySelector(position.el);
                    if (isIdSelector && foundEl) {
                        warn(`The selector "${position.el}" should be passed as "el: document.querySelector('${position.el}')" because it starts with "#".`);
                        // return to avoid other warnings
                        return;
                    }
                }
                catch (err) {
                    warn(`The selector "${position.el}" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);
                    // return to avoid other warnings
                    return;
                }
            }
        }
        const el = typeof positionEl === 'string'
            ? isIdSelector
                ? document.getElementById(positionEl.slice(1))
                : document.querySelector(positionEl)
            : positionEl;
        if (!el) {
            ( true) &&
                warn(`Couldn't find element using selector "${position.el}" returned by scrollBehavior.`);
            return;
        }
        scrollToOptions = getElementPosition(el, position);
    }
    else {
        scrollToOptions = position;
    }
    if ('scrollBehavior' in document.documentElement.style)
        window.scrollTo(scrollToOptions);
    else {
        window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
    }
}
function getScrollKey(path, delta) {
    const position = history.state ? history.state.position - delta : -1;
    return position + path;
}
const scrollPositions = new Map();
function saveScrollPosition(key, scrollPosition) {
    scrollPositions.set(key, scrollPosition);
}
function getSavedScrollPosition(key) {
    const scroll = scrollPositions.get(key);
    // consume it so it's not used again
    scrollPositions.delete(key);
    return scroll;
}
// TODO: RFC about how to save scroll position
/**
 * ScrollBehavior instance used by the router to compute and restore the scroll
 * position when navigating.
 */
// export interface ScrollHandler<ScrollPositionEntry extends HistoryStateValue, ScrollPosition extends ScrollPositionEntry> {
//   // returns a scroll position that can be saved in history
//   compute(): ScrollPositionEntry
//   // can take an extended ScrollPositionEntry
//   scroll(position: ScrollPosition): void
// }
// export const scrollHandler: ScrollHandler<ScrollPosition> = {
//   compute: computeScroll,
//   scroll: scrollToPosition,
// }

let createBaseLocation = () => location.protocol + '//' + location.host;
/**
 * Creates a normalized history location from a window.location object
 * @param base - The base path
 * @param location - The window.location object
 */
function createCurrentLocation(base, location) {
    const { pathname, search, hash } = location;
    // allows hash bases like #, /#, #/, #!, #!/, /#!/, or even /folder#end
    const hashPos = base.indexOf('#');
    if (hashPos > -1) {
        let slicePos = hash.includes(base.slice(hashPos))
            ? base.slice(hashPos).length
            : 1;
        let pathFromHash = hash.slice(slicePos);
        // prepend the starting slash to hash so the url starts with /#
        if (pathFromHash[0] !== '/')
            pathFromHash = '/' + pathFromHash;
        return stripBase(pathFromHash, '');
    }
    const path = stripBase(pathname, base);
    return path + search + hash;
}
function useHistoryListeners(base, historyState, currentLocation, replace) {
    let listeners = [];
    let teardowns = [];
    // TODO: should it be a stack? a Dict. Check if the popstate listener
    // can trigger twice
    let pauseState = null;
    const popStateHandler = ({ state, }) => {
        const to = createCurrentLocation(base, location);
        const from = currentLocation.value;
        const fromState = historyState.value;
        let delta = 0;
        if (state) {
            currentLocation.value = to;
            historyState.value = state;
            // ignore the popstate and reset the pauseState
            if (pauseState && pauseState === from) {
                pauseState = null;
                return;
            }
            delta = fromState ? state.position - fromState.position : 0;
        }
        else {
            replace(to);
        }
        // Here we could also revert the navigation by calling history.go(-delta)
        // this listener will have to be adapted to not trigger again and to wait for the url
        // to be updated before triggering the listeners. Some kind of validation function would also
        // need to be passed to the listeners so the navigation can be accepted
        // call all listeners
        listeners.forEach(listener => {
            listener(currentLocation.value, from, {
                delta,
                type: NavigationType.pop,
                direction: delta
                    ? delta > 0
                        ? NavigationDirection.forward
                        : NavigationDirection.back
                    : NavigationDirection.unknown,
            });
        });
    };
    function pauseListeners() {
        pauseState = currentLocation.value;
    }
    function listen(callback) {
        // set up the listener and prepare teardown callbacks
        listeners.push(callback);
        const teardown = () => {
            const index = listeners.indexOf(callback);
            if (index > -1)
                listeners.splice(index, 1);
        };
        teardowns.push(teardown);
        return teardown;
    }
    function beforeUnloadListener() {
        const { history } = window;
        if (!history.state)
            return;
        history.replaceState(assign({}, history.state, { scroll: computeScrollPosition() }), '');
    }
    function destroy() {
        for (const teardown of teardowns)
            teardown();
        teardowns = [];
        window.removeEventListener('popstate', popStateHandler);
        window.removeEventListener('beforeunload', beforeUnloadListener);
    }
    // set up the listeners and prepare teardown callbacks
    window.addEventListener('popstate', popStateHandler);
    // TODO: could we use 'pagehide' or 'visibilitychange' instead?
    // https://developer.chrome.com/blog/page-lifecycle-api/
    window.addEventListener('beforeunload', beforeUnloadListener, {
        passive: true,
    });
    return {
        pauseListeners,
        listen,
        destroy,
    };
}
/**
 * Creates a state object
 */
function buildState(back, current, forward, replaced = false, computeScroll = false) {
    return {
        back,
        current,
        forward,
        replaced,
        position: window.history.length,
        scroll: computeScroll ? computeScrollPosition() : null,
    };
}
function useHistoryStateNavigation(base) {
    const { history, location } = window;
    // private variables
    const currentLocation = {
        value: createCurrentLocation(base, location),
    };
    const historyState = { value: history.state };
    // build current history entry as this is a fresh navigation
    if (!historyState.value) {
        changeLocation(currentLocation.value, {
            back: null,
            current: currentLocation.value,
            forward: null,
            // the length is off by one, we need to decrease it
            position: history.length - 1,
            replaced: true,
            // don't add a scroll as the user may have an anchor, and we want
            // scrollBehavior to be triggered without a saved position
            scroll: null,
        }, true);
    }
    function changeLocation(to, state, replace) {
        /**
         * if a base tag is provided, and we are on a normal domain, we have to
         * respect the provided `base` attribute because pushState() will use it and
         * potentially erase anything before the `#` like at
         * https://github.com/vuejs/router/issues/685 where a base of
         * `/folder/#` but a base of `/` would erase the `/folder/` section. If
         * there is no host, the `<base>` tag makes no sense and if there isn't a
         * base tag we can just use everything after the `#`.
         */
        const hashIndex = base.indexOf('#');
        const url = hashIndex > -1
            ? (location.host && document.querySelector('base')
                ? base
                : base.slice(hashIndex)) + to
            : createBaseLocation() + base + to;
        try {
            // BROWSER QUIRK
            // NOTE: Safari throws a SecurityError when calling this function 100 times in 30 seconds
            history[replace ? 'replaceState' : 'pushState'](state, '', url);
            historyState.value = state;
        }
        catch (err) {
            if ((true)) {
                warn('Error with push/replace State', err);
            }
            else {}
            // Force the navigation, this also resets the call count
            location[replace ? 'replace' : 'assign'](url);
        }
    }
    function replace(to, data) {
        const state = assign({}, history.state, buildState(historyState.value.back, 
        // keep back and forward entries but override current position
        to, historyState.value.forward, true), data, { position: historyState.value.position });
        changeLocation(to, state, true);
        currentLocation.value = to;
    }
    function push(to, data) {
        // Add to current entry the information of where we are going
        // as well as saving the current position
        const currentState = assign({}, 
        // use current history state to gracefully handle a wrong call to
        // history.replaceState
        // https://github.com/vuejs/router/issues/366
        historyState.value, history.state, {
            forward: to,
            scroll: computeScrollPosition(),
        });
        if (( true) && !history.state) {
            warn(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\n\n` +
                `history.replaceState(history.state, '', url)\n\n` +
                `You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`);
        }
        changeLocation(currentState.current, currentState, true);
        const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);
        changeLocation(to, state, false);
        currentLocation.value = to;
    }
    return {
        location: currentLocation,
        state: historyState,
        push,
        replace,
    };
}
/**
 * Creates an HTML5 history. Most common history for single page applications.
 *
 * @param base -
 */
function createWebHistory(base) {
    base = normalizeBase(base);
    const historyNavigation = useHistoryStateNavigation(base);
    const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
    function go(delta, triggerListeners = true) {
        if (!triggerListeners)
            historyListeners.pauseListeners();
        history.go(delta);
    }
    const routerHistory = assign({
        // it's overridden right after
        location: '',
        base,
        go,
        createHref: createHref.bind(null, base),
    }, historyNavigation, historyListeners);
    Object.defineProperty(routerHistory, 'location', {
        enumerable: true,
        get: () => historyNavigation.location.value,
    });
    Object.defineProperty(routerHistory, 'state', {
        enumerable: true,
        get: () => historyNavigation.state.value,
    });
    return routerHistory;
}

/**
 * Creates an in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.
 * It's up to the user to replace that location with the starter location by either calling `router.push` or `router.replace`.
 *
 * @param base - Base applied to all urls, defaults to '/'
 * @returns a history object that can be passed to the router constructor
 */
function createMemoryHistory(base = '') {
    let listeners = [];
    let queue = [START];
    let position = 0;
    base = normalizeBase(base);
    function setLocation(location) {
        position++;
        if (position !== queue.length) {
            // we are in the middle, we remove everything from here in the queue
            queue.splice(position);
        }
        queue.push(location);
    }
    function triggerListeners(to, from, { direction, delta }) {
        const info = {
            direction,
            delta,
            type: NavigationType.pop,
        };
        for (const callback of listeners) {
            callback(to, from, info);
        }
    }
    const routerHistory = {
        // rewritten by Object.defineProperty
        location: START,
        // TODO: should be kept in queue
        state: {},
        base,
        createHref: createHref.bind(null, base),
        replace(to) {
            // remove current entry and decrement position
            queue.splice(position--, 1);
            setLocation(to);
        },
        push(to, data) {
            setLocation(to);
        },
        listen(callback) {
            listeners.push(callback);
            return () => {
                const index = listeners.indexOf(callback);
                if (index > -1)
                    listeners.splice(index, 1);
            };
        },
        destroy() {
            listeners = [];
            queue = [START];
            position = 0;
        },
        go(delta, shouldTrigger = true) {
            const from = this.location;
            const direction = 
            // we are considering delta === 0 going forward, but in abstract mode
            // using 0 for the delta doesn't make sense like it does in html5 where
            // it reloads the page
            delta < 0 ? NavigationDirection.back : NavigationDirection.forward;
            position = Math.max(0, Math.min(position + delta, queue.length - 1));
            if (shouldTrigger) {
                triggerListeners(this.location, from, {
                    direction,
                    delta,
                });
            }
        },
    };
    Object.defineProperty(routerHistory, 'location', {
        enumerable: true,
        get: () => queue[position],
    });
    return routerHistory;
}

/**
 * Creates a hash history. Useful for web applications with no host (e.g. `file://`) or when configuring a server to
 * handle any URL is not possible.
 *
 * @param base - optional base to provide. Defaults to `location.pathname + location.search` If there is a `<base>` tag
 * in the `head`, its value will be ignored in favor of this parameter **but note it affects all the history.pushState()
 * calls**, meaning that if you use a `<base>` tag, it's `href` value **has to match this parameter** (ignoring anything
 * after the `#`).
 *
 * @example
 * ```js
 * // at https://example.com/folder
 * createWebHashHistory() // gives a url of `https://example.com/folder#`
 * createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`
 * // if the `#` is provided in the base, it won't be added by `createWebHashHistory`
 * createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`
 * // you should avoid doing this because it changes the original url and breaks copying urls
 * createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`
 *
 * // at file:///usr/etc/folder/index.html
 * // for locations with no `host`, the base is ignored
 * createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`
 * ```
 */
function createWebHashHistory(base) {
    // Make sure this implementation is fine in terms of encoding, specially for IE11
    // for `file://`, directly use the pathname and ignore the base
    // location.pathname contains an initial `/` even at the root: `https://example.com`
    base = location.host ? base || location.pathname + location.search : '';
    // allow the user to provide a `#` in the middle: `/base/#/app`
    if (!base.includes('#'))
        base += '#';
    if (( true) && !base.endsWith('#/') && !base.endsWith('#')) {
        warn(`A hash base must end with a "#":\n"${base}" should be "${base.replace(/#.*$/, '#')}".`);
    }
    return createWebHistory(base);
}

function isRouteLocation(route) {
    return typeof route === 'string' || (route && typeof route === 'object');
}
function isRouteName(name) {
    return typeof name === 'string' || typeof name === 'symbol';
}

/**
 * Initial route location where the router is. Can be used in navigation guards
 * to differentiate the initial navigation.
 *
 * @example
 * ```js
 * import { START_LOCATION } from 'vue-router'
 *
 * router.beforeEach((to, from) => {
 *   if (from === START_LOCATION) {
 *     // initial navigation
 *   }
 * })
 * ```
 */
const START_LOCATION_NORMALIZED = {
    path: '/',
    name: undefined,
    params: {},
    query: {},
    hash: '',
    fullPath: '/',
    matched: [],
    meta: {},
    redirectedFrom: undefined,
};

const NavigationFailureSymbol = Symbol(( true) ? 'navigation failure' : 0);
/**
 * Enumeration with all possible types for navigation failures. Can be passed to
 * {@link isNavigationFailure} to check for specific failures.
 */
var NavigationFailureType;
(function (NavigationFailureType) {
    /**
     * An aborted navigation is a navigation that failed because a navigation
     * guard returned `false` or called `next(false)`
     */
    NavigationFailureType[NavigationFailureType["aborted"] = 4] = "aborted";
    /**
     * A cancelled navigation is a navigation that failed because a more recent
     * navigation finished started (not necessarily finished).
     */
    NavigationFailureType[NavigationFailureType["cancelled"] = 8] = "cancelled";
    /**
     * A duplicated navigation is a navigation that failed because it was
     * initiated while already being at the exact same location.
     */
    NavigationFailureType[NavigationFailureType["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
// DEV only debug messages
const ErrorTypeMessages = {
    [1 /* ErrorTypes.MATCHER_NOT_FOUND */]({ location, currentLocation }) {
        return `No match for\n ${JSON.stringify(location)}${currentLocation
            ? '\nwhile being at\n' + JSON.stringify(currentLocation)
            : ''}`;
    },
    [2 /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */]({ from, to, }) {
        return `Redirected from "${from.fullPath}" to "${stringifyRoute(to)}" via a navigation guard.`;
    },
    [4 /* ErrorTypes.NAVIGATION_ABORTED */]({ from, to }) {
        return `Navigation aborted from "${from.fullPath}" to "${to.fullPath}" via a navigation guard.`;
    },
    [8 /* ErrorTypes.NAVIGATION_CANCELLED */]({ from, to }) {
        return `Navigation cancelled from "${from.fullPath}" to "${to.fullPath}" with a new navigation.`;
    },
    [16 /* ErrorTypes.NAVIGATION_DUPLICATED */]({ from, to }) {
        return `Avoided redundant navigation to current location: "${from.fullPath}".`;
    },
};
function createRouterError(type, params) {
    // keep full error messages in cjs versions
    if (true) {
        return assign(new Error(ErrorTypeMessages[type](params)), {
            type,
            [NavigationFailureSymbol]: true,
        }, params);
    }
    else {}
}
function isNavigationFailure(error, type) {
    return (error instanceof Error &&
        NavigationFailureSymbol in error &&
        (type == null || !!(error.type & type)));
}
const propertiesToLog = ['params', 'query', 'hash'];
function stringifyRoute(to) {
    if (typeof to === 'string')
        return to;
    if ('path' in to)
        return to.path;
    const location = {};
    for (const key of propertiesToLog) {
        if (key in to)
            location[key] = to[key];
    }
    return JSON.stringify(location, null, 2);
}

// default pattern for a param: non-greedy everything but /
const BASE_PARAM_PATTERN = '[^/]+?';
const BASE_PATH_PARSER_OPTIONS = {
    sensitive: false,
    strict: false,
    start: true,
    end: true,
};
// Special Regex characters that must be escaped in static tokens
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
/**
 * Creates a path parser from an array of Segments (a segment is an array of Tokens)
 *
 * @param segments - array of segments returned by tokenizePath
 * @param extraOptions - optional options for the regexp
 * @returns a PathParser
 */
function tokensToParser(segments, extraOptions) {
    const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
    // the amount of scores is the same as the length of segments except for the root segment "/"
    const score = [];
    // the regexp as a string
    let pattern = options.start ? '^' : '';
    // extracted keys
    const keys = [];
    for (const segment of segments) {
        // the root segment needs special treatment
        const segmentScores = segment.length ? [] : [90 /* PathScore.Root */];
        // allow trailing slash
        if (options.strict && !segment.length)
            pattern += '/';
        for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
            const token = segment[tokenIndex];
            // resets the score if we are inside a sub-segment /:a-other-:b
            let subSegmentScore = 40 /* PathScore.Segment */ +
                (options.sensitive ? 0.25 /* PathScore.BonusCaseSensitive */ : 0);
            if (token.type === 0 /* TokenType.Static */) {
                // prepend the slash if we are starting a new segment
                if (!tokenIndex)
                    pattern += '/';
                pattern += token.value.replace(REGEX_CHARS_RE, '\\$&');
                subSegmentScore += 40 /* PathScore.Static */;
            }
            else if (token.type === 1 /* TokenType.Param */) {
                const { value, repeatable, optional, regexp } = token;
                keys.push({
                    name: value,
                    repeatable,
                    optional,
                });
                const re = regexp ? regexp : BASE_PARAM_PATTERN;
                // the user provided a custom regexp /:id(\\d+)
                if (re !== BASE_PARAM_PATTERN) {
                    subSegmentScore += 10 /* PathScore.BonusCustomRegExp */;
                    // make sure the regexp is valid before using it
                    try {
                        new RegExp(`(${re})`);
                    }
                    catch (err) {
                        throw new Error(`Invalid custom RegExp for param "${value}" (${re}): ` +
                            err.message);
                    }
                }
                // when we repeat we must take care of the repeating leading slash
                let subPattern = repeatable ? `((?:${re})(?:/(?:${re}))*)` : `(${re})`;
                // prepend the slash if we are starting a new segment
                if (!tokenIndex)
                    subPattern =
                        // avoid an optional / if there are more segments e.g. /:p?-static
                        // or /:p?-:p2
                        optional && segment.length < 2
                            ? `(?:/${subPattern})`
                            : '/' + subPattern;
                if (optional)
                    subPattern += '?';
                pattern += subPattern;
                subSegmentScore += 20 /* PathScore.Dynamic */;
                if (optional)
                    subSegmentScore += -8 /* PathScore.BonusOptional */;
                if (repeatable)
                    subSegmentScore += -20 /* PathScore.BonusRepeatable */;
                if (re === '.*')
                    subSegmentScore += -50 /* PathScore.BonusWildcard */;
            }
            segmentScores.push(subSegmentScore);
        }
        // an empty array like /home/ -> [[{home}], []]
        // if (!segment.length) pattern += '/'
        score.push(segmentScores);
    }
    // only apply the strict bonus to the last score
    if (options.strict && options.end) {
        const i = score.length - 1;
        score[i][score[i].length - 1] += 0.7000000000000001 /* PathScore.BonusStrict */;
    }
    // TODO: dev only warn double trailing slash
    if (!options.strict)
        pattern += '/?';
    if (options.end)
        pattern += '$';
    // allow paths like /dynamic to only match dynamic or dynamic/... but not dynamic_something_else
    else if (options.strict)
        pattern += '(?:/|$)';
    const re = new RegExp(pattern, options.sensitive ? '' : 'i');
    function parse(path) {
        const match = path.match(re);
        const params = {};
        if (!match)
            return null;
        for (let i = 1; i < match.length; i++) {
            const value = match[i] || '';
            const key = keys[i - 1];
            params[key.name] = value && key.repeatable ? value.split('/') : value;
        }
        return params;
    }
    function stringify(params) {
        let path = '';
        // for optional parameters to allow to be empty
        let avoidDuplicatedSlash = false;
        for (const segment of segments) {
            if (!avoidDuplicatedSlash || !path.endsWith('/'))
                path += '/';
            avoidDuplicatedSlash = false;
            for (const token of segment) {
                if (token.type === 0 /* TokenType.Static */) {
                    path += token.value;
                }
                else if (token.type === 1 /* TokenType.Param */) {
                    const { value, repeatable, optional } = token;
                    const param = value in params ? params[value] : '';
                    if (isArray(param) && !repeatable) {
                        throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
                    }
                    const text = isArray(param)
                        ? param.join('/')
                        : param;
                    if (!text) {
                        if (optional) {
                            // if we have more than one optional param like /:a?-static we don't need to care about the optional param
                            if (segment.length < 2) {
                                // remove the last slash as we could be at the end
                                if (path.endsWith('/'))
                                    path = path.slice(0, -1);
                                // do not append a slash on the next iteration
                                else
                                    avoidDuplicatedSlash = true;
                            }
                        }
                        else
                            throw new Error(`Missing required param "${value}"`);
                    }
                    path += text;
                }
            }
        }
        // avoid empty path when we have multiple optional params
        return path || '/';
    }
    return {
        re,
        score,
        keys,
        parse,
        stringify,
    };
}
/**
 * Compares an array of numbers as used in PathParser.score and returns a
 * number. This function can be used to `sort` an array
 *
 * @param a - first array of numbers
 * @param b - second array of numbers
 * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b
 * should be sorted first
 */
function compareScoreArray(a, b) {
    let i = 0;
    while (i < a.length && i < b.length) {
        const diff = b[i] - a[i];
        // only keep going if diff === 0
        if (diff)
            return diff;
        i++;
    }
    // if the last subsegment was Static, the shorter segments should be sorted first
    // otherwise sort the longest segment first
    if (a.length < b.length) {
        return a.length === 1 && a[0] === 40 /* PathScore.Static */ + 40 /* PathScore.Segment */
            ? -1
            : 1;
    }
    else if (a.length > b.length) {
        return b.length === 1 && b[0] === 40 /* PathScore.Static */ + 40 /* PathScore.Segment */
            ? 1
            : -1;
    }
    return 0;
}
/**
 * Compare function that can be used with `sort` to sort an array of PathParser
 *
 * @param a - first PathParser
 * @param b - second PathParser
 * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b
 */
function comparePathParserScore(a, b) {
    let i = 0;
    const aScore = a.score;
    const bScore = b.score;
    while (i < aScore.length && i < bScore.length) {
        const comp = compareScoreArray(aScore[i], bScore[i]);
        // do not return if both are equal
        if (comp)
            return comp;
        i++;
    }
    if (Math.abs(bScore.length - aScore.length) === 1) {
        if (isLastScoreNegative(aScore))
            return 1;
        if (isLastScoreNegative(bScore))
            return -1;
    }
    // if a and b share the same score entries but b has more, sort b first
    return bScore.length - aScore.length;
    // this is the ternary version
    // return aScore.length < bScore.length
    //   ? 1
    //   : aScore.length > bScore.length
    //   ? -1
    //   : 0
}
/**
 * This allows detecting splats at the end of a path: /home/:id(.*)*
 *
 * @param score - score to check
 * @returns true if the last entry is negative
 */
function isLastScoreNegative(score) {
    const last = score[score.length - 1];
    return score.length > 0 && last[last.length - 1] < 0;
}

const ROOT_TOKEN = {
    type: 0 /* TokenType.Static */,
    value: '',
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
// After some profiling, the cache seems to be unnecessary because tokenizePath
// (the slowest part of adding a route) is very fast
// const tokenCache = new Map<string, Token[][]>()
function tokenizePath(path) {
    if (!path)
        return [[]];
    if (path === '/')
        return [[ROOT_TOKEN]];
    if (!path.startsWith('/')) {
        throw new Error(( true)
            ? `Route paths should start with a "/": "${path}" should be "/${path}".`
            : 0);
    }
    // if (tokenCache.has(path)) return tokenCache.get(path)!
    function crash(message) {
        throw new Error(`ERR (${state})/"${buffer}": ${message}`);
    }
    let state = 0 /* TokenizerState.Static */;
    let previousState = state;
    const tokens = [];
    // the segment will always be valid because we get into the initial state
    // with the leading /
    let segment;
    function finalizeSegment() {
        if (segment)
            tokens.push(segment);
        segment = [];
    }
    // index on the path
    let i = 0;
    // char at index
    let char;
    // buffer of the value read
    let buffer = '';
    // custom regexp for a param
    let customRe = '';
    function consumeBuffer() {
        if (!buffer)
            return;
        if (state === 0 /* TokenizerState.Static */) {
            segment.push({
                type: 0 /* TokenType.Static */,
                value: buffer,
            });
        }
        else if (state === 1 /* TokenizerState.Param */ ||
            state === 2 /* TokenizerState.ParamRegExp */ ||
            state === 3 /* TokenizerState.ParamRegExpEnd */) {
            if (segment.length > 1 && (char === '*' || char === '+'))
                crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
            segment.push({
                type: 1 /* TokenType.Param */,
                value: buffer,
                regexp: customRe,
                repeatable: char === '*' || char === '+',
                optional: char === '*' || char === '?',
            });
        }
        else {
            crash('Invalid state to consume buffer');
        }
        buffer = '';
    }
    function addCharToBuffer() {
        buffer += char;
    }
    while (i < path.length) {
        char = path[i++];
        if (char === '\\' && state !== 2 /* TokenizerState.ParamRegExp */) {
            previousState = state;
            state = 4 /* TokenizerState.EscapeNext */;
            continue;
        }
        switch (state) {
            case 0 /* TokenizerState.Static */:
                if (char === '/') {
                    if (buffer) {
                        consumeBuffer();
                    }
                    finalizeSegment();
                }
                else if (char === ':') {
                    consumeBuffer();
                    state = 1 /* TokenizerState.Param */;
                }
                else {
                    addCharToBuffer();
                }
                break;
            case 4 /* TokenizerState.EscapeNext */:
                addCharToBuffer();
                state = previousState;
                break;
            case 1 /* TokenizerState.Param */:
                if (char === '(') {
                    state = 2 /* TokenizerState.ParamRegExp */;
                }
                else if (VALID_PARAM_RE.test(char)) {
                    addCharToBuffer();
                }
                else {
                    consumeBuffer();
                    state = 0 /* TokenizerState.Static */;
                    // go back one character if we were not modifying
                    if (char !== '*' && char !== '?' && char !== '+')
                        i--;
                }
                break;
            case 2 /* TokenizerState.ParamRegExp */:
                // TODO: is it worth handling nested regexp? like :p(?:prefix_([^/]+)_suffix)
                // it already works by escaping the closing )
                // https://paths.esm.dev/?p=AAMeJbiAwQEcDKbAoAAkP60PG2R6QAvgNaA6AFACM2ABuQBB#
                // is this really something people need since you can also write
                // /prefix_:p()_suffix
                if (char === ')') {
                    // handle the escaped )
                    if (customRe[customRe.length - 1] == '\\')
                        customRe = customRe.slice(0, -1) + char;
                    else
                        state = 3 /* TokenizerState.ParamRegExpEnd */;
                }
                else {
                    customRe += char;
                }
                break;
            case 3 /* TokenizerState.ParamRegExpEnd */:
                // same as finalizing a param
                consumeBuffer();
                state = 0 /* TokenizerState.Static */;
                // go back one character if we were not modifying
                if (char !== '*' && char !== '?' && char !== '+')
                    i--;
                customRe = '';
                break;
            default:
                crash('Unknown state');
                break;
        }
    }
    if (state === 2 /* TokenizerState.ParamRegExp */)
        crash(`Unfinished custom RegExp for param "${buffer}"`);
    consumeBuffer();
    finalizeSegment();
    // tokenCache.set(path, tokens)
    return tokens;
}

function createRouteRecordMatcher(record, parent, options) {
    const parser = tokensToParser(tokenizePath(record.path), options);
    // warn against params with the same name
    if ((true)) {
        const existingKeys = new Set();
        for (const key of parser.keys) {
            if (existingKeys.has(key.name))
                warn(`Found duplicated params with name "${key.name}" for path "${record.path}". Only the last one will be available on "$route.params".`);
            existingKeys.add(key.name);
        }
    }
    const matcher = assign(parser, {
        record,
        parent,
        // these needs to be populated by the parent
        children: [],
        alias: [],
    });
    if (parent) {
        // both are aliases or both are not aliases
        // we don't want to mix them because the order is used when
        // passing originalRecord in Matcher.addRoute
        if (!matcher.record.aliasOf === !parent.record.aliasOf)
            parent.children.push(matcher);
    }
    return matcher;
}

/**
 * Creates a Router Matcher.
 *
 * @internal
 * @param routes - array of initial routes
 * @param globalOptions - global route options
 */
function createRouterMatcher(routes, globalOptions) {
    // normalized ordered array of matchers
    const matchers = [];
    const matcherMap = new Map();
    globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
    function getRecordMatcher(name) {
        return matcherMap.get(name);
    }
    function addRoute(record, parent, originalRecord) {
        // used later on to remove by name
        const isRootAdd = !originalRecord;
        const mainNormalizedRecord = normalizeRouteRecord(record);
        if ((true)) {
            checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent);
        }
        // we might be the child of an alias
        mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
        const options = mergeOptions(globalOptions, record);
        // generate an array of records to correctly handle aliases
        const normalizedRecords = [
            mainNormalizedRecord,
        ];
        if ('alias' in record) {
            const aliases = typeof record.alias === 'string' ? [record.alias] : record.alias;
            for (const alias of aliases) {
                normalizedRecords.push(assign({}, mainNormalizedRecord, {
                    // this allows us to hold a copy of the `components` option
                    // so that async components cache is hold on the original record
                    components: originalRecord
                        ? originalRecord.record.components
                        : mainNormalizedRecord.components,
                    path: alias,
                    // we might be the child of an alias
                    aliasOf: originalRecord
                        ? originalRecord.record
                        : mainNormalizedRecord,
                    // the aliases are always of the same kind as the original since they
                    // are defined on the same record
                }));
            }
        }
        let matcher;
        let originalMatcher;
        for (const normalizedRecord of normalizedRecords) {
            const { path } = normalizedRecord;
            // Build up the path for nested routes if the child isn't an absolute
            // route. Only add the / delimiter if the child path isn't empty and if the
            // parent path doesn't have a trailing slash
            if (parent && path[0] !== '/') {
                const parentPath = parent.record.path;
                const connectingSlash = parentPath[parentPath.length - 1] === '/' ? '' : '/';
                normalizedRecord.path =
                    parent.record.path + (path && connectingSlash + path);
            }
            if (( true) && normalizedRecord.path === '*') {
                throw new Error('Catch all routes ("*") must now be defined using a param with a custom regexp.\n' +
                    'See more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.');
            }
            // create the object beforehand, so it can be passed to children
            matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
            if (( true) && parent && path[0] === '/')
                checkMissingParamsInAbsolutePath(matcher, parent);
            // if we are an alias we must tell the original record that we exist,
            // so we can be removed
            if (originalRecord) {
                originalRecord.alias.push(matcher);
                if ((true)) {
                    checkSameParams(originalRecord, matcher);
                }
            }
            else {
                // otherwise, the first record is the original and others are aliases
                originalMatcher = originalMatcher || matcher;
                if (originalMatcher !== matcher)
                    originalMatcher.alias.push(matcher);
                // remove the route if named and only for the top record (avoid in nested calls)
                // this works because the original record is the first one
                if (isRootAdd && record.name && !isAliasRecord(matcher))
                    removeRoute(record.name);
            }
            if (mainNormalizedRecord.children) {
                const children = mainNormalizedRecord.children;
                for (let i = 0; i < children.length; i++) {
                    addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);
                }
            }
            // if there was no original record, then the first one was not an alias and all
            // other aliases (if any) need to reference this record when adding children
            originalRecord = originalRecord || matcher;
            // TODO: add normalized records for more flexibility
            // if (parent && isAliasRecord(originalRecord)) {
            //   parent.children.push(originalRecord)
            // }
            // Avoid adding a record that doesn't display anything. This allows passing through records without a component to
            // not be reached and pass through the catch all route
            if ((matcher.record.components &&
                Object.keys(matcher.record.components).length) ||
                matcher.record.name ||
                matcher.record.redirect) {
                insertMatcher(matcher);
            }
        }
        return originalMatcher
            ? () => {
                // since other matchers are aliases, they should be removed by the original matcher
                removeRoute(originalMatcher);
            }
            : noop;
    }
    function removeRoute(matcherRef) {
        if (isRouteName(matcherRef)) {
            const matcher = matcherMap.get(matcherRef);
            if (matcher) {
                matcherMap.delete(matcherRef);
                matchers.splice(matchers.indexOf(matcher), 1);
                matcher.children.forEach(removeRoute);
                matcher.alias.forEach(removeRoute);
            }
        }
        else {
            const index = matchers.indexOf(matcherRef);
            if (index > -1) {
                matchers.splice(index, 1);
                if (matcherRef.record.name)
                    matcherMap.delete(matcherRef.record.name);
                matcherRef.children.forEach(removeRoute);
                matcherRef.alias.forEach(removeRoute);
            }
        }
    }
    function getRoutes() {
        return matchers;
    }
    function insertMatcher(matcher) {
        let i = 0;
        while (i < matchers.length &&
            comparePathParserScore(matcher, matchers[i]) >= 0 &&
            // Adding children with empty path should still appear before the parent
            // https://github.com/vuejs/router/issues/1124
            (matcher.record.path !== matchers[i].record.path ||
                !isRecordChildOf(matcher, matchers[i])))
            i++;
        matchers.splice(i, 0, matcher);
        // only add the original record to the name map
        if (matcher.record.name && !isAliasRecord(matcher))
            matcherMap.set(matcher.record.name, matcher);
    }
    function resolve(location, currentLocation) {
        let matcher;
        let params = {};
        let path;
        let name;
        if ('name' in location && location.name) {
            matcher = matcherMap.get(location.name);
            if (!matcher)
                throw createRouterError(1 /* ErrorTypes.MATCHER_NOT_FOUND */, {
                    location,
                });
            // warn if the user is passing invalid params so they can debug it better when they get removed
            if ((true)) {
                const invalidParams = Object.keys(location.params || {}).filter(paramName => !matcher.keys.find(k => k.name === paramName));
                if (invalidParams.length) {
                    warn(`Discarded invalid param(s) "${invalidParams.join('", "')}" when navigating. See https://github.com/vuejs/router/blob/main/packages/router/CHANGELOG.md#414-2022-08-22 for more details.`);
                }
            }
            name = matcher.record.name;
            params = assign(
            // paramsFromLocation is a new object
            paramsFromLocation(currentLocation.params, 
            // only keep params that exist in the resolved location
            // TODO: only keep optional params coming from a parent record
            matcher.keys.filter(k => !k.optional).map(k => k.name)), 
            // discard any existing params in the current location that do not exist here
            // #1497 this ensures better active/exact matching
            location.params &&
                paramsFromLocation(location.params, matcher.keys.map(k => k.name)));
            // throws if cannot be stringified
            path = matcher.stringify(params);
        }
        else if ('path' in location) {
            // no need to resolve the path with the matcher as it was provided
            // this also allows the user to control the encoding
            path = location.path;
            if (( true) && !path.startsWith('/')) {
                warn(`The Matcher cannot resolve relative paths but received "${path}". Unless you directly called \`matcher.resolve("${path}")\`, this is probably a bug in vue-router. Please open an issue at https://github.com/vuejs/router/issues/new/choose.`);
            }
            matcher = matchers.find(m => m.re.test(path));
            // matcher should have a value after the loop
            if (matcher) {
                // we know the matcher works because we tested the regexp
                params = matcher.parse(path);
                name = matcher.record.name;
            }
            // location is a relative path
        }
        else {
            // match by name or path of current route
            matcher = currentLocation.name
                ? matcherMap.get(currentLocation.name)
                : matchers.find(m => m.re.test(currentLocation.path));
            if (!matcher)
                throw createRouterError(1 /* ErrorTypes.MATCHER_NOT_FOUND */, {
                    location,
                    currentLocation,
                });
            name = matcher.record.name;
            // since we are navigating to the same location, we don't need to pick the
            // params like when `name` is provided
            params = assign({}, currentLocation.params, location.params);
            path = matcher.stringify(params);
        }
        const matched = [];
        let parentMatcher = matcher;
        while (parentMatcher) {
            // reversed order so parents are at the beginning
            matched.unshift(parentMatcher.record);
            parentMatcher = parentMatcher.parent;
        }
        return {
            name,
            path,
            params,
            matched,
            meta: mergeMetaFields(matched),
        };
    }
    // add initial routes
    routes.forEach(route => addRoute(route));
    return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher };
}
function paramsFromLocation(params, keys) {
    const newParams = {};
    for (const key of keys) {
        if (key in params)
            newParams[key] = params[key];
    }
    return newParams;
}
/**
 * Normalizes a RouteRecordRaw. Creates a copy
 *
 * @param record
 * @returns the normalized version
 */
function normalizeRouteRecord(record) {
    return {
        path: record.path,
        redirect: record.redirect,
        name: record.name,
        meta: record.meta || {},
        aliasOf: undefined,
        beforeEnter: record.beforeEnter,
        props: normalizeRecordProps(record),
        children: record.children || [],
        instances: {},
        leaveGuards: new Set(),
        updateGuards: new Set(),
        enterCallbacks: {},
        components: 'components' in record
            ? record.components || null
            : record.component && { default: record.component },
    };
}
/**
 * Normalize the optional `props` in a record to always be an object similar to
 * components. Also accept a boolean for components.
 * @param record
 */
function normalizeRecordProps(record) {
    const propsObject = {};
    // props does not exist on redirect records, but we can set false directly
    const props = record.props || false;
    if ('component' in record) {
        propsObject.default = props;
    }
    else {
        // NOTE: we could also allow a function to be applied to every component.
        // Would need user feedback for use cases
        for (const name in record.components)
            propsObject[name] = typeof props === 'object' ? props[name] : props;
    }
    return propsObject;
}
/**
 * Checks if a record or any of its parent is an alias
 * @param record
 */
function isAliasRecord(record) {
    while (record) {
        if (record.record.aliasOf)
            return true;
        record = record.parent;
    }
    return false;
}
/**
 * Merge meta fields of an array of records
 *
 * @param matched - array of matched records
 */
function mergeMetaFields(matched) {
    return matched.reduce((meta, record) => assign(meta, record.meta), {});
}
function mergeOptions(defaults, partialOptions) {
    const options = {};
    for (const key in defaults) {
        options[key] = key in partialOptions ? partialOptions[key] : defaults[key];
    }
    return options;
}
function isSameParam(a, b) {
    return (a.name === b.name &&
        a.optional === b.optional &&
        a.repeatable === b.repeatable);
}
/**
 * Check if a path and its alias have the same required params
 *
 * @param a - original record
 * @param b - alias record
 */
function checkSameParams(a, b) {
    for (const key of a.keys) {
        if (!key.optional && !b.keys.find(isSameParam.bind(null, key)))
            return warn(`Alias "${b.record.path}" and the original record: "${a.record.path}" must have the exact same param named "${key.name}"`);
    }
    for (const key of b.keys) {
        if (!key.optional && !a.keys.find(isSameParam.bind(null, key)))
            return warn(`Alias "${b.record.path}" and the original record: "${a.record.path}" must have the exact same param named "${key.name}"`);
    }
}
/**
 * A route with a name and a child with an empty path without a name should warn when adding the route
 *
 * @param mainNormalizedRecord - RouteRecordNormalized
 * @param parent - RouteRecordMatcher
 */
function checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent) {
    if (parent &&
        parent.record.name &&
        !mainNormalizedRecord.name &&
        !mainNormalizedRecord.path) {
        warn(`The route named "${String(parent.record.name)}" has a child without a name and an empty path. Using that name won't render the empty path child so you probably want to move the name to the child instead. If this is intentional, add a name to the child route to remove the warning.`);
    }
}
function checkMissingParamsInAbsolutePath(record, parent) {
    for (const key of parent.keys) {
        if (!record.keys.find(isSameParam.bind(null, key)))
            return warn(`Absolute path "${record.record.path}" must have the exact same param named "${key.name}" as its parent "${parent.record.path}".`);
    }
}
function isRecordChildOf(record, parent) {
    return parent.children.some(child => child === record || isRecordChildOf(record, child));
}

/**
 * Encoding Rules ␣ = Space Path: ␣ " < > # ? { } Query: ␣ " < > # & = Hash: ␣ "
 * < > `
 *
 * On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)
 * defines some extra characters to be encoded. Most browsers do not encode them
 * in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to
 * also encode `!'()*`. Leaving un-encoded only ASCII alphanumeric(`a-zA-Z0-9`)
 * plus `-._~`. This extra safety should be applied to query by patching the
 * string returned by encodeURIComponent encodeURI also encodes `[\]^`. `\`
 * should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\`
 * into a `/` if directly typed in. The _backtick_ (`````) should also be
 * encoded everywhere because some browsers like FF encode it when directly
 * written while others don't. Safari and IE don't encode ``"<>{}``` in hash.
 */
// const EXTRA_RESERVED_RE = /[!'()*]/g
// const encodeReservedReplacer = (c: string) => '%' + c.charCodeAt(0).toString(16)
const HASH_RE = /#/g; // %23
const AMPERSAND_RE = /&/g; // %26
const SLASH_RE = /\//g; // %2F
const EQUAL_RE = /=/g; // %3D
const IM_RE = /\?/g; // %3F
const PLUS_RE = /\+/g; // %2B
/**
 * NOTE: It's not clear to me if we should encode the + symbol in queries, it
 * seems to be less flexible than not doing so and I can't find out the legacy
 * systems requiring this for regular requests like text/html. In the standard,
 * the encoding of the plus character is only mentioned for
 * application/x-www-form-urlencoded
 * (https://url.spec.whatwg.org/#urlencoded-parsing) and most browsers seems lo
 * leave the plus character as is in queries. To be more flexible, we allow the
 * plus character on the query, but it can also be manually encoded by the user.
 *
 * Resources:
 * - https://url.spec.whatwg.org/#urlencoded-parsing
 * - https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20
 */
const ENC_BRACKET_OPEN_RE = /%5B/g; // [
const ENC_BRACKET_CLOSE_RE = /%5D/g; // ]
const ENC_CARET_RE = /%5E/g; // ^
const ENC_BACKTICK_RE = /%60/g; // `
const ENC_CURLY_OPEN_RE = /%7B/g; // {
const ENC_PIPE_RE = /%7C/g; // |
const ENC_CURLY_CLOSE_RE = /%7D/g; // }
const ENC_SPACE_RE = /%20/g; // }
/**
 * Encode characters that need to be encoded on the path, search and hash
 * sections of the URL.
 *
 * @internal
 * @param text - string to encode
 * @returns encoded string
 */
function commonEncode(text) {
    return encodeURI('' + text)
        .replace(ENC_PIPE_RE, '|')
        .replace(ENC_BRACKET_OPEN_RE, '[')
        .replace(ENC_BRACKET_CLOSE_RE, ']');
}
/**
 * Encode characters that need to be encoded on the hash section of the URL.
 *
 * @param text - string to encode
 * @returns encoded string
 */
function encodeHash(text) {
    return commonEncode(text)
        .replace(ENC_CURLY_OPEN_RE, '{')
        .replace(ENC_CURLY_CLOSE_RE, '}')
        .replace(ENC_CARET_RE, '^');
}
/**
 * Encode characters that need to be encoded query values on the query
 * section of the URL.
 *
 * @param text - string to encode
 * @returns encoded string
 */
function encodeQueryValue(text) {
    return (commonEncode(text)
        // Encode the space as +, encode the + to differentiate it from the space
        .replace(PLUS_RE, '%2B')
        .replace(ENC_SPACE_RE, '+')
        .replace(HASH_RE, '%23')
        .replace(AMPERSAND_RE, '%26')
        .replace(ENC_BACKTICK_RE, '`')
        .replace(ENC_CURLY_OPEN_RE, '{')
        .replace(ENC_CURLY_CLOSE_RE, '}')
        .replace(ENC_CARET_RE, '^'));
}
/**
 * Like `encodeQueryValue` but also encodes the `=` character.
 *
 * @param text - string to encode
 */
function encodeQueryKey(text) {
    return encodeQueryValue(text).replace(EQUAL_RE, '%3D');
}
/**
 * Encode characters that need to be encoded on the path section of the URL.
 *
 * @param text - string to encode
 * @returns encoded string
 */
function encodePath(text) {
    return commonEncode(text).replace(HASH_RE, '%23').replace(IM_RE, '%3F');
}
/**
 * Encode characters that need to be encoded on the path section of the URL as a
 * param. This function encodes everything {@link encodePath} does plus the
 * slash (`/`) character. If `text` is `null` or `undefined`, returns an empty
 * string instead.
 *
 * @param text - string to encode
 * @returns encoded string
 */
function encodeParam(text) {
    return text == null ? '' : encodePath(text).replace(SLASH_RE, '%2F');
}
/**
 * Decode text using `decodeURIComponent`. Returns the original text if it
 * fails.
 *
 * @param text - string to decode
 * @returns decoded string
 */
function decode(text) {
    try {
        return decodeURIComponent('' + text);
    }
    catch (err) {
        ( true) && warn(`Error decoding "${text}". Using original value`);
    }
    return '' + text;
}

/**
 * Transforms a queryString into a {@link LocationQuery} object. Accept both, a
 * version with the leading `?` and without Should work as URLSearchParams

 * @internal
 *
 * @param search - search string to parse
 * @returns a query object
 */
function parseQuery(search) {
    const query = {};
    // avoid creating an object with an empty key and empty value
    // because of split('&')
    if (search === '' || search === '?')
        return query;
    const hasLeadingIM = search[0] === '?';
    const searchParams = (hasLeadingIM ? search.slice(1) : search).split('&');
    for (let i = 0; i < searchParams.length; ++i) {
        // pre decode the + into space
        const searchParam = searchParams[i].replace(PLUS_RE, ' ');
        // allow the = character
        const eqPos = searchParam.indexOf('=');
        const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
        const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
        if (key in query) {
            // an extra variable for ts types
            let currentValue = query[key];
            if (!isArray(currentValue)) {
                currentValue = query[key] = [currentValue];
            }
            currentValue.push(value);
        }
        else {
            query[key] = value;
        }
    }
    return query;
}
/**
 * Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it
 * doesn't prepend a `?`
 *
 * @internal
 *
 * @param query - query object to stringify
 * @returns string version of the query without the leading `?`
 */
function stringifyQuery(query) {
    let search = '';
    for (let key in query) {
        const value = query[key];
        key = encodeQueryKey(key);
        if (value == null) {
            // only null adds the value
            if (value !== undefined) {
                search += (search.length ? '&' : '') + key;
            }
            continue;
        }
        // keep null values
        const values = isArray(value)
            ? value.map(v => v && encodeQueryValue(v))
            : [value && encodeQueryValue(value)];
        values.forEach(value => {
            // skip undefined values in arrays as if they were not present
            // smaller code than using filter
            if (value !== undefined) {
                // only append & with non-empty search
                search += (search.length ? '&' : '') + key;
                if (value != null)
                    search += '=' + value;
            }
        });
    }
    return search;
}
/**
 * Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting
 * numbers into strings, removing keys with an undefined value and replacing
 * undefined with null in arrays
 *
 * @param query - query object to normalize
 * @returns a normalized query object
 */
function normalizeQuery(query) {
    const normalizedQuery = {};
    for (const key in query) {
        const value = query[key];
        if (value !== undefined) {
            normalizedQuery[key] = isArray(value)
                ? value.map(v => (v == null ? null : '' + v))
                : value == null
                    ? value
                    : '' + value;
        }
    }
    return normalizedQuery;
}

/**
 * RouteRecord being rendered by the closest ancestor Router View. Used for
 * `onBeforeRouteUpdate` and `onBeforeRouteLeave`. rvlm stands for Router View
 * Location Matched
 *
 * @internal
 */
const matchedRouteKey = Symbol(( true) ? 'router view location matched' : 0);
/**
 * Allows overriding the router view depth to control which component in
 * `matched` is rendered. rvd stands for Router View Depth
 *
 * @internal
 */
const viewDepthKey = Symbol(( true) ? 'router view depth' : 0);
/**
 * Allows overriding the router instance returned by `useRouter` in tests. r
 * stands for router
 *
 * @internal
 */
const routerKey = Symbol(( true) ? 'router' : 0);
/**
 * Allows overriding the current route returned by `useRoute` in tests. rl
 * stands for route location
 *
 * @internal
 */
const routeLocationKey = Symbol(( true) ? 'route location' : 0);
/**
 * Allows overriding the current route used by router-view. Internally this is
 * used when the `route` prop is passed.
 *
 * @internal
 */
const routerViewLocationKey = Symbol(( true) ? 'router view location' : 0);

/**
 * Create a list of callbacks that can be reset. Used to create before and after navigation guards list
 */
function useCallbacks() {
    let handlers = [];
    function add(handler) {
        handlers.push(handler);
        return () => {
            const i = handlers.indexOf(handler);
            if (i > -1)
                handlers.splice(i, 1);
        };
    }
    function reset() {
        handlers = [];
    }
    return {
        add,
        list: () => handlers.slice(),
        reset,
    };
}

function registerGuard(record, name, guard) {
    const removeFromList = () => {
        record[name].delete(guard);
    };
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(removeFromList);
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onDeactivated)(removeFromList);
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onActivated)(() => {
        record[name].add(guard);
    });
    record[name].add(guard);
}
/**
 * Add a navigation guard that triggers whenever the component for the current
 * location is about to be left. Similar to {@link beforeRouteLeave} but can be
 * used in any component. The guard is removed when the component is unmounted.
 *
 * @param leaveGuard - {@link NavigationGuard}
 */
function onBeforeRouteLeave(leaveGuard) {
    if (( true) && !(0,vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)()) {
        warn('getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function');
        return;
    }
    const activeRecord = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(matchedRouteKey, 
    // to avoid warning
    {}).value;
    if (!activeRecord) {
        ( true) &&
            warn('No active route record was found when calling `onBeforeRouteLeave()`. Make sure you call this function inside a component child of <router-view>. Maybe you called it inside of App.vue?');
        return;
    }
    registerGuard(activeRecord, 'leaveGuards', leaveGuard);
}
/**
 * Add a navigation guard that triggers whenever the current location is about
 * to be updated. Similar to {@link beforeRouteUpdate} but can be used in any
 * component. The guard is removed when the component is unmounted.
 *
 * @param updateGuard - {@link NavigationGuard}
 */
function onBeforeRouteUpdate(updateGuard) {
    if (( true) && !(0,vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)()) {
        warn('getCurrentInstance() returned null. onBeforeRouteUpdate() must be called at the top of a setup function');
        return;
    }
    const activeRecord = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(matchedRouteKey, 
    // to avoid warning
    {}).value;
    if (!activeRecord) {
        ( true) &&
            warn('No active route record was found when calling `onBeforeRouteUpdate()`. Make sure you call this function inside a component child of <router-view>. Maybe you called it inside of App.vue?');
        return;
    }
    registerGuard(activeRecord, 'updateGuards', updateGuard);
}
function guardToPromiseFn(guard, to, from, record, name) {
    // keep a reference to the enterCallbackArray to prevent pushing callbacks if a new navigation took place
    const enterCallbackArray = record &&
        // name is defined if record is because of the function overload
        (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
    return () => new Promise((resolve, reject) => {
        const next = (valid) => {
            if (valid === false) {
                reject(createRouterError(4 /* ErrorTypes.NAVIGATION_ABORTED */, {
                    from,
                    to,
                }));
            }
            else if (valid instanceof Error) {
                reject(valid);
            }
            else if (isRouteLocation(valid)) {
                reject(createRouterError(2 /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */, {
                    from: to,
                    to: valid,
                }));
            }
            else {
                if (enterCallbackArray &&
                    // since enterCallbackArray is truthy, both record and name also are
                    record.enterCallbacks[name] === enterCallbackArray &&
                    typeof valid === 'function') {
                    enterCallbackArray.push(valid);
                }
                resolve();
            }
        };
        // wrapping with Promise.resolve allows it to work with both async and sync guards
        const guardReturn = guard.call(record && record.instances[name], to, from, ( true) ? canOnlyBeCalledOnce(next, to, from) : 0);
        let guardCall = Promise.resolve(guardReturn);
        if (guard.length < 3)
            guardCall = guardCall.then(next);
        if (( true) && guard.length > 2) {
            const message = `The "next" callback was never called inside of ${guard.name ? '"' + guard.name + '"' : ''}:\n${guard.toString()}\n. If you are returning a value instead of calling "next", make sure to remove the "next" parameter from your function.`;
            if (typeof guardReturn === 'object' && 'then' in guardReturn) {
                guardCall = guardCall.then(resolvedValue => {
                    // @ts-expect-error: _called is added at canOnlyBeCalledOnce
                    if (!next._called) {
                        warn(message);
                        return Promise.reject(new Error('Invalid navigation guard'));
                    }
                    return resolvedValue;
                });
            }
            else if (guardReturn !== undefined) {
                // @ts-expect-error: _called is added at canOnlyBeCalledOnce
                if (!next._called) {
                    warn(message);
                    reject(new Error('Invalid navigation guard'));
                    return;
                }
            }
        }
        guardCall.catch(err => reject(err));
    });
}
function canOnlyBeCalledOnce(next, to, from) {
    let called = 0;
    return function () {
        if (called++ === 1)
            warn(`The "next" callback was called more than once in one navigation guard when going from "${from.fullPath}" to "${to.fullPath}". It should be called exactly one time in each navigation guard. This will fail in production.`);
        // @ts-expect-error: we put it in the original one because it's easier to check
        next._called = true;
        if (called === 1)
            next.apply(null, arguments);
    };
}
function extractComponentsGuards(matched, guardType, to, from) {
    const guards = [];
    for (const record of matched) {
        if (( true) && !record.components && !record.children.length) {
            warn(`Record with path "${record.path}" is either missing a "component(s)"` +
                ` or "children" property.`);
        }
        for (const name in record.components) {
            let rawComponent = record.components[name];
            if ((true)) {
                if (!rawComponent ||
                    (typeof rawComponent !== 'object' &&
                        typeof rawComponent !== 'function')) {
                    warn(`Component "${name}" in record with path "${record.path}" is not` +
                        ` a valid component. Received "${String(rawComponent)}".`);
                    // throw to ensure we stop here but warn to ensure the message isn't
                    // missed by the user
                    throw new Error('Invalid route component');
                }
                else if ('then' in rawComponent) {
                    // warn if user wrote import('/component.vue') instead of () =>
                    // import('./component.vue')
                    warn(`Component "${name}" in record with path "${record.path}" is a ` +
                        `Promise instead of a function that returns a Promise. Did you ` +
                        `write "import('./MyPage.vue')" instead of ` +
                        `"() => import('./MyPage.vue')" ? This will break in ` +
                        `production if not fixed.`);
                    const promise = rawComponent;
                    rawComponent = () => promise;
                }
                else if (rawComponent.__asyncLoader &&
                    // warn only once per component
                    !rawComponent.__warnedDefineAsync) {
                    rawComponent.__warnedDefineAsync = true;
                    warn(`Component "${name}" in record with path "${record.path}" is defined ` +
                        `using "defineAsyncComponent()". ` +
                        `Write "() => import('./MyPage.vue')" instead of ` +
                        `"defineAsyncComponent(() => import('./MyPage.vue'))".`);
                }
            }
            // skip update and leave guards if the route component is not mounted
            if (guardType !== 'beforeRouteEnter' && !record.instances[name])
                continue;
            if (isRouteComponent(rawComponent)) {
                // __vccOpts is added by vue-class-component and contain the regular options
                const options = rawComponent.__vccOpts || rawComponent;
                const guard = options[guardType];
                guard && guards.push(guardToPromiseFn(guard, to, from, record, name));
            }
            else {
                // start requesting the chunk already
                let componentPromise = rawComponent();
                if (( true) && !('catch' in componentPromise)) {
                    warn(`Component "${name}" in record with path "${record.path}" is a function that does not return a Promise. If you were passing a functional component, make sure to add a "displayName" to the component. This will break in production if not fixed.`);
                    componentPromise = Promise.resolve(componentPromise);
                }
                guards.push(() => componentPromise.then(resolved => {
                    if (!resolved)
                        return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
                    const resolvedComponent = isESModule(resolved)
                        ? resolved.default
                        : resolved;
                    // replace the function with the resolved component
                    // cannot be null or undefined because we went into the for loop
                    record.components[name] = resolvedComponent;
                    // __vccOpts is added by vue-class-component and contain the regular options
                    const options = resolvedComponent.__vccOpts || resolvedComponent;
                    const guard = options[guardType];
                    return guard && guardToPromiseFn(guard, to, from, record, name)();
                }));
            }
        }
    }
    return guards;
}
/**
 * Allows differentiating lazy components from functional components and vue-class-component
 * @internal
 *
 * @param component
 */
function isRouteComponent(component) {
    return (typeof component === 'object' ||
        'displayName' in component ||
        'props' in component ||
        '__vccOpts' in component);
}
/**
 * Ensures a route is loaded, so it can be passed as o prop to `<RouterView>`.
 *
 * @param route - resolved route to load
 */
function loadRouteLocation(route) {
    return route.matched.every(record => record.redirect)
        ? Promise.reject(new Error('Cannot load a route that redirects.'))
        : Promise.all(route.matched.map(record => record.components &&
            Promise.all(Object.keys(record.components).reduce((promises, name) => {
                const rawComponent = record.components[name];
                if (typeof rawComponent === 'function' &&
                    !('displayName' in rawComponent)) {
                    promises.push(rawComponent().then(resolved => {
                        if (!resolved)
                            return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}". Ensure you passed a function that returns a promise.`));
                        const resolvedComponent = isESModule(resolved)
                            ? resolved.default
                            : resolved;
                        // replace the function with the resolved component
                        // cannot be null or undefined because we went into the for loop
                        record.components[name] = resolvedComponent;
                        return;
                    }));
                }
                return promises;
            }, [])))).then(() => route);
}

// TODO: we could allow currentRoute as a prop to expose `isActive` and
// `isExactActive` behavior should go through an RFC
function useLink(props) {
    const router = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(routerKey);
    const currentRoute = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(routeLocationKey);
    const route = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => router.resolve((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(props.to)));
    const activeRecordIndex = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
        const { matched } = route.value;
        const { length } = matched;
        const routeMatched = matched[length - 1];
        const currentMatched = currentRoute.matched;
        if (!routeMatched || !currentMatched.length)
            return -1;
        const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
        if (index > -1)
            return index;
        // possible parent record
        const parentRecordPath = getOriginalPath(matched[length - 2]);
        return (
        // we are dealing with nested routes
        length > 1 &&
            // if the parent and matched route have the same path, this link is
            // referring to the empty child. Or we currently are on a different
            // child of the same parent
            getOriginalPath(routeMatched) === parentRecordPath &&
            // avoid comparing the child with its parent
            currentMatched[currentMatched.length - 1].path !== parentRecordPath
            ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2]))
            : index);
    });
    const isActive = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => activeRecordIndex.value > -1 &&
        includesParams(currentRoute.params, route.value.params));
    const isExactActive = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => activeRecordIndex.value > -1 &&
        activeRecordIndex.value === currentRoute.matched.length - 1 &&
        isSameRouteLocationParams(currentRoute.params, route.value.params));
    function navigate(e = {}) {
        if (guardEvent(e)) {
            return router[(0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(props.replace) ? 'replace' : 'push']((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(props.to)
            // avoid uncaught errors are they are logged anyway
            ).catch(noop);
        }
        return Promise.resolve();
    }
    // devtools only
    if (( true) && isBrowser) {
        const instance = (0,vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
        if (instance) {
            const linkContextDevtools = {
                route: route.value,
                isActive: isActive.value,
                isExactActive: isExactActive.value,
            };
            // @ts-expect-error: this is internal
            instance.__vrl_devtools = instance.__vrl_devtools || [];
            // @ts-expect-error: this is internal
            instance.__vrl_devtools.push(linkContextDevtools);
            (0,vue__WEBPACK_IMPORTED_MODULE_0__.watchEffect)(() => {
                linkContextDevtools.route = route.value;
                linkContextDevtools.isActive = isActive.value;
                linkContextDevtools.isExactActive = isExactActive.value;
            }, { flush: 'post' });
        }
    }
    /**
     * NOTE: update {@link _RouterLinkI}'s `$slots` type when updating this
     */
    return {
        route,
        href: (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => route.value.href),
        isActive,
        isExactActive,
        navigate,
    };
}
const RouterLinkImpl = /*#__PURE__*/ (0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({
    name: 'RouterLink',
    compatConfig: { MODE: 3 },
    props: {
        to: {
            type: [String, Object],
            required: true,
        },
        replace: Boolean,
        activeClass: String,
        // inactiveClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
            type: String,
            default: 'page',
        },
    },
    useLink,
    setup(props, { slots }) {
        const link = (0,vue__WEBPACK_IMPORTED_MODULE_0__.reactive)(useLink(props));
        const { options } = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(routerKey);
        const elClass = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => ({
            [getLinkClass(props.activeClass, options.linkActiveClass, 'router-link-active')]: link.isActive,
            // [getLinkClass(
            //   props.inactiveClass,
            //   options.linkInactiveClass,
            //   'router-link-inactive'
            // )]: !link.isExactActive,
            [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, 'router-link-exact-active')]: link.isExactActive,
        }));
        return () => {
            const children = slots.default && slots.default(link);
            return props.custom
                ? children
                : (0,vue__WEBPACK_IMPORTED_MODULE_0__.h)('a', {
                    'aria-current': link.isExactActive
                        ? props.ariaCurrentValue
                        : null,
                    href: link.href,
                    // this would override user added attrs but Vue will still add
                    // the listener, so we end up triggering both
                    onClick: link.navigate,
                    class: elClass.value,
                }, children);
        };
    },
});
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
/**
 * Component to render a link that triggers a navigation on click.
 */
const RouterLink = RouterLinkImpl;
function guardEvent(e) {
    // don't redirect with control keys
    if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
        return;
    // don't redirect when preventDefault called
    if (e.defaultPrevented)
        return;
    // don't redirect on right click
    if (e.button !== undefined && e.button !== 0)
        return;
    // don't redirect if `target="_blank"`
    // @ts-expect-error getAttribute does exist
    if (e.currentTarget && e.currentTarget.getAttribute) {
        // @ts-expect-error getAttribute exists
        const target = e.currentTarget.getAttribute('target');
        if (/\b_blank\b/i.test(target))
            return;
    }
    // this may be a Weex event which doesn't have this method
    if (e.preventDefault)
        e.preventDefault();
    return true;
}
function includesParams(outer, inner) {
    for (const key in inner) {
        const innerValue = inner[key];
        const outerValue = outer[key];
        if (typeof innerValue === 'string') {
            if (innerValue !== outerValue)
                return false;
        }
        else {
            if (!isArray(outerValue) ||
                outerValue.length !== innerValue.length ||
                innerValue.some((value, i) => value !== outerValue[i]))
                return false;
        }
    }
    return true;
}
/**
 * Get the original path value of a record by following its aliasOf
 * @param record
 */
function getOriginalPath(record) {
    return record ? (record.aliasOf ? record.aliasOf.path : record.path) : '';
}
/**
 * Utility class to get the active class based on defaults.
 * @param propClass
 * @param globalClass
 * @param defaultClass
 */
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null
    ? propClass
    : globalClass != null
        ? globalClass
        : defaultClass;

const RouterViewImpl = /*#__PURE__*/ (0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({
    name: 'RouterView',
    // #674 we manually inherit them
    inheritAttrs: false,
    props: {
        name: {
            type: String,
            default: 'default',
        },
        route: Object,
    },
    // Better compat for @vue/compat users
    // https://github.com/vuejs/router/issues/1315
    compatConfig: { MODE: 3 },
    setup(props, { attrs, slots }) {
        ( true) && warnDeprecatedUsage();
        const injectedRoute = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(routerViewLocationKey);
        const routeToDisplay = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => props.route || injectedRoute.value);
        const injectedDepth = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(viewDepthKey, 0);
        // The depth changes based on empty components option, which allows passthrough routes e.g. routes with children
        // that are used to reuse the `path` property
        const depth = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
            let initialDepth = (0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(injectedDepth);
            const { matched } = routeToDisplay.value;
            let matchedRoute;
            while ((matchedRoute = matched[initialDepth]) &&
                !matchedRoute.components) {
                initialDepth++;
            }
            return initialDepth;
        });
        const matchedRouteRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => routeToDisplay.value.matched[depth.value]);
        (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(viewDepthKey, (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => depth.value + 1));
        (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(matchedRouteKey, matchedRouteRef);
        (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(routerViewLocationKey, routeToDisplay);
        const viewRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)();
        // watch at the same time the component instance, the route record we are
        // rendering, and the name
        (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {
            // copy reused instances
            if (to) {
                // this will update the instance for new instances as well as reused
                // instances when navigating to a new route
                to.instances[name] = instance;
                // the component instance is reused for a different route or name, so
                // we copy any saved update or leave guards. With async setup, the
                // mounting component will mount before the matchedRoute changes,
                // making instance === oldInstance, so we check if guards have been
                // added before. This works because we remove guards when
                // unmounting/deactivating components
                if (from && from !== to && instance && instance === oldInstance) {
                    if (!to.leaveGuards.size) {
                        to.leaveGuards = from.leaveGuards;
                    }
                    if (!to.updateGuards.size) {
                        to.updateGuards = from.updateGuards;
                    }
                }
            }
            // trigger beforeRouteEnter next callbacks
            if (instance &&
                to &&
                // if there is no instance but to and from are the same this might be
                // the first visit
                (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
                (to.enterCallbacks[name] || []).forEach(callback => callback(instance));
            }
        }, { flush: 'post' });
        return () => {
            const route = routeToDisplay.value;
            // we need the value at the time we render because when we unmount, we
            // navigated to a different location so the value is different
            const currentName = props.name;
            const matchedRoute = matchedRouteRef.value;
            const ViewComponent = matchedRoute && matchedRoute.components[currentName];
            if (!ViewComponent) {
                return normalizeSlot(slots.default, { Component: ViewComponent, route });
            }
            // props from route configuration
            const routePropsOption = matchedRoute.props[currentName];
            const routeProps = routePropsOption
                ? routePropsOption === true
                    ? route.params
                    : typeof routePropsOption === 'function'
                        ? routePropsOption(route)
                        : routePropsOption
                : null;
            const onVnodeUnmounted = vnode => {
                // remove the instance reference to prevent leak
                if (vnode.component.isUnmounted) {
                    matchedRoute.instances[currentName] = null;
                }
            };
            const component = (0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(ViewComponent, assign({}, routeProps, attrs, {
                onVnodeUnmounted,
                ref: viewRef,
            }));
            if (( true) &&
                isBrowser &&
                component.ref) {
                // TODO: can display if it's an alias, its props
                const info = {
                    depth: depth.value,
                    name: matchedRoute.name,
                    path: matchedRoute.path,
                    meta: matchedRoute.meta,
                };
                const internalInstances = isArray(component.ref)
                    ? component.ref.map(r => r.i)
                    : [component.ref.i];
                internalInstances.forEach(instance => {
                    // @ts-expect-error
                    instance.__vrv_devtools = info;
                });
            }
            return (
            // pass the vnode to the slot as a prop.
            // h and <component :is="..."> both accept vnodes
            normalizeSlot(slots.default, { Component: component, route }) ||
                component);
        };
    },
});
function normalizeSlot(slot, data) {
    if (!slot)
        return null;
    const slotContent = slot(data);
    return slotContent.length === 1 ? slotContent[0] : slotContent;
}
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
/**
 * Component to display the current route the user is at.
 */
const RouterView = RouterViewImpl;
// warn against deprecated usage with <transition> & <keep-alive>
// due to functional component being no longer eager in Vue 3
function warnDeprecatedUsage() {
    const instance = (0,vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
    const parentName = instance.parent && instance.parent.type.name;
    const parentSubTreeType = instance.parent && instance.parent.subTree && instance.parent.subTree.type;
    if (parentName &&
        (parentName === 'KeepAlive' || parentName.includes('Transition')) &&
        typeof parentSubTreeType === 'object' &&
        parentSubTreeType.name === 'RouterView') {
        const comp = parentName === 'KeepAlive' ? 'keep-alive' : 'transition';
        warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\n` +
            `Use slot props instead:\n\n` +
            `<router-view v-slot="{ Component }">\n` +
            `  <${comp}>\n` +
            `    <component :is="Component" />\n` +
            `  </${comp}>\n` +
            `</router-view>`);
    }
}

/**
 * Copies a route location and removes any problematic properties that cannot be shown in devtools (e.g. Vue instances).
 *
 * @param routeLocation - routeLocation to format
 * @param tooltip - optional tooltip
 * @returns a copy of the routeLocation
 */
function formatRouteLocation(routeLocation, tooltip) {
    const copy = assign({}, routeLocation, {
        // remove variables that can contain vue instances
        matched: routeLocation.matched.map(matched => omit(matched, ['instances', 'children', 'aliasOf'])),
    });
    return {
        _custom: {
            type: null,
            readOnly: true,
            display: routeLocation.fullPath,
            tooltip,
            value: copy,
        },
    };
}
function formatDisplay(display) {
    return {
        _custom: {
            display,
        },
    };
}
// to support multiple router instances
let routerId = 0;
function addDevtools(app, router, matcher) {
    // Take over router.beforeEach and afterEach
    // make sure we are not registering the devtool twice
    if (router.__hasDevtools)
        return;
    router.__hasDevtools = true;
    // increment to support multiple router instances
    const id = routerId++;
    (0,_vue_devtools_api__WEBPACK_IMPORTED_MODULE_1__.setupDevtoolsPlugin)({
        id: 'org.vuejs.router' + (id ? '.' + id : ''),
        label: 'Vue Router',
        packageName: 'vue-router',
        homepage: 'https://router.vuejs.org',
        logo: 'https://router.vuejs.org/logo.png',
        componentStateTypes: ['Routing'],
        app,
    }, api => {
        if (typeof api.now !== 'function') {
            console.warn('[Vue Router]: You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.');
        }
        // display state added by the router
        api.on.inspectComponent((payload, ctx) => {
            if (payload.instanceData) {
                payload.instanceData.state.push({
                    type: 'Routing',
                    key: '$route',
                    editable: false,
                    value: formatRouteLocation(router.currentRoute.value, 'Current Route'),
                });
            }
        });
        // mark router-link as active and display tags on router views
        api.on.visitComponentTree(({ treeNode: node, componentInstance }) => {
            if (componentInstance.__vrv_devtools) {
                const info = componentInstance.__vrv_devtools;
                node.tags.push({
                    label: (info.name ? `${info.name.toString()}: ` : '') + info.path,
                    textColor: 0,
                    tooltip: 'This component is rendered by &lt;router-view&gt;',
                    backgroundColor: PINK_500,
                });
            }
            // if multiple useLink are used
            if (isArray(componentInstance.__vrl_devtools)) {
                componentInstance.__devtoolsApi = api;
                componentInstance.__vrl_devtools.forEach(devtoolsData => {
                    let backgroundColor = ORANGE_400;
                    let tooltip = '';
                    if (devtoolsData.isExactActive) {
                        backgroundColor = LIME_500;
                        tooltip = 'This is exactly active';
                    }
                    else if (devtoolsData.isActive) {
                        backgroundColor = BLUE_600;
                        tooltip = 'This link is active';
                    }
                    node.tags.push({
                        label: devtoolsData.route.path,
                        textColor: 0,
                        tooltip,
                        backgroundColor,
                    });
                });
            }
        });
        (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(router.currentRoute, () => {
            // refresh active state
            refreshRoutesView();
            api.notifyComponentUpdate();
            api.sendInspectorTree(routerInspectorId);
            api.sendInspectorState(routerInspectorId);
        });
        const navigationsLayerId = 'router:navigations:' + id;
        api.addTimelineLayer({
            id: navigationsLayerId,
            label: `Router${id ? ' ' + id : ''} Navigations`,
            color: 0x40a8c4,
        });
        // const errorsLayerId = 'router:errors'
        // api.addTimelineLayer({
        //   id: errorsLayerId,
        //   label: 'Router Errors',
        //   color: 0xea5455,
        // })
        router.onError((error, to) => {
            api.addTimelineEvent({
                layerId: navigationsLayerId,
                event: {
                    title: 'Error during Navigation',
                    subtitle: to.fullPath,
                    logType: 'error',
                    time: api.now(),
                    data: { error },
                    groupId: to.meta.__navigationId,
                },
            });
        });
        // attached to `meta` and used to group events
        let navigationId = 0;
        router.beforeEach((to, from) => {
            const data = {
                guard: formatDisplay('beforeEach'),
                from: formatRouteLocation(from, 'Current Location during this navigation'),
                to: formatRouteLocation(to, 'Target location'),
            };
            // Used to group navigations together, hide from devtools
            Object.defineProperty(to.meta, '__navigationId', {
                value: navigationId++,
            });
            api.addTimelineEvent({
                layerId: navigationsLayerId,
                event: {
                    time: api.now(),
                    title: 'Start of navigation',
                    subtitle: to.fullPath,
                    data,
                    groupId: to.meta.__navigationId,
                },
            });
        });
        router.afterEach((to, from, failure) => {
            const data = {
                guard: formatDisplay('afterEach'),
            };
            if (failure) {
                data.failure = {
                    _custom: {
                        type: Error,
                        readOnly: true,
                        display: failure ? failure.message : '',
                        tooltip: 'Navigation Failure',
                        value: failure,
                    },
                };
                data.status = formatDisplay('❌');
            }
            else {
                data.status = formatDisplay('✅');
            }
            // we set here to have the right order
            data.from = formatRouteLocation(from, 'Current Location during this navigation');
            data.to = formatRouteLocation(to, 'Target location');
            api.addTimelineEvent({
                layerId: navigationsLayerId,
                event: {
                    title: 'End of navigation',
                    subtitle: to.fullPath,
                    time: api.now(),
                    data,
                    logType: failure ? 'warning' : 'default',
                    groupId: to.meta.__navigationId,
                },
            });
        });
        /**
         * Inspector of Existing routes
         */
        const routerInspectorId = 'router-inspector:' + id;
        api.addInspector({
            id: routerInspectorId,
            label: 'Routes' + (id ? ' ' + id : ''),
            icon: 'book',
            treeFilterPlaceholder: 'Search routes',
        });
        function refreshRoutesView() {
            // the routes view isn't active
            if (!activeRoutesPayload)
                return;
            const payload = activeRoutesPayload;
            // children routes will appear as nested
            let routes = matcher.getRoutes().filter(route => !route.parent ||
                // these routes have a parent with no component which will not appear in the view
                // therefore we still need to include them
                !route.parent.record.components);
            // reset match state to false
            routes.forEach(resetMatchStateOnRouteRecord);
            // apply a match state if there is a payload
            if (payload.filter) {
                routes = routes.filter(route => 
                // save matches state based on the payload
                isRouteMatching(route, payload.filter.toLowerCase()));
            }
            // mark active routes
            routes.forEach(route => markRouteRecordActive(route, router.currentRoute.value));
            payload.rootNodes = routes.map(formatRouteRecordForInspector);
        }
        let activeRoutesPayload;
        api.on.getInspectorTree(payload => {
            activeRoutesPayload = payload;
            if (payload.app === app && payload.inspectorId === routerInspectorId) {
                refreshRoutesView();
            }
        });
        /**
         * Display information about the currently selected route record
         */
        api.on.getInspectorState(payload => {
            if (payload.app === app && payload.inspectorId === routerInspectorId) {
                const routes = matcher.getRoutes();
                const route = routes.find(route => route.record.__vd_id === payload.nodeId);
                if (route) {
                    payload.state = {
                        options: formatRouteRecordMatcherForStateInspector(route),
                    };
                }
            }
        });
        api.sendInspectorTree(routerInspectorId);
        api.sendInspectorState(routerInspectorId);
    });
}
function modifierForKey(key) {
    if (key.optional) {
        return key.repeatable ? '*' : '?';
    }
    else {
        return key.repeatable ? '+' : '';
    }
}
function formatRouteRecordMatcherForStateInspector(route) {
    const { record } = route;
    const fields = [
        { editable: false, key: 'path', value: record.path },
    ];
    if (record.name != null) {
        fields.push({
            editable: false,
            key: 'name',
            value: record.name,
        });
    }
    fields.push({ editable: false, key: 'regexp', value: route.re });
    if (route.keys.length) {
        fields.push({
            editable: false,
            key: 'keys',
            value: {
                _custom: {
                    type: null,
                    readOnly: true,
                    display: route.keys
                        .map(key => `${key.name}${modifierForKey(key)}`)
                        .join(' '),
                    tooltip: 'Param keys',
                    value: route.keys,
                },
            },
        });
    }
    if (record.redirect != null) {
        fields.push({
            editable: false,
            key: 'redirect',
            value: record.redirect,
        });
    }
    if (route.alias.length) {
        fields.push({
            editable: false,
            key: 'aliases',
            value: route.alias.map(alias => alias.record.path),
        });
    }
    if (Object.keys(route.record.meta).length) {
        fields.push({
            editable: false,
            key: 'meta',
            value: route.record.meta,
        });
    }
    fields.push({
        key: 'score',
        editable: false,
        value: {
            _custom: {
                type: null,
                readOnly: true,
                display: route.score.map(score => score.join(', ')).join(' | '),
                tooltip: 'Score used to sort routes',
                value: route.score,
            },
        },
    });
    return fields;
}
/**
 * Extracted from tailwind palette
 */
const PINK_500 = 0xec4899;
const BLUE_600 = 0x2563eb;
const LIME_500 = 0x84cc16;
const CYAN_400 = 0x22d3ee;
const ORANGE_400 = 0xfb923c;
// const GRAY_100 = 0xf4f4f5
const DARK = 0x666666;
function formatRouteRecordForInspector(route) {
    const tags = [];
    const { record } = route;
    if (record.name != null) {
        tags.push({
            label: String(record.name),
            textColor: 0,
            backgroundColor: CYAN_400,
        });
    }
    if (record.aliasOf) {
        tags.push({
            label: 'alias',
            textColor: 0,
            backgroundColor: ORANGE_400,
        });
    }
    if (route.__vd_match) {
        tags.push({
            label: 'matches',
            textColor: 0,
            backgroundColor: PINK_500,
        });
    }
    if (route.__vd_exactActive) {
        tags.push({
            label: 'exact',
            textColor: 0,
            backgroundColor: LIME_500,
        });
    }
    if (route.__vd_active) {
        tags.push({
            label: 'active',
            textColor: 0,
            backgroundColor: BLUE_600,
        });
    }
    if (record.redirect) {
        tags.push({
            label: typeof record.redirect === 'string'
                ? `redirect: ${record.redirect}`
                : 'redirects',
            textColor: 0xffffff,
            backgroundColor: DARK,
        });
    }
    // add an id to be able to select it. Using the `path` is not possible because
    // empty path children would collide with their parents
    let id = record.__vd_id;
    if (id == null) {
        id = String(routeRecordId++);
        record.__vd_id = id;
    }
    return {
        id,
        label: record.path,
        tags,
        children: route.children.map(formatRouteRecordForInspector),
    };
}
//  incremental id for route records and inspector state
let routeRecordId = 0;
const EXTRACT_REGEXP_RE = /^\/(.*)\/([a-z]*)$/;
function markRouteRecordActive(route, currentRoute) {
    // no route will be active if matched is empty
    // reset the matching state
    const isExactActive = currentRoute.matched.length &&
        isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);
    route.__vd_exactActive = route.__vd_active = isExactActive;
    if (!isExactActive) {
        route.__vd_active = currentRoute.matched.some(match => isSameRouteRecord(match, route.record));
    }
    route.children.forEach(childRoute => markRouteRecordActive(childRoute, currentRoute));
}
function resetMatchStateOnRouteRecord(route) {
    route.__vd_match = false;
    route.children.forEach(resetMatchStateOnRouteRecord);
}
function isRouteMatching(route, filter) {
    const found = String(route.re).match(EXTRACT_REGEXP_RE);
    route.__vd_match = false;
    if (!found || found.length < 3) {
        return false;
    }
    // use a regexp without $ at the end to match nested routes better
    const nonEndingRE = new RegExp(found[1].replace(/\$$/, ''), found[2]);
    if (nonEndingRE.test(filter)) {
        // mark children as matches
        route.children.forEach(child => isRouteMatching(child, filter));
        // exception case: `/`
        if (route.record.path !== '/' || filter === '/') {
            route.__vd_match = route.re.test(filter);
            return true;
        }
        // hide the / route
        return false;
    }
    const path = route.record.path.toLowerCase();
    const decodedPath = decode(path);
    // also allow partial matching on the path
    if (!filter.startsWith('/') &&
        (decodedPath.includes(filter) || path.includes(filter)))
        return true;
    if (decodedPath.startsWith(filter) || path.startsWith(filter))
        return true;
    if (route.record.name && String(route.record.name).includes(filter))
        return true;
    return route.children.some(child => isRouteMatching(child, filter));
}
function omit(obj, keys) {
    const ret = {};
    for (const key in obj) {
        if (!keys.includes(key)) {
            // @ts-expect-error
            ret[key] = obj[key];
        }
    }
    return ret;
}

/**
 * Creates a Router instance that can be used by a Vue app.
 *
 * @param options - {@link RouterOptions}
 */
function createRouter(options) {
    const matcher = createRouterMatcher(options.routes, options);
    const parseQuery$1 = options.parseQuery || parseQuery;
    const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
    const routerHistory = options.history;
    if (( true) && !routerHistory)
        throw new Error('Provide the "history" option when calling "createRouter()":' +
            ' https://next.router.vuejs.org/api/#history.');
    const beforeGuards = useCallbacks();
    const beforeResolveGuards = useCallbacks();
    const afterGuards = useCallbacks();
    const currentRoute = (0,vue__WEBPACK_IMPORTED_MODULE_0__.shallowRef)(START_LOCATION_NORMALIZED);
    let pendingLocation = START_LOCATION_NORMALIZED;
    // leave the scrollRestoration if no scrollBehavior is provided
    if (isBrowser && options.scrollBehavior && 'scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
    }
    const normalizeParams = applyToParams.bind(null, paramValue => '' + paramValue);
    const encodeParams = applyToParams.bind(null, encodeParam);
    const decodeParams = 
    // @ts-expect-error: intentionally avoid the type check
    applyToParams.bind(null, decode);
    function addRoute(parentOrRoute, route) {
        let parent;
        let record;
        if (isRouteName(parentOrRoute)) {
            parent = matcher.getRecordMatcher(parentOrRoute);
            record = route;
        }
        else {
            record = parentOrRoute;
        }
        return matcher.addRoute(record, parent);
    }
    function removeRoute(name) {
        const recordMatcher = matcher.getRecordMatcher(name);
        if (recordMatcher) {
            matcher.removeRoute(recordMatcher);
        }
        else if ((true)) {
            warn(`Cannot remove non-existent route "${String(name)}"`);
        }
    }
    function getRoutes() {
        return matcher.getRoutes().map(routeMatcher => routeMatcher.record);
    }
    function hasRoute(name) {
        return !!matcher.getRecordMatcher(name);
    }
    function resolve(rawLocation, currentLocation) {
        // const objectLocation = routerLocationAsObject(rawLocation)
        // we create a copy to modify it later
        currentLocation = assign({}, currentLocation || currentRoute.value);
        if (typeof rawLocation === 'string') {
            const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
            const matchedRoute = matcher.resolve({ path: locationNormalized.path }, currentLocation);
            const href = routerHistory.createHref(locationNormalized.fullPath);
            if ((true)) {
                if (href.startsWith('//'))
                    warn(`Location "${rawLocation}" resolved to "${href}". A resolved location cannot start with multiple slashes.`);
                else if (!matchedRoute.matched.length) {
                    warn(`No match found for location with path "${rawLocation}"`);
                }
            }
            // locationNormalized is always a new object
            return assign(locationNormalized, matchedRoute, {
                params: decodeParams(matchedRoute.params),
                hash: decode(locationNormalized.hash),
                redirectedFrom: undefined,
                href,
            });
        }
        let matcherLocation;
        // path could be relative in object as well
        if ('path' in rawLocation) {
            if (( true) &&
                'params' in rawLocation &&
                !('name' in rawLocation) &&
                // @ts-expect-error: the type is never
                Object.keys(rawLocation.params).length) {
                warn(`Path "${rawLocation.path}" was passed with params but they will be ignored. Use a named route alongside params instead.`);
            }
            matcherLocation = assign({}, rawLocation, {
                path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path,
            });
        }
        else {
            // remove any nullish param
            const targetParams = assign({}, rawLocation.params);
            for (const key in targetParams) {
                if (targetParams[key] == null) {
                    delete targetParams[key];
                }
            }
            // pass encoded values to the matcher, so it can produce encoded path and fullPath
            matcherLocation = assign({}, rawLocation, {
                params: encodeParams(targetParams),
            });
            // current location params are decoded, we need to encode them in case the
            // matcher merges the params
            currentLocation.params = encodeParams(currentLocation.params);
        }
        const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
        const hash = rawLocation.hash || '';
        if (( true) && hash && !hash.startsWith('#')) {
            warn(`A \`hash\` should always start with the character "#". Replace "${hash}" with "#${hash}".`);
        }
        // the matcher might have merged current location params, so
        // we need to run the decoding again
        matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
        const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
            hash: encodeHash(hash),
            path: matchedRoute.path,
        }));
        const href = routerHistory.createHref(fullPath);
        if ((true)) {
            if (href.startsWith('//')) {
                warn(`Location "${rawLocation}" resolved to "${href}". A resolved location cannot start with multiple slashes.`);
            }
            else if (!matchedRoute.matched.length) {
                warn(`No match found for location with path "${'path' in rawLocation ? rawLocation.path : rawLocation}"`);
            }
        }
        return assign({
            fullPath,
            // keep the hash encoded so fullPath is effectively path + encodedQuery +
            // hash
            hash,
            query: 
            // if the user is using a custom query lib like qs, we might have
            // nested objects, so we keep the query as is, meaning it can contain
            // numbers at `$route.query`, but at the point, the user will have to
            // use their own type anyway.
            // https://github.com/vuejs/router/issues/328#issuecomment-649481567
            stringifyQuery$1 === stringifyQuery
                ? normalizeQuery(rawLocation.query)
                : (rawLocation.query || {}),
        }, matchedRoute, {
            redirectedFrom: undefined,
            href,
        });
    }
    function locationAsObject(to) {
        return typeof to === 'string'
            ? parseURL(parseQuery$1, to, currentRoute.value.path)
            : assign({}, to);
    }
    function checkCanceledNavigation(to, from) {
        if (pendingLocation !== to) {
            return createRouterError(8 /* ErrorTypes.NAVIGATION_CANCELLED */, {
                from,
                to,
            });
        }
    }
    function push(to) {
        return pushWithRedirect(to);
    }
    function replace(to) {
        return push(assign(locationAsObject(to), { replace: true }));
    }
    function handleRedirectRecord(to) {
        const lastMatched = to.matched[to.matched.length - 1];
        if (lastMatched && lastMatched.redirect) {
            const { redirect } = lastMatched;
            let newTargetLocation = typeof redirect === 'function' ? redirect(to) : redirect;
            if (typeof newTargetLocation === 'string') {
                newTargetLocation =
                    newTargetLocation.includes('?') || newTargetLocation.includes('#')
                        ? (newTargetLocation = locationAsObject(newTargetLocation))
                        : // force empty params
                            { path: newTargetLocation };
                // @ts-expect-error: force empty params when a string is passed to let
                // the router parse them again
                newTargetLocation.params = {};
            }
            if (( true) &&
                !('path' in newTargetLocation) &&
                !('name' in newTargetLocation)) {
                warn(`Invalid redirect found:\n${JSON.stringify(newTargetLocation, null, 2)}\n when navigating to "${to.fullPath}". A redirect must contain a name or path. This will break in production.`);
                throw new Error('Invalid redirect');
            }
            return assign({
                query: to.query,
                hash: to.hash,
                // avoid transferring params if the redirect has a path
                params: 'path' in newTargetLocation ? {} : to.params,
            }, newTargetLocation);
        }
    }
    function pushWithRedirect(to, redirectedFrom) {
        const targetLocation = (pendingLocation = resolve(to));
        const from = currentRoute.value;
        const data = to.state;
        const force = to.force;
        // to could be a string where `replace` is a function
        const replace = to.replace === true;
        const shouldRedirect = handleRedirectRecord(targetLocation);
        if (shouldRedirect)
            return pushWithRedirect(assign(locationAsObject(shouldRedirect), {
                state: typeof shouldRedirect === 'object'
                    ? assign({}, data, shouldRedirect.state)
                    : data,
                force,
                replace,
            }), 
            // keep original redirectedFrom if it exists
            redirectedFrom || targetLocation);
        // if it was a redirect we already called `pushWithRedirect` above
        const toLocation = targetLocation;
        toLocation.redirectedFrom = redirectedFrom;
        let failure;
        if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
            failure = createRouterError(16 /* ErrorTypes.NAVIGATION_DUPLICATED */, { to: toLocation, from });
            // trigger scroll to allow scrolling to the same anchor
            handleScroll(from, from, 
            // this is a push, the only way for it to be triggered from a
            // history.listen is with a redirect, which makes it become a push
            true, 
            // This cannot be the first navigation because the initial location
            // cannot be manually navigated to
            false);
        }
        return (failure ? Promise.resolve(failure) : navigate(toLocation, from))
            .catch((error) => isNavigationFailure(error)
            ? // navigation redirects still mark the router as ready
                isNavigationFailure(error, 2 /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */)
                    ? error
                    : markAsReady(error) // also returns the error
            : // reject any unknown error
                triggerError(error, toLocation, from))
            .then((failure) => {
            if (failure) {
                if (isNavigationFailure(failure, 2 /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */)) {
                    if (( true) &&
                        // we are redirecting to the same location we were already at
                        isSameRouteLocation(stringifyQuery$1, resolve(failure.to), toLocation) &&
                        // and we have done it a couple of times
                        redirectedFrom &&
                        // @ts-expect-error: added only in dev
                        (redirectedFrom._count = redirectedFrom._count
                            ? // @ts-expect-error
                                redirectedFrom._count + 1
                            : 1) > 30) {
                        warn(`Detected a possibly infinite redirection in a navigation guard when going from "${from.fullPath}" to "${toLocation.fullPath}". Aborting to avoid a Stack Overflow.\n Are you always returning a new location within a navigation guard? That would lead to this error. Only return when redirecting or aborting, that should fix this. This might break in production if not fixed.`);
                        return Promise.reject(new Error('Infinite redirect in navigation guard'));
                    }
                    return pushWithRedirect(
                    // keep options
                    assign({
                        // preserve an existing replacement but allow the redirect to override it
                        replace,
                    }, locationAsObject(failure.to), {
                        state: typeof failure.to === 'object'
                            ? assign({}, data, failure.to.state)
                            : data,
                        force,
                    }), 
                    // preserve the original redirectedFrom if any
                    redirectedFrom || toLocation);
                }
            }
            else {
                // if we fail we don't finalize the navigation
                failure = finalizeNavigation(toLocation, from, true, replace, data);
            }
            triggerAfterEach(toLocation, from, failure);
            return failure;
        });
    }
    /**
     * Helper to reject and skip all navigation guards if a new navigation happened
     * @param to
     * @param from
     */
    function checkCanceledNavigationAndReject(to, from) {
        const error = checkCanceledNavigation(to, from);
        return error ? Promise.reject(error) : Promise.resolve();
    }
    function runWithContext(fn) {
        const app = installedApps.values().next().value;
        // support Vue < 3.3
        return app && typeof app.runWithContext === 'function'
            ? app.runWithContext(fn)
            : fn();
    }
    // TODO: refactor the whole before guards by internally using router.beforeEach
    function navigate(to, from) {
        let guards;
        const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
        // all components here have been resolved once because we are leaving
        guards = extractComponentsGuards(leavingRecords.reverse(), 'beforeRouteLeave', to, from);
        // leavingRecords is already reversed
        for (const record of leavingRecords) {
            record.leaveGuards.forEach(guard => {
                guards.push(guardToPromiseFn(guard, to, from));
            });
        }
        const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
        guards.push(canceledNavigationCheck);
        // run the queue of per route beforeRouteLeave guards
        return (runGuardQueue(guards)
            .then(() => {
            // check global guards beforeEach
            guards = [];
            for (const guard of beforeGuards.list()) {
                guards.push(guardToPromiseFn(guard, to, from));
            }
            guards.push(canceledNavigationCheck);
            return runGuardQueue(guards);
        })
            .then(() => {
            // check in components beforeRouteUpdate
            guards = extractComponentsGuards(updatingRecords, 'beforeRouteUpdate', to, from);
            for (const record of updatingRecords) {
                record.updateGuards.forEach(guard => {
                    guards.push(guardToPromiseFn(guard, to, from));
                });
            }
            guards.push(canceledNavigationCheck);
            // run the queue of per route beforeEnter guards
            return runGuardQueue(guards);
        })
            .then(() => {
            // check the route beforeEnter
            guards = [];
            for (const record of enteringRecords) {
                // do not trigger beforeEnter on reused views
                if (record.beforeEnter) {
                    if (isArray(record.beforeEnter)) {
                        for (const beforeEnter of record.beforeEnter)
                            guards.push(guardToPromiseFn(beforeEnter, to, from));
                    }
                    else {
                        guards.push(guardToPromiseFn(record.beforeEnter, to, from));
                    }
                }
            }
            guards.push(canceledNavigationCheck);
            // run the queue of per route beforeEnter guards
            return runGuardQueue(guards);
        })
            .then(() => {
            // NOTE: at this point to.matched is normalized and does not contain any () => Promise<Component>
            // clear existing enterCallbacks, these are added by extractComponentsGuards
            to.matched.forEach(record => (record.enterCallbacks = {}));
            // check in-component beforeRouteEnter
            guards = extractComponentsGuards(enteringRecords, 'beforeRouteEnter', to, from);
            guards.push(canceledNavigationCheck);
            // run the queue of per route beforeEnter guards
            return runGuardQueue(guards);
        })
            .then(() => {
            // check global guards beforeResolve
            guards = [];
            for (const guard of beforeResolveGuards.list()) {
                guards.push(guardToPromiseFn(guard, to, from));
            }
            guards.push(canceledNavigationCheck);
            return runGuardQueue(guards);
        })
            // catch any navigation canceled
            .catch(err => isNavigationFailure(err, 8 /* ErrorTypes.NAVIGATION_CANCELLED */)
            ? err
            : Promise.reject(err)));
    }
    function triggerAfterEach(to, from, failure) {
        // navigation is confirmed, call afterGuards
        // TODO: wrap with error handlers
        afterGuards
            .list()
            .forEach(guard => runWithContext(() => guard(to, from, failure)));
    }
    /**
     * - Cleans up any navigation guards
     * - Changes the url if necessary
     * - Calls the scrollBehavior
     */
    function finalizeNavigation(toLocation, from, isPush, replace, data) {
        // a more recent navigation took place
        const error = checkCanceledNavigation(toLocation, from);
        if (error)
            return error;
        // only consider as push if it's not the first navigation
        const isFirstNavigation = from === START_LOCATION_NORMALIZED;
        const state = !isBrowser ? {} : history.state;
        // change URL only if the user did a push/replace and if it's not the initial navigation because
        // it's just reflecting the url
        if (isPush) {
            // on the initial navigation, we want to reuse the scroll position from
            // history state if it exists
            if (replace || isFirstNavigation)
                routerHistory.replace(toLocation.fullPath, assign({
                    scroll: isFirstNavigation && state && state.scroll,
                }, data));
            else
                routerHistory.push(toLocation.fullPath, data);
        }
        // accept current navigation
        currentRoute.value = toLocation;
        handleScroll(toLocation, from, isPush, isFirstNavigation);
        markAsReady();
    }
    let removeHistoryListener;
    // attach listener to history to trigger navigations
    function setupListeners() {
        // avoid setting up listeners twice due to an invalid first navigation
        if (removeHistoryListener)
            return;
        removeHistoryListener = routerHistory.listen((to, _from, info) => {
            if (!router.listening)
                return;
            // cannot be a redirect route because it was in history
            const toLocation = resolve(to);
            // due to dynamic routing, and to hash history with manual navigation
            // (manually changing the url or calling history.hash = '#/somewhere'),
            // there could be a redirect record in history
            const shouldRedirect = handleRedirectRecord(toLocation);
            if (shouldRedirect) {
                pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);
                return;
            }
            pendingLocation = toLocation;
            const from = currentRoute.value;
            // TODO: should be moved to web history?
            if (isBrowser) {
                saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
            }
            navigate(toLocation, from)
                .catch((error) => {
                if (isNavigationFailure(error, 4 /* ErrorTypes.NAVIGATION_ABORTED */ | 8 /* ErrorTypes.NAVIGATION_CANCELLED */)) {
                    return error;
                }
                if (isNavigationFailure(error, 2 /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */)) {
                    // Here we could call if (info.delta) routerHistory.go(-info.delta,
                    // false) but this is bug prone as we have no way to wait the
                    // navigation to be finished before calling pushWithRedirect. Using
                    // a setTimeout of 16ms seems to work but there is no guarantee for
                    // it to work on every browser. So instead we do not restore the
                    // history entry and trigger a new navigation as requested by the
                    // navigation guard.
                    // the error is already handled by router.push we just want to avoid
                    // logging the error
                    pushWithRedirect(error.to, toLocation
                    // avoid an uncaught rejection, let push call triggerError
                    )
                        .then(failure => {
                        // manual change in hash history #916 ending up in the URL not
                        // changing, but it was changed by the manual url change, so we
                        // need to manually change it ourselves
                        if (isNavigationFailure(failure, 4 /* ErrorTypes.NAVIGATION_ABORTED */ |
                            16 /* ErrorTypes.NAVIGATION_DUPLICATED */) &&
                            !info.delta &&
                            info.type === NavigationType.pop) {
                            routerHistory.go(-1, false);
                        }
                    })
                        .catch(noop);
                    // avoid the then branch
                    return Promise.reject();
                }
                // do not restore history on unknown direction
                if (info.delta) {
                    routerHistory.go(-info.delta, false);
                }
                // unrecognized error, transfer to the global handler
                return triggerError(error, toLocation, from);
            })
                .then((failure) => {
                failure =
                    failure ||
                        finalizeNavigation(
                        // after navigation, all matched components are resolved
                        toLocation, from, false);
                // revert the navigation
                if (failure) {
                    if (info.delta &&
                        // a new navigation has been triggered, so we do not want to revert, that will change the current history
                        // entry while a different route is displayed
                        !isNavigationFailure(failure, 8 /* ErrorTypes.NAVIGATION_CANCELLED */)) {
                        routerHistory.go(-info.delta, false);
                    }
                    else if (info.type === NavigationType.pop &&
                        isNavigationFailure(failure, 4 /* ErrorTypes.NAVIGATION_ABORTED */ | 16 /* ErrorTypes.NAVIGATION_DUPLICATED */)) {
                        // manual change in hash history #916
                        // it's like a push but lacks the information of the direction
                        routerHistory.go(-1, false);
                    }
                }
                triggerAfterEach(toLocation, from, failure);
            })
                // avoid warnings in the console about uncaught rejections, they are logged by triggerErrors
                .catch(noop);
        });
    }
    // Initialization and Errors
    let readyHandlers = useCallbacks();
    let errorListeners = useCallbacks();
    let ready;
    /**
     * Trigger errorListeners added via onError and throws the error as well
     *
     * @param error - error to throw
     * @param to - location we were navigating to when the error happened
     * @param from - location we were navigating from when the error happened
     * @returns the error as a rejected promise
     */
    function triggerError(error, to, from) {
        markAsReady(error);
        const list = errorListeners.list();
        if (list.length) {
            list.forEach(handler => handler(error, to, from));
        }
        else {
            if ((true)) {
                warn('uncaught error during route navigation:');
            }
            console.error(error);
        }
        // reject the error no matter there were error listeners or not
        return Promise.reject(error);
    }
    function isReady() {
        if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
            return Promise.resolve();
        return new Promise((resolve, reject) => {
            readyHandlers.add([resolve, reject]);
        });
    }
    function markAsReady(err) {
        if (!ready) {
            // still not ready if an error happened
            ready = !err;
            setupListeners();
            readyHandlers
                .list()
                .forEach(([resolve, reject]) => (err ? reject(err) : resolve()));
            readyHandlers.reset();
        }
        return err;
    }
    // Scroll behavior
    function handleScroll(to, from, isPush, isFirstNavigation) {
        const { scrollBehavior } = options;
        if (!isBrowser || !scrollBehavior)
            return Promise.resolve();
        const scrollPosition = (!isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0))) ||
            ((isFirstNavigation || !isPush) &&
                history.state &&
                history.state.scroll) ||
            null;
        return (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)()
            .then(() => scrollBehavior(to, from, scrollPosition))
            .then(position => position && scrollToPosition(position))
            .catch(err => triggerError(err, to, from));
    }
    const go = (delta) => routerHistory.go(delta);
    let started;
    const installedApps = new Set();
    const router = {
        currentRoute,
        listening: true,
        addRoute,
        removeRoute,
        hasRoute,
        getRoutes,
        resolve,
        options,
        push,
        replace,
        go,
        back: () => go(-1),
        forward: () => go(1),
        beforeEach: beforeGuards.add,
        beforeResolve: beforeResolveGuards.add,
        afterEach: afterGuards.add,
        onError: errorListeners.add,
        isReady,
        install(app) {
            const router = this;
            app.component('RouterLink', RouterLink);
            app.component('RouterView', RouterView);
            app.config.globalProperties.$router = router;
            Object.defineProperty(app.config.globalProperties, '$route', {
                enumerable: true,
                get: () => (0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(currentRoute),
            });
            // this initial navigation is only necessary on client, on server it doesn't
            // make sense because it will create an extra unnecessary navigation and could
            // lead to problems
            if (isBrowser &&
                // used for the initial navigation client side to avoid pushing
                // multiple times when the router is used in multiple apps
                !started &&
                currentRoute.value === START_LOCATION_NORMALIZED) {
                // see above
                started = true;
                push(routerHistory.location).catch(err => {
                    if ((true))
                        warn('Unexpected error when starting the router:', err);
                });
            }
            const reactiveRoute = {};
            for (const key in START_LOCATION_NORMALIZED) {
                Object.defineProperty(reactiveRoute, key, {
                    get: () => currentRoute.value[key],
                    enumerable: true,
                });
            }
            app.provide(routerKey, router);
            app.provide(routeLocationKey, (0,vue__WEBPACK_IMPORTED_MODULE_0__.shallowReactive)(reactiveRoute));
            app.provide(routerViewLocationKey, currentRoute);
            const unmountApp = app.unmount;
            installedApps.add(app);
            app.unmount = function () {
                installedApps.delete(app);
                // the router is not attached to an app anymore
                if (installedApps.size < 1) {
                    // invalidate the current navigation
                    pendingLocation = START_LOCATION_NORMALIZED;
                    removeHistoryListener && removeHistoryListener();
                    removeHistoryListener = null;
                    currentRoute.value = START_LOCATION_NORMALIZED;
                    started = false;
                    ready = false;
                }
                unmountApp();
            };
            // TODO: this probably needs to be updated so it can be used by vue-termui
            if (( true) && isBrowser) {
                addDevtools(app, router, matcher);
            }
        },
    };
    // TODO: type this as NavigationGuardReturn or similar instead of any
    function runGuardQueue(guards) {
        return guards.reduce((promise, guard) => promise.then(() => runWithContext(guard)), Promise.resolve());
    }
    return router;
}
function extractChangingRecords(to, from) {
    const leavingRecords = [];
    const updatingRecords = [];
    const enteringRecords = [];
    const len = Math.max(from.matched.length, to.matched.length);
    for (let i = 0; i < len; i++) {
        const recordFrom = from.matched[i];
        if (recordFrom) {
            if (to.matched.find(record => isSameRouteRecord(record, recordFrom)))
                updatingRecords.push(recordFrom);
            else
                leavingRecords.push(recordFrom);
        }
        const recordTo = to.matched[i];
        if (recordTo) {
            // the type doesn't matter because we are comparing per reference
            if (!from.matched.find(record => isSameRouteRecord(record, recordTo))) {
                enteringRecords.push(recordTo);
            }
        }
    }
    return [leavingRecords, updatingRecords, enteringRecords];
}

/**
 * Returns the router instance. Equivalent to using `$router` inside
 * templates.
 */
function useRouter() {
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(routerKey);
}
/**
 * Returns the current route location. Equivalent to using `$route` inside
 * templates.
 */
function useRoute() {
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(routeLocationKey);
}




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		try {
/******/ 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 			module = execOptions.module;
/******/ 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 		} catch(e) {
/******/ 			module.error = e;
/******/ 			throw e;
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".bundle.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	(() => {
/******/ 		__webpack_require__.hmrF = () => ("main." + __webpack_require__.h() + ".hot-update.json");
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	(() => {
/******/ 		__webpack_require__.h = () => ("26216ef11c6e9bd13935")
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "echarts_learn:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	(() => {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises = 0;
/******/ 		var blockingPromisesWaiting = [];
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		// eslint-disable-next-line no-unused-vars
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId) {
/******/ 				return trackBlockingPromise(require.e(chunkId));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				//inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results);
/******/ 		}
/******/ 		
/******/ 		function unblock() {
/******/ 			if (--blockingPromises === 0) {
/******/ 				setStatus("ready").then(function () {
/******/ 					if (blockingPromises === 0) {
/******/ 						var list = blockingPromisesWaiting;
/******/ 						blockingPromisesWaiting = [];
/******/ 						for (var i = 0; i < list.length; i++) {
/******/ 							list[i]();
/******/ 						}
/******/ 					}
/******/ 				});
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 				/* fallthrough */
/******/ 				case "prepare":
/******/ 					blockingPromises++;
/******/ 					promise.then(unblock, unblock);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises === 0) return fn();
/******/ 			return new Promise(function (resolve) {
/******/ 				blockingPromisesWaiting.push(function () {
/******/ 					resolve(fn());
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							},
/******/ 							[])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								} else {
/******/ 									return setStatus("ready").then(function () {
/******/ 										return updatedModules;
/******/ 									});
/******/ 								}
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error(
/******/ 						"apply() is only allowed in ready status (state: " +
/******/ 							currentStatus +
/******/ 							")"
/******/ 					);
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = __webpack_require__.hmrS_jsonp = __webpack_require__.hmrS_jsonp || {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		var currentUpdatedModulesList;
/******/ 		var waitingUpdateResolves = {};
/******/ 		function loadUpdateChunk(chunkId, updatedModulesList) {
/******/ 			currentUpdatedModulesList = updatedModulesList;
/******/ 			return new Promise((resolve, reject) => {
/******/ 				waitingUpdateResolves[chunkId] = resolve;
/******/ 				// start update chunk loading
/******/ 				var url = __webpack_require__.p + __webpack_require__.hu(chunkId);
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				var loadingEnded = (event) => {
/******/ 					if(waitingUpdateResolves[chunkId]) {
/******/ 						waitingUpdateResolves[chunkId] = undefined
/******/ 						var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 						var realSrc = event && event.target && event.target.src;
/******/ 						error.message = 'Loading hot update chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 						error.name = 'ChunkLoadError';
/******/ 						error.type = errorType;
/******/ 						error.request = realSrc;
/******/ 						reject(error);
/******/ 					}
/******/ 				};
/******/ 				__webpack_require__.l(url, loadingEnded);
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		self["webpackHotUpdateecharts_learn"] = (chunkId, moreModules, runtime) => {
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					currentUpdate[moduleId] = moreModules[moduleId];
/******/ 					if(currentUpdatedModulesList) currentUpdatedModulesList.push(moduleId);
/******/ 				}
/******/ 			}
/******/ 			if(runtime) currentUpdateRuntime.push(runtime);
/******/ 			if(waitingUpdateResolves[chunkId]) {
/******/ 				waitingUpdateResolves[chunkId]();
/******/ 				waitingUpdateResolves[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.jsonpHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result;
/******/ 					if (newModuleFactory) {
/******/ 						result = getAffectedModuleEffects(moduleId);
/******/ 					} else {
/******/ 						result = {
/******/ 							type: "disposed",
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err2) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err2,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err2);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.jsonp = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.jsonp = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				} else {
/******/ 					currentUpdateChunks[chunkId] = false;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.jsonpHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						!currentUpdateChunks[chunkId]
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = () => {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then((response) => {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkecharts_learn"] = self["webpackChunkecharts_learn"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDRDQUFNO0FBQ2Q7QUFDQSxlQUFlLGdEQUFNO0FBQ3JCO0FBQ0E7QUFDQSxnQkFBZ0IsK0NBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFLLFdBQVcsb0RBQVU7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtDQUFLO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOEJBQThCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUUrTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwOURyTTs7QUFFMUI7QUFDQTtBQUNBOztBQUVBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUI7QUFPbEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tOO0FBQzFKOztBQUV4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsS0FBcUM7QUFDOUMsZ0dBQWdHLEdBQUcsVUFBVSxLQUFLLDJCQUEyQixLQUFLO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrREFBa0Q7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBcUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsWUFBWSxxREFBcUQsWUFBWTtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBcUM7QUFDbEQsOERBQThELFlBQVk7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBLHNDQUFzQyxtQkFBbUIsaUNBQWlDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsSUFBcUM7QUFDdEQ7QUFDQTtBQUNBLGlCQUFpQixFQUVKO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLHVEQUF1RCx1Q0FBdUM7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxhQUFhLEtBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaURBQWlELHFDQUFxQztBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQXFDO0FBQzlDLG1EQUFtRCxLQUFLLGVBQWUsMEJBQTBCO0FBQ2pHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQSx3Q0FBd0MsS0FBcUMsMkJBQTJCLENBQUU7QUFDMUc7QUFDQTtBQUNBLElBQUksMkJBQTJCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0RBQXNEO0FBQ3ZEO0FBQ0E7QUFDQSw2Q0FBNkMsMkJBQTJCO0FBQ3hFLGlDQUFpQyx5QkFBeUIsRUFBRTtBQUM1RDtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0wscURBQXFELFdBQVc7QUFDaEUsbUNBQW1DLGNBQWMsUUFBUSxtQkFBbUI7QUFDNUUsS0FBSztBQUNMLDhDQUE4QyxVQUFVO0FBQ3hELDJDQUEyQyxjQUFjLFFBQVEsWUFBWTtBQUM3RSxLQUFLO0FBQ0wsZ0RBQWdELFVBQVU7QUFDMUQsNkNBQTZDLGNBQWMsUUFBUSxZQUFZO0FBQy9FLEtBQUs7QUFDTCxrREFBa0QsVUFBVTtBQUM1RCxxRUFBcUUsY0FBYztBQUNuRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFnRDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTLEVBS0o7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNkJBQTZCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQ0FBc0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEdBQUc7QUFDMUM7QUFDQTtBQUNBLDRFQUE0RSxNQUFNLEtBQUssR0FBRztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxHQUFHLFVBQVUsR0FBRyxZQUFZLEdBQUc7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFdBQVc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBLDJEQUEyRCxNQUFNO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsTUFBTTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEtBQXFDO0FBQzlELHVEQUF1RCxLQUFLLGdCQUFnQixLQUFLO0FBQ2pGLGNBQWMsQ0FBd0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE1BQU0sS0FBSyxPQUFPLEtBQUssUUFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQXFDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxTQUFTLGNBQWMsWUFBWTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNENBQTRDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFxQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBcUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixLQUFxQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQXFDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQixJQUFxQztBQUN0RCx1RUFBdUU7QUFDdkU7QUFDQSx3REFBd0QsMkJBQTJCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBcUM7QUFDdEQsZ0ZBQWdGLEtBQUssbURBQW1ELEtBQUs7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0Esb0NBQW9DLDJCQUEyQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxjQUFjLDhCQUE4QixjQUFjLDBDQUEwQyxTQUFTO0FBQy9JO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxjQUFjLDhCQUE4QixjQUFjLDBDQUEwQyxTQUFTO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJCQUEyQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1CQUFtQiwwQ0FBMEMsU0FBUyxtQkFBbUIsbUJBQW1CO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsMkJBQTJCO0FBQzNCLHdCQUF3QjtBQUN4Qix1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHFDQUFxQztBQUNyQyw2QkFBNkI7QUFDN0IsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQyw0QkFBNEI7QUFDNUIsbUNBQW1DO0FBQ25DLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGtCQUFrQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQXFDLDZCQUE2QixLQUFLO0FBQ2hGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0IsUUFBUSxxQkFBcUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxLQUFxQyxxQ0FBcUMsQ0FBRTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsS0FBcUMsMEJBQTBCLENBQUU7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEtBQXFDLGVBQWUsQ0FBRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBcUMsdUJBQXVCLENBQUU7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEtBQXFDLDZCQUE2QixDQUFFOztBQUUxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQVc7QUFDZixJQUFJLGtEQUFhO0FBQ2pCLElBQUksZ0RBQVc7QUFDZjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx3QkFBd0I7QUFDckU7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsU0FBUyxLQUFxQyxNQUFNLHVEQUFrQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkNBQU07QUFDL0I7QUFDQSxNQUFNO0FBQ047QUFDQSxTQUFTLEtBQXFDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlCQUF5QjtBQUN2RDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxTQUFTLEtBQXFDLE1BQU0sdURBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyQ0FBTTtBQUMvQjtBQUNBLE1BQU07QUFDTjtBQUNBLFNBQVMsS0FBcUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsS0FBcUMsMENBQTBDLENBQUk7QUFDdks7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFxQztBQUNsRCw4RUFBOEUseUNBQXlDLEtBQUssaUJBQWlCO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLGNBQWMsUUFBUSxZQUFZO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBcUM7QUFDbEQsc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsSUFBcUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEtBQUsseUJBQXlCLFlBQVk7QUFDakYseURBQXlELHFCQUFxQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxLQUFLLHlCQUF5QixZQUFZO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsS0FBSyx5QkFBeUIsWUFBWTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEtBQXFDO0FBQzFELHVDQUF1QyxLQUFLLHlCQUF5QixZQUFZO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLEtBQUssUUFBUSxZQUFZO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsS0FBSyxRQUFRLFlBQVk7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkNBQU07QUFDekIseUJBQXlCLDJDQUFNO0FBQy9CLGtCQUFrQiw2Q0FBUSxzQkFBc0IsMENBQUs7QUFDckQsOEJBQThCLDZDQUFRO0FBQ3RDLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUJBQXFCLDZDQUFRO0FBQzdCO0FBQ0EsMEJBQTBCLDZDQUFRO0FBQ2xDO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSwwQkFBMEIsMENBQUssc0NBQXNDLDBDQUFLO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsS0FBZ0U7QUFDekUseUJBQXlCLHVEQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0RBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxjQUFjLDZDQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsb0RBQWU7QUFDcEQ7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLHFCQUFxQiw2Q0FBUTtBQUM3QixnQkFBZ0IsVUFBVSxFQUFFLDJDQUFNO0FBQ2xDLHdCQUF3Qiw2Q0FBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQ0FBQztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsb0RBQWU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCLG1CQUFtQixjQUFjO0FBQ2pDLFNBQVMsS0FBcUM7QUFDOUMsOEJBQThCLDJDQUFNO0FBQ3BDLCtCQUErQiw2Q0FBUTtBQUN2Qyw4QkFBOEIsMkNBQU07QUFDcEM7QUFDQTtBQUNBLHNCQUFzQiw2Q0FBUTtBQUM5QiwrQkFBK0IsMENBQUs7QUFDcEMsb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdDQUFnQyw2Q0FBUTtBQUN4QyxRQUFRLDRDQUFPLGVBQWUsNkNBQVE7QUFDdEMsUUFBUSw0Q0FBTztBQUNmLFFBQVEsNENBQU87QUFDZix3QkFBd0Isd0NBQUc7QUFDM0I7QUFDQTtBQUNBLFFBQVEsMENBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsaUNBQWlDO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNDQUFDLHlCQUF5QjtBQUN4RDtBQUNBO0FBQ0EsYUFBYTtBQUNiLGlCQUFpQixLQUFnRTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsNkJBQTZCO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1REFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0Msa0JBQWtCLEtBQUs7QUFDdkI7QUFDQSxtQkFBbUIsS0FBSztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNFQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0EscUNBQXFDLG1DQUFtQztBQUN4RTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMscUJBQXFCO0FBQ2hFO0FBQ0EsZ0VBQWdFLGVBQWU7QUFDL0U7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1QsUUFBUSwwQ0FBSztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBLFVBQVUsa0RBQWtEO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtCQUFrQixpREFBaUQ7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVMsRUFBRSxvQkFBb0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0JBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQXFDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsK0NBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLElBQXFDO0FBQ3ZELHNEQUFzRCxhQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLG1EQUFtRCwrQkFBK0I7QUFDbEY7QUFDQSxpQkFBaUIsSUFBcUM7QUFDdEQ7QUFDQSxzQ0FBc0MsWUFBWSxpQkFBaUIsS0FBSztBQUN4RTtBQUNBLG1FQUFtRSxZQUFZO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBcUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUJBQWlCO0FBQy9DO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFxQztBQUNsRCxvRkFBb0YsS0FBSyxXQUFXLEtBQUs7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGFBQWEsSUFBcUM7QUFDbEQ7QUFDQSxrQ0FBa0MsWUFBWSxpQkFBaUIsS0FBSztBQUNwRTtBQUNBO0FBQ0EsK0RBQStELHVEQUF1RDtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxlQUFlO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQXFDO0FBQ3REO0FBQ0E7QUFDQSxpREFBaUQsMkNBQTJDLHlCQUF5QixZQUFZO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLHNCQUFzQjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEtBQXFDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSCxjQUFjLFFBQVEsb0JBQW9CO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsZUFBZTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEdBQUc7V0FDSDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxtQkFBbUIsMkJBQTJCO1dBQzlDO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxLQUFLO1dBQ0w7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBLGtCQUFrQixjQUFjO1dBQ2hDO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQSxjQUFjLE1BQU07V0FDcEI7V0FDQTtXQUNBO1dBQ0EsS0FBSztXQUNMO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxjQUFjLGFBQWE7V0FDM0I7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQSxpQkFBaUIsNEJBQTRCO1dBQzdDO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxJQUFJO1dBQ0o7V0FDQTs7V0FFQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLElBQUk7V0FDSjs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7O1dBRUE7V0FDQTtXQUNBLGdCQUFnQiw0QkFBNEI7V0FDNUM7V0FDQTtXQUNBOztXQUVBO1dBQ0E7O1dBRUE7V0FDQTs7V0FFQTtXQUNBOztXQUVBO1dBQ0EsZ0JBQWdCLDRCQUE0QjtXQUM1QztXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxrQkFBa0IsdUNBQXVDO1dBQ3pEO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0EsbUJBQW1CLGlDQUFpQztXQUNwRDtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0Esc0JBQXNCLHVDQUF1QztXQUM3RDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxzQkFBc0Isc0JBQXNCO1dBQzVDO1dBQ0E7V0FDQSxTQUFTO1dBQ1Q7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLFdBQVc7V0FDWCxXQUFXO1dBQ1g7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxZQUFZO1dBQ1o7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsVUFBVTtXQUNWO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLFdBQVc7V0FDWDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBLG1CQUFtQix3Q0FBd0M7V0FDM0Q7V0FDQTtXQUNBO1dBQ0E7V0FDQSxNQUFNO1dBQ047V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLFFBQVE7V0FDUixRQUFRO1dBQ1I7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsU0FBUztXQUNUO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLE9BQU87V0FDUDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsUUFBUTtXQUNSO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxFQUFFLElBQUk7V0FDTjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsSUFBSTtXQUNKO1dBQ0E7V0FDQSxFQUFFO1dBQ0Y7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0Esc0NBQXNDO1dBQ3RDO1dBQ0E7V0FDQSxFQUFFO1dBQ0Y7O1dBRUE7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsTUFBTSxxQkFBcUI7V0FDM0I7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBOztXQUVBO1dBQ0E7V0FDQTs7Ozs7VUU5akJBO1VBQ0E7VUFDQTtVQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNoYXJ0c19sZWFybi8uL25vZGVfbW9kdWxlcy9AdnVlL2RldnRvb2xzLWFwaS9saWIvZXNtL2NvbnN0LmpzIiwid2VicGFjazovL2VjaGFydHNfbGVhcm4vLi9ub2RlX21vZHVsZXMvQHZ1ZS9kZXZ0b29scy1hcGkvbGliL2VzbS9lbnYuanMiLCJ3ZWJwYWNrOi8vZWNoYXJ0c19sZWFybi8uL25vZGVfbW9kdWxlcy9AdnVlL2RldnRvb2xzLWFwaS9saWIvZXNtL2luZGV4LmpzIiwid2VicGFjazovL2VjaGFydHNfbGVhcm4vLi9ub2RlX21vZHVsZXMvQHZ1ZS9kZXZ0b29scy1hcGkvbGliL2VzbS9wcm94eS5qcyIsIndlYnBhY2s6Ly9lY2hhcnRzX2xlYXJuLy4vbm9kZV9tb2R1bGVzL0B2dWUvZGV2dG9vbHMtYXBpL2xpYi9lc20vdGltZS5qcyIsIndlYnBhY2s6Ly9lY2hhcnRzX2xlYXJuLy4vbm9kZV9tb2R1bGVzL0B2dWUvcmVhY3Rpdml0eS9kaXN0L3JlYWN0aXZpdHkuZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vZWNoYXJ0c19sZWFybi8uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtY29yZS9kaXN0L3J1bnRpbWUtY29yZS5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly9lY2hhcnRzX2xlYXJuLy4vbm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1kb20vZGlzdC9ydW50aW1lLWRvbS5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly9lY2hhcnRzX2xlYXJuLy4vbm9kZV9tb2R1bGVzL0B2dWUvc2hhcmVkL2Rpc3Qvc2hhcmVkLmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovL2VjaGFydHNfbGVhcm4vLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qcyIsIndlYnBhY2s6Ly9lY2hhcnRzX2xlYXJuLy4vc3JjL0FwcC52dWUiLCJ3ZWJwYWNrOi8vZWNoYXJ0c19sZWFybi8uL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUucnVudGltZS5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly9lY2hhcnRzX2xlYXJuLy4vc3JjL21haW4udHMiLCJ3ZWJwYWNrOi8vZWNoYXJ0c19sZWFybi8uL3NyYy9yb3V0ZXIvcm91dGVyLnRzIiwid2VicGFjazovL2VjaGFydHNfbGVhcm4vLi9zcmMvQXBwLnZ1ZT84YTI5Iiwid2VicGFjazovL2VjaGFydHNfbGVhcm4vLi9zcmMvQXBwLnZ1ZT84Y2UyIiwid2VicGFjazovL2VjaGFydHNfbGVhcm4vLi9ub2RlX21vZHVsZXMvcGluaWEvZGlzdC9waW5pYS5tanMiLCJ3ZWJwYWNrOi8vZWNoYXJ0c19sZWFybi8uL25vZGVfbW9kdWxlcy9waW5pYS9ub2RlX21vZHVsZXMvdnVlLWRlbWkvbGliL2luZGV4Lm1qcyIsIndlYnBhY2s6Ly9lY2hhcnRzX2xlYXJuLy4vbm9kZV9tb2R1bGVzL3Z1ZS1yb3V0ZXIvZGlzdC92dWUtcm91dGVyLm1qcyIsIndlYnBhY2s6Ly9lY2hhcnRzX2xlYXJuL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2VjaGFydHNfbGVhcm4vd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL2VjaGFydHNfbGVhcm4vd2VicGFjay9ydW50aW1lL2Vuc3VyZSBjaHVuayIsIndlYnBhY2s6Ly9lY2hhcnRzX2xlYXJuL3dlYnBhY2svcnVudGltZS9nZXQgamF2YXNjcmlwdCBjaHVuayBmaWxlbmFtZSIsIndlYnBhY2s6Ly9lY2hhcnRzX2xlYXJuL3dlYnBhY2svcnVudGltZS9nZXQgamF2YXNjcmlwdCB1cGRhdGUgY2h1bmsgZmlsZW5hbWUiLCJ3ZWJwYWNrOi8vZWNoYXJ0c19sZWFybi93ZWJwYWNrL3J1bnRpbWUvZ2V0IHVwZGF0ZSBtYW5pZmVzdCBmaWxlbmFtZSIsIndlYnBhY2s6Ly9lY2hhcnRzX2xlYXJuL3dlYnBhY2svcnVudGltZS9nZXRGdWxsSGFzaCIsIndlYnBhY2s6Ly9lY2hhcnRzX2xlYXJuL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vZWNoYXJ0c19sZWFybi93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2VjaGFydHNfbGVhcm4vd2VicGFjay9ydW50aW1lL2xvYWQgc2NyaXB0Iiwid2VicGFjazovL2VjaGFydHNfbGVhcm4vd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9lY2hhcnRzX2xlYXJuL3dlYnBhY2svcnVudGltZS9ob3QgbW9kdWxlIHJlcGxhY2VtZW50Iiwid2VicGFjazovL2VjaGFydHNfbGVhcm4vd2VicGFjay9ydW50aW1lL3B1YmxpY1BhdGgiLCJ3ZWJwYWNrOi8vZWNoYXJ0c19sZWFybi93ZWJwYWNrL3J1bnRpbWUvanNvbnAgY2h1bmsgbG9hZGluZyIsIndlYnBhY2s6Ly9lY2hhcnRzX2xlYXJuL3dlYnBhY2svYmVmb3JlLXN0YXJ0dXAiLCJ3ZWJwYWNrOi8vZWNoYXJ0c19sZWFybi93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8vZWNoYXJ0c19sZWFybi93ZWJwYWNrL2FmdGVyLXN0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IEhPT0tfU0VUVVAgPSAnZGV2dG9vbHMtcGx1Z2luOnNldHVwJztcbmV4cG9ydCBjb25zdCBIT09LX1BMVUdJTl9TRVRUSU5HU19TRVQgPSAncGx1Z2luOnNldHRpbmdzOnNldCc7XG4iLCJleHBvcnQgZnVuY3Rpb24gZ2V0RGV2dG9vbHNHbG9iYWxIb29rKCkge1xuICAgIHJldHVybiBnZXRUYXJnZXQoKS5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgPyB3aW5kb3dcbiAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBnbG9iYWxcbiAgICAgICAgICAgIDoge307XG59XG5leHBvcnQgY29uc3QgaXNQcm94eUF2YWlsYWJsZSA9IHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJztcbiIsImltcG9ydCB7IGdldFRhcmdldCwgZ2V0RGV2dG9vbHNHbG9iYWxIb29rLCBpc1Byb3h5QXZhaWxhYmxlIH0gZnJvbSAnLi9lbnYuanMnO1xuaW1wb3J0IHsgSE9PS19TRVRVUCB9IGZyb20gJy4vY29uc3QuanMnO1xuaW1wb3J0IHsgQXBpUHJveHkgfSBmcm9tICcuL3Byb3h5LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vYXBpL2luZGV4LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vcGx1Z2luLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdGltZS5qcyc7XG5leHBvcnQgZnVuY3Rpb24gc2V0dXBEZXZ0b29sc1BsdWdpbihwbHVnaW5EZXNjcmlwdG9yLCBzZXR1cEZuKSB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IHBsdWdpbkRlc2NyaXB0b3I7XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KCk7XG4gICAgY29uc3QgaG9vayA9IGdldERldnRvb2xzR2xvYmFsSG9vaygpO1xuICAgIGNvbnN0IGVuYWJsZVByb3h5ID0gaXNQcm94eUF2YWlsYWJsZSAmJiBkZXNjcmlwdG9yLmVuYWJsZUVhcmx5UHJveHk7XG4gICAgaWYgKGhvb2sgJiYgKHRhcmdldC5fX1ZVRV9ERVZUT09MU19QTFVHSU5fQVBJX0FWQUlMQUJMRV9fIHx8ICFlbmFibGVQcm94eSkpIHtcbiAgICAgICAgaG9vay5lbWl0KEhPT0tfU0VUVVAsIHBsdWdpbkRlc2NyaXB0b3IsIHNldHVwRm4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcHJveHkgPSBlbmFibGVQcm94eSA/IG5ldyBBcGlQcm94eShkZXNjcmlwdG9yLCBob29rKSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGxpc3QgPSB0YXJnZXQuX19WVUVfREVWVE9PTFNfUExVR0lOU19fID0gdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX1BMVUdJTlNfXyB8fCBbXTtcbiAgICAgICAgbGlzdC5wdXNoKHtcbiAgICAgICAgICAgIHBsdWdpbkRlc2NyaXB0b3I6IGRlc2NyaXB0b3IsXG4gICAgICAgICAgICBzZXR1cEZuLFxuICAgICAgICAgICAgcHJveHksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJveHkpXG4gICAgICAgICAgICBzZXR1cEZuKHByb3h5LnByb3hpZWRUYXJnZXQpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEhPT0tfUExVR0lOX1NFVFRJTkdTX1NFVCB9IGZyb20gJy4vY29uc3QuanMnO1xuaW1wb3J0IHsgbm93IH0gZnJvbSAnLi90aW1lLmpzJztcbmV4cG9ydCBjbGFzcyBBcGlQcm94eSB7XG4gICAgY29uc3RydWN0b3IocGx1Z2luLCBob29rKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy50YXJnZXRRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLm9uUXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgICAgIHRoaXMuaG9vayA9IGhvb2s7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTZXR0aW5ncyA9IHt9O1xuICAgICAgICBpZiAocGx1Z2luLnNldHRpbmdzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkIGluIHBsdWdpbi5zZXR0aW5ncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBwbHVnaW4uc2V0dGluZ3NbaWRdO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRTZXR0aW5nc1tpZF0gPSBpdGVtLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2NhbFNldHRpbmdzU2F2ZUlkID0gYF9fdnVlLWRldnRvb2xzLXBsdWdpbi1zZXR0aW5nc19fJHtwbHVnaW4uaWR9YDtcbiAgICAgICAgbGV0IGN1cnJlbnRTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRTZXR0aW5ncyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByYXcgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShsb2NhbFNldHRpbmdzU2F2ZUlkKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHJhdyk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGN1cnJlbnRTZXR0aW5ncywgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIGdldFNldHRpbmdzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50U2V0dGluZ3M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0U2V0dGluZ3ModmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShsb2NhbFNldHRpbmdzU2F2ZUlkLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBub29wXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRTZXR0aW5ncyA9IHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vdygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm93KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaG9vaykge1xuICAgICAgICAgICAgaG9vay5vbihIT09LX1BMVUdJTl9TRVRUSU5HU19TRVQsIChwbHVnaW5JZCwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luSWQgPT09IHRoaXMucGx1Z2luLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFsbGJhY2tzLnNldFNldHRpbmdzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3hpZWRPbiA9IG5ldyBQcm94eSh7fSwge1xuICAgICAgICAgICAgZ2V0OiAoX3RhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXQub25bcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25RdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHByb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb3hpZWRUYXJnZXQgPSBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgICAgIGdldDogKF90YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9wID09PSAnb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3hpZWRPbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoT2JqZWN0LmtleXModGhpcy5mYWxsYmFja3MpLmluY2x1ZGVzKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXRRdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHByb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlOiAoKSA9PiB7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZhbGxiYWNrc1twcm9wXSguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0UXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogcHJvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBzZXRSZWFsVGFyZ2V0KHRhcmdldCkge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMub25RdWV1ZSkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXQub25baXRlbS5tZXRob2RdKC4uLml0ZW0uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMudGFyZ2V0UXVldWUpIHtcbiAgICAgICAgICAgIGl0ZW0ucmVzb2x2ZShhd2FpdCB0aGlzLnRhcmdldFtpdGVtLm1ldGhvZF0oLi4uaXRlbS5hcmdzKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJsZXQgc3VwcG9ydGVkO1xubGV0IHBlcmY7XG5leHBvcnQgZnVuY3Rpb24gaXNQZXJmb3JtYW5jZVN1cHBvcnRlZCgpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHN1cHBvcnRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcGVyZiA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgKChfYSA9IGdsb2JhbC5wZXJmX2hvb2tzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGVyZm9ybWFuY2UpKSB7XG4gICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHBlcmYgPSBnbG9iYWwucGVyZl9ob29rcy5wZXJmb3JtYW5jZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwcG9ydGVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4gaXNQZXJmb3JtYW5jZVN1cHBvcnRlZCgpID8gcGVyZi5ub3coKSA6IERhdGUubm93KCk7XG59XG4iLCJpbXBvcnQgeyBleHRlbmQsIGlzQXJyYXksIGlzU3ltYm9sLCBpc01hcCwgaXNJbnRlZ2VyS2V5LCBoYXNPd24sIGhhc0NoYW5nZWQsIGlzT2JqZWN0LCBtYWtlTWFwLCBjYXBpdGFsaXplLCB0b1Jhd1R5cGUsIGRlZiwgaXNGdW5jdGlvbiwgTk9PUCB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuZnVuY3Rpb24gd2Fybihtc2csIC4uLmFyZ3MpIHtcbiAgY29uc29sZS53YXJuKGBbVnVlIHdhcm5dICR7bXNnfWAsIC4uLmFyZ3MpO1xufVxuXG5sZXQgYWN0aXZlRWZmZWN0U2NvcGU7XG5jbGFzcyBFZmZlY3RTY29wZSB7XG4gIGNvbnN0cnVjdG9yKGRldGFjaGVkID0gZmFsc2UpIHtcbiAgICB0aGlzLmRldGFjaGVkID0gZGV0YWNoZWQ7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmVmZmVjdHMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmNsZWFudXBzID0gW107XG4gICAgdGhpcy5wYXJlbnQgPSBhY3RpdmVFZmZlY3RTY29wZTtcbiAgICBpZiAoIWRldGFjaGVkICYmIGFjdGl2ZUVmZmVjdFNjb3BlKSB7XG4gICAgICB0aGlzLmluZGV4ID0gKGFjdGl2ZUVmZmVjdFNjb3BlLnNjb3BlcyB8fCAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzID0gW10pKS5wdXNoKFxuICAgICAgICB0aGlzXG4gICAgICApIC0gMTtcbiAgICB9XG4gIH1cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICB9XG4gIHJ1bihmbikge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRFZmZlY3RTY29wZSA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gY3VycmVudEVmZmVjdFNjb3BlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihgY2Fubm90IHJ1biBhbiBpbmFjdGl2ZSBlZmZlY3Qgc2NvcGUuYCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBub24tZGV0YWNoZWQgc2NvcGVzXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb24oKSB7XG4gICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBub24tZGV0YWNoZWQgc2NvcGVzXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb2ZmKCkge1xuICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcy5wYXJlbnQ7XG4gIH1cbiAgc3RvcChmcm9tUGFyZW50KSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgbGV0IGksIGw7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5lZmZlY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmVmZmVjdHNbaV0uc3RvcCgpO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2xlYW51cHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuY2xlYW51cHNbaV0oKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNjb3Blcykge1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5zY29wZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5zY29wZXNbaV0uc3RvcCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmRldGFjaGVkICYmIHRoaXMucGFyZW50ICYmICFmcm9tUGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLnBhcmVudC5zY29wZXMucG9wKCk7XG4gICAgICAgIGlmIChsYXN0ICYmIGxhc3QgIT09IHRoaXMpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5zY29wZXNbdGhpcy5pbmRleF0gPSBsYXN0O1xuICAgICAgICAgIGxhc3QuaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnBhcmVudCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZWZmZWN0U2NvcGUoZGV0YWNoZWQpIHtcbiAgcmV0dXJuIG5ldyBFZmZlY3RTY29wZShkZXRhY2hlZCk7XG59XG5mdW5jdGlvbiByZWNvcmRFZmZlY3RTY29wZShlZmZlY3QsIHNjb3BlID0gYWN0aXZlRWZmZWN0U2NvcGUpIHtcbiAgaWYgKHNjb3BlICYmIHNjb3BlLmFjdGl2ZSkge1xuICAgIHNjb3BlLmVmZmVjdHMucHVzaChlZmZlY3QpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50U2NvcGUoKSB7XG4gIHJldHVybiBhY3RpdmVFZmZlY3RTY29wZTtcbn1cbmZ1bmN0aW9uIG9uU2NvcGVEaXNwb3NlKGZuKSB7XG4gIGlmIChhY3RpdmVFZmZlY3RTY29wZSkge1xuICAgIGFjdGl2ZUVmZmVjdFNjb3BlLmNsZWFudXBzLnB1c2goZm4pO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuKFxuICAgICAgYG9uU2NvcGVEaXNwb3NlKCkgaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGVmZmVjdCBzY29wZSB0byBiZSBhc3NvY2lhdGVkIHdpdGguYFxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgY3JlYXRlRGVwID0gKGVmZmVjdHMpID0+IHtcbiAgY29uc3QgZGVwID0gbmV3IFNldChlZmZlY3RzKTtcbiAgZGVwLncgPSAwO1xuICBkZXAubiA9IDA7XG4gIHJldHVybiBkZXA7XG59O1xuY29uc3Qgd2FzVHJhY2tlZCA9IChkZXApID0+IChkZXAudyAmIHRyYWNrT3BCaXQpID4gMDtcbmNvbnN0IG5ld1RyYWNrZWQgPSAoZGVwKSA9PiAoZGVwLm4gJiB0cmFja09wQml0KSA+IDA7XG5jb25zdCBpbml0RGVwTWFya2VycyA9ICh7IGRlcHMgfSkgPT4ge1xuICBpZiAoZGVwcy5sZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlcHNbaV0udyB8PSB0cmFja09wQml0O1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IGZpbmFsaXplRGVwTWFya2VycyA9IChlZmZlY3QpID0+IHtcbiAgY29uc3QgeyBkZXBzIH0gPSBlZmZlY3Q7XG4gIGlmIChkZXBzLmxlbmd0aCkge1xuICAgIGxldCBwdHIgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZGVwID0gZGVwc1tpXTtcbiAgICAgIGlmICh3YXNUcmFja2VkKGRlcCkgJiYgIW5ld1RyYWNrZWQoZGVwKSkge1xuICAgICAgICBkZXAuZGVsZXRlKGVmZmVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXBzW3B0cisrXSA9IGRlcDtcbiAgICAgIH1cbiAgICAgIGRlcC53ICY9IH50cmFja09wQml0O1xuICAgICAgZGVwLm4gJj0gfnRyYWNrT3BCaXQ7XG4gICAgfVxuICAgIGRlcHMubGVuZ3RoID0gcHRyO1xuICB9XG59O1xuXG5jb25zdCB0YXJnZXRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmxldCBlZmZlY3RUcmFja0RlcHRoID0gMDtcbmxldCB0cmFja09wQml0ID0gMTtcbmNvbnN0IG1heE1hcmtlckJpdHMgPSAzMDtcbmxldCBhY3RpdmVFZmZlY3Q7XG5jb25zdCBJVEVSQVRFX0tFWSA9IFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gXCJpdGVyYXRlXCIgOiBcIlwiKTtcbmNvbnN0IE1BUF9LRVlfSVRFUkFURV9LRVkgPSBTeW1ib2woISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IFwiTWFwIGtleSBpdGVyYXRlXCIgOiBcIlwiKTtcbmNsYXNzIFJlYWN0aXZlRWZmZWN0IHtcbiAgY29uc3RydWN0b3IoZm4sIHNjaGVkdWxlciA9IG51bGwsIHNjb3BlKSB7XG4gICAgdGhpcy5mbiA9IGZuO1xuICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmRlcHMgPSBbXTtcbiAgICB0aGlzLnBhcmVudCA9IHZvaWQgMDtcbiAgICByZWNvcmRFZmZlY3RTY29wZSh0aGlzLCBzY29wZSk7XG4gIH1cbiAgcnVuKCkge1xuICAgIGlmICghdGhpcy5hY3RpdmUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZuKCk7XG4gICAgfVxuICAgIGxldCBwYXJlbnQgPSBhY3RpdmVFZmZlY3Q7XG4gICAgbGV0IGxhc3RTaG91bGRUcmFjayA9IHNob3VsZFRyYWNrO1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucGFyZW50ID0gYWN0aXZlRWZmZWN0O1xuICAgICAgYWN0aXZlRWZmZWN0ID0gdGhpcztcbiAgICAgIHNob3VsZFRyYWNrID0gdHJ1ZTtcbiAgICAgIHRyYWNrT3BCaXQgPSAxIDw8ICsrZWZmZWN0VHJhY2tEZXB0aDtcbiAgICAgIGlmIChlZmZlY3RUcmFja0RlcHRoIDw9IG1heE1hcmtlckJpdHMpIHtcbiAgICAgICAgaW5pdERlcE1hcmtlcnModGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGVhbnVwRWZmZWN0KHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZm4oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGVmZmVjdFRyYWNrRGVwdGggPD0gbWF4TWFya2VyQml0cykge1xuICAgICAgICBmaW5hbGl6ZURlcE1hcmtlcnModGhpcyk7XG4gICAgICB9XG4gICAgICB0cmFja09wQml0ID0gMSA8PCAtLWVmZmVjdFRyYWNrRGVwdGg7XG4gICAgICBhY3RpdmVFZmZlY3QgPSB0aGlzLnBhcmVudDtcbiAgICAgIHNob3VsZFRyYWNrID0gbGFzdFNob3VsZFRyYWNrO1xuICAgICAgdGhpcy5wYXJlbnQgPSB2b2lkIDA7XG4gICAgICBpZiAodGhpcy5kZWZlclN0b3ApIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0b3AoKSB7XG4gICAgaWYgKGFjdGl2ZUVmZmVjdCA9PT0gdGhpcykge1xuICAgICAgdGhpcy5kZWZlclN0b3AgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgIGNsZWFudXBFZmZlY3QodGhpcyk7XG4gICAgICBpZiAodGhpcy5vblN0b3ApIHtcbiAgICAgICAgdGhpcy5vblN0b3AoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjbGVhbnVwRWZmZWN0KGVmZmVjdDIpIHtcbiAgY29uc3QgeyBkZXBzIH0gPSBlZmZlY3QyO1xuICBpZiAoZGVwcy5sZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlcHNbaV0uZGVsZXRlKGVmZmVjdDIpO1xuICAgIH1cbiAgICBkZXBzLmxlbmd0aCA9IDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGVmZmVjdChmbiwgb3B0aW9ucykge1xuICBpZiAoZm4uZWZmZWN0IGluc3RhbmNlb2YgUmVhY3RpdmVFZmZlY3QpIHtcbiAgICBmbiA9IGZuLmVmZmVjdC5mbjtcbiAgfVxuICBjb25zdCBfZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGZuKTtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBleHRlbmQoX2VmZmVjdCwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuc2NvcGUpXG4gICAgICByZWNvcmRFZmZlY3RTY29wZShfZWZmZWN0LCBvcHRpb25zLnNjb3BlKTtcbiAgfVxuICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMubGF6eSkge1xuICAgIF9lZmZlY3QucnVuKCk7XG4gIH1cbiAgY29uc3QgcnVubmVyID0gX2VmZmVjdC5ydW4uYmluZChfZWZmZWN0KTtcbiAgcnVubmVyLmVmZmVjdCA9IF9lZmZlY3Q7XG4gIHJldHVybiBydW5uZXI7XG59XG5mdW5jdGlvbiBzdG9wKHJ1bm5lcikge1xuICBydW5uZXIuZWZmZWN0LnN0b3AoKTtcbn1cbmxldCBzaG91bGRUcmFjayA9IHRydWU7XG5jb25zdCB0cmFja1N0YWNrID0gW107XG5mdW5jdGlvbiBwYXVzZVRyYWNraW5nKCkge1xuICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xuICBzaG91bGRUcmFjayA9IGZhbHNlO1xufVxuZnVuY3Rpb24gZW5hYmxlVHJhY2tpbmcoKSB7XG4gIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XG4gIHNob3VsZFRyYWNrID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlc2V0VHJhY2tpbmcoKSB7XG4gIGNvbnN0IGxhc3QgPSB0cmFja1N0YWNrLnBvcCgpO1xuICBzaG91bGRUcmFjayA9IGxhc3QgPT09IHZvaWQgMCA/IHRydWUgOiBsYXN0O1xufVxuZnVuY3Rpb24gdHJhY2sodGFyZ2V0LCB0eXBlLCBrZXkpIHtcbiAgaWYgKHNob3VsZFRyYWNrICYmIGFjdGl2ZUVmZmVjdCkge1xuICAgIGxldCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xuICAgIGlmICghZGVwc01hcCkge1xuICAgICAgdGFyZ2V0TWFwLnNldCh0YXJnZXQsIGRlcHNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgbGV0IGRlcCA9IGRlcHNNYXAuZ2V0KGtleSk7XG4gICAgaWYgKCFkZXApIHtcbiAgICAgIGRlcHNNYXAuc2V0KGtleSwgZGVwID0gY3JlYXRlRGVwKCkpO1xuICAgIH1cbiAgICBjb25zdCBldmVudEluZm8gPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8geyBlZmZlY3Q6IGFjdGl2ZUVmZmVjdCwgdGFyZ2V0LCB0eXBlLCBrZXkgfSA6IHZvaWQgMDtcbiAgICB0cmFja0VmZmVjdHMoZGVwLCBldmVudEluZm8pO1xuICB9XG59XG5mdW5jdGlvbiB0cmFja0VmZmVjdHMoZGVwLCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSB7XG4gIGxldCBzaG91bGRUcmFjazIgPSBmYWxzZTtcbiAgaWYgKGVmZmVjdFRyYWNrRGVwdGggPD0gbWF4TWFya2VyQml0cykge1xuICAgIGlmICghbmV3VHJhY2tlZChkZXApKSB7XG4gICAgICBkZXAubiB8PSB0cmFja09wQml0O1xuICAgICAgc2hvdWxkVHJhY2syID0gIXdhc1RyYWNrZWQoZGVwKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2hvdWxkVHJhY2syID0gIWRlcC5oYXMoYWN0aXZlRWZmZWN0KTtcbiAgfVxuICBpZiAoc2hvdWxkVHJhY2syKSB7XG4gICAgZGVwLmFkZChhY3RpdmVFZmZlY3QpO1xuICAgIGFjdGl2ZUVmZmVjdC5kZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBhY3RpdmVFZmZlY3Qub25UcmFjaykge1xuICAgICAgYWN0aXZlRWZmZWN0Lm9uVHJhY2soXG4gICAgICAgIGV4dGVuZChcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlZmZlY3Q6IGFjdGl2ZUVmZmVjdFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVidWdnZXJFdmVudEV4dHJhSW5mb1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdHJpZ2dlcih0YXJnZXQsIHR5cGUsIGtleSwgbmV3VmFsdWUsIG9sZFZhbHVlLCBvbGRUYXJnZXQpIHtcbiAgY29uc3QgZGVwc01hcCA9IHRhcmdldE1hcC5nZXQodGFyZ2V0KTtcbiAgaWYgKCFkZXBzTWFwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBkZXBzID0gW107XG4gIGlmICh0eXBlID09PSBcImNsZWFyXCIpIHtcbiAgICBkZXBzID0gWy4uLmRlcHNNYXAudmFsdWVzKCldO1xuICB9IGVsc2UgaWYgKGtleSA9PT0gXCJsZW5ndGhcIiAmJiBpc0FycmF5KHRhcmdldCkpIHtcbiAgICBjb25zdCBuZXdMZW5ndGggPSBOdW1iZXIobmV3VmFsdWUpO1xuICAgIGRlcHNNYXAuZm9yRWFjaCgoZGVwLCBrZXkyKSA9PiB7XG4gICAgICBpZiAoa2V5MiA9PT0gXCJsZW5ndGhcIiB8fCAhaXNTeW1ib2woa2V5MikgJiYga2V5MiA+PSBuZXdMZW5ndGgpIHtcbiAgICAgICAgZGVwcy5wdXNoKGRlcCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGtleSAhPT0gdm9pZCAwKSB7XG4gICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoa2V5KSk7XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XG4gICAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc0ludGVnZXJLZXkoa2V5KSkge1xuICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChcImxlbmd0aFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGVsZXRlXCI6XG4gICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChNQVBfS0VZX0lURVJBVEVfS0VZKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNldFwiOlxuICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb25zdCBldmVudEluZm8gPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8geyB0YXJnZXQsIHR5cGUsIGtleSwgbmV3VmFsdWUsIG9sZFZhbHVlLCBvbGRUYXJnZXQgfSA6IHZvaWQgMDtcbiAgaWYgKGRlcHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGRlcHNbMF0pIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIHRyaWdnZXJFZmZlY3RzKGRlcHNbMF0sIGV2ZW50SW5mbyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmlnZ2VyRWZmZWN0cyhkZXBzWzBdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgZGVwIG9mIGRlcHMpIHtcbiAgICAgIGlmIChkZXApIHtcbiAgICAgICAgZWZmZWN0cy5wdXNoKC4uLmRlcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB0cmlnZ2VyRWZmZWN0cyhjcmVhdGVEZXAoZWZmZWN0cyksIGV2ZW50SW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXJFZmZlY3RzKGNyZWF0ZURlcChlZmZlY3RzKSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyRWZmZWN0cyhkZXAsIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pIHtcbiAgY29uc3QgZWZmZWN0cyA9IGlzQXJyYXkoZGVwKSA/IGRlcCA6IFsuLi5kZXBdO1xuICBmb3IgKGNvbnN0IGVmZmVjdDIgb2YgZWZmZWN0cykge1xuICAgIGlmIChlZmZlY3QyLmNvbXB1dGVkKSB7XG4gICAgICB0cmlnZ2VyRWZmZWN0KGVmZmVjdDIsIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGVmZmVjdDIgb2YgZWZmZWN0cykge1xuICAgIGlmICghZWZmZWN0Mi5jb21wdXRlZCkge1xuICAgICAgdHJpZ2dlckVmZmVjdChlZmZlY3QyLCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJFZmZlY3QoZWZmZWN0MiwgZGVidWdnZXJFdmVudEV4dHJhSW5mbykge1xuICBpZiAoZWZmZWN0MiAhPT0gYWN0aXZlRWZmZWN0IHx8IGVmZmVjdDIuYWxsb3dSZWN1cnNlKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgZWZmZWN0Mi5vblRyaWdnZXIpIHtcbiAgICAgIGVmZmVjdDIub25UcmlnZ2VyKGV4dGVuZCh7IGVmZmVjdDogZWZmZWN0MiB9LCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSk7XG4gICAgfVxuICAgIGlmIChlZmZlY3QyLnNjaGVkdWxlcikge1xuICAgICAgZWZmZWN0Mi5zY2hlZHVsZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWZmZWN0Mi5ydW4oKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldERlcEZyb21SZWFjdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgX2E7XG4gIHJldHVybiAoX2EgPSB0YXJnZXRNYXAuZ2V0KG9iamVjdCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5nZXQoa2V5KTtcbn1cblxuY29uc3QgaXNOb25UcmFja2FibGVLZXlzID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoYF9fcHJvdG9fXyxfX3ZfaXNSZWYsX19pc1Z1ZWApO1xuY29uc3QgYnVpbHRJblN5bWJvbHMgPSBuZXcgU2V0KFxuICAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoU3ltYm9sKS5maWx0ZXIoKGtleSkgPT4ga2V5ICE9PSBcImFyZ3VtZW50c1wiICYmIGtleSAhPT0gXCJjYWxsZXJcIikubWFwKChrZXkpID0+IFN5bWJvbFtrZXldKS5maWx0ZXIoaXNTeW1ib2wpXG4pO1xuY29uc3QgYXJyYXlJbnN0cnVtZW50YXRpb25zID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUFycmF5SW5zdHJ1bWVudGF0aW9ucygpO1xuZnVuY3Rpb24gY3JlYXRlQXJyYXlJbnN0cnVtZW50YXRpb25zKCkge1xuICBjb25zdCBpbnN0cnVtZW50YXRpb25zID0ge307XG4gIFtcImluY2x1ZGVzXCIsIFwiaW5kZXhPZlwiLCBcImxhc3RJbmRleE9mXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGluc3RydW1lbnRhdGlvbnNba2V5XSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IGFyciA9IHRvUmF3KHRoaXMpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0cmFjayhhcnIsIFwiZ2V0XCIsIGkgKyBcIlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlcyA9IGFycltrZXldKC4uLmFyZ3MpO1xuICAgICAgaWYgKHJlcyA9PT0gLTEgfHwgcmVzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gYXJyW2tleV0oLi4uYXJncy5tYXAodG9SYXcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIFtcInB1c2hcIiwgXCJwb3BcIiwgXCJzaGlmdFwiLCBcInVuc2hpZnRcIiwgXCJzcGxpY2VcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaW5zdHJ1bWVudGF0aW9uc1trZXldID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgY29uc3QgcmVzID0gdG9SYXcodGhpcylba2V5XS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiBpbnN0cnVtZW50YXRpb25zO1xufVxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkoa2V5KSB7XG4gIGNvbnN0IG9iaiA9IHRvUmF3KHRoaXMpO1xuICB0cmFjayhvYmosIFwiaGFzXCIsIGtleSk7XG4gIHJldHVybiBvYmouaGFzT3duUHJvcGVydHkoa2V5KTtcbn1cbmNsYXNzIEJhc2VSZWFjdGl2ZUhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihfaXNSZWFkb25seSA9IGZhbHNlLCBfc2hhbGxvdyA9IGZhbHNlKSB7XG4gICAgdGhpcy5faXNSZWFkb25seSA9IF9pc1JlYWRvbmx5O1xuICAgIHRoaXMuX3NoYWxsb3cgPSBfc2hhbGxvdztcbiAgfVxuICBnZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSB7XG4gICAgY29uc3QgaXNSZWFkb25seTIgPSB0aGlzLl9pc1JlYWRvbmx5LCBzaGFsbG93ID0gdGhpcy5fc2hhbGxvdztcbiAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIpIHtcbiAgICAgIHJldHVybiAhaXNSZWFkb25seTI7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIikge1xuICAgICAgcmV0dXJuIGlzUmVhZG9ubHkyO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1NoYWxsb3dcIikge1xuICAgICAgcmV0dXJuIHNoYWxsb3c7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiICYmIHJlY2VpdmVyID09PSAoaXNSZWFkb25seTIgPyBzaGFsbG93ID8gc2hhbGxvd1JlYWRvbmx5TWFwIDogcmVhZG9ubHlNYXAgOiBzaGFsbG93ID8gc2hhbGxvd1JlYWN0aXZlTWFwIDogcmVhY3RpdmVNYXApLmdldCh0YXJnZXQpKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gaXNBcnJheSh0YXJnZXQpO1xuICAgIGlmICghaXNSZWFkb25seTIpIHtcbiAgICAgIGlmICh0YXJnZXRJc0FycmF5ICYmIGhhc093bihhcnJheUluc3RydW1lbnRhdGlvbnMsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KGFycmF5SW5zdHJ1bWVudGF0aW9ucywga2V5LCByZWNlaXZlcik7XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSBcImhhc093blByb3BlcnR5XCIpIHtcbiAgICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXMgPSBSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpO1xuICAgIGlmIChpc1N5bWJvbChrZXkpID8gYnVpbHRJblN5bWJvbHMuaGFzKGtleSkgOiBpc05vblRyYWNrYWJsZUtleXMoa2V5KSkge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKCFpc1JlYWRvbmx5Mikge1xuICAgICAgdHJhY2sodGFyZ2V0LCBcImdldFwiLCBrZXkpO1xuICAgIH1cbiAgICBpZiAoc2hhbGxvdykge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKGlzUmVmKHJlcykpIHtcbiAgICAgIHJldHVybiB0YXJnZXRJc0FycmF5ICYmIGlzSW50ZWdlcktleShrZXkpID8gcmVzIDogcmVzLnZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgcmV0dXJuIGlzUmVhZG9ubHkyID8gcmVhZG9ubHkocmVzKSA6IHJlYWN0aXZlKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbn1cbmNsYXNzIE11dGFibGVSZWFjdGl2ZUhhbmRsZXIgZXh0ZW5kcyBCYXNlUmVhY3RpdmVIYW5kbGVyIHtcbiAgY29uc3RydWN0b3Ioc2hhbGxvdyA9IGZhbHNlKSB7XG4gICAgc3VwZXIoZmFsc2UsIHNoYWxsb3cpO1xuICB9XG4gIHNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgbGV0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgaWYgKGlzUmVhZG9ubHkob2xkVmFsdWUpICYmIGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghdGhpcy5fc2hhbGxvdykge1xuICAgICAgaWYgKCFpc1NoYWxsb3codmFsdWUpICYmICFpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgICAgICBvbGRWYWx1ZSA9IHRvUmF3KG9sZFZhbHVlKTtcbiAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSAmJiBpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaGFkS2V5ID0gaXNBcnJheSh0YXJnZXQpICYmIGlzSW50ZWdlcktleShrZXkpID8gTnVtYmVyKGtleSkgPCB0YXJnZXQubGVuZ3RoIDogaGFzT3duKHRhcmdldCwga2V5KTtcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICBpZiAodGFyZ2V0ID09PSB0b1JhdyhyZWNlaXZlcikpIHtcbiAgICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCBrZXksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcbiAgICBjb25zdCBoYWRLZXkgPSBoYXNPd24odGFyZ2V0LCBrZXkpO1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSk7XG4gICAgaWYgKHJlc3VsdCAmJiBoYWRLZXkpIHtcbiAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiLCBrZXksIHZvaWQgMCwgb2xkVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGhhcyh0YXJnZXQsIGtleSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuaGFzKHRhcmdldCwga2V5KTtcbiAgICBpZiAoIWlzU3ltYm9sKGtleSkgfHwgIWJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpKSB7XG4gICAgICB0cmFjayh0YXJnZXQsIFwiaGFzXCIsIGtleSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgb3duS2V5cyh0YXJnZXQpIHtcbiAgICB0cmFjayhcbiAgICAgIHRhcmdldCxcbiAgICAgIFwiaXRlcmF0ZVwiLFxuICAgICAgaXNBcnJheSh0YXJnZXQpID8gXCJsZW5ndGhcIiA6IElURVJBVEVfS0VZXG4gICAgKTtcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XG4gIH1cbn1cbmNsYXNzIFJlYWRvbmx5UmVhY3RpdmVIYW5kbGVyIGV4dGVuZHMgQmFzZVJlYWN0aXZlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKHNoYWxsb3cgPSBmYWxzZSkge1xuICAgIHN1cGVyKHRydWUsIHNoYWxsb3cpO1xuICB9XG4gIHNldCh0YXJnZXQsIGtleSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgU2V0IG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsXG4gICAgICAgIHRhcmdldFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihcbiAgICAgICAgYERlbGV0ZSBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLFxuICAgICAgICB0YXJnZXRcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5jb25zdCBtdXRhYmxlSGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE11dGFibGVSZWFjdGl2ZUhhbmRsZXIoKTtcbmNvbnN0IHJlYWRvbmx5SGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlYWRvbmx5UmVhY3RpdmVIYW5kbGVyKCk7XG5jb25zdCBzaGFsbG93UmVhY3RpdmVIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTXV0YWJsZVJlYWN0aXZlSGFuZGxlcihcbiAgdHJ1ZVxuKTtcbmNvbnN0IHNoYWxsb3dSZWFkb25seUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBSZWFkb25seVJlYWN0aXZlSGFuZGxlcih0cnVlKTtcblxuY29uc3QgdG9TaGFsbG93ID0gKHZhbHVlKSA9PiB2YWx1ZTtcbmNvbnN0IGdldFByb3RvID0gKHYpID0+IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yodik7XG5mdW5jdGlvbiBnZXQodGFyZ2V0LCBrZXksIGlzUmVhZG9ubHkgPSBmYWxzZSwgaXNTaGFsbG93ID0gZmFsc2UpIHtcbiAgdGFyZ2V0ID0gdGFyZ2V0W1wiX192X3Jhd1wiXTtcbiAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcbiAgaWYgKCFpc1JlYWRvbmx5KSB7XG4gICAgaWYgKGhhc0NoYW5nZWQoa2V5LCByYXdLZXkpKSB7XG4gICAgICB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIsIGtleSk7XG4gICAgfVxuICAgIHRyYWNrKHJhd1RhcmdldCwgXCJnZXRcIiwgcmF3S2V5KTtcbiAgfVxuICBjb25zdCB7IGhhczogaGFzMiB9ID0gZ2V0UHJvdG8ocmF3VGFyZ2V0KTtcbiAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgaWYgKGhhczIuY2FsbChyYXdUYXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KGtleSkpO1xuICB9IGVsc2UgaWYgKGhhczIuY2FsbChyYXdUYXJnZXQsIHJhd0tleSkpIHtcbiAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KHJhd0tleSkpO1xuICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gcmF3VGFyZ2V0KSB7XG4gICAgdGFyZ2V0LmdldChrZXkpO1xuICB9XG59XG5mdW5jdGlvbiBoYXMoa2V5LCBpc1JlYWRvbmx5ID0gZmFsc2UpIHtcbiAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIl07XG4gIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XG4gIGlmICghaXNSZWFkb25seSkge1xuICAgIGlmIChoYXNDaGFuZ2VkKGtleSwgcmF3S2V5KSkge1xuICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiLCBrZXkpO1xuICAgIH1cbiAgICB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIsIHJhd0tleSk7XG4gIH1cbiAgcmV0dXJuIGtleSA9PT0gcmF3S2V5ID8gdGFyZ2V0LmhhcyhrZXkpIDogdGFyZ2V0LmhhcyhrZXkpIHx8IHRhcmdldC5oYXMocmF3S2V5KTtcbn1cbmZ1bmN0aW9uIHNpemUodGFyZ2V0LCBpc1JlYWRvbmx5ID0gZmFsc2UpIHtcbiAgdGFyZ2V0ID0gdGFyZ2V0W1wiX192X3Jhd1wiXTtcbiAgIWlzUmVhZG9ubHkgJiYgdHJhY2sodG9SYXcodGFyZ2V0KSwgXCJpdGVyYXRlXCIsIElURVJBVEVfS0VZKTtcbiAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgXCJzaXplXCIsIHRhcmdldCk7XG59XG5mdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICBjb25zdCBwcm90byA9IGdldFByb3RvKHRhcmdldCk7XG4gIGNvbnN0IGhhZEtleSA9IHByb3RvLmhhcy5jYWxsKHRhcmdldCwgdmFsdWUpO1xuICBpZiAoIWhhZEtleSkge1xuICAgIHRhcmdldC5hZGQodmFsdWUpO1xuICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCB2YWx1ZSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICBjb25zdCB7IGhhczogaGFzMiwgZ2V0OiBnZXQyIH0gPSBnZXRQcm90byh0YXJnZXQpO1xuICBsZXQgaGFkS2V5ID0gaGFzMi5jYWxsKHRhcmdldCwga2V5KTtcbiAgaWYgKCFoYWRLZXkpIHtcbiAgICBrZXkgPSB0b1JhdyhrZXkpO1xuICAgIGhhZEtleSA9IGhhczIuY2FsbCh0YXJnZXQsIGtleSk7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzMiwga2V5KTtcbiAgfVxuICBjb25zdCBvbGRWYWx1ZSA9IGdldDIuY2FsbCh0YXJnZXQsIGtleSk7XG4gIHRhcmdldC5zZXQoa2V5LCB2YWx1ZSk7XG4gIGlmICghaGFkS2V5KSB7XG4gICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIsIGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBkZWxldGVFbnRyeShrZXkpIHtcbiAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gIGNvbnN0IHsgaGFzOiBoYXMyLCBnZXQ6IGdldDIgfSA9IGdldFByb3RvKHRhcmdldCk7XG4gIGxldCBoYWRLZXkgPSBoYXMyLmNhbGwodGFyZ2V0LCBrZXkpO1xuICBpZiAoIWhhZEtleSkge1xuICAgIGtleSA9IHRvUmF3KGtleSk7XG4gICAgaGFkS2V5ID0gaGFzMi5jYWxsKHRhcmdldCwga2V5KTtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMyLCBrZXkpO1xuICB9XG4gIGNvbnN0IG9sZFZhbHVlID0gZ2V0MiA/IGdldDIuY2FsbCh0YXJnZXQsIGtleSkgOiB2b2lkIDA7XG4gIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5kZWxldGUoa2V5KTtcbiAgaWYgKGhhZEtleSkge1xuICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiLCBrZXksIHZvaWQgMCwgb2xkVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjbGVhcigpIHtcbiAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gIGNvbnN0IGhhZEl0ZW1zID0gdGFyZ2V0LnNpemUgIT09IDA7XG4gIGNvbnN0IG9sZFRhcmdldCA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBpc01hcCh0YXJnZXQpID8gbmV3IE1hcCh0YXJnZXQpIDogbmV3IFNldCh0YXJnZXQpIDogdm9pZCAwO1xuICBjb25zdCByZXN1bHQgPSB0YXJnZXQuY2xlYXIoKTtcbiAgaWYgKGhhZEl0ZW1zKSB7XG4gICAgdHJpZ2dlcih0YXJnZXQsIFwiY2xlYXJcIiwgdm9pZCAwLCB2b2lkIDAsIG9sZFRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZvckVhY2goaXNSZWFkb25seSwgaXNTaGFsbG93KSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgY29uc3Qgb2JzZXJ2ZWQgPSB0aGlzO1xuICAgIGNvbnN0IHRhcmdldCA9IG9ic2VydmVkW1wiX192X3Jhd1wiXTtcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcIml0ZXJhdGVcIiwgSVRFUkFURV9LRVkpO1xuICAgIHJldHVybiB0YXJnZXQuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgd3JhcCh2YWx1ZSksIHdyYXAoa2V5KSwgb2JzZXJ2ZWQpO1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBpc1JlYWRvbmx5LCBpc1NoYWxsb3cpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiXTtcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgIGNvbnN0IHRhcmdldElzTWFwID0gaXNNYXAocmF3VGFyZ2V0KTtcbiAgICBjb25zdCBpc1BhaXIgPSBtZXRob2QgPT09IFwiZW50cmllc1wiIHx8IG1ldGhvZCA9PT0gU3ltYm9sLml0ZXJhdG9yICYmIHRhcmdldElzTWFwO1xuICAgIGNvbnN0IGlzS2V5T25seSA9IG1ldGhvZCA9PT0gXCJrZXlzXCIgJiYgdGFyZ2V0SXNNYXA7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRhcmdldFttZXRob2RdKC4uLmFyZ3MpO1xuICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gICAgIWlzUmVhZG9ubHkgJiYgdHJhY2soXG4gICAgICByYXdUYXJnZXQsXG4gICAgICBcIml0ZXJhdGVcIixcbiAgICAgIGlzS2V5T25seSA/IE1BUF9LRVlfSVRFUkFURV9LRVkgOiBJVEVSQVRFX0tFWVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIGl0ZXJhdG9yIHByb3RvY29sXG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIGRvbmUgPyB7IHZhbHVlLCBkb25lIH0gOiB7XG4gICAgICAgICAgdmFsdWU6IGlzUGFpciA/IFt3cmFwKHZhbHVlWzBdKSwgd3JhcCh2YWx1ZVsxXSldIDogd3JhcCh2YWx1ZSksXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIC8vIGl0ZXJhYmxlIHByb3RvY29sXG4gICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlYWRvbmx5TWV0aG9kKHR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgY29uc3Qga2V5ID0gYXJnc1swXSA/IGBvbiBrZXkgXCIke2FyZ3NbMF19XCIgYCA6IGBgO1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgJHtjYXBpdGFsaXplKHR5cGUpfSBvcGVyYXRpb24gJHtrZXl9ZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCxcbiAgICAgICAgdG9SYXcodGhpcylcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlID09PSBcImRlbGV0ZVwiID8gZmFsc2UgOiB0aGlzO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSW5zdHJ1bWVudGF0aW9ucygpIHtcbiAgY29uc3QgbXV0YWJsZUluc3RydW1lbnRhdGlvbnMyID0ge1xuICAgIGdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywga2V5KTtcbiAgICB9LFxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIHNpemUodGhpcyk7XG4gICAgfSxcbiAgICBoYXMsXG4gICAgYWRkLFxuICAgIHNldCxcbiAgICBkZWxldGU6IGRlbGV0ZUVudHJ5LFxuICAgIGNsZWFyLFxuICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2goZmFsc2UsIGZhbHNlKVxuICB9O1xuICBjb25zdCBzaGFsbG93SW5zdHJ1bWVudGF0aW9uczIgPSB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIGZhbHNlLCB0cnVlKTtcbiAgICB9LFxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIHNpemUodGhpcyk7XG4gICAgfSxcbiAgICBoYXMsXG4gICAgYWRkLFxuICAgIHNldCxcbiAgICBkZWxldGU6IGRlbGV0ZUVudHJ5LFxuICAgIGNsZWFyLFxuICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2goZmFsc2UsIHRydWUpXG4gIH07XG4gIGNvbnN0IHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9uczIgPSB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIHRydWUpO1xuICAgIH0sXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gc2l6ZSh0aGlzLCB0cnVlKTtcbiAgICB9LFxuICAgIGhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBoYXMuY2FsbCh0aGlzLCBrZXksIHRydWUpO1xuICAgIH0sXG4gICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiKSxcbiAgICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwic2V0XCIpLFxuICAgIGRlbGV0ZTogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJkZWxldGVcIiksXG4gICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIiksXG4gICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaCh0cnVlLCBmYWxzZSlcbiAgfTtcbiAgY29uc3Qgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uczIgPSB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIHRydWUsIHRydWUpO1xuICAgIH0sXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gc2l6ZSh0aGlzLCB0cnVlKTtcbiAgICB9LFxuICAgIGhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBoYXMuY2FsbCh0aGlzLCBrZXksIHRydWUpO1xuICAgIH0sXG4gICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiKSxcbiAgICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwic2V0XCIpLFxuICAgIGRlbGV0ZTogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJkZWxldGVcIiksXG4gICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIiksXG4gICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaCh0cnVlLCB0cnVlKVxuICB9O1xuICBjb25zdCBpdGVyYXRvck1ldGhvZHMgPSBbXCJrZXlzXCIsIFwidmFsdWVzXCIsIFwiZW50cmllc1wiLCBTeW1ib2wuaXRlcmF0b3JdO1xuICBpdGVyYXRvck1ldGhvZHMuZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gICAgbXV0YWJsZUluc3RydW1lbnRhdGlvbnMyW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChcbiAgICAgIG1ldGhvZCxcbiAgICAgIGZhbHNlLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9uczJbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKFxuICAgICAgbWV0aG9kLFxuICAgICAgdHJ1ZSxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICBzaGFsbG93SW5zdHJ1bWVudGF0aW9uczJbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKFxuICAgICAgbWV0aG9kLFxuICAgICAgZmFsc2UsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zMlttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QoXG4gICAgICBtZXRob2QsXG4gICAgICB0cnVlLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH0pO1xuICByZXR1cm4gW1xuICAgIG11dGFibGVJbnN0cnVtZW50YXRpb25zMixcbiAgICByZWFkb25seUluc3RydW1lbnRhdGlvbnMyLFxuICAgIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zMixcbiAgICBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zMlxuICBdO1xufVxuY29uc3QgW1xuICBtdXRhYmxlSW5zdHJ1bWVudGF0aW9ucyxcbiAgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zLFxuICBzaGFsbG93SW5zdHJ1bWVudGF0aW9ucyxcbiAgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1xuXSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25zKCk7XG5mdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoaXNSZWFkb25seSwgc2hhbGxvdykge1xuICBjb25zdCBpbnN0cnVtZW50YXRpb25zID0gc2hhbGxvdyA/IGlzUmVhZG9ubHkgPyBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zIDogc2hhbGxvd0luc3RydW1lbnRhdGlvbnMgOiBpc1JlYWRvbmx5ID8gcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zIDogbXV0YWJsZUluc3RydW1lbnRhdGlvbnM7XG4gIHJldHVybiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiB7XG4gICAgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFjdGl2ZVwiKSB7XG4gICAgICByZXR1cm4gIWlzUmVhZG9ubHk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIikge1xuICAgICAgcmV0dXJuIGlzUmVhZG9ubHk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICByZXR1cm4gUmVmbGVjdC5nZXQoXG4gICAgICBoYXNPd24oaW5zdHJ1bWVudGF0aW9ucywga2V5KSAmJiBrZXkgaW4gdGFyZ2V0ID8gaW5zdHJ1bWVudGF0aW9ucyA6IHRhcmdldCxcbiAgICAgIGtleSxcbiAgICAgIHJlY2VpdmVyXG4gICAgKTtcbiAgfTtcbn1cbmNvbnN0IG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gIGdldDogLyogQF9fUFVSRV9fICovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgZmFsc2UpXG59O1xuY29uc3Qgc2hhbGxvd0NvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCB0cnVlKVxufTtcbmNvbnN0IHJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgZmFsc2UpXG59O1xuY29uc3Qgc2hhbGxvd1JlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgdHJ1ZSlcbn07XG5mdW5jdGlvbiBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhczIsIGtleSkge1xuICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICBpZiAocmF3S2V5ICE9PSBrZXkgJiYgaGFzMi5jYWxsKHRhcmdldCwgcmF3S2V5KSkge1xuICAgIGNvbnN0IHR5cGUgPSB0b1Jhd1R5cGUodGFyZ2V0KTtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgUmVhY3RpdmUgJHt0eXBlfSBjb250YWlucyBib3RoIHRoZSByYXcgYW5kIHJlYWN0aXZlIHZlcnNpb25zIG9mIHRoZSBzYW1lIG9iamVjdCR7dHlwZSA9PT0gYE1hcGAgPyBgIGFzIGtleXNgIDogYGB9LCB3aGljaCBjYW4gbGVhZCB0byBpbmNvbnNpc3RlbmNpZXMuIEF2b2lkIGRpZmZlcmVudGlhdGluZyBiZXR3ZWVuIHRoZSByYXcgYW5kIHJlYWN0aXZlIHZlcnNpb25zIG9mIGFuIG9iamVjdCBhbmQgb25seSB1c2UgdGhlIHJlYWN0aXZlIHZlcnNpb24gaWYgcG9zc2libGUuYFxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgcmVhY3RpdmVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHNoYWxsb3dSZWFjdGl2ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmVhZG9ubHlNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHNoYWxsb3dSZWFkb25seU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gdGFyZ2V0VHlwZU1hcChyYXdUeXBlKSB7XG4gIHN3aXRjaCAocmF3VHlwZSkge1xuICAgIGNhc2UgXCJPYmplY3RcIjpcbiAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgIHJldHVybiAxIC8qIENPTU1PTiAqLztcbiAgICBjYXNlIFwiTWFwXCI6XG4gICAgY2FzZSBcIlNldFwiOlxuICAgIGNhc2UgXCJXZWFrTWFwXCI6XG4gICAgY2FzZSBcIldlYWtTZXRcIjpcbiAgICAgIHJldHVybiAyIC8qIENPTExFQ1RJT04gKi87XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAwIC8qIElOVkFMSUQgKi87XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRhcmdldFR5cGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlW1wiX192X3NraXBcIl0gfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpID8gMCAvKiBJTlZBTElEICovIDogdGFyZ2V0VHlwZU1hcCh0b1Jhd1R5cGUodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIHJlYWN0aXZlKHRhcmdldCkge1xuICBpZiAoaXNSZWFkb25seSh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QoXG4gICAgdGFyZ2V0LFxuICAgIGZhbHNlLFxuICAgIG11dGFibGVIYW5kbGVycyxcbiAgICBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzLFxuICAgIHJlYWN0aXZlTWFwXG4gICk7XG59XG5mdW5jdGlvbiBzaGFsbG93UmVhY3RpdmUodGFyZ2V0KSB7XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcbiAgICB0YXJnZXQsXG4gICAgZmFsc2UsXG4gICAgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMsXG4gICAgc2hhbGxvd0NvbGxlY3Rpb25IYW5kbGVycyxcbiAgICBzaGFsbG93UmVhY3RpdmVNYXBcbiAgKTtcbn1cbmZ1bmN0aW9uIHJlYWRvbmx5KHRhcmdldCkge1xuICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QoXG4gICAgdGFyZ2V0LFxuICAgIHRydWUsXG4gICAgcmVhZG9ubHlIYW5kbGVycyxcbiAgICByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyxcbiAgICByZWFkb25seU1hcFxuICApO1xufVxuZnVuY3Rpb24gc2hhbGxvd1JlYWRvbmx5KHRhcmdldCkge1xuICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QoXG4gICAgdGFyZ2V0LFxuICAgIHRydWUsXG4gICAgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMsXG4gICAgc2hhbGxvd1JlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzLFxuICAgIHNoYWxsb3dSZWFkb25seU1hcFxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBpc1JlYWRvbmx5MiwgYmFzZUhhbmRsZXJzLCBjb2xsZWN0aW9uSGFuZGxlcnMsIHByb3h5TWFwKSB7XG4gIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYHZhbHVlIGNhbm5vdCBiZSBtYWRlIHJlYWN0aXZlOiAke1N0cmluZyh0YXJnZXQpfWApO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGlmICh0YXJnZXRbXCJfX3ZfcmF3XCJdICYmICEoaXNSZWFkb25seTIgJiYgdGFyZ2V0W1wiX192X2lzUmVhY3RpdmVcIl0pKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBjb25zdCBleGlzdGluZ1Byb3h5ID0gcHJveHlNYXAuZ2V0KHRhcmdldCk7XG4gIGlmIChleGlzdGluZ1Byb3h5KSB7XG4gICAgcmV0dXJuIGV4aXN0aW5nUHJveHk7XG4gIH1cbiAgY29uc3QgdGFyZ2V0VHlwZSA9IGdldFRhcmdldFR5cGUodGFyZ2V0KTtcbiAgaWYgKHRhcmdldFR5cGUgPT09IDAgLyogSU5WQUxJRCAqLykge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoXG4gICAgdGFyZ2V0LFxuICAgIHRhcmdldFR5cGUgPT09IDIgLyogQ09MTEVDVElPTiAqLyA/IGNvbGxlY3Rpb25IYW5kbGVycyA6IGJhc2VIYW5kbGVyc1xuICApO1xuICBwcm94eU1hcC5zZXQodGFyZ2V0LCBwcm94eSk7XG4gIHJldHVybiBwcm94eTtcbn1cbmZ1bmN0aW9uIGlzUmVhY3RpdmUodmFsdWUpIHtcbiAgaWYgKGlzUmVhZG9ubHkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWVbXCJfX3ZfcmF3XCJdKTtcbiAgfVxuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFjdGl2ZVwiXSk7XG59XG5mdW5jdGlvbiBpc1JlYWRvbmx5KHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1JlYWRvbmx5XCJdKTtcbn1cbmZ1bmN0aW9uIGlzU2hhbGxvdyh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNTaGFsbG93XCJdKTtcbn1cbmZ1bmN0aW9uIGlzUHJveHkodmFsdWUpIHtcbiAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWUpIHx8IGlzUmVhZG9ubHkodmFsdWUpO1xufVxuZnVuY3Rpb24gdG9SYXcob2JzZXJ2ZWQpIHtcbiAgY29uc3QgcmF3ID0gb2JzZXJ2ZWQgJiYgb2JzZXJ2ZWRbXCJfX3ZfcmF3XCJdO1xuICByZXR1cm4gcmF3ID8gdG9SYXcocmF3KSA6IG9ic2VydmVkO1xufVxuZnVuY3Rpb24gbWFya1Jhdyh2YWx1ZSkge1xuICBkZWYodmFsdWUsIFwiX192X3NraXBcIiwgdHJ1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IHRvUmVhY3RpdmUgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWN0aXZlKHZhbHVlKSA6IHZhbHVlO1xuY29uc3QgdG9SZWFkb25seSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhZG9ubHkodmFsdWUpIDogdmFsdWU7XG5cbmZ1bmN0aW9uIHRyYWNrUmVmVmFsdWUocmVmMikge1xuICBpZiAoc2hvdWxkVHJhY2sgJiYgYWN0aXZlRWZmZWN0KSB7XG4gICAgcmVmMiA9IHRvUmF3KHJlZjIpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB0cmFja0VmZmVjdHMocmVmMi5kZXAgfHwgKHJlZjIuZGVwID0gY3JlYXRlRGVwKCkpLCB7XG4gICAgICAgIHRhcmdldDogcmVmMixcbiAgICAgICAgdHlwZTogXCJnZXRcIixcbiAgICAgICAga2V5OiBcInZhbHVlXCJcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFja0VmZmVjdHMocmVmMi5kZXAgfHwgKHJlZjIuZGVwID0gY3JlYXRlRGVwKCkpKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJSZWZWYWx1ZShyZWYyLCBuZXdWYWwpIHtcbiAgcmVmMiA9IHRvUmF3KHJlZjIpO1xuICBjb25zdCBkZXAgPSByZWYyLmRlcDtcbiAgaWYgKGRlcCkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB0cmlnZ2VyRWZmZWN0cyhkZXAsIHtcbiAgICAgICAgdGFyZ2V0OiByZWYyLFxuICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICBrZXk6IFwidmFsdWVcIixcbiAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXJFZmZlY3RzKGRlcCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc1JlZihyKSB7XG4gIHJldHVybiAhIShyICYmIHIuX192X2lzUmVmID09PSB0cnVlKTtcbn1cbmZ1bmN0aW9uIHJlZih2YWx1ZSkge1xuICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCBmYWxzZSk7XG59XG5mdW5jdGlvbiBzaGFsbG93UmVmKHZhbHVlKSB7XG4gIHJldHVybiBjcmVhdGVSZWYodmFsdWUsIHRydWUpO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVmKHJhd1ZhbHVlLCBzaGFsbG93KSB7XG4gIGlmIChpc1JlZihyYXdWYWx1ZSkpIHtcbiAgICByZXR1cm4gcmF3VmFsdWU7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWZJbXBsKHJhd1ZhbHVlLCBzaGFsbG93KTtcbn1cbmNsYXNzIFJlZkltcGwge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgX192X2lzU2hhbGxvdykge1xuICAgIHRoaXMuX192X2lzU2hhbGxvdyA9IF9fdl9pc1NoYWxsb3c7XG4gICAgdGhpcy5kZXAgPSB2b2lkIDA7XG4gICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgIHRoaXMuX3Jhd1ZhbHVlID0gX192X2lzU2hhbGxvdyA/IHZhbHVlIDogdG9SYXcodmFsdWUpO1xuICAgIHRoaXMuX3ZhbHVlID0gX192X2lzU2hhbGxvdyA/IHZhbHVlIDogdG9SZWFjdGl2ZSh2YWx1ZSk7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHRyYWNrUmVmVmFsdWUodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIHNldCB2YWx1ZShuZXdWYWwpIHtcbiAgICBjb25zdCB1c2VEaXJlY3RWYWx1ZSA9IHRoaXMuX192X2lzU2hhbGxvdyB8fCBpc1NoYWxsb3cobmV3VmFsKSB8fCBpc1JlYWRvbmx5KG5ld1ZhbCk7XG4gICAgbmV3VmFsID0gdXNlRGlyZWN0VmFsdWUgPyBuZXdWYWwgOiB0b1JhdyhuZXdWYWwpO1xuICAgIGlmIChoYXNDaGFuZ2VkKG5ld1ZhbCwgdGhpcy5fcmF3VmFsdWUpKSB7XG4gICAgICB0aGlzLl9yYXdWYWx1ZSA9IG5ld1ZhbDtcbiAgICAgIHRoaXMuX3ZhbHVlID0gdXNlRGlyZWN0VmFsdWUgPyBuZXdWYWwgOiB0b1JlYWN0aXZlKG5ld1ZhbCk7XG4gICAgICB0cmlnZ2VyUmVmVmFsdWUodGhpcywgbmV3VmFsKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJSZWYocmVmMikge1xuICB0cmlnZ2VyUmVmVmFsdWUocmVmMiwgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHJlZjIudmFsdWUgOiB2b2lkIDApO1xufVxuZnVuY3Rpb24gdW5yZWYocmVmMikge1xuICByZXR1cm4gaXNSZWYocmVmMikgPyByZWYyLnZhbHVlIDogcmVmMjtcbn1cbmZ1bmN0aW9uIHRvVmFsdWUoc291cmNlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKHNvdXJjZSkgPyBzb3VyY2UoKSA6IHVucmVmKHNvdXJjZSk7XG59XG5jb25zdCBzaGFsbG93VW53cmFwSGFuZGxlcnMgPSB7XG4gIGdldDogKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4gdW5yZWYoUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSksXG4gIHNldDogKHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpID0+IHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgIGlmIChpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gcHJveHlSZWZzKG9iamVjdFdpdGhSZWZzKSB7XG4gIHJldHVybiBpc1JlYWN0aXZlKG9iamVjdFdpdGhSZWZzKSA/IG9iamVjdFdpdGhSZWZzIDogbmV3IFByb3h5KG9iamVjdFdpdGhSZWZzLCBzaGFsbG93VW53cmFwSGFuZGxlcnMpO1xufVxuY2xhc3MgQ3VzdG9tUmVmSW1wbCB7XG4gIGNvbnN0cnVjdG9yKGZhY3RvcnkpIHtcbiAgICB0aGlzLmRlcCA9IHZvaWQgMDtcbiAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XG4gICAgY29uc3QgeyBnZXQsIHNldCB9ID0gZmFjdG9yeShcbiAgICAgICgpID0+IHRyYWNrUmVmVmFsdWUodGhpcyksXG4gICAgICAoKSA9PiB0cmlnZ2VyUmVmVmFsdWUodGhpcylcbiAgICApO1xuICAgIHRoaXMuX2dldCA9IGdldDtcbiAgICB0aGlzLl9zZXQgPSBzZXQ7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoKTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgdGhpcy5fc2V0KG5ld1ZhbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGN1c3RvbVJlZihmYWN0b3J5KSB7XG4gIHJldHVybiBuZXcgQ3VzdG9tUmVmSW1wbChmYWN0b3J5KTtcbn1cbmZ1bmN0aW9uIHRvUmVmcyhvYmplY3QpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzUHJveHkob2JqZWN0KSkge1xuICAgIGNvbnNvbGUud2FybihgdG9SZWZzKCkgZXhwZWN0cyBhIHJlYWN0aXZlIG9iamVjdCBidXQgcmVjZWl2ZWQgYSBwbGFpbiBvbmUuYCk7XG4gIH1cbiAgY29uc3QgcmV0ID0gaXNBcnJheShvYmplY3QpID8gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpIDoge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgIHJldFtrZXldID0gcHJvcGVydHlUb1JlZihvYmplY3QsIGtleSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmNsYXNzIE9iamVjdFJlZkltcGwge1xuICBjb25zdHJ1Y3Rvcihfb2JqZWN0LCBfa2V5LCBfZGVmYXVsdFZhbHVlKSB7XG4gICAgdGhpcy5fb2JqZWN0ID0gX29iamVjdDtcbiAgICB0aGlzLl9rZXkgPSBfa2V5O1xuICAgIHRoaXMuX2RlZmF1bHRWYWx1ZSA9IF9kZWZhdWx0VmFsdWU7XG4gICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBjb25zdCB2YWwgPSB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XTtcbiAgICByZXR1cm4gdmFsID09PSB2b2lkIDAgPyB0aGlzLl9kZWZhdWx0VmFsdWUgOiB2YWw7XG4gIH1cbiAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgIHRoaXMuX29iamVjdFt0aGlzLl9rZXldID0gbmV3VmFsO1xuICB9XG4gIGdldCBkZXAoKSB7XG4gICAgcmV0dXJuIGdldERlcEZyb21SZWFjdGl2ZSh0b1Jhdyh0aGlzLl9vYmplY3QpLCB0aGlzLl9rZXkpO1xuICB9XG59XG5jbGFzcyBHZXR0ZXJSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoX2dldHRlcikge1xuICAgIHRoaXMuX2dldHRlciA9IF9nZXR0ZXI7XG4gICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgIHRoaXMuX192X2lzUmVhZG9ubHkgPSB0cnVlO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0dGVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvUmVmKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKGlzUmVmKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgIHJldHVybiBuZXcgR2V0dGVyUmVmSW1wbChzb3VyY2UpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHNvdXJjZSkgJiYgYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gcHJvcGVydHlUb1JlZihzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVmKHNvdXJjZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb3BlcnR5VG9SZWYoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICBjb25zdCB2YWwgPSBzb3VyY2Vba2V5XTtcbiAgcmV0dXJuIGlzUmVmKHZhbCkgPyB2YWwgOiBuZXcgT2JqZWN0UmVmSW1wbChzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKTtcbn1cblxuY2xhc3MgQ29tcHV0ZWRSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoZ2V0dGVyLCBfc2V0dGVyLCBpc1JlYWRvbmx5LCBpc1NTUikge1xuICAgIHRoaXMuX3NldHRlciA9IF9zZXR0ZXI7XG4gICAgdGhpcy5kZXAgPSB2b2lkIDA7XG4gICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgIHRoaXNbXCJfX3ZfaXNSZWFkb25seVwiXSA9IGZhbHNlO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLmVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChnZXR0ZXIsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fZGlydHkpIHtcbiAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgICAgICB0cmlnZ2VyUmVmVmFsdWUodGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lZmZlY3QuY29tcHV0ZWQgPSB0aGlzO1xuICAgIHRoaXMuZWZmZWN0LmFjdGl2ZSA9IHRoaXMuX2NhY2hlYWJsZSA9ICFpc1NTUjtcbiAgICB0aGlzW1wiX192X2lzUmVhZG9ubHlcIl0gPSBpc1JlYWRvbmx5O1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdG9SYXcodGhpcyk7XG4gICAgdHJhY2tSZWZWYWx1ZShzZWxmKTtcbiAgICBpZiAoc2VsZi5fZGlydHkgfHwgIXNlbGYuX2NhY2hlYWJsZSkge1xuICAgICAgc2VsZi5fZGlydHkgPSBmYWxzZTtcbiAgICAgIHNlbGYuX3ZhbHVlID0gc2VsZi5lZmZlY3QucnVuKCk7XG4gICAgfVxuICAgIHJldHVybiBzZWxmLl92YWx1ZTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcbiAgICB0aGlzLl9zZXR0ZXIobmV3VmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBjb21wdXRlZChnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucywgaXNTU1IgPSBmYWxzZSkge1xuICBsZXQgZ2V0dGVyO1xuICBsZXQgc2V0dGVyO1xuICBjb25zdCBvbmx5R2V0dGVyID0gaXNGdW5jdGlvbihnZXR0ZXJPck9wdGlvbnMpO1xuICBpZiAob25seUdldHRlcikge1xuICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucztcbiAgICBzZXR0ZXIgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gKCkgPT4ge1xuICAgICAgY29uc29sZS53YXJuKFwiV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgdmFsdWUgaXMgcmVhZG9ubHlcIik7XG4gICAgfSA6IE5PT1A7XG4gIH0gZWxzZSB7XG4gICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLmdldDtcbiAgICBzZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuc2V0O1xuICB9XG4gIGNvbnN0IGNSZWYgPSBuZXcgQ29tcHV0ZWRSZWZJbXBsKGdldHRlciwgc2V0dGVyLCBvbmx5R2V0dGVyIHx8ICFzZXR0ZXIsIGlzU1NSKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgZGVidWdPcHRpb25zICYmICFpc1NTUikge1xuICAgIGNSZWYuZWZmZWN0Lm9uVHJhY2sgPSBkZWJ1Z09wdGlvbnMub25UcmFjaztcbiAgICBjUmVmLmVmZmVjdC5vblRyaWdnZXIgPSBkZWJ1Z09wdGlvbnMub25UcmlnZ2VyO1xuICB9XG4gIHJldHVybiBjUmVmO1xufVxuXG5jb25zdCB0aWNrID0gLyogQF9fUFVSRV9fICovIFByb21pc2UucmVzb2x2ZSgpO1xuY29uc3QgcXVldWUgPSBbXTtcbmxldCBxdWV1ZWQgPSBmYWxzZTtcbmNvbnN0IHNjaGVkdWxlciA9IChmbikgPT4ge1xuICBxdWV1ZS5wdXNoKGZuKTtcbiAgaWYgKCFxdWV1ZWQpIHtcbiAgICBxdWV1ZWQgPSB0cnVlO1xuICAgIHRpY2sudGhlbihmbHVzaCk7XG4gIH1cbn07XG5jb25zdCBmbHVzaCA9ICgpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldKCk7XG4gIH1cbiAgcXVldWUubGVuZ3RoID0gMDtcbiAgcXVldWVkID0gZmFsc2U7XG59O1xuY2xhc3MgRGVmZXJyZWRDb21wdXRlZFJlZkltcGwge1xuICBjb25zdHJ1Y3RvcihnZXR0ZXIpIHtcbiAgICB0aGlzLmRlcCA9IHZvaWQgMDtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgIHRoaXNbXCJfX3ZfaXNSZWFkb25seVwiXSA9IHRydWU7XG4gICAgbGV0IGNvbXBhcmVUYXJnZXQ7XG4gICAgbGV0IGhhc0NvbXBhcmVUYXJnZXQgPSBmYWxzZTtcbiAgICBsZXQgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgdGhpcy5lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZ2V0dGVyLCAoY29tcHV0ZWRUcmlnZ2VyKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXApIHtcbiAgICAgICAgaWYgKGNvbXB1dGVkVHJpZ2dlcikge1xuICAgICAgICAgIGNvbXBhcmVUYXJnZXQgPSB0aGlzLl92YWx1ZTtcbiAgICAgICAgICBoYXNDb21wYXJlVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWVUb0NvbXBhcmUgPSBoYXNDb21wYXJlVGFyZ2V0ID8gY29tcGFyZVRhcmdldCA6IHRoaXMuX3ZhbHVlO1xuICAgICAgICAgIHNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgaGFzQ29tcGFyZVRhcmdldCA9IGZhbHNlO1xuICAgICAgICAgIHNjaGVkdWxlcigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5lZmZlY3QuYWN0aXZlICYmIHRoaXMuX2dldCgpICE9PSB2YWx1ZVRvQ29tcGFyZSkge1xuICAgICAgICAgICAgICB0cmlnZ2VyUmVmVmFsdWUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5kZXApIHtcbiAgICAgICAgICBpZiAoZS5jb21wdXRlZCBpbnN0YW5jZW9mIERlZmVycmVkQ29tcHV0ZWRSZWZJbXBsKSB7XG4gICAgICAgICAgICBlLnNjaGVkdWxlcihcbiAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAvKiBjb21wdXRlZFRyaWdnZXIgKi9cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgfSk7XG4gICAgdGhpcy5lZmZlY3QuY29tcHV0ZWQgPSB0aGlzO1xuICB9XG4gIF9nZXQoKSB7XG4gICAgaWYgKHRoaXMuX2RpcnR5KSB7XG4gICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlID0gdGhpcy5lZmZlY3QucnVuKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgdHJhY2tSZWZWYWx1ZSh0aGlzKTtcbiAgICByZXR1cm4gdG9SYXcodGhpcykuX2dldCgpO1xuICB9XG59XG5mdW5jdGlvbiBkZWZlcnJlZENvbXB1dGVkKGdldHRlcikge1xuICByZXR1cm4gbmV3IERlZmVycmVkQ29tcHV0ZWRSZWZJbXBsKGdldHRlcik7XG59XG5cbmV4cG9ydCB7IEVmZmVjdFNjb3BlLCBJVEVSQVRFX0tFWSwgUmVhY3RpdmVFZmZlY3QsIGNvbXB1dGVkLCBjdXN0b21SZWYsIGRlZmVycmVkQ29tcHV0ZWQsIGVmZmVjdCwgZWZmZWN0U2NvcGUsIGVuYWJsZVRyYWNraW5nLCBnZXRDdXJyZW50U2NvcGUsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBpc1NoYWxsb3csIG1hcmtSYXcsIG9uU2NvcGVEaXNwb3NlLCBwYXVzZVRyYWNraW5nLCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFkb25seSwgcmVmLCByZXNldFRyYWNraW5nLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgc3RvcCwgdG9SYXcsIHRvUmVmLCB0b1JlZnMsIHRvVmFsdWUsIHRyYWNrLCB0cmlnZ2VyLCB0cmlnZ2VyUmVmLCB1bnJlZiB9O1xuIiwiaW1wb3J0IHsgcGF1c2VUcmFja2luZywgcmVzZXRUcmFja2luZywgaXNSZWYsIHRvUmF3LCBnZXRDdXJyZW50U2NvcGUsIGlzU2hhbGxvdyBhcyBpc1NoYWxsb3ckMSwgaXNSZWFjdGl2ZSwgUmVhY3RpdmVFZmZlY3QsIHJlZiwgc2hhbGxvd1JlYWRvbmx5LCB0cmFjaywgcmVhY3RpdmUsIHNoYWxsb3dSZWFjdGl2ZSwgdHJpZ2dlciwgaXNQcm94eSwgcHJveHlSZWZzLCBtYXJrUmF3LCBFZmZlY3RTY29wZSwgY29tcHV0ZWQgYXMgY29tcHV0ZWQkMSwgaXNSZWFkb25seSB9IGZyb20gJ0B2dWUvcmVhY3Rpdml0eSc7XG5leHBvcnQgeyBFZmZlY3RTY29wZSwgUmVhY3RpdmVFZmZlY3QsIGN1c3RvbVJlZiwgZWZmZWN0LCBlZmZlY3RTY29wZSwgZ2V0Q3VycmVudFNjb3BlLCBpc1Byb3h5LCBpc1JlYWN0aXZlLCBpc1JlYWRvbmx5LCBpc1JlZiwgaXNTaGFsbG93LCBtYXJrUmF3LCBvblNjb3BlRGlzcG9zZSwgcHJveHlSZWZzLCByZWFjdGl2ZSwgcmVhZG9ubHksIHJlZiwgc2hhbGxvd1JlYWN0aXZlLCBzaGFsbG93UmVhZG9ubHksIHNoYWxsb3dSZWYsIHN0b3AsIHRvUmF3LCB0b1JlZiwgdG9SZWZzLCB0b1ZhbHVlLCB0cmlnZ2VyUmVmLCB1bnJlZiB9IGZyb20gJ0B2dWUvcmVhY3Rpdml0eSc7XG5pbXBvcnQgeyBpc1N0cmluZywgaXNGdW5jdGlvbiwgaXNQcm9taXNlLCBpc0FycmF5LCBOT09QLCBnZXRHbG9iYWxUaGlzLCBleHRlbmQsIEVNUFRZX09CSiwgdG9IYW5kbGVyS2V5LCBsb29zZVRvTnVtYmVyLCBoeXBoZW5hdGUsIGNhbWVsaXplLCBpc09iamVjdCwgaXNPbiwgaGFzT3duLCBpc01vZGVsTGlzdGVuZXIsIHRvTnVtYmVyLCBoYXNDaGFuZ2VkLCByZW1vdmUsIGlzU2V0LCBpc01hcCwgaXNQbGFpbk9iamVjdCwgaXNCdWlsdEluRGlyZWN0aXZlLCBpbnZva2VBcnJheUZucywgaXNSZWdFeHAsIGNhcGl0YWxpemUsIGlzR2xvYmFsbHlBbGxvd2VkLCBOTywgZGVmLCBpc1Jlc2VydmVkUHJvcCwgRU1QVFlfQVJSLCB0b1Jhd1R5cGUsIG1ha2VNYXAsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVTdHlsZSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcbmV4cG9ydCB7IGNhbWVsaXplLCBjYXBpdGFsaXplLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplUHJvcHMsIG5vcm1hbGl6ZVN0eWxlLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuY29uc3Qgc3RhY2sgPSBbXTtcbmZ1bmN0aW9uIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZSkge1xuICBzdGFjay5wdXNoKHZub2RlKTtcbn1cbmZ1bmN0aW9uIHBvcFdhcm5pbmdDb250ZXh0KCkge1xuICBzdGFjay5wb3AoKTtcbn1cbmZ1bmN0aW9uIHdhcm4obXNnLCAuLi5hcmdzKSB7XG4gIGlmICghISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSlcbiAgICByZXR1cm47XG4gIHBhdXNlVHJhY2tpbmcoKTtcbiAgY29uc3QgaW5zdGFuY2UgPSBzdGFjay5sZW5ndGggPyBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5jb21wb25lbnQgOiBudWxsO1xuICBjb25zdCBhcHBXYXJuSGFuZGxlciA9IGluc3RhbmNlICYmIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLndhcm5IYW5kbGVyO1xuICBjb25zdCB0cmFjZSA9IGdldENvbXBvbmVudFRyYWNlKCk7XG4gIGlmIChhcHBXYXJuSGFuZGxlcikge1xuICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhcbiAgICAgIGFwcFdhcm5IYW5kbGVyLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICAxMSxcbiAgICAgIFtcbiAgICAgICAgbXNnICsgYXJncy5qb2luKFwiXCIpLFxuICAgICAgICBpbnN0YW5jZSAmJiBpbnN0YW5jZS5wcm94eSxcbiAgICAgICAgdHJhY2UubWFwKFxuICAgICAgICAgICh7IHZub2RlIH0pID0+IGBhdCA8JHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCB2bm9kZS50eXBlKX0+YFxuICAgICAgICApLmpvaW4oXCJcXG5cIiksXG4gICAgICAgIHRyYWNlXG4gICAgICBdXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB3YXJuQXJncyA9IFtgW1Z1ZSB3YXJuXTogJHttc2d9YCwgLi4uYXJnc107XG4gICAgaWYgKHRyYWNlLmxlbmd0aCAmJiAvLyBhdm9pZCBzcGFtbWluZyBjb25zb2xlIGR1cmluZyB0ZXN0c1xuICAgIHRydWUpIHtcbiAgICAgIHdhcm5BcmdzLnB1c2goYFxuYCwgLi4uZm9ybWF0VHJhY2UodHJhY2UpKTtcbiAgICB9XG4gICAgY29uc29sZS53YXJuKC4uLndhcm5BcmdzKTtcbiAgfVxuICByZXNldFRyYWNraW5nKCk7XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRUcmFjZSgpIHtcbiAgbGV0IGN1cnJlbnRWTm9kZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICBpZiAoIWN1cnJlbnRWTm9kZSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBub3JtYWxpemVkU3RhY2sgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnRWTm9kZSkge1xuICAgIGNvbnN0IGxhc3QgPSBub3JtYWxpemVkU3RhY2tbMF07XG4gICAgaWYgKGxhc3QgJiYgbGFzdC52bm9kZSA9PT0gY3VycmVudFZOb2RlKSB7XG4gICAgICBsYXN0LnJlY3Vyc2VDb3VudCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3JtYWxpemVkU3RhY2sucHVzaCh7XG4gICAgICAgIHZub2RlOiBjdXJyZW50Vk5vZGUsXG4gICAgICAgIHJlY3Vyc2VDb3VudDogMFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudEluc3RhbmNlID0gY3VycmVudFZOb2RlLmNvbXBvbmVudCAmJiBjdXJyZW50Vk5vZGUuY29tcG9uZW50LnBhcmVudDtcbiAgICBjdXJyZW50Vk5vZGUgPSBwYXJlbnRJbnN0YW5jZSAmJiBwYXJlbnRJbnN0YW5jZS52bm9kZTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZFN0YWNrO1xufVxuZnVuY3Rpb24gZm9ybWF0VHJhY2UodHJhY2UpIHtcbiAgY29uc3QgbG9ncyA9IFtdO1xuICB0cmFjZS5mb3JFYWNoKChlbnRyeSwgaSkgPT4ge1xuICAgIGxvZ3MucHVzaCguLi5pID09PSAwID8gW10gOiBbYFxuYF0sIC4uLmZvcm1hdFRyYWNlRW50cnkoZW50cnkpKTtcbiAgfSk7XG4gIHJldHVybiBsb2dzO1xufVxuZnVuY3Rpb24gZm9ybWF0VHJhY2VFbnRyeSh7IHZub2RlLCByZWN1cnNlQ291bnQgfSkge1xuICBjb25zdCBwb3N0Zml4ID0gcmVjdXJzZUNvdW50ID4gMCA/IGAuLi4gKCR7cmVjdXJzZUNvdW50fSByZWN1cnNpdmUgY2FsbHMpYCA6IGBgO1xuICBjb25zdCBpc1Jvb3QgPSB2bm9kZS5jb21wb25lbnQgPyB2bm9kZS5jb21wb25lbnQucGFyZW50ID09IG51bGwgOiBmYWxzZTtcbiAgY29uc3Qgb3BlbiA9IGAgYXQgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShcbiAgICB2bm9kZS5jb21wb25lbnQsXG4gICAgdm5vZGUudHlwZSxcbiAgICBpc1Jvb3RcbiAgKX1gO1xuICBjb25zdCBjbG9zZSA9IGA+YCArIHBvc3RmaXg7XG4gIHJldHVybiB2bm9kZS5wcm9wcyA/IFtvcGVuLCAuLi5mb3JtYXRQcm9wcyh2bm9kZS5wcm9wcyksIGNsb3NlXSA6IFtvcGVuICsgY2xvc2VdO1xufVxuZnVuY3Rpb24gZm9ybWF0UHJvcHMocHJvcHMpIHtcbiAgY29uc3QgcmVzID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcyk7XG4gIGtleXMuc2xpY2UoMCwgMykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgcmVzLnB1c2goLi4uZm9ybWF0UHJvcChrZXksIHByb3BzW2tleV0pKTtcbiAgfSk7XG4gIGlmIChrZXlzLmxlbmd0aCA+IDMpIHtcbiAgICByZXMucHVzaChgIC4uLmApO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBmb3JtYXRQcm9wKGtleSwgdmFsdWUsIHJhdykge1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09JHt2YWx1ZX1gXTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIiB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09JHt2YWx1ZX1gXTtcbiAgfSBlbHNlIGlmIChpc1JlZih2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IGZvcm1hdFByb3Aoa2V5LCB0b1Jhdyh2YWx1ZS52YWx1ZSksIHRydWUpO1xuICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PVJlZjxgLCB2YWx1ZSwgYD5gXTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHJldHVybiBbYCR7a2V5fT1mbiR7dmFsdWUubmFtZSA/IGA8JHt2YWx1ZS5uYW1lfT5gIDogYGB9YF07XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09YCwgdmFsdWVdO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnROdW1iZXIodmFsLCB0eXBlKSB7XG4gIGlmICghISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSlcbiAgICByZXR1cm47XG4gIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsICE9PSBcIm51bWJlclwiKSB7XG4gICAgd2FybihgJHt0eXBlfSBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwpfS5gKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybihgJHt0eXBlfSBpcyBOYU4gLSB0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuYCk7XG4gIH1cbn1cblxuY29uc3QgRXJyb3JUeXBlU3RyaW5ncyA9IHtcbiAgW1wic3BcIl06IFwic2VydmVyUHJlZmV0Y2ggaG9va1wiLFxuICBbXCJiY1wiXTogXCJiZWZvcmVDcmVhdGUgaG9va1wiLFxuICBbXCJjXCJdOiBcImNyZWF0ZWQgaG9va1wiLFxuICBbXCJibVwiXTogXCJiZWZvcmVNb3VudCBob29rXCIsXG4gIFtcIm1cIl06IFwibW91bnRlZCBob29rXCIsXG4gIFtcImJ1XCJdOiBcImJlZm9yZVVwZGF0ZSBob29rXCIsXG4gIFtcInVcIl06IFwidXBkYXRlZFwiLFxuICBbXCJidW1cIl06IFwiYmVmb3JlVW5tb3VudCBob29rXCIsXG4gIFtcInVtXCJdOiBcInVubW91bnRlZCBob29rXCIsXG4gIFtcImFcIl06IFwiYWN0aXZhdGVkIGhvb2tcIixcbiAgW1wiZGFcIl06IFwiZGVhY3RpdmF0ZWQgaG9va1wiLFxuICBbXCJlY1wiXTogXCJlcnJvckNhcHR1cmVkIGhvb2tcIixcbiAgW1wicnRjXCJdOiBcInJlbmRlclRyYWNrZWQgaG9va1wiLFxuICBbXCJydGdcIl06IFwicmVuZGVyVHJpZ2dlcmVkIGhvb2tcIixcbiAgWzBdOiBcInNldHVwIGZ1bmN0aW9uXCIsXG4gIFsxXTogXCJyZW5kZXIgZnVuY3Rpb25cIixcbiAgWzJdOiBcIndhdGNoZXIgZ2V0dGVyXCIsXG4gIFszXTogXCJ3YXRjaGVyIGNhbGxiYWNrXCIsXG4gIFs0XTogXCJ3YXRjaGVyIGNsZWFudXAgZnVuY3Rpb25cIixcbiAgWzVdOiBcIm5hdGl2ZSBldmVudCBoYW5kbGVyXCIsXG4gIFs2XTogXCJjb21wb25lbnQgZXZlbnQgaGFuZGxlclwiLFxuICBbN106IFwidm5vZGUgaG9va1wiLFxuICBbOF06IFwiZGlyZWN0aXZlIGhvb2tcIixcbiAgWzldOiBcInRyYW5zaXRpb24gaG9va1wiLFxuICBbMTBdOiBcImFwcCBlcnJvckhhbmRsZXJcIixcbiAgWzExXTogXCJhcHAgd2FybkhhbmRsZXJcIixcbiAgWzEyXTogXCJyZWYgZnVuY3Rpb25cIixcbiAgWzEzXTogXCJhc3luYyBjb21wb25lbnQgbG9hZGVyXCIsXG4gIFsxNF06IFwic2NoZWR1bGVyIGZsdXNoLiBUaGlzIGlzIGxpa2VseSBhIFZ1ZSBpbnRlcm5hbHMgYnVnLiBQbGVhc2Ugb3BlbiBhbiBpc3N1ZSBhdCBodHRwczovL25ldy1pc3N1ZS52dWVqcy5vcmcvP3JlcG89dnVlanMvY29yZVwiXG59O1xuZnVuY3Rpb24gY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncykge1xuICBsZXQgcmVzO1xuICB0cnkge1xuICAgIHJlcyA9IGFyZ3MgPyBmbiguLi5hcmdzKSA6IGZuKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpIHtcbiAgaWYgKGlzRnVuY3Rpb24oZm4pKSB7XG4gICAgY29uc3QgcmVzID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncyk7XG4gICAgaWYgKHJlcyAmJiBpc1Byb21pc2UocmVzKSkge1xuICAgICAgcmVzLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbi5sZW5ndGg7IGkrKykge1xuICAgIHZhbHVlcy5wdXNoKGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGZuW2ldLCBpbnN0YW5jZSwgdHlwZSwgYXJncykpO1xuICB9XG4gIHJldHVybiB2YWx1ZXM7XG59XG5mdW5jdGlvbiBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlLCB0aHJvd0luRGV2ID0gdHJ1ZSkge1xuICBjb25zdCBjb250ZXh0Vk5vZGUgPSBpbnN0YW5jZSA/IGluc3RhbmNlLnZub2RlIDogbnVsbDtcbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgbGV0IGN1ciA9IGluc3RhbmNlLnBhcmVudDtcbiAgICBjb25zdCBleHBvc2VkSW5zdGFuY2UgPSBpbnN0YW5jZS5wcm94eTtcbiAgICBjb25zdCBlcnJvckluZm8gPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gRXJyb3JUeXBlU3RyaW5nc1t0eXBlXSA6IHR5cGU7XG4gICAgd2hpbGUgKGN1cikge1xuICAgICAgY29uc3QgZXJyb3JDYXB0dXJlZEhvb2tzID0gY3VyLmVjO1xuICAgICAgaWYgKGVycm9yQ2FwdHVyZWRIb29rcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVycm9yQ2FwdHVyZWRIb29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChlcnJvckNhcHR1cmVkSG9va3NbaV0oZXJyLCBleHBvc2VkSW5zdGFuY2UsIGVycm9ySW5mbykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdXIgPSBjdXIucGFyZW50O1xuICAgIH1cbiAgICBjb25zdCBhcHBFcnJvckhhbmRsZXIgPSBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5lcnJvckhhbmRsZXI7XG4gICAgaWYgKGFwcEVycm9ySGFuZGxlcikge1xuICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKFxuICAgICAgICBhcHBFcnJvckhhbmRsZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIDEwLFxuICAgICAgICBbZXJyLCBleHBvc2VkSW5zdGFuY2UsIGVycm9ySW5mb11cbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2KTtcbn1cbmZ1bmN0aW9uIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2ID0gdHJ1ZSkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IGluZm8gPSBFcnJvclR5cGVTdHJpbmdzW3R5cGVdO1xuICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcbiAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChjb250ZXh0Vk5vZGUpO1xuICAgIH1cbiAgICB3YXJuKGBVbmhhbmRsZWQgZXJyb3Ike2luZm8gPyBgIGR1cmluZyBleGVjdXRpb24gb2YgJHtpbmZvfWAgOiBgYH1gKTtcbiAgICBpZiAoY29udGV4dFZOb2RlKSB7XG4gICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgIH1cbiAgICBpZiAodGhyb3dJbkRldikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5sZXQgaXNGbHVzaGluZyA9IGZhbHNlO1xubGV0IGlzRmx1c2hQZW5kaW5nID0gZmFsc2U7XG5jb25zdCBxdWV1ZSA9IFtdO1xubGV0IGZsdXNoSW5kZXggPSAwO1xuY29uc3QgcGVuZGluZ1Bvc3RGbHVzaENicyA9IFtdO1xubGV0IGFjdGl2ZVBvc3RGbHVzaENicyA9IG51bGw7XG5sZXQgcG9zdEZsdXNoSW5kZXggPSAwO1xuY29uc3QgcmVzb2x2ZWRQcm9taXNlID0gLyogQF9fUFVSRV9fICovIFByb21pc2UucmVzb2x2ZSgpO1xubGV0IGN1cnJlbnRGbHVzaFByb21pc2UgPSBudWxsO1xuY29uc3QgUkVDVVJTSU9OX0xJTUlUID0gMTAwO1xuZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgY29uc3QgcCA9IGN1cnJlbnRGbHVzaFByb21pc2UgfHwgcmVzb2x2ZWRQcm9taXNlO1xuICByZXR1cm4gZm4gPyBwLnRoZW4odGhpcyA/IGZuLmJpbmQodGhpcykgOiBmbikgOiBwO1xufVxuZnVuY3Rpb24gZmluZEluc2VydGlvbkluZGV4KGlkKSB7XG4gIGxldCBzdGFydCA9IGZsdXNoSW5kZXggKyAxO1xuICBsZXQgZW5kID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcbiAgICBjb25zdCBtaWRkbGUgPSBzdGFydCArIGVuZCA+Pj4gMTtcbiAgICBjb25zdCBtaWRkbGVKb2IgPSBxdWV1ZVttaWRkbGVdO1xuICAgIGNvbnN0IG1pZGRsZUpvYklkID0gZ2V0SWQobWlkZGxlSm9iKTtcbiAgICBpZiAobWlkZGxlSm9iSWQgPCBpZCB8fCBtaWRkbGVKb2JJZCA9PT0gaWQgJiYgbWlkZGxlSm9iLnByZSkge1xuICAgICAgc3RhcnQgPSBtaWRkbGUgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmQgPSBtaWRkbGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGFydDtcbn1cbmZ1bmN0aW9uIHF1ZXVlSm9iKGpvYikge1xuICBpZiAoIXF1ZXVlLmxlbmd0aCB8fCAhcXVldWUuaW5jbHVkZXMoXG4gICAgam9iLFxuICAgIGlzRmx1c2hpbmcgJiYgam9iLmFsbG93UmVjdXJzZSA/IGZsdXNoSW5kZXggKyAxIDogZmx1c2hJbmRleFxuICApKSB7XG4gICAgaWYgKGpvYi5pZCA9PSBudWxsKSB7XG4gICAgICBxdWV1ZS5wdXNoKGpvYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXVlLnNwbGljZShmaW5kSW5zZXJ0aW9uSW5kZXgoam9iLmlkKSwgMCwgam9iKTtcbiAgICB9XG4gICAgcXVldWVGbHVzaCgpO1xuICB9XG59XG5mdW5jdGlvbiBxdWV1ZUZsdXNoKCkge1xuICBpZiAoIWlzRmx1c2hpbmcgJiYgIWlzRmx1c2hQZW5kaW5nKSB7XG4gICAgaXNGbHVzaFBlbmRpbmcgPSB0cnVlO1xuICAgIGN1cnJlbnRGbHVzaFByb21pc2UgPSByZXNvbHZlZFByb21pc2UudGhlbihmbHVzaEpvYnMpO1xuICB9XG59XG5mdW5jdGlvbiBpbnZhbGlkYXRlSm9iKGpvYikge1xuICBjb25zdCBpID0gcXVldWUuaW5kZXhPZihqb2IpO1xuICBpZiAoaSA+IGZsdXNoSW5kZXgpIHtcbiAgICBxdWV1ZS5zcGxpY2UoaSwgMSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHF1ZXVlUG9zdEZsdXNoQ2IoY2IpIHtcbiAgaWYgKCFpc0FycmF5KGNiKSkge1xuICAgIGlmICghYWN0aXZlUG9zdEZsdXNoQ2JzIHx8ICFhY3RpdmVQb3N0Rmx1c2hDYnMuaW5jbHVkZXMoXG4gICAgICBjYixcbiAgICAgIGNiLmFsbG93UmVjdXJzZSA/IHBvc3RGbHVzaEluZGV4ICsgMSA6IHBvc3RGbHVzaEluZGV4XG4gICAgKSkge1xuICAgICAgcGVuZGluZ1Bvc3RGbHVzaENicy5wdXNoKGNiKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGVuZGluZ1Bvc3RGbHVzaENicy5wdXNoKC4uLmNiKTtcbiAgfVxuICBxdWV1ZUZsdXNoKCk7XG59XG5mdW5jdGlvbiBmbHVzaFByZUZsdXNoQ2JzKHNlZW4sIGkgPSBpc0ZsdXNoaW5nID8gZmx1c2hJbmRleCArIDEgOiAwKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgc2VlbiA9IHNlZW4gfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBmb3IgKDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2IgPSBxdWV1ZVtpXTtcbiAgICBpZiAoY2IgJiYgY2IucHJlKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgY2IpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKGksIDEpO1xuICAgICAgaS0tO1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoUG9zdEZsdXNoQ2JzKHNlZW4pIHtcbiAgaWYgKHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoKSB7XG4gICAgY29uc3QgZGVkdXBlZCA9IFsuLi5uZXcgU2V0KHBlbmRpbmdQb3N0Rmx1c2hDYnMpXTtcbiAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCA9IDA7XG4gICAgaWYgKGFjdGl2ZVBvc3RGbHVzaENicykge1xuICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzLnB1c2goLi4uZGVkdXBlZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFjdGl2ZVBvc3RGbHVzaENicyA9IGRlZHVwZWQ7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHNlZW4gPSBzZWVuIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGFjdGl2ZVBvc3RGbHVzaENicy5zb3J0KChhLCBiKSA9PiBnZXRJZChhKSAtIGdldElkKGIpKTtcbiAgICBmb3IgKHBvc3RGbHVzaEluZGV4ID0gMDsgcG9zdEZsdXNoSW5kZXggPCBhY3RpdmVQb3N0Rmx1c2hDYnMubGVuZ3RoOyBwb3N0Rmx1c2hJbmRleCsrKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgYWN0aXZlUG9zdEZsdXNoQ2JzW3Bvc3RGbHVzaEluZGV4XSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBhY3RpdmVQb3N0Rmx1c2hDYnNbcG9zdEZsdXNoSW5kZXhdKCk7XG4gICAgfVxuICAgIGFjdGl2ZVBvc3RGbHVzaENicyA9IG51bGw7XG4gICAgcG9zdEZsdXNoSW5kZXggPSAwO1xuICB9XG59XG5jb25zdCBnZXRJZCA9IChqb2IpID0+IGpvYi5pZCA9PSBudWxsID8gSW5maW5pdHkgOiBqb2IuaWQ7XG5jb25zdCBjb21wYXJhdG9yID0gKGEsIGIpID0+IHtcbiAgY29uc3QgZGlmZiA9IGdldElkKGEpIC0gZ2V0SWQoYik7XG4gIGlmIChkaWZmID09PSAwKSB7XG4gICAgaWYgKGEucHJlICYmICFiLnByZSlcbiAgICAgIHJldHVybiAtMTtcbiAgICBpZiAoYi5wcmUgJiYgIWEucHJlKVxuICAgICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIGRpZmY7XG59O1xuZnVuY3Rpb24gZmx1c2hKb2JzKHNlZW4pIHtcbiAgaXNGbHVzaFBlbmRpbmcgPSBmYWxzZTtcbiAgaXNGbHVzaGluZyA9IHRydWU7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgc2VlbiA9IHNlZW4gfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBxdWV1ZS5zb3J0KGNvbXBhcmF0b3IpO1xuICBjb25zdCBjaGVjayA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyAoam9iKSA9PiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2Vlbiwgam9iKSA6IE5PT1A7XG4gIHRyeSB7XG4gICAgZm9yIChmbHVzaEluZGV4ID0gMDsgZmx1c2hJbmRleCA8IHF1ZXVlLmxlbmd0aDsgZmx1c2hJbmRleCsrKSB7XG4gICAgICBjb25zdCBqb2IgPSBxdWV1ZVtmbHVzaEluZGV4XTtcbiAgICAgIGlmIChqb2IgJiYgam9iLmFjdGl2ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hlY2soam9iKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhqb2IsIG51bGwsIDE0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgZmx1c2hJbmRleCA9IDA7XG4gICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICBmbHVzaFBvc3RGbHVzaENicyhzZWVuKTtcbiAgICBpc0ZsdXNoaW5nID0gZmFsc2U7XG4gICAgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCB8fCBwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCkge1xuICAgICAgZmx1c2hKb2JzKHNlZW4pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGZuKSB7XG4gIGlmICghc2Vlbi5oYXMoZm4pKSB7XG4gICAgc2Vlbi5zZXQoZm4sIDEpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvdW50ID0gc2Vlbi5nZXQoZm4pO1xuICAgIGlmIChjb3VudCA+IFJFQ1VSU0lPTl9MSU1JVCkge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBmbi5vd25lckluc3RhbmNlO1xuICAgICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGluc3RhbmNlICYmIGdldENvbXBvbmVudE5hbWUoaW5zdGFuY2UudHlwZSk7XG4gICAgICB3YXJuKFxuICAgICAgICBgTWF4aW11bSByZWN1cnNpdmUgdXBkYXRlcyBleGNlZWRlZCR7Y29tcG9uZW50TmFtZSA/IGAgaW4gY29tcG9uZW50IDwke2NvbXBvbmVudE5hbWV9PmAgOiBgYH0uIFRoaXMgbWVhbnMgeW91IGhhdmUgYSByZWFjdGl2ZSBlZmZlY3QgdGhhdCBpcyBtdXRhdGluZyBpdHMgb3duIGRlcGVuZGVuY2llcyBhbmQgdGh1cyByZWN1cnNpdmVseSB0cmlnZ2VyaW5nIGl0c2VsZi4gUG9zc2libGUgc291cmNlcyBpbmNsdWRlIGNvbXBvbmVudCB0ZW1wbGF0ZSwgcmVuZGVyIGZ1bmN0aW9uLCB1cGRhdGVkIGhvb2sgb3Igd2F0Y2hlciBzb3VyY2UgZnVuY3Rpb24uYFxuICAgICAgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWVuLnNldChmbiwgY291bnQgKyAxKTtcbiAgICB9XG4gIH1cbn1cblxubGV0IGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcbmNvbnN0IGhtckRpcnR5Q29tcG9uZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG5pZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfSE1SX1JVTlRJTUVfXyA9IHtcbiAgICBjcmVhdGVSZWNvcmQ6IHRyeVdyYXAoY3JlYXRlUmVjb3JkKSxcbiAgICByZXJlbmRlcjogdHJ5V3JhcChyZXJlbmRlciksXG4gICAgcmVsb2FkOiB0cnlXcmFwKHJlbG9hZClcbiAgfTtcbn1cbmNvbnN0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiByZWdpc3RlckhNUihpbnN0YW5jZSkge1xuICBjb25zdCBpZCA9IGluc3RhbmNlLnR5cGUuX19obXJJZDtcbiAgbGV0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xuICBpZiAoIXJlY29yZCkge1xuICAgIGNyZWF0ZVJlY29yZChpZCwgaW5zdGFuY2UudHlwZSk7XG4gICAgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gIH1cbiAgcmVjb3JkLmluc3RhbmNlcy5hZGQoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gdW5yZWdpc3RlckhNUihpbnN0YW5jZSkge1xuICBtYXAuZ2V0KGluc3RhbmNlLnR5cGUuX19obXJJZCkuaW5zdGFuY2VzLmRlbGV0ZShpbnN0YW5jZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWNvcmQoaWQsIGluaXRpYWxEZWYpIHtcbiAgaWYgKG1hcC5oYXMoaWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG1hcC5zZXQoaWQsIHtcbiAgICBpbml0aWFsRGVmOiBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbml0aWFsRGVmKSxcbiAgICBpbnN0YW5jZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbiAgfSk7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiBpc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkgPyBjb21wb25lbnQuX192Y2NPcHRzIDogY29tcG9uZW50O1xufVxuZnVuY3Rpb24gcmVyZW5kZXIoaWQsIG5ld1JlbmRlcikge1xuICBjb25zdCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgaWYgKCFyZWNvcmQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVjb3JkLmluaXRpYWxEZWYucmVuZGVyID0gbmV3UmVuZGVyO1xuICBbLi4ucmVjb3JkLmluc3RhbmNlc10uZm9yRWFjaCgoaW5zdGFuY2UpID0+IHtcbiAgICBpZiAobmV3UmVuZGVyKSB7XG4gICAgICBpbnN0YW5jZS5yZW5kZXIgPSBuZXdSZW5kZXI7XG4gICAgICBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbnN0YW5jZS50eXBlKS5yZW5kZXIgPSBuZXdSZW5kZXI7XG4gICAgfVxuICAgIGluc3RhbmNlLnJlbmRlckNhY2hlID0gW107XG4gICAgaXNIbXJVcGRhdGluZyA9IHRydWU7XG4gICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbG9hZChpZCwgbmV3Q29tcCkge1xuICBjb25zdCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgaWYgKCFyZWNvcmQpXG4gICAgcmV0dXJuO1xuICBuZXdDb21wID0gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQobmV3Q29tcCk7XG4gIHVwZGF0ZUNvbXBvbmVudERlZihyZWNvcmQuaW5pdGlhbERlZiwgbmV3Q29tcCk7XG4gIGNvbnN0IGluc3RhbmNlcyA9IFsuLi5yZWNvcmQuaW5zdGFuY2VzXTtcbiAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcbiAgICBjb25zdCBvbGRDb21wID0gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5zdGFuY2UudHlwZSk7XG4gICAgaWYgKCFobXJEaXJ0eUNvbXBvbmVudHMuaGFzKG9sZENvbXApKSB7XG4gICAgICBpZiAob2xkQ29tcCAhPT0gcmVjb3JkLmluaXRpYWxEZWYpIHtcbiAgICAgICAgdXBkYXRlQ29tcG9uZW50RGVmKG9sZENvbXAsIG5ld0NvbXApO1xuICAgICAgfVxuICAgICAgaG1yRGlydHlDb21wb25lbnRzLmFkZChvbGRDb21wKTtcbiAgICB9XG4gICAgaW5zdGFuY2UuYXBwQ29udGV4dC5wcm9wc0NhY2hlLmRlbGV0ZShpbnN0YW5jZS50eXBlKTtcbiAgICBpbnN0YW5jZS5hcHBDb250ZXh0LmVtaXRzQ2FjaGUuZGVsZXRlKGluc3RhbmNlLnR5cGUpO1xuICAgIGluc3RhbmNlLmFwcENvbnRleHQub3B0aW9uc0NhY2hlLmRlbGV0ZShpbnN0YW5jZS50eXBlKTtcbiAgICBpZiAoaW5zdGFuY2UuY2VSZWxvYWQpIHtcbiAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5hZGQob2xkQ29tcCk7XG4gICAgICBpbnN0YW5jZS5jZVJlbG9hZChuZXdDb21wLnN0eWxlcyk7XG4gICAgICBobXJEaXJ0eUNvbXBvbmVudHMuZGVsZXRlKG9sZENvbXApO1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UucGFyZW50KSB7XG4gICAgICBxdWV1ZUpvYihpbnN0YW5jZS5wYXJlbnQudXBkYXRlKTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLmFwcENvbnRleHQucmVsb2FkKSB7XG4gICAgICBpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiW0hNUl0gUm9vdCBvciBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlIG1vZGlmaWVkLiBGdWxsIHJlbG9hZCByZXF1aXJlZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcXVldWVQb3N0Rmx1c2hDYigoKSA9PiB7XG4gICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcbiAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5kZWxldGUoXG4gICAgICAgIG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluc3RhbmNlLnR5cGUpXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnREZWYob2xkQ29tcCwgbmV3Q29tcCkge1xuICBleHRlbmQob2xkQ29tcCwgbmV3Q29tcCk7XG4gIGZvciAoY29uc3Qga2V5IGluIG9sZENvbXApIHtcbiAgICBpZiAoa2V5ICE9PSBcIl9fZmlsZVwiICYmICEoa2V5IGluIG5ld0NvbXApKSB7XG4gICAgICBkZWxldGUgb2xkQ29tcFtrZXldO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdHJ5V3JhcChmbikge1xuICByZXR1cm4gKGlkLCBhcmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKGlkLCBhcmcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbSE1SXSBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgVnVlIGNvbXBvbmVudCBob3QtcmVsb2FkLiBGdWxsIHJlbG9hZCByZXF1aXJlZC5gXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxubGV0IGRldnRvb2xzO1xubGV0IGJ1ZmZlciA9IFtdO1xubGV0IGRldnRvb2xzTm90SW5zdGFsbGVkID0gZmFsc2U7XG5mdW5jdGlvbiBlbWl0JDEoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgaWYgKGRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdChldmVudCwgLi4uYXJncyk7XG4gIH0gZWxzZSBpZiAoIWRldnRvb2xzTm90SW5zdGFsbGVkKSB7XG4gICAgYnVmZmVyLnB1c2goeyBldmVudCwgYXJncyB9KTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0RGV2dG9vbHNIb29rKGhvb2ssIHRhcmdldCkge1xuICB2YXIgX2EsIF9iO1xuICBkZXZ0b29scyA9IGhvb2s7XG4gIGlmIChkZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVuYWJsZWQgPSB0cnVlO1xuICAgIGJ1ZmZlci5mb3JFYWNoKCh7IGV2ZW50LCBhcmdzIH0pID0+IGRldnRvb2xzLmVtaXQoZXZlbnQsIC4uLmFyZ3MpKTtcbiAgICBidWZmZXIgPSBbXTtcbiAgfSBlbHNlIGlmIChcbiAgICAvLyBoYW5kbGUgbGF0ZSBkZXZ0b29scyBpbmplY3Rpb24gLSBvbmx5IGRvIHRoaXMgaWYgd2UgYXJlIGluIGFuIGFjdHVhbFxuICAgIC8vIGJyb3dzZXIgZW52aXJvbm1lbnQgdG8gYXZvaWQgdGhlIHRpbWVyIGhhbmRsZSBzdGFsbGluZyB0ZXN0IHJ1bm5lciBleGl0XG4gICAgLy8gKCM0ODE1KVxuICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgLy8gc29tZSBlbnZzIG1vY2sgd2luZG93IGJ1dCBub3QgZnVsbHlcbiAgICB3aW5kb3cuSFRNTEVsZW1lbnQgJiYgLy8gYWxzbyBleGNsdWRlIGpzZG9tXG4gICAgISgoX2IgPSAoX2EgPSB3aW5kb3cubmF2aWdhdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EudXNlckFnZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2IuaW5jbHVkZXMoXCJqc2RvbVwiKSlcbiAgKSB7XG4gICAgY29uc3QgcmVwbGF5ID0gdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gPSB0YXJnZXQuX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXyB8fCBbXTtcbiAgICByZXBsYXkucHVzaCgobmV3SG9vaykgPT4ge1xuICAgICAgc2V0RGV2dG9vbHNIb29rKG5ld0hvb2ssIHRhcmdldCk7XG4gICAgfSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIWRldnRvb2xzKSB7XG4gICAgICAgIHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fID0gbnVsbDtcbiAgICAgICAgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSB0cnVlO1xuICAgICAgICBidWZmZXIgPSBbXTtcbiAgICAgIH1cbiAgICB9LCAzZTMpO1xuICB9IGVsc2Uge1xuICAgIGRldnRvb2xzTm90SW5zdGFsbGVkID0gdHJ1ZTtcbiAgICBidWZmZXIgPSBbXTtcbiAgfVxufVxuZnVuY3Rpb24gZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbikge1xuICBlbWl0JDEoXCJhcHA6aW5pdFwiIC8qIEFQUF9JTklUICovLCBhcHAsIHZlcnNpb24sIHtcbiAgICBGcmFnbWVudCxcbiAgICBUZXh0LFxuICAgIENvbW1lbnQsXG4gICAgU3RhdGljXG4gIH0pO1xufVxuZnVuY3Rpb24gZGV2dG9vbHNVbm1vdW50QXBwKGFwcCkge1xuICBlbWl0JDEoXCJhcHA6dW5tb3VudFwiIC8qIEFQUF9VTk1PVU5UICovLCBhcHApO1xufVxuY29uc3QgZGV2dG9vbHNDb21wb25lbnRBZGRlZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXG4gIFwiY29tcG9uZW50OmFkZGVkXCIgLyogQ09NUE9ORU5UX0FEREVEICovXG4pO1xuY29uc3QgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDp1cGRhdGVkXCIgLyogQ09NUE9ORU5UX1VQREFURUQgKi8pO1xuY29uc3QgX2RldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXG4gIFwiY29tcG9uZW50OnJlbW92ZWRcIiAvKiBDT01QT05FTlRfUkVNT1ZFRCAqL1xuKTtcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCA9IChjb21wb25lbnQpID0+IHtcbiAgaWYgKGRldnRvb2xzICYmIHR5cGVvZiBkZXZ0b29scy5jbGVhbnVwQnVmZmVyID09PSBcImZ1bmN0aW9uXCIgJiYgLy8gcmVtb3ZlIHRoZSBjb21wb25lbnQgaWYgaXQgd2Fzbid0IGJ1ZmZlcmVkXG4gICFkZXZ0b29scy5jbGVhbnVwQnVmZmVyKGNvbXBvbmVudCkpIHtcbiAgICBfZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkKGNvbXBvbmVudCk7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soaG9vaykge1xuICByZXR1cm4gKGNvbXBvbmVudCkgPT4ge1xuICAgIGVtaXQkMShcbiAgICAgIGhvb2ssXG4gICAgICBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsXG4gICAgICBjb21wb25lbnQudWlkLFxuICAgICAgY29tcG9uZW50LnBhcmVudCA/IGNvbXBvbmVudC5wYXJlbnQudWlkIDogdm9pZCAwLFxuICAgICAgY29tcG9uZW50XG4gICAgKTtcbiAgfTtcbn1cbmNvbnN0IGRldnRvb2xzUGVyZlN0YXJ0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKFxuICBcInBlcmY6c3RhcnRcIiAvKiBQRVJGT1JNQU5DRV9TVEFSVCAqL1xuKTtcbmNvbnN0IGRldnRvb2xzUGVyZkVuZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhcbiAgXCJwZXJmOmVuZFwiIC8qIFBFUkZPUk1BTkNFX0VORCAqL1xuKTtcbmZ1bmN0aW9uIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKGhvb2spIHtcbiAgcmV0dXJuIChjb21wb25lbnQsIHR5cGUsIHRpbWUpID0+IHtcbiAgICBlbWl0JDEoaG9vaywgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLCBjb21wb25lbnQudWlkLCBjb21wb25lbnQsIHR5cGUsIHRpbWUpO1xuICB9O1xufVxuZnVuY3Rpb24gZGV2dG9vbHNDb21wb25lbnRFbWl0KGNvbXBvbmVudCwgZXZlbnQsIHBhcmFtcykge1xuICBlbWl0JDEoXG4gICAgXCJjb21wb25lbnQ6ZW1pdFwiIC8qIENPTVBPTkVOVF9FTUlUICovLFxuICAgIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCxcbiAgICBjb21wb25lbnQsXG4gICAgZXZlbnQsXG4gICAgcGFyYW1zXG4gICk7XG59XG5cbmZ1bmN0aW9uIGVtaXQoaW5zdGFuY2UsIGV2ZW50LCAuLi5yYXdBcmdzKSB7XG4gIGlmIChpbnN0YW5jZS5pc1VubW91bnRlZClcbiAgICByZXR1cm47XG4gIGNvbnN0IHByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVtaXRzT3B0aW9ucyxcbiAgICAgIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc11cbiAgICB9ID0gaW5zdGFuY2U7XG4gICAgaWYgKGVtaXRzT3B0aW9ucykge1xuICAgICAgaWYgKCEoZXZlbnQgaW4gZW1pdHNPcHRpb25zKSAmJiB0cnVlKSB7XG4gICAgICAgIGlmICghcHJvcHNPcHRpb25zIHx8ICEodG9IYW5kbGVyS2V5KGV2ZW50KSBpbiBwcm9wc09wdGlvbnMpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBDb21wb25lbnQgZW1pdHRlZCBldmVudCBcIiR7ZXZlbnR9XCIgYnV0IGl0IGlzIG5laXRoZXIgZGVjbGFyZWQgaW4gdGhlIGVtaXRzIG9wdGlvbiBub3IgYXMgYW4gXCIke3RvSGFuZGxlcktleShldmVudCl9XCIgcHJvcC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gZW1pdHNPcHRpb25zW2V2ZW50XTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsaWRhdG9yKSkge1xuICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSB2YWxpZGF0b3IoLi4ucmF3QXJncyk7XG4gICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICBgSW52YWxpZCBldmVudCBhcmd1bWVudHM6IGV2ZW50IHZhbGlkYXRpb24gZmFpbGVkIGZvciBldmVudCBcIiR7ZXZlbnR9XCIuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IGFyZ3MgPSByYXdBcmdzO1xuICBjb25zdCBpc01vZGVsTGlzdGVuZXIgPSBldmVudC5zdGFydHNXaXRoKFwidXBkYXRlOlwiKTtcbiAgY29uc3QgbW9kZWxBcmcgPSBpc01vZGVsTGlzdGVuZXIgJiYgZXZlbnQuc2xpY2UoNyk7XG4gIGlmIChtb2RlbEFyZyAmJiBtb2RlbEFyZyBpbiBwcm9wcykge1xuICAgIGNvbnN0IG1vZGlmaWVyc0tleSA9IGAke21vZGVsQXJnID09PSBcIm1vZGVsVmFsdWVcIiA/IFwibW9kZWxcIiA6IG1vZGVsQXJnfU1vZGlmaWVyc2A7XG4gICAgY29uc3QgeyBudW1iZXIsIHRyaW0gfSA9IHByb3BzW21vZGlmaWVyc0tleV0gfHwgRU1QVFlfT0JKO1xuICAgIGlmICh0cmltKSB7XG4gICAgICBhcmdzID0gcmF3QXJncy5tYXAoKGEpID0+IGlzU3RyaW5nKGEpID8gYS50cmltKCkgOiBhKTtcbiAgICB9XG4gICAgaWYgKG51bWJlcikge1xuICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKGxvb3NlVG9OdW1iZXIpO1xuICAgIH1cbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBkZXZ0b29sc0NvbXBvbmVudEVtaXQoaW5zdGFuY2UsIGV2ZW50LCBhcmdzKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHByb3BzW3RvSGFuZGxlcktleShsb3dlckNhc2VFdmVudCldKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgRXZlbnQgXCIke2xvd2VyQ2FzZUV2ZW50fVwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50ICR7Zm9ybWF0Q29tcG9uZW50TmFtZShcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICBpbnN0YW5jZS50eXBlXG4gICAgICAgICl9IGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcIiR7ZXZlbnR9XCIuIE5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIHYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcIiR7aHlwaGVuYXRlKGV2ZW50KX1cIiBpbnN0ZWFkIG9mIFwiJHtldmVudH1cIi5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBsZXQgaGFuZGxlck5hbWU7XG4gIGxldCBoYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoZXZlbnQpXSB8fCAvLyBhbHNvIHRyeSBjYW1lbENhc2UgZXZlbnQgaGFuZGxlciAoIzIyNDkpXG4gIHByb3BzW2hhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGNhbWVsaXplKGV2ZW50KSldO1xuICBpZiAoIWhhbmRsZXIgJiYgaXNNb2RlbExpc3RlbmVyKSB7XG4gICAgaGFuZGxlciA9IHByb3BzW2hhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGh5cGhlbmF0ZShldmVudCkpXTtcbiAgfVxuICBpZiAoaGFuZGxlcikge1xuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgaGFuZGxlcixcbiAgICAgIGluc3RhbmNlLFxuICAgICAgNixcbiAgICAgIGFyZ3NcbiAgICApO1xuICB9XG4gIGNvbnN0IG9uY2VIYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgKyBgT25jZWBdO1xuICBpZiAob25jZUhhbmRsZXIpIHtcbiAgICBpZiAoIWluc3RhbmNlLmVtaXR0ZWQpIHtcbiAgICAgIGluc3RhbmNlLmVtaXR0ZWQgPSB7fTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLmVtaXR0ZWRbaGFuZGxlck5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGluc3RhbmNlLmVtaXR0ZWRbaGFuZGxlck5hbWVdID0gdHJ1ZTtcbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgIG9uY2VIYW5kbGVyLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICA2LFxuICAgICAgYXJnc1xuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcbiAgY29uc3QgY2FjaGUgPSBhcHBDb250ZXh0LmVtaXRzQ2FjaGU7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChjb21wKTtcbiAgaWYgKGNhY2hlZCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuICBjb25zdCByYXcgPSBjb21wLmVtaXRzO1xuICBsZXQgbm9ybWFsaXplZCA9IHt9O1xuICBsZXQgaGFzRXh0ZW5kcyA9IGZhbHNlO1xuICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xuICAgIGNvbnN0IGV4dGVuZEVtaXRzID0gKHJhdzIpID0+IHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGcm9tRXh0ZW5kID0gbm9ybWFsaXplRW1pdHNPcHRpb25zKHJhdzIsIGFwcENvbnRleHQsIHRydWUpO1xuICAgICAgaWYgKG5vcm1hbGl6ZWRGcm9tRXh0ZW5kKSB7XG4gICAgICAgIGhhc0V4dGVuZHMgPSB0cnVlO1xuICAgICAgICBleHRlbmQobm9ybWFsaXplZCwgbm9ybWFsaXplZEZyb21FeHRlbmQpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKCFhc01peGluICYmIGFwcENvbnRleHQubWl4aW5zLmxlbmd0aCkge1xuICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRFbWl0cyk7XG4gICAgfVxuICAgIGlmIChjb21wLmV4dGVuZHMpIHtcbiAgICAgIGV4dGVuZEVtaXRzKGNvbXAuZXh0ZW5kcyk7XG4gICAgfVxuICAgIGlmIChjb21wLm1peGlucykge1xuICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRFbWl0cyk7XG4gICAgfVxuICB9XG4gIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XG4gICAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgICBjYWNoZS5zZXQoY29tcCwgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChpc0FycmF5KHJhdykpIHtcbiAgICByYXcuZm9yRWFjaCgoa2V5KSA9PiBub3JtYWxpemVkW2tleV0gPSBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICBleHRlbmQobm9ybWFsaXplZCwgcmF3KTtcbiAgfVxuICBpZiAoaXNPYmplY3QoY29tcCkpIHtcbiAgICBjYWNoZS5zZXQoY29tcCwgbm9ybWFsaXplZCk7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5mdW5jdGlvbiBpc0VtaXRMaXN0ZW5lcihvcHRpb25zLCBrZXkpIHtcbiAgaWYgKCFvcHRpb25zIHx8ICFpc09uKGtleSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAga2V5ID0ga2V5LnNsaWNlKDIpLnJlcGxhY2UoL09uY2UkLywgXCJcIik7XG4gIHJldHVybiBoYXNPd24ob3B0aW9ucywga2V5WzBdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSkpIHx8IGhhc093bihvcHRpb25zLCBoeXBoZW5hdGUoa2V5KSkgfHwgaGFzT3duKG9wdGlvbnMsIGtleSk7XG59XG5cbmxldCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xubGV0IGN1cnJlbnRTY29wZUlkID0gbnVsbDtcbmZ1bmN0aW9uIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpbnN0YW5jZSkge1xuICBjb25zdCBwcmV2ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgY3VycmVudFNjb3BlSWQgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS50eXBlLl9fc2NvcGVJZCB8fCBudWxsO1xuICByZXR1cm4gcHJldjtcbn1cbmZ1bmN0aW9uIHB1c2hTY29wZUlkKGlkKSB7XG4gIGN1cnJlbnRTY29wZUlkID0gaWQ7XG59XG5mdW5jdGlvbiBwb3BTY29wZUlkKCkge1xuICBjdXJyZW50U2NvcGVJZCA9IG51bGw7XG59XG5jb25zdCB3aXRoU2NvcGVJZCA9IChfaWQpID0+IHdpdGhDdHg7XG5mdW5jdGlvbiB3aXRoQ3R4KGZuLCBjdHggPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIGlzTm9uU2NvcGVkU2xvdCkge1xuICBpZiAoIWN0eClcbiAgICByZXR1cm4gZm47XG4gIGlmIChmbi5fbikge1xuICAgIHJldHVybiBmbjtcbiAgfVxuICBjb25zdCByZW5kZXJGbldpdGhDb250ZXh0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAocmVuZGVyRm5XaXRoQ29udGV4dC5fZCkge1xuICAgICAgc2V0QmxvY2tUcmFja2luZygtMSk7XG4gICAgfVxuICAgIGNvbnN0IHByZXZJbnN0YW5jZSA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShjdHgpO1xuICAgIGxldCByZXM7XG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IGZuKC4uLmFyZ3MpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UocHJldkluc3RhbmNlKTtcbiAgICAgIGlmIChyZW5kZXJGbldpdGhDb250ZXh0Ll9kKSB7XG4gICAgICAgIHNldEJsb2NrVHJhY2tpbmcoMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkKGN0eCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG4gIHJlbmRlckZuV2l0aENvbnRleHQuX24gPSB0cnVlO1xuICByZW5kZXJGbldpdGhDb250ZXh0Ll9jID0gdHJ1ZTtcbiAgcmVuZGVyRm5XaXRoQ29udGV4dC5fZCA9IHRydWU7XG4gIHJldHVybiByZW5kZXJGbldpdGhDb250ZXh0O1xufVxuXG5sZXQgYWNjZXNzZWRBdHRycyA9IGZhbHNlO1xuZnVuY3Rpb24gbWFya0F0dHJzQWNjZXNzZWQoKSB7XG4gIGFjY2Vzc2VkQXR0cnMgPSB0cnVlO1xufVxuZnVuY3Rpb24gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSkge1xuICBjb25zdCB7XG4gICAgdHlwZTogQ29tcG9uZW50LFxuICAgIHZub2RlLFxuICAgIHByb3h5LFxuICAgIHdpdGhQcm94eSxcbiAgICBwcm9wcyxcbiAgICBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdLFxuICAgIHNsb3RzLFxuICAgIGF0dHJzLFxuICAgIGVtaXQsXG4gICAgcmVuZGVyLFxuICAgIHJlbmRlckNhY2hlLFxuICAgIGRhdGEsXG4gICAgc2V0dXBTdGF0ZSxcbiAgICBjdHgsXG4gICAgaW5oZXJpdEF0dHJzXG4gIH0gPSBpbnN0YW5jZTtcbiAgbGV0IHJlc3VsdDtcbiAgbGV0IGZhbGx0aHJvdWdoQXR0cnM7XG4gIGNvbnN0IHByZXYgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaW5zdGFuY2UpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGFjY2Vzc2VkQXR0cnMgPSBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA0KSB7XG4gICAgICBjb25zdCBwcm94eVRvVXNlID0gd2l0aFByb3h5IHx8IHByb3h5O1xuICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUoXG4gICAgICAgIHJlbmRlci5jYWxsKFxuICAgICAgICAgIHByb3h5VG9Vc2UsXG4gICAgICAgICAgcHJveHlUb1VzZSxcbiAgICAgICAgICByZW5kZXJDYWNoZSxcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBzZXR1cFN0YXRlLFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgY3R4XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBmYWxsdGhyb3VnaEF0dHJzID0gYXR0cnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlbmRlcjIgPSBDb21wb25lbnQ7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBhdHRycyA9PT0gcHJvcHMpIHtcbiAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVZOb2RlKFxuICAgICAgICByZW5kZXIyLmxlbmd0aCA+IDEgPyByZW5kZXIyKFxuICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyB7XG4gICAgICAgICAgICBnZXQgYXR0cnMoKSB7XG4gICAgICAgICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgICAgICAgICAgIHJldHVybiBhdHRycztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzbG90cyxcbiAgICAgICAgICAgIGVtaXRcbiAgICAgICAgICB9IDogeyBhdHRycywgc2xvdHMsIGVtaXQgfVxuICAgICAgICApIDogcmVuZGVyMihcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBudWxsXG4gICAgICAgICAgLyogd2Uga25vdyBpdCBkb2Vzbid0IG5lZWQgaXQgKi9cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBDb21wb25lbnQucHJvcHMgPyBhdHRycyA6IGdldEZ1bmN0aW9uYWxGYWxsdGhyb3VnaChhdHRycyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBibG9ja1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMSk7XG4gICAgcmVzdWx0ID0gY3JlYXRlVk5vZGUoQ29tbWVudCk7XG4gIH1cbiAgbGV0IHJvb3QgPSByZXN1bHQ7XG4gIGxldCBzZXRSb290ID0gdm9pZCAwO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiByZXN1bHQucGF0Y2hGbGFnID4gMCAmJiByZXN1bHQucGF0Y2hGbGFnICYgMjA0OCkge1xuICAgIFtyb290LCBzZXRSb290XSA9IGdldENoaWxkUm9vdChyZXN1bHQpO1xuICB9XG4gIGlmIChmYWxsdGhyb3VnaEF0dHJzICYmIGluaGVyaXRBdHRycyAhPT0gZmFsc2UpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmFsbHRocm91Z2hBdHRycyk7XG4gICAgY29uc3QgeyBzaGFwZUZsYWcgfSA9IHJvb3Q7XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBpZiAoc2hhcGVGbGFnICYgKDEgfCA2KSkge1xuICAgICAgICBpZiAocHJvcHNPcHRpb25zICYmIGtleXMuc29tZShpc01vZGVsTGlzdGVuZXIpKSB7XG4gICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IGZpbHRlck1vZGVsTGlzdGVuZXJzKFxuICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyxcbiAgICAgICAgICAgIHByb3BzT3B0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCwgZmFsbHRocm91Z2hBdHRycyk7XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWFjY2Vzc2VkQXR0cnMgJiYgcm9vdC50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgIGNvbnN0IGFsbEF0dHJzID0gT2JqZWN0LmtleXMoYXR0cnMpO1xuICAgICAgICBjb25zdCBldmVudEF0dHJzID0gW107XG4gICAgICAgIGNvbnN0IGV4dHJhQXR0cnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhbGxBdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBhbGxBdHRyc1tpXTtcbiAgICAgICAgICBpZiAoaXNPbihrZXkpKSB7XG4gICAgICAgICAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpKSB7XG4gICAgICAgICAgICAgIGV2ZW50QXR0cnMucHVzaChrZXlbMl0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4dHJhQXR0cnMucHVzaChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmFBdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYEV4dHJhbmVvdXMgbm9uLXByb3BzIGF0dHJpYnV0ZXMgKCR7ZXh0cmFBdHRycy5qb2luKFwiLCBcIil9KSB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgcm9vdCBub2Rlcy5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRBdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYEV4dHJhbmVvdXMgbm9uLWVtaXRzIGV2ZW50IGxpc3RlbmVycyAoJHtldmVudEF0dHJzLmpvaW4oXCIsIFwiKX0pIHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCByb290IG5vZGVzLiBJZiB0aGUgbGlzdGVuZXIgaXMgaW50ZW5kZWQgdG8gYmUgYSBjb21wb25lbnQgY3VzdG9tIGV2ZW50IGxpc3RlbmVyIG9ubHksIGRlY2xhcmUgaXQgdXNpbmcgdGhlIFwiZW1pdHNcIiBvcHRpb24uYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZub2RlLmRpcnMpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNFbGVtZW50Um9vdChyb290KSkge1xuICAgICAgd2FybihcbiAgICAgICAgYFJ1bnRpbWUgZGlyZWN0aXZlIHVzZWQgb24gY29tcG9uZW50IHdpdGggbm9uLWVsZW1lbnQgcm9vdCBub2RlLiBUaGUgZGlyZWN0aXZlcyB3aWxsIG5vdCBmdW5jdGlvbiBhcyBpbnRlbmRlZC5gXG4gICAgICApO1xuICAgIH1cbiAgICByb290ID0gY2xvbmVWTm9kZShyb290KTtcbiAgICByb290LmRpcnMgPSByb290LmRpcnMgPyByb290LmRpcnMuY29uY2F0KHZub2RlLmRpcnMpIDogdm5vZGUuZGlycztcbiAgfVxuICBpZiAodm5vZGUudHJhbnNpdGlvbikge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0VsZW1lbnRSb290KHJvb3QpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgQ29tcG9uZW50IGluc2lkZSA8VHJhbnNpdGlvbj4gcmVuZGVycyBub24tZWxlbWVudCByb290IG5vZGUgdGhhdCBjYW5ub3QgYmUgYW5pbWF0ZWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcm9vdC50cmFuc2l0aW9uID0gdm5vZGUudHJhbnNpdGlvbjtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzZXRSb290KSB7XG4gICAgc2V0Um9vdChyb290KTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSByb290O1xuICB9XG4gIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGdldENoaWxkUm9vdCA9ICh2bm9kZSkgPT4ge1xuICBjb25zdCByYXdDaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICBjb25zdCBkeW5hbWljQ2hpbGRyZW4gPSB2bm9kZS5keW5hbWljQ2hpbGRyZW47XG4gIGNvbnN0IGNoaWxkUm9vdCA9IGZpbHRlclNpbmdsZVJvb3QocmF3Q2hpbGRyZW4pO1xuICBpZiAoIWNoaWxkUm9vdCkge1xuICAgIHJldHVybiBbdm5vZGUsIHZvaWQgMF07XG4gIH1cbiAgY29uc3QgaW5kZXggPSByYXdDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCk7XG4gIGNvbnN0IGR5bmFtaWNJbmRleCA9IGR5bmFtaWNDaGlsZHJlbiA/IGR5bmFtaWNDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCkgOiAtMTtcbiAgY29uc3Qgc2V0Um9vdCA9ICh1cGRhdGVkUm9vdCkgPT4ge1xuICAgIHJhd0NoaWxkcmVuW2luZGV4XSA9IHVwZGF0ZWRSb290O1xuICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgIGlmIChkeW5hbWljSW5kZXggPiAtMSkge1xuICAgICAgICBkeW5hbWljQ2hpbGRyZW5bZHluYW1pY0luZGV4XSA9IHVwZGF0ZWRSb290O1xuICAgICAgfSBlbHNlIGlmICh1cGRhdGVkUm9vdC5wYXRjaEZsYWcgPiAwKSB7XG4gICAgICAgIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9IFsuLi5keW5hbWljQ2hpbGRyZW4sIHVwZGF0ZWRSb290XTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBbbm9ybWFsaXplVk5vZGUoY2hpbGRSb290KSwgc2V0Um9vdF07XG59O1xuZnVuY3Rpb24gZmlsdGVyU2luZ2xlUm9vdChjaGlsZHJlbikge1xuICBsZXQgc2luZ2xlUm9vdDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVk5vZGUoY2hpbGQpKSB7XG4gICAgICBpZiAoY2hpbGQudHlwZSAhPT0gQ29tbWVudCB8fCBjaGlsZC5jaGlsZHJlbiA9PT0gXCJ2LWlmXCIpIHtcbiAgICAgICAgaWYgKHNpbmdsZVJvb3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2luZ2xlUm9vdCA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNpbmdsZVJvb3Q7XG59XG5jb25zdCBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2ggPSAoYXR0cnMpID0+IHtcbiAgbGV0IHJlcztcbiAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICBpZiAoa2V5ID09PSBcImNsYXNzXCIgfHwga2V5ID09PSBcInN0eWxlXCIgfHwgaXNPbihrZXkpKSB7XG4gICAgICAocmVzIHx8IChyZXMgPSB7fSkpW2tleV0gPSBhdHRyc1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGZpbHRlck1vZGVsTGlzdGVuZXJzID0gKGF0dHJzLCBwcm9wcykgPT4ge1xuICBjb25zdCByZXMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpIHx8ICEoa2V5LnNsaWNlKDkpIGluIHByb3BzKSkge1xuICAgICAgcmVzW2tleV0gPSBhdHRyc1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGlzRWxlbWVudFJvb3QgPSAodm5vZGUpID0+IHtcbiAgcmV0dXJuIHZub2RlLnNoYXBlRmxhZyAmICg2IHwgMSkgfHwgdm5vZGUudHlwZSA9PT0gQ29tbWVudDtcbn07XG5mdW5jdGlvbiBzaG91bGRVcGRhdGVDb21wb25lbnQocHJldlZOb2RlLCBuZXh0Vk5vZGUsIG9wdGltaXplZCkge1xuICBjb25zdCB7IHByb3BzOiBwcmV2UHJvcHMsIGNoaWxkcmVuOiBwcmV2Q2hpbGRyZW4sIGNvbXBvbmVudCB9ID0gcHJldlZOb2RlO1xuICBjb25zdCB7IHByb3BzOiBuZXh0UHJvcHMsIGNoaWxkcmVuOiBuZXh0Q2hpbGRyZW4sIHBhdGNoRmxhZyB9ID0gbmV4dFZOb2RlO1xuICBjb25zdCBlbWl0cyA9IGNvbXBvbmVudC5lbWl0c09wdGlvbnM7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIChwcmV2Q2hpbGRyZW4gfHwgbmV4dENoaWxkcmVuKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG5leHRWTm9kZS5kaXJzIHx8IG5leHRWTm9kZS50cmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG9wdGltaXplZCAmJiBwYXRjaEZsYWcgPj0gMCkge1xuICAgIGlmIChwYXRjaEZsYWcgJiAxMDI0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHBhdGNoRmxhZyAmIDE2KSB7XG4gICAgICBpZiAoIXByZXZQcm9wcykge1xuICAgICAgICByZXR1cm4gISFuZXh0UHJvcHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XG4gICAgfSBlbHNlIGlmIChwYXRjaEZsYWcgJiA4KSB7XG4gICAgICBjb25zdCBkeW5hbWljUHJvcHMgPSBuZXh0Vk5vZGUuZHluYW1pY1Byb3BzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZHluYW1pY1Byb3BzW2ldO1xuICAgICAgICBpZiAobmV4dFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldICYmICFpc0VtaXRMaXN0ZW5lcihlbWl0cywga2V5KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChwcmV2Q2hpbGRyZW4gfHwgbmV4dENoaWxkcmVuKSB7XG4gICAgICBpZiAoIW5leHRDaGlsZHJlbiB8fCAhbmV4dENoaWxkcmVuLiRzdGFibGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcmV2UHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXByZXZQcm9wcykge1xuICAgICAgcmV0dXJuICEhbmV4dFByb3BzO1xuICAgIH1cbiAgICBpZiAoIW5leHRQcm9wcykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzT3B0aW9ucykge1xuICBjb25zdCBuZXh0S2V5cyA9IE9iamVjdC5rZXlzKG5leHRQcm9wcyk7XG4gIGlmIChuZXh0S2V5cy5sZW5ndGggIT09IE9iamVjdC5rZXlzKHByZXZQcm9wcykubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0S2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IG5leHRLZXlzW2ldO1xuICAgIGlmIChuZXh0UHJvcHNba2V5XSAhPT0gcHJldlByb3BzW2tleV0gJiYgIWlzRW1pdExpc3RlbmVyKGVtaXRzT3B0aW9ucywga2V5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUhPQ0hvc3RFbCh7IHZub2RlLCBwYXJlbnQgfSwgZWwpIHtcbiAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQuc3ViVHJlZSA9PT0gdm5vZGUpIHtcbiAgICAodm5vZGUgPSBwYXJlbnQudm5vZGUpLmVsID0gZWw7XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxufVxuXG5jb25zdCBpc1N1c3BlbnNlID0gKHR5cGUpID0+IHR5cGUuX19pc1N1c3BlbnNlO1xuY29uc3QgU3VzcGVuc2VJbXBsID0ge1xuICBuYW1lOiBcIlN1c3BlbnNlXCIsXG4gIC8vIEluIG9yZGVyIHRvIG1ha2UgU3VzcGVuc2UgdHJlZS1zaGFrYWJsZSwgd2UgbmVlZCB0byBhdm9pZCBpbXBvcnRpbmcgaXRcbiAgLy8gZGlyZWN0bHkgaW4gdGhlIHJlbmRlcmVyLiBUaGUgcmVuZGVyZXIgY2hlY2tzIGZvciB0aGUgX19pc1N1c3BlbnNlIGZsYWdcbiAgLy8gb24gYSB2bm9kZSdzIHR5cGUgYW5kIGNhbGxzIHRoZSBgcHJvY2Vzc2AgbWV0aG9kLCBwYXNzaW5nIGluIHJlbmRlcmVyXG4gIC8vIGludGVybmFscy5cbiAgX19pc1N1c3BlbnNlOiB0cnVlLFxuICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpIHtcbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgbW91bnRTdXNwZW5zZShcbiAgICAgICAgbjIsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgIHJlbmRlcmVySW50ZXJuYWxzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRjaFN1c3BlbnNlKFxuICAgICAgICBuMSxcbiAgICAgICAgbjIsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIGlzU1ZHLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgcmVuZGVyZXJJbnRlcm5hbHNcbiAgICAgICk7XG4gICAgfVxuICB9LFxuICBoeWRyYXRlOiBoeWRyYXRlU3VzcGVuc2UsXG4gIGNyZWF0ZTogY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSxcbiAgbm9ybWFsaXplOiBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuXG59O1xuY29uc3QgU3VzcGVuc2UgPSBTdXNwZW5zZUltcGwgO1xuZnVuY3Rpb24gdHJpZ2dlckV2ZW50KHZub2RlLCBuYW1lKSB7XG4gIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wc1tuYW1lXTtcbiAgaWYgKGlzRnVuY3Rpb24oZXZlbnRMaXN0ZW5lcikpIHtcbiAgICBldmVudExpc3RlbmVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2Uodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSB7XG4gIGNvbnN0IHtcbiAgICBwOiBwYXRjaCxcbiAgICBvOiB7IGNyZWF0ZUVsZW1lbnQgfVxuICB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gIGNvbnN0IGhpZGRlbkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgIHZub2RlLFxuICAgIHBhcmVudFN1c3BlbnNlLFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBjb250YWluZXIsXG4gICAgaGlkZGVuQ29udGFpbmVyLFxuICAgIGFuY2hvcixcbiAgICBpc1NWRyxcbiAgICBzbG90U2NvcGVJZHMsXG4gICAgb3B0aW1pemVkLFxuICAgIHJlbmRlcmVySW50ZXJuYWxzXG4gICk7XG4gIHBhdGNoKFxuICAgIG51bGwsXG4gICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IHZub2RlLnNzQ29udGVudCxcbiAgICBoaWRkZW5Db250YWluZXIsXG4gICAgbnVsbCxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgc3VzcGVuc2UsXG4gICAgaXNTVkcsXG4gICAgc2xvdFNjb3BlSWRzXG4gICk7XG4gIGlmIChzdXNwZW5zZS5kZXBzID4gMCkge1xuICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgXCJvblBlbmRpbmdcIik7XG4gICAgdHJpZ2dlckV2ZW50KHZub2RlLCBcIm9uRmFsbGJhY2tcIik7XG4gICAgcGF0Y2goXG4gICAgICBudWxsLFxuICAgICAgdm5vZGUuc3NGYWxsYmFjayxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGFuY2hvcixcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIG51bGwsXG4gICAgICAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgaXNTVkcsXG4gICAgICBzbG90U2NvcGVJZHNcbiAgICApO1xuICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgdm5vZGUuc3NGYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgc3VzcGVuc2UucmVzb2x2ZShmYWxzZSwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoU3VzcGVuc2UobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHsgcDogcGF0Y2gsIHVtOiB1bm1vdW50LCBvOiB7IGNyZWF0ZUVsZW1lbnQgfSB9KSB7XG4gIGNvbnN0IHN1c3BlbnNlID0gbjIuc3VzcGVuc2UgPSBuMS5zdXNwZW5zZTtcbiAgc3VzcGVuc2Uudm5vZGUgPSBuMjtcbiAgbjIuZWwgPSBuMS5lbDtcbiAgY29uc3QgbmV3QnJhbmNoID0gbjIuc3NDb250ZW50O1xuICBjb25zdCBuZXdGYWxsYmFjayA9IG4yLnNzRmFsbGJhY2s7XG4gIGNvbnN0IHsgYWN0aXZlQnJhbmNoLCBwZW5kaW5nQnJhbmNoLCBpc0luRmFsbGJhY2ssIGlzSHlkcmF0aW5nIH0gPSBzdXNwZW5zZTtcbiAgaWYgKHBlbmRpbmdCcmFuY2gpIHtcbiAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbmV3QnJhbmNoO1xuICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBwZW5kaW5nQnJhbmNoKSkge1xuICAgICAgcGF0Y2goXG4gICAgICAgIHBlbmRpbmdCcmFuY2gsXG4gICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHN1c3BlbnNlLFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNJbkZhbGxiYWNrKSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgICBuZXdGYWxsYmFjayxcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0ZhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3VzcGVuc2UucGVuZGluZ0lkKys7XG4gICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgc3VzcGVuc2UuaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoID0gcGVuZGluZ0JyYW5jaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVubW91bnQocGVuZGluZ0JyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSk7XG4gICAgICB9XG4gICAgICBzdXNwZW5zZS5kZXBzID0gMDtcbiAgICAgIHN1c3BlbnNlLmVmZmVjdHMubGVuZ3RoID0gMDtcbiAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBpZiAoaXNJbkZhbGxiYWNrKSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgICAgICBuZXdGYWxsYmFjayxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3RmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFjdGl2ZUJyYW5jaCAmJiBpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBhY3RpdmVCcmFuY2gpKSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYWN0aXZlQnJhbmNoICYmIGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIGFjdGl2ZUJyYW5jaCkpIHtcbiAgICAgIHBhdGNoKFxuICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgIGlzU1ZHLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3QnJhbmNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlckV2ZW50KG4yLCBcIm9uUGVuZGluZ1wiKTtcbiAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBuZXdCcmFuY2g7XG4gICAgICBzdXNwZW5zZS5wZW5kaW5nSWQrKztcbiAgICAgIHBhdGNoKFxuICAgICAgICBudWxsLFxuICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgaXNTVkcsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IHRpbWVvdXQsIHBlbmRpbmdJZCB9ID0gc3VzcGVuc2U7XG4gICAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdJZCA9PT0gcGVuZGluZ0lkKSB7XG4gICAgICAgICAgICAgIHN1c3BlbnNlLmZhbGxiYWNrKG5ld0ZhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aW1lb3V0ID09PSAwKSB7XG4gICAgICAgICAgc3VzcGVuc2UuZmFsbGJhY2sobmV3RmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5sZXQgaGFzV2FybmVkID0gZmFsc2U7XG5mdW5jdGlvbiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHZub2RlLCBwYXJlbnRTdXNwZW5zZSwgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIsIGhpZGRlbkNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBpc0h5ZHJhdGluZyA9IGZhbHNlKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRydWUgJiYgIWhhc1dhcm5lZCkge1xuICAgIGhhc1dhcm5lZCA9IHRydWU7XG4gICAgY29uc29sZVtjb25zb2xlLmluZm8gPyBcImluZm9cIiA6IFwibG9nXCJdKFxuICAgICAgYDxTdXNwZW5zZT4gaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUgYW5kIGl0cyBBUEkgd2lsbCBsaWtlbHkgY2hhbmdlLmBcbiAgICApO1xuICB9XG4gIGNvbnN0IHtcbiAgICBwOiBwYXRjaCxcbiAgICBtOiBtb3ZlLFxuICAgIHVtOiB1bm1vdW50LFxuICAgIG46IG5leHQsXG4gICAgbzogeyBwYXJlbnROb2RlLCByZW1vdmUgfVxuICB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gIGxldCBwYXJlbnRTdXNwZW5zZUlkO1xuICBjb25zdCBpc1N1c3BlbnNpYmxlID0gaXNWTm9kZVN1c3BlbnNpYmxlKHZub2RlKTtcbiAgaWYgKGlzU3VzcGVuc2libGUpIHtcbiAgICBpZiAocGFyZW50U3VzcGVuc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgIHBhcmVudFN1c3BlbnNlSWQgPSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQ7XG4gICAgICBwYXJlbnRTdXNwZW5zZS5kZXBzKys7XG4gICAgfVxuICB9XG4gIGNvbnN0IHRpbWVvdXQgPSB2bm9kZS5wcm9wcyA/IHRvTnVtYmVyKHZub2RlLnByb3BzLnRpbWVvdXQpIDogdm9pZCAwO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGFzc2VydE51bWJlcih0aW1lb3V0LCBgU3VzcGVuc2UgdGltZW91dGApO1xuICB9XG4gIGNvbnN0IHN1c3BlbnNlID0ge1xuICAgIHZub2RlLFxuICAgIHBhcmVudDogcGFyZW50U3VzcGVuc2UsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIGlzU1ZHLFxuICAgIGNvbnRhaW5lcixcbiAgICBoaWRkZW5Db250YWluZXIsXG4gICAgYW5jaG9yLFxuICAgIGRlcHM6IDAsXG4gICAgcGVuZGluZ0lkOiAwLFxuICAgIHRpbWVvdXQ6IHR5cGVvZiB0aW1lb3V0ID09PSBcIm51bWJlclwiID8gdGltZW91dCA6IC0xLFxuICAgIGFjdGl2ZUJyYW5jaDogbnVsbCxcbiAgICBwZW5kaW5nQnJhbmNoOiBudWxsLFxuICAgIGlzSW5GYWxsYmFjazogdHJ1ZSxcbiAgICBpc0h5ZHJhdGluZyxcbiAgICBpc1VubW91bnRlZDogZmFsc2UsXG4gICAgZWZmZWN0czogW10sXG4gICAgcmVzb2x2ZShyZXN1bWUgPSBmYWxzZSwgc3luYyA9IGZhbHNlKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBpZiAoIXJlc3VtZSAmJiAhc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBzdXNwZW5zZS5yZXNvbHZlKCkgaXMgY2FsbGVkIHdpdGhvdXQgYSBwZW5kaW5nIGJyYW5jaC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VzcGVuc2UuaXNVbm1vdW50ZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgc3VzcGVuc2UucmVzb2x2ZSgpIGlzIGNhbGxlZCBvbiBhbiBhbHJlYWR5IHVubW91bnRlZCBzdXNwZW5zZSBib3VuZGFyeS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICB2bm9kZTogdm5vZGUyLFxuICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgIHBlbmRpbmdCcmFuY2gsXG4gICAgICAgIHBlbmRpbmdJZCxcbiAgICAgICAgZWZmZWN0cyxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50OiBwYXJlbnRDb21wb25lbnQyLFxuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcjJcbiAgICAgIH0gPSBzdXNwZW5zZTtcbiAgICAgIGxldCBkZWxheUVudGVyID0gZmFsc2U7XG4gICAgICBpZiAoc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgc3VzcGVuc2UuaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXJlc3VtZSkge1xuICAgICAgICBkZWxheUVudGVyID0gYWN0aXZlQnJhbmNoICYmIHBlbmRpbmdCcmFuY2gudHJhbnNpdGlvbiAmJiBwZW5kaW5nQnJhbmNoLnRyYW5zaXRpb24ubW9kZSA9PT0gXCJvdXQtaW5cIjtcbiAgICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcbiAgICAgICAgICBhY3RpdmVCcmFuY2gudHJhbnNpdGlvbi5hZnRlckxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdJZCA9PT0gc3VzcGVuc2UucGVuZGluZ0lkKSB7XG4gICAgICAgICAgICAgIG1vdmUocGVuZGluZ0JyYW5jaCwgY29udGFpbmVyMiwgYW5jaG9yMiwgMCk7XG4gICAgICAgICAgICAgIHF1ZXVlUG9zdEZsdXNoQ2IoZWZmZWN0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBhbmNob3I6IGFuY2hvcjIgfSA9IHN1c3BlbnNlO1xuICAgICAgICBpZiAoYWN0aXZlQnJhbmNoKSB7XG4gICAgICAgICAgYW5jaG9yMiA9IG5leHQoYWN0aXZlQnJhbmNoKTtcbiAgICAgICAgICB1bm1vdW50KGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50Miwgc3VzcGVuc2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVsYXlFbnRlcikge1xuICAgICAgICAgIG1vdmUocGVuZGluZ0JyYW5jaCwgY29udGFpbmVyMiwgYW5jaG9yMiwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgcGVuZGluZ0JyYW5jaCk7XG4gICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbnVsbDtcbiAgICAgIHN1c3BlbnNlLmlzSW5GYWxsYmFjayA9IGZhbHNlO1xuICAgICAgbGV0IHBhcmVudCA9IHN1c3BlbnNlLnBhcmVudDtcbiAgICAgIGxldCBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSBmYWxzZTtcbiAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgICAgcGFyZW50LmVmZmVjdHMucHVzaCguLi5lZmZlY3RzKTtcbiAgICAgICAgICBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIWhhc1VucmVzb2x2ZWRBbmNlc3RvciAmJiAhZGVsYXlFbnRlcikge1xuICAgICAgICBxdWV1ZVBvc3RGbHVzaENiKGVmZmVjdHMpO1xuICAgICAgfVxuICAgICAgc3VzcGVuc2UuZWZmZWN0cyA9IFtdO1xuICAgICAgaWYgKGlzU3VzcGVuc2libGUpIHtcbiAgICAgICAgaWYgKHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiYgcGFyZW50U3VzcGVuc2VJZCA9PT0gcGFyZW50U3VzcGVuc2UucGVuZGluZ0lkKSB7XG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcy0tO1xuICAgICAgICAgIGlmIChwYXJlbnRTdXNwZW5zZS5kZXBzID09PSAwICYmICFzeW5jKSB7XG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cmlnZ2VyRXZlbnQodm5vZGUyLCBcIm9uUmVzb2x2ZVwiKTtcbiAgICB9LFxuICAgIGZhbGxiYWNrKGZhbGxiYWNrVk5vZGUpIHtcbiAgICAgIGlmICghc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IHZub2RlOiB2bm9kZTIsIGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50OiBwYXJlbnRDb21wb25lbnQyLCBjb250YWluZXI6IGNvbnRhaW5lcjIsIGlzU1ZHOiBpc1NWRzIgfSA9IHN1c3BlbnNlO1xuICAgICAgdHJpZ2dlckV2ZW50KHZub2RlMiwgXCJvbkZhbGxiYWNrXCIpO1xuICAgICAgY29uc3QgYW5jaG9yMiA9IG5leHQoYWN0aXZlQnJhbmNoKTtcbiAgICAgIGNvbnN0IG1vdW50RmFsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIGlmICghc3VzcGVuc2UuaXNJbkZhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgZmFsbGJhY2tWTm9kZSxcbiAgICAgICAgICBjb250YWluZXIyLFxuICAgICAgICAgIGFuY2hvcjIsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50MixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICAgICAgaXNTVkcyLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBmYWxsYmFja1ZOb2RlKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBkZWxheUVudGVyID0gZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uICYmIGZhbGxiYWNrVk5vZGUudHJhbnNpdGlvbi5tb2RlID09PSBcIm91dC1pblwiO1xuICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcbiAgICAgICAgYWN0aXZlQnJhbmNoLnRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSA9IG1vdW50RmFsbGJhY2s7XG4gICAgICB9XG4gICAgICBzdXNwZW5zZS5pc0luRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgdW5tb3VudChcbiAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQyLFxuICAgICAgICBudWxsLFxuICAgICAgICAvLyBubyBzdXNwZW5zZSBzbyB1bm1vdW50IGhvb2tzIGZpcmUgbm93XG4gICAgICAgIHRydWVcbiAgICAgICAgLy8gc2hvdWxkUmVtb3ZlXG4gICAgICApO1xuICAgICAgaWYgKCFkZWxheUVudGVyKSB7XG4gICAgICAgIG1vdW50RmFsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdmUoY29udGFpbmVyMiwgYW5jaG9yMiwgdHlwZSkge1xuICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmIG1vdmUoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCBjb250YWluZXIyLCBhbmNob3IyLCB0eXBlKTtcbiAgICAgIHN1c3BlbnNlLmNvbnRhaW5lciA9IGNvbnRhaW5lcjI7XG4gICAgfSxcbiAgICBuZXh0KCkge1xuICAgICAgcmV0dXJuIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCAmJiBuZXh0KHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCk7XG4gICAgfSxcbiAgICByZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QpIHtcbiAgICAgIGNvbnN0IGlzSW5QZW5kaW5nU3VzcGVuc2UgPSAhIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2g7XG4gICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSkge1xuICAgICAgICBzdXNwZW5zZS5kZXBzKys7XG4gICAgICB9XG4gICAgICBjb25zdCBoeWRyYXRlZEVsID0gaW5zdGFuY2Uudm5vZGUuZWw7XG4gICAgICBpbnN0YW5jZS5hc3luY0RlcC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDApO1xuICAgICAgfSkudGhlbigoYXN5bmNTZXR1cFJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAoaW5zdGFuY2UuaXNVbm1vdW50ZWQgfHwgc3VzcGVuc2UuaXNVbm1vdW50ZWQgfHwgc3VzcGVuc2UucGVuZGluZ0lkICE9PSBpbnN0YW5jZS5zdXNwZW5zZUlkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLmFzeW5jUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IHZub2RlOiB2bm9kZTIgfSA9IGluc3RhbmNlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZTIpO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBhc3luY1NldHVwUmVzdWx0LCBmYWxzZSk7XG4gICAgICAgIGlmIChoeWRyYXRlZEVsKSB7XG4gICAgICAgICAgdm5vZGUyLmVsID0gaHlkcmF0ZWRFbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9ICFoeWRyYXRlZEVsICYmIGluc3RhbmNlLnN1YlRyZWUuZWw7XG4gICAgICAgIHNldHVwUmVuZGVyRWZmZWN0KFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIHZub2RlMixcbiAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGhhdmUgYmVlbiBtb3ZlZCBiZWZvcmUgcmVzb2x2ZS5cbiAgICAgICAgICAvLyBpZiB0aGlzIGlzIG5vdCBhIGh5ZHJhdGlvbiwgaW5zdGFuY2Uuc3ViVHJlZSB3aWxsIGJlIHRoZSBjb21tZW50XG4gICAgICAgICAgLy8gcGxhY2Vob2xkZXIuXG4gICAgICAgICAgcGFyZW50Tm9kZShoeWRyYXRlZEVsIHx8IGluc3RhbmNlLnN1YlRyZWUuZWwpLFxuICAgICAgICAgIC8vIGFuY2hvciB3aWxsIG5vdCBiZSB1c2VkIGlmIHRoaXMgaXMgaHlkcmF0aW9uLCBzbyBvbmx5IG5lZWQgdG9cbiAgICAgICAgICAvLyBjb25zaWRlciB0aGUgY29tbWVudCBwbGFjZWhvbGRlciBjYXNlLlxuICAgICAgICAgIGh5ZHJhdGVkRWwgPyBudWxsIDogbmV4dChpbnN0YW5jZS5zdWJUcmVlKSxcbiAgICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgcmVtb3ZlKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIHZub2RlMi5lbCk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSAmJiAtLXN1c3BlbnNlLmRlcHMgPT09IDApIHtcbiAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdW5tb3VudChwYXJlbnRTdXNwZW5zZTIsIGRvUmVtb3ZlKSB7XG4gICAgICBzdXNwZW5zZS5pc1VubW91bnRlZCA9IHRydWU7XG4gICAgICBpZiAoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKSB7XG4gICAgICAgIHVubW91bnQoXG4gICAgICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZTIsXG4gICAgICAgICAgZG9SZW1vdmVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgIHVubW91bnQoXG4gICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UyLFxuICAgICAgICAgIGRvUmVtb3ZlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gc3VzcGVuc2U7XG59XG5mdW5jdGlvbiBoeWRyYXRlU3VzcGVuc2Uobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGh5ZHJhdGVOb2RlKSB7XG4gIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgIHZub2RlLFxuICAgIHBhcmVudFN1c3BlbnNlLFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBub2RlLnBhcmVudE5vZGUsXG4gICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICBudWxsLFxuICAgIGlzU1ZHLFxuICAgIHNsb3RTY29wZUlkcyxcbiAgICBvcHRpbWl6ZWQsXG4gICAgcmVuZGVyZXJJbnRlcm5hbHMsXG4gICAgdHJ1ZVxuICAgIC8qIGh5ZHJhdGluZyAqL1xuICApO1xuICBjb25zdCByZXN1bHQgPSBoeWRyYXRlTm9kZShcbiAgICBub2RlLFxuICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSB2bm9kZS5zc0NvbnRlbnQsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIHN1c3BlbnNlLFxuICAgIHNsb3RTY29wZUlkcyxcbiAgICBvcHRpbWl6ZWRcbiAgKTtcbiAgaWYgKHN1c3BlbnNlLmRlcHMgPT09IDApIHtcbiAgICBzdXNwZW5zZS5yZXNvbHZlKGZhbHNlLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlbih2bm9kZSkge1xuICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xuICBjb25zdCBpc1Nsb3RDaGlsZHJlbiA9IHNoYXBlRmxhZyAmIDMyO1xuICB2bm9kZS5zc0NvbnRlbnQgPSBub3JtYWxpemVTdXNwZW5zZVNsb3QoXG4gICAgaXNTbG90Q2hpbGRyZW4gPyBjaGlsZHJlbi5kZWZhdWx0IDogY2hpbGRyZW5cbiAgKTtcbiAgdm5vZGUuc3NGYWxsYmFjayA9IGlzU2xvdENoaWxkcmVuID8gbm9ybWFsaXplU3VzcGVuc2VTbG90KGNoaWxkcmVuLmZhbGxiYWNrKSA6IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VTbG90KHMpIHtcbiAgbGV0IGJsb2NrO1xuICBpZiAoaXNGdW5jdGlvbihzKSkge1xuICAgIGNvbnN0IHRyYWNrQmxvY2sgPSBpc0Jsb2NrVHJlZUVuYWJsZWQgJiYgcy5fYztcbiAgICBpZiAodHJhY2tCbG9jaykge1xuICAgICAgcy5fZCA9IGZhbHNlO1xuICAgICAgb3BlbkJsb2NrKCk7XG4gICAgfVxuICAgIHMgPSBzKCk7XG4gICAgaWYgKHRyYWNrQmxvY2spIHtcbiAgICAgIHMuX2QgPSB0cnVlO1xuICAgICAgYmxvY2sgPSBjdXJyZW50QmxvY2s7XG4gICAgICBjbG9zZUJsb2NrKCk7XG4gICAgfVxuICB9XG4gIGlmIChpc0FycmF5KHMpKSB7XG4gICAgY29uc3Qgc2luZ2xlQ2hpbGQgPSBmaWx0ZXJTaW5nbGVSb290KHMpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFzaW5nbGVDaGlsZCkge1xuICAgICAgd2FybihgPFN1c3BlbnNlPiBzbG90cyBleHBlY3QgYSBzaW5nbGUgcm9vdCBub2RlLmApO1xuICAgIH1cbiAgICBzID0gc2luZ2xlQ2hpbGQ7XG4gIH1cbiAgcyA9IG5vcm1hbGl6ZVZOb2RlKHMpO1xuICBpZiAoYmxvY2sgJiYgIXMuZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgcy5keW5hbWljQ2hpbGRyZW4gPSBibG9jay5maWx0ZXIoKGMpID0+IGMgIT09IHMpO1xuICB9XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UoZm4sIHN1c3BlbnNlKSB7XG4gIGlmIChzdXNwZW5zZSAmJiBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgaWYgKGlzQXJyYXkoZm4pKSB7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goLi4uZm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goZm4pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVBvc3RGbHVzaENiKGZuKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBicmFuY2gpIHtcbiAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoID0gYnJhbmNoO1xuICBjb25zdCB7IHZub2RlLCBwYXJlbnRDb21wb25lbnQgfSA9IHN1c3BlbnNlO1xuICBjb25zdCBlbCA9IHZub2RlLmVsID0gYnJhbmNoLmVsO1xuICBpZiAocGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC5zdWJUcmVlID09PSB2bm9kZSkge1xuICAgIHBhcmVudENvbXBvbmVudC52bm9kZS5lbCA9IGVsO1xuICAgIHVwZGF0ZUhPQ0hvc3RFbChwYXJlbnRDb21wb25lbnQsIGVsKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNWTm9kZVN1c3BlbnNpYmxlKHZub2RlKSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuICgoX2EgPSB2bm9kZS5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnN1c3BlbnNpYmxlKSAhPSBudWxsICYmIHZub2RlLnByb3BzLnN1c3BlbnNpYmxlICE9PSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gd2F0Y2hFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB3YXRjaFBvc3RFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkb1dhdGNoKFxuICAgIGVmZmVjdCxcbiAgICBudWxsLFxuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBleHRlbmQoe30sIG9wdGlvbnMsIHsgZmx1c2g6IFwicG9zdFwiIH0pIDogeyBmbHVzaDogXCJwb3N0XCIgfVxuICApO1xufVxuZnVuY3Rpb24gd2F0Y2hTeW5jRWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xuICByZXR1cm4gZG9XYXRjaChcbiAgICBlZmZlY3QsXG4gICAgbnVsbCxcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gZXh0ZW5kKHt9LCBvcHRpb25zLCB7IGZsdXNoOiBcInN5bmNcIiB9KSA6IHsgZmx1c2g6IFwic3luY1wiIH1cbiAgKTtcbn1cbmNvbnN0IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA9IHt9O1xuZnVuY3Rpb24gd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucykge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNGdW5jdGlvbihjYikpIHtcbiAgICB3YXJuKFxuICAgICAgYFxcYHdhdGNoKGZuLCBvcHRpb25zPylcXGAgc2lnbmF0dXJlIGhhcyBiZWVuIG1vdmVkIHRvIGEgc2VwYXJhdGUgQVBJLiBVc2UgXFxgd2F0Y2hFZmZlY3QoZm4sIG9wdGlvbnM/KVxcYCBpbnN0ZWFkLiBcXGB3YXRjaFxcYCBub3cgb25seSBzdXBwb3J0cyBcXGB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zPykgc2lnbmF0dXJlLmBcbiAgICApO1xuICB9XG4gIHJldHVybiBkb1dhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZG9XYXRjaChzb3VyY2UsIGNiLCB7IGltbWVkaWF0ZSwgZGVlcCwgZmx1c2gsIG9uVHJhY2ssIG9uVHJpZ2dlciB9ID0gRU1QVFlfT0JKKSB7XG4gIHZhciBfYTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWNiKSB7XG4gICAgaWYgKGltbWVkaWF0ZSAhPT0gdm9pZCAwKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgd2F0Y2goKSBcImltbWVkaWF0ZVwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChkZWVwICE9PSB2b2lkIDApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGB3YXRjaCgpIFwiZGVlcFwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHdhcm5JbnZhbGlkU291cmNlID0gKHMpID0+IHtcbiAgICB3YXJuKFxuICAgICAgYEludmFsaWQgd2F0Y2ggc291cmNlOiBgLFxuICAgICAgcyxcbiAgICAgIGBBIHdhdGNoIHNvdXJjZSBjYW4gb25seSBiZSBhIGdldHRlci9lZmZlY3QgZnVuY3Rpb24sIGEgcmVmLCBhIHJlYWN0aXZlIG9iamVjdCwgb3IgYW4gYXJyYXkgb2YgdGhlc2UgdHlwZXMuYFxuICAgICk7XG4gIH07XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudFNjb3BlKCkgPT09ICgoX2EgPSBjdXJyZW50SW5zdGFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zY29wZSkgPyBjdXJyZW50SW5zdGFuY2UgOiBudWxsO1xuICBsZXQgZ2V0dGVyO1xuICBsZXQgZm9yY2VUcmlnZ2VyID0gZmFsc2U7XG4gIGxldCBpc011bHRpU291cmNlID0gZmFsc2U7XG4gIGlmIChpc1JlZihzb3VyY2UpKSB7XG4gICAgZ2V0dGVyID0gKCkgPT4gc291cmNlLnZhbHVlO1xuICAgIGZvcmNlVHJpZ2dlciA9IGlzU2hhbGxvdyQxKHNvdXJjZSk7XG4gIH0gZWxzZSBpZiAoaXNSZWFjdGl2ZShzb3VyY2UpKSB7XG4gICAgZ2V0dGVyID0gKCkgPT4gc291cmNlO1xuICAgIGRlZXAgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIGlzTXVsdGlTb3VyY2UgPSB0cnVlO1xuICAgIGZvcmNlVHJpZ2dlciA9IHNvdXJjZS5zb21lKChzKSA9PiBpc1JlYWN0aXZlKHMpIHx8IGlzU2hhbGxvdyQxKHMpKTtcbiAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UubWFwKChzKSA9PiB7XG4gICAgICBpZiAoaXNSZWYocykpIHtcbiAgICAgICAgcmV0dXJuIHMudmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKGlzUmVhY3RpdmUocykpIHtcbiAgICAgICAgcmV0dXJuIHRyYXZlcnNlKHMpO1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHMpKSB7XG4gICAgICAgIHJldHVybiBjYWxsV2l0aEVycm9ySGFuZGxpbmcocywgaW5zdGFuY2UsIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuSW52YWxpZFNvdXJjZShzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHNvdXJjZSkpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGdldHRlciA9ICgpID0+IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhzb3VyY2UsIGluc3RhbmNlLCAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2V0dGVyID0gKCkgPT4ge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuaXNVbm1vdW50ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsZWFudXApIHtcbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAzLFxuICAgICAgICAgIFtvbkNsZWFudXBdXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBnZXR0ZXIgPSBOT09QO1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybkludmFsaWRTb3VyY2Uoc291cmNlKTtcbiAgfVxuICBpZiAoY2IgJiYgZGVlcCkge1xuICAgIGNvbnN0IGJhc2VHZXR0ZXIgPSBnZXR0ZXI7XG4gICAgZ2V0dGVyID0gKCkgPT4gdHJhdmVyc2UoYmFzZUdldHRlcigpKTtcbiAgfVxuICBsZXQgY2xlYW51cDtcbiAgbGV0IG9uQ2xlYW51cCA9IChmbikgPT4ge1xuICAgIGNsZWFudXAgPSBlZmZlY3Qub25TdG9wID0gKCkgPT4ge1xuICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgNCk7XG4gICAgfTtcbiAgfTtcbiAgbGV0IHNzckNsZWFudXA7XG4gIGlmIChpc0luU1NSQ29tcG9uZW50U2V0dXApIHtcbiAgICBvbkNsZWFudXAgPSBOT09QO1xuICAgIGlmICghY2IpIHtcbiAgICAgIGdldHRlcigpO1xuICAgIH0gZWxzZSBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhjYiwgaW5zdGFuY2UsIDMsIFtcbiAgICAgICAgZ2V0dGVyKCksXG4gICAgICAgIGlzTXVsdGlTb3VyY2UgPyBbXSA6IHZvaWQgMCxcbiAgICAgICAgb25DbGVhbnVwXG4gICAgICBdKTtcbiAgICB9XG4gICAgaWYgKGZsdXNoID09PSBcInN5bmNcIikge1xuICAgICAgY29uc3QgY3R4ID0gdXNlU1NSQ29udGV4dCgpO1xuICAgICAgc3NyQ2xlYW51cCA9IGN0eC5fX3dhdGNoZXJIYW5kbGVzIHx8IChjdHguX193YXRjaGVySGFuZGxlcyA9IFtdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE5PT1A7XG4gICAgfVxuICB9XG4gIGxldCBvbGRWYWx1ZSA9IGlzTXVsdGlTb3VyY2UgPyBuZXcgQXJyYXkoc291cmNlLmxlbmd0aCkuZmlsbChJTklUSUFMX1dBVENIRVJfVkFMVUUpIDogSU5JVElBTF9XQVRDSEVSX1ZBTFVFO1xuICBjb25zdCBqb2IgPSAoKSA9PiB7XG4gICAgaWYgKCFlZmZlY3QuYWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjYikge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBlZmZlY3QucnVuKCk7XG4gICAgICBpZiAoZGVlcCB8fCBmb3JjZVRyaWdnZXIgfHwgKGlzTXVsdGlTb3VyY2UgPyBuZXdWYWx1ZS5zb21lKCh2LCBpKSA9PiBoYXNDaGFuZ2VkKHYsIG9sZFZhbHVlW2ldKSkgOiBoYXNDaGFuZ2VkKG5ld1ZhbHVlLCBvbGRWYWx1ZSkpIHx8IGZhbHNlKSB7XG4gICAgICAgIGlmIChjbGVhbnVwKSB7XG4gICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGNiLCBpbnN0YW5jZSwgMywgW1xuICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgIC8vIHBhc3MgdW5kZWZpbmVkIGFzIHRoZSBvbGQgdmFsdWUgd2hlbiBpdCdzIGNoYW5nZWQgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgICAgb2xkVmFsdWUgPT09IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA/IHZvaWQgMCA6IGlzTXVsdGlTb3VyY2UgJiYgb2xkVmFsdWVbMF0gPT09IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA/IFtdIDogb2xkVmFsdWUsXG4gICAgICAgICAgb25DbGVhbnVwXG4gICAgICAgIF0pO1xuICAgICAgICBvbGRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlZmZlY3QucnVuKCk7XG4gICAgfVxuICB9O1xuICBqb2IuYWxsb3dSZWN1cnNlID0gISFjYjtcbiAgbGV0IHNjaGVkdWxlcjtcbiAgaWYgKGZsdXNoID09PSBcInN5bmNcIikge1xuICAgIHNjaGVkdWxlciA9IGpvYjtcbiAgfSBlbHNlIGlmIChmbHVzaCA9PT0gXCJwb3N0XCIpIHtcbiAgICBzY2hlZHVsZXIgPSAoKSA9PiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3Qoam9iLCBpbnN0YW5jZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSk7XG4gIH0gZWxzZSB7XG4gICAgam9iLnByZSA9IHRydWU7XG4gICAgaWYgKGluc3RhbmNlKVxuICAgICAgam9iLmlkID0gaW5zdGFuY2UudWlkO1xuICAgIHNjaGVkdWxlciA9ICgpID0+IHF1ZXVlSm9iKGpvYik7XG4gIH1cbiAgY29uc3QgZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGdldHRlciwgc2NoZWR1bGVyKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBlZmZlY3Qub25UcmFjayA9IG9uVHJhY2s7XG4gICAgZWZmZWN0Lm9uVHJpZ2dlciA9IG9uVHJpZ2dlcjtcbiAgfVxuICBpZiAoY2IpIHtcbiAgICBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICBqb2IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2xkVmFsdWUgPSBlZmZlY3QucnVuKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGZsdXNoID09PSBcInBvc3RcIikge1xuICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChcbiAgICAgIGVmZmVjdC5ydW4uYmluZChlZmZlY3QpLFxuICAgICAgaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc3VzcGVuc2VcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGVmZmVjdC5ydW4oKTtcbiAgfVxuICBjb25zdCB1bndhdGNoID0gKCkgPT4ge1xuICAgIGVmZmVjdC5zdG9wKCk7XG4gICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLnNjb3BlKSB7XG4gICAgICByZW1vdmUoaW5zdGFuY2Uuc2NvcGUuZWZmZWN0cywgZWZmZWN0KTtcbiAgICB9XG4gIH07XG4gIGlmIChzc3JDbGVhbnVwKVxuICAgIHNzckNsZWFudXAucHVzaCh1bndhdGNoKTtcbiAgcmV0dXJuIHVud2F0Y2g7XG59XG5mdW5jdGlvbiBpbnN0YW5jZVdhdGNoKHNvdXJjZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgcHVibGljVGhpcyA9IHRoaXMucHJveHk7XG4gIGNvbnN0IGdldHRlciA9IGlzU3RyaW5nKHNvdXJjZSkgPyBzb3VyY2UuaW5jbHVkZXMoXCIuXCIpID8gY3JlYXRlUGF0aEdldHRlcihwdWJsaWNUaGlzLCBzb3VyY2UpIDogKCkgPT4gcHVibGljVGhpc1tzb3VyY2VdIDogc291cmNlLmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcyk7XG4gIGxldCBjYjtcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgY2IgPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBjYiA9IHZhbHVlLmhhbmRsZXI7XG4gICAgb3B0aW9ucyA9IHZhbHVlO1xuICB9XG4gIGNvbnN0IGN1ciA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgc2V0Q3VycmVudEluc3RhbmNlKHRoaXMpO1xuICBjb25zdCByZXMgPSBkb1dhdGNoKGdldHRlciwgY2IuYmluZChwdWJsaWNUaGlzKSwgb3B0aW9ucyk7XG4gIGlmIChjdXIpIHtcbiAgICBzZXRDdXJyZW50SW5zdGFuY2UoY3VyKTtcbiAgfSBlbHNlIHtcbiAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRoR2V0dGVyKGN0eCwgcGF0aCkge1xuICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIuXCIpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCBjdXIgPSBjdHg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGggJiYgY3VyOyBpKyspIHtcbiAgICAgIGN1ciA9IGN1cltzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBjdXI7XG4gIH07XG59XG5mdW5jdGlvbiB0cmF2ZXJzZSh2YWx1ZSwgc2Vlbikge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZVtcIl9fdl9za2lwXCJdKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHNlZW4gPSBzZWVuIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGlmIChzZWVuLmhhcyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgc2Vlbi5hZGQodmFsdWUpO1xuICBpZiAoaXNSZWYodmFsdWUpKSB7XG4gICAgdHJhdmVyc2UodmFsdWUudmFsdWUsIHNlZW4pO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdHJhdmVyc2UodmFsdWVbaV0sIHNlZW4pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1NldCh2YWx1ZSkgfHwgaXNNYXAodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaCgodikgPT4ge1xuICAgICAgdHJhdmVyc2Uodiwgc2Vlbik7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgdHJhdmVyc2UodmFsdWVba2V5XSwgc2Vlbik7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWUpIHtcbiAgaWYgKGlzQnVpbHRJbkRpcmVjdGl2ZShuYW1lKSkge1xuICAgIHdhcm4oXCJEbyBub3QgdXNlIGJ1aWx0LWluIGRpcmVjdGl2ZSBpZHMgYXMgY3VzdG9tIGRpcmVjdGl2ZSBpZDogXCIgKyBuYW1lKTtcbiAgfVxufVxuZnVuY3Rpb24gd2l0aERpcmVjdGl2ZXModm5vZGUsIGRpcmVjdGl2ZXMpIHtcbiAgY29uc3QgaW50ZXJuYWxJbnN0YW5jZSA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgaWYgKGludGVybmFsSW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYHdpdGhEaXJlY3RpdmVzIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHJlbmRlciBmdW5jdGlvbnMuYCk7XG4gICAgcmV0dXJuIHZub2RlO1xuICB9XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0RXhwb3NlUHJveHkoaW50ZXJuYWxJbnN0YW5jZSkgfHwgaW50ZXJuYWxJbnN0YW5jZS5wcm94eTtcbiAgY29uc3QgYmluZGluZ3MgPSB2bm9kZS5kaXJzIHx8ICh2bm9kZS5kaXJzID0gW10pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcmVjdGl2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgW2RpciwgdmFsdWUsIGFyZywgbW9kaWZpZXJzID0gRU1QVFlfT0JKXSA9IGRpcmVjdGl2ZXNbaV07XG4gICAgaWYgKGRpcikge1xuICAgICAgaWYgKGlzRnVuY3Rpb24oZGlyKSkge1xuICAgICAgICBkaXIgPSB7XG4gICAgICAgICAgbW91bnRlZDogZGlyLFxuICAgICAgICAgIHVwZGF0ZWQ6IGRpclxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGRpci5kZWVwKSB7XG4gICAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGJpbmRpbmdzLnB1c2goe1xuICAgICAgICBkaXIsXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb2xkVmFsdWU6IHZvaWQgMCxcbiAgICAgICAgYXJnLFxuICAgICAgICBtb2RpZmllcnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm5vZGU7XG59XG5mdW5jdGlvbiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBwcmV2Vk5vZGUsIGluc3RhbmNlLCBuYW1lKSB7XG4gIGNvbnN0IGJpbmRpbmdzID0gdm5vZGUuZGlycztcbiAgY29uc3Qgb2xkQmluZGluZ3MgPSBwcmV2Vk5vZGUgJiYgcHJldlZOb2RlLmRpcnM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBiaW5kaW5nID0gYmluZGluZ3NbaV07XG4gICAgaWYgKG9sZEJpbmRpbmdzKSB7XG4gICAgICBiaW5kaW5nLm9sZFZhbHVlID0gb2xkQmluZGluZ3NbaV0udmFsdWU7XG4gICAgfVxuICAgIGxldCBob29rID0gYmluZGluZy5kaXJbbmFtZV07XG4gICAgaWYgKGhvb2spIHtcbiAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA4LCBbXG4gICAgICAgIHZub2RlLmVsLFxuICAgICAgICBiaW5kaW5nLFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgcHJldlZOb2RlXG4gICAgICBdKTtcbiAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgbGVhdmVDYktleSA9IFN5bWJvbChcIl9sZWF2ZUNiXCIpO1xuY29uc3QgZW50ZXJDYktleSA9IFN5bWJvbChcIl9lbnRlckNiXCIpO1xuZnVuY3Rpb24gdXNlVHJhbnNpdGlvblN0YXRlKCkge1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgIGlzTGVhdmluZzogZmFsc2UsXG4gICAgaXNVbm1vdW50aW5nOiBmYWxzZSxcbiAgICBsZWF2aW5nVk5vZGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gIH07XG4gIG9uTW91bnRlZCgoKSA9PiB7XG4gICAgc3RhdGUuaXNNb3VudGVkID0gdHJ1ZTtcbiAgfSk7XG4gIG9uQmVmb3JlVW5tb3VudCgoKSA9PiB7XG4gICAgc3RhdGUuaXNVbm1vdW50aW5nID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmNvbnN0IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yID0gW0Z1bmN0aW9uLCBBcnJheV07XG5jb25zdCBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IHtcbiAgbW9kZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIHBlcnNpc3RlZDogQm9vbGVhbixcbiAgLy8gZW50ZXJcbiAgb25CZWZvcmVFbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFmdGVyRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkVudGVyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgLy8gbGVhdmVcbiAgb25CZWZvcmVMZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFmdGVyTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkxlYXZlQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgLy8gYXBwZWFyXG4gIG9uQmVmb3JlQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFmdGVyQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BcHBlYXJDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yXG59O1xuY29uc3QgQmFzZVRyYW5zaXRpb25JbXBsID0ge1xuICBuYW1lOiBgQmFzZVRyYW5zaXRpb25gLFxuICBwcm9wczogQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsXG4gIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XG4gICAgbGV0IHByZXZUcmFuc2l0aW9uS2V5O1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKHNsb3RzLmRlZmF1bHQoKSwgdHJ1ZSk7XG4gICAgICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGNoaWxkID0gY2hpbGRyZW5bMF07XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICBsZXQgaGFzRm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGMudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaGFzRm91bmQpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICBcIjx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQgb3IgY29tcG9uZW50LiBVc2UgPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkID0gYztcbiAgICAgICAgICAgIGhhc0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSlcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgICAgIGNvbnN0IHsgbW9kZSB9ID0gcmF3UHJvcHM7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBtb2RlICYmIG1vZGUgIT09IFwiaW4tb3V0XCIgJiYgbW9kZSAhPT0gXCJvdXQtaW5cIiAmJiBtb2RlICE9PSBcImRlZmF1bHRcIikge1xuICAgICAgICB3YXJuKGBpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAke21vZGV9YCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuaXNMZWF2aW5nKSB7XG4gICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlubmVyQ2hpbGQgPSBnZXRLZWVwQWxpdmVDaGlsZChjaGlsZCk7XG4gICAgICBpZiAoIWlubmVyQ2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xuICAgICAgfVxuICAgICAgY29uc3QgZW50ZXJIb29rcyA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgIGlubmVyQ2hpbGQsXG4gICAgICAgIHJhd1Byb3BzLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgaW5zdGFuY2VcbiAgICAgICk7XG4gICAgICBzZXRUcmFuc2l0aW9uSG9va3MoaW5uZXJDaGlsZCwgZW50ZXJIb29rcyk7XG4gICAgICBjb25zdCBvbGRDaGlsZCA9IGluc3RhbmNlLnN1YlRyZWU7XG4gICAgICBjb25zdCBvbGRJbm5lckNoaWxkID0gb2xkQ2hpbGQgJiYgZ2V0S2VlcEFsaXZlQ2hpbGQob2xkQ2hpbGQpO1xuICAgICAgbGV0IHRyYW5zaXRpb25LZXlDaGFuZ2VkID0gZmFsc2U7XG4gICAgICBjb25zdCB7IGdldFRyYW5zaXRpb25LZXkgfSA9IGlubmVyQ2hpbGQudHlwZTtcbiAgICAgIGlmIChnZXRUcmFuc2l0aW9uS2V5KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGdldFRyYW5zaXRpb25LZXkoKTtcbiAgICAgICAgaWYgKHByZXZUcmFuc2l0aW9uS2V5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICBwcmV2VHJhbnNpdGlvbktleSA9IGtleTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgIT09IHByZXZUcmFuc2l0aW9uS2V5KSB7XG4gICAgICAgICAgcHJldlRyYW5zaXRpb25LZXkgPSBrZXk7XG4gICAgICAgICAgdHJhbnNpdGlvbktleUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2xkSW5uZXJDaGlsZCAmJiBvbGRJbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQgJiYgKCFpc1NhbWVWTm9kZVR5cGUoaW5uZXJDaGlsZCwgb2xkSW5uZXJDaGlsZCkgfHwgdHJhbnNpdGlvbktleUNoYW5nZWQpKSB7XG4gICAgICAgIGNvbnN0IGxlYXZpbmdIb29rcyA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgICAgb2xkSW5uZXJDaGlsZCxcbiAgICAgICAgICByYXdQcm9wcyxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICApO1xuICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Mob2xkSW5uZXJDaGlsZCwgbGVhdmluZ0hvb2tzKTtcbiAgICAgICAgaWYgKG1vZGUgPT09IFwib3V0LWluXCIpIHtcbiAgICAgICAgICBzdGF0ZS5pc0xlYXZpbmcgPSB0cnVlO1xuICAgICAgICAgIGxlYXZpbmdIb29rcy5hZnRlckxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UudXBkYXRlLmFjdGl2ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gXCJpbi1vdXRcIiAmJiBpbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgICBsZWF2aW5nSG9va3MuZGVsYXlMZWF2ZSA9IChlbCwgZWFybHlSZW1vdmUsIGRlbGF5ZWRMZWF2ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShcbiAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgIG9sZElubmVyQ2hpbGRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZWF2aW5nVk5vZGVzQ2FjaGVbU3RyaW5nKG9sZElubmVyQ2hpbGQua2V5KV0gPSBvbGRJbm5lckNoaWxkO1xuICAgICAgICAgICAgZWxbbGVhdmVDYktleV0gPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGVhcmx5UmVtb3ZlKCk7XG4gICAgICAgICAgICAgIGVsW2xlYXZlQ2JLZXldID0gdm9pZCAwO1xuICAgICAgICAgICAgICBkZWxldGUgZW50ZXJIb29rcy5kZWxheWVkTGVhdmU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZW50ZXJIb29rcy5kZWxheWVkTGVhdmUgPSBkZWxheWVkTGVhdmU7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH07XG4gIH1cbn07XG5jb25zdCBCYXNlVHJhbnNpdGlvbiA9IEJhc2VUcmFuc2l0aW9uSW1wbDtcbmZ1bmN0aW9uIGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoc3RhdGUsIHZub2RlKSB7XG4gIGNvbnN0IHsgbGVhdmluZ1ZOb2RlcyB9ID0gc3RhdGU7XG4gIGxldCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBsZWF2aW5nVk5vZGVzLmdldCh2bm9kZS50eXBlKTtcbiAgaWYgKCFsZWF2aW5nVk5vZGVzQ2FjaGUpIHtcbiAgICBsZWF2aW5nVk5vZGVzQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZWF2aW5nVk5vZGVzLnNldCh2bm9kZS50eXBlLCBsZWF2aW5nVk5vZGVzQ2FjaGUpO1xuICB9XG4gIHJldHVybiBsZWF2aW5nVk5vZGVzQ2FjaGU7XG59XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKHZub2RlLCBwcm9wcywgc3RhdGUsIGluc3RhbmNlKSB7XG4gIGNvbnN0IHtcbiAgICBhcHBlYXIsXG4gICAgbW9kZSxcbiAgICBwZXJzaXN0ZWQgPSBmYWxzZSxcbiAgICBvbkJlZm9yZUVudGVyLFxuICAgIG9uRW50ZXIsXG4gICAgb25BZnRlckVudGVyLFxuICAgIG9uRW50ZXJDYW5jZWxsZWQsXG4gICAgb25CZWZvcmVMZWF2ZSxcbiAgICBvbkxlYXZlLFxuICAgIG9uQWZ0ZXJMZWF2ZSxcbiAgICBvbkxlYXZlQ2FuY2VsbGVkLFxuICAgIG9uQmVmb3JlQXBwZWFyLFxuICAgIG9uQXBwZWFyLFxuICAgIG9uQWZ0ZXJBcHBlYXIsXG4gICAgb25BcHBlYXJDYW5jZWxsZWRcbiAgfSA9IHByb3BzO1xuICBjb25zdCBrZXkgPSBTdHJpbmcodm5vZGUua2V5KTtcbiAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgdm5vZGUpO1xuICBjb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzKSA9PiB7XG4gICAgaG9vayAmJiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgIGhvb2ssXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDksXG4gICAgICBhcmdzXG4gICAgKTtcbiAgfTtcbiAgY29uc3QgY2FsbEFzeW5jSG9vayA9IChob29rLCBhcmdzKSA9PiB7XG4gICAgY29uc3QgZG9uZSA9IGFyZ3NbMV07XG4gICAgY2FsbEhvb2soaG9vaywgYXJncyk7XG4gICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcbiAgICAgIGlmIChob29rLmV2ZXJ5KChob29rMikgPT4gaG9vazIubGVuZ3RoIDw9IDEpKVxuICAgICAgICBkb25lKCk7XG4gICAgfSBlbHNlIGlmIChob29rLmxlbmd0aCA8PSAxKSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBob29rcyA9IHtcbiAgICBtb2RlLFxuICAgIHBlcnNpc3RlZCxcbiAgICBiZWZvcmVFbnRlcihlbCkge1xuICAgICAgbGV0IGhvb2sgPSBvbkJlZm9yZUVudGVyO1xuICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgaWYgKGFwcGVhcikge1xuICAgICAgICAgIGhvb2sgPSBvbkJlZm9yZUFwcGVhciB8fCBvbkJlZm9yZUVudGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVsW2xlYXZlQ2JLZXldKSB7XG4gICAgICAgIGVsW2xlYXZlQ2JLZXldKFxuICAgICAgICAgIHRydWVcbiAgICAgICAgICAvKiBjYW5jZWxsZWQgKi9cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxlYXZpbmdWTm9kZSA9IGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldO1xuICAgICAgaWYgKGxlYXZpbmdWTm9kZSAmJiBpc1NhbWVWTm9kZVR5cGUodm5vZGUsIGxlYXZpbmdWTm9kZSkgJiYgbGVhdmluZ1ZOb2RlLmVsW2xlYXZlQ2JLZXldKSB7XG4gICAgICAgIGxlYXZpbmdWTm9kZS5lbFtsZWF2ZUNiS2V5XSgpO1xuICAgICAgfVxuICAgICAgY2FsbEhvb2soaG9vaywgW2VsXSk7XG4gICAgfSxcbiAgICBlbnRlcihlbCkge1xuICAgICAgbGV0IGhvb2sgPSBvbkVudGVyO1xuICAgICAgbGV0IGFmdGVySG9vayA9IG9uQWZ0ZXJFbnRlcjtcbiAgICAgIGxldCBjYW5jZWxIb29rID0gb25FbnRlckNhbmNlbGxlZDtcbiAgICAgIGlmICghc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICAgIGlmIChhcHBlYXIpIHtcbiAgICAgICAgICBob29rID0gb25BcHBlYXIgfHwgb25FbnRlcjtcbiAgICAgICAgICBhZnRlckhvb2sgPSBvbkFmdGVyQXBwZWFyIHx8IG9uQWZ0ZXJFbnRlcjtcbiAgICAgICAgICBjYW5jZWxIb29rID0gb25BcHBlYXJDYW5jZWxsZWQgfHwgb25FbnRlckNhbmNlbGxlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGRvbmUgPSBlbFtlbnRlckNiS2V5XSA9IChjYW5jZWxsZWQpID0+IHtcbiAgICAgICAgaWYgKGNhbGxlZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICBjYWxsSG9vayhjYW5jZWxIb29rLCBbZWxdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsSG9vayhhZnRlckhvb2ssIFtlbF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob29rcy5kZWxheWVkTGVhdmUpIHtcbiAgICAgICAgICBob29rcy5kZWxheWVkTGVhdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbFtlbnRlckNiS2V5XSA9IHZvaWQgMDtcbiAgICAgIH07XG4gICAgICBpZiAoaG9vaykge1xuICAgICAgICBjYWxsQXN5bmNIb29rKGhvb2ssIFtlbCwgZG9uZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbGVhdmUoZWwsIHJlbW92ZSkge1xuICAgICAgY29uc3Qga2V5MiA9IFN0cmluZyh2bm9kZS5rZXkpO1xuICAgICAgaWYgKGVsW2VudGVyQ2JLZXldKSB7XG4gICAgICAgIGVsW2VudGVyQ2JLZXldKFxuICAgICAgICAgIHRydWVcbiAgICAgICAgICAvKiBjYW5jZWxsZWQgKi9cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5pc1VubW91bnRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgY2FsbEhvb2sob25CZWZvcmVMZWF2ZSwgW2VsXSk7XG4gICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBkb25lID0gZWxbbGVhdmVDYktleV0gPSAoY2FuY2VsbGVkKSA9PiB7XG4gICAgICAgIGlmIChjYWxsZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmVDYW5jZWxsZWQsIFtlbF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxIb29rKG9uQWZ0ZXJMZWF2ZSwgW2VsXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxbbGVhdmVDYktleV0gPSB2b2lkIDA7XG4gICAgICAgIGlmIChsZWF2aW5nVk5vZGVzQ2FjaGVba2V5Ml0gPT09IHZub2RlKSB7XG4gICAgICAgICAgZGVsZXRlIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXkyXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXkyXSA9IHZub2RlO1xuICAgICAgaWYgKG9uTGVhdmUpIHtcbiAgICAgICAgY2FsbEFzeW5jSG9vayhvbkxlYXZlLCBbZWwsIGRvbmVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNsb25lKHZub2RlMikge1xuICAgICAgcmV0dXJuIHJlc29sdmVUcmFuc2l0aW9uSG9va3Modm5vZGUyLCBwcm9wcywgc3RhdGUsIGluc3RhbmNlKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBob29rcztcbn1cbmZ1bmN0aW9uIGVtcHR5UGxhY2Vob2xkZXIodm5vZGUpIHtcbiAgaWYgKGlzS2VlcEFsaXZlKHZub2RlKSkge1xuICAgIHZub2RlID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgdm5vZGUuY2hpbGRyZW4gPSBudWxsO1xuICAgIHJldHVybiB2bm9kZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0S2VlcEFsaXZlQ2hpbGQodm5vZGUpIHtcbiAgcmV0dXJuIGlzS2VlcEFsaXZlKHZub2RlKSA/IHZub2RlLmNoaWxkcmVuID8gdm5vZGUuY2hpbGRyZW5bMF0gOiB2b2lkIDAgOiB2bm9kZTtcbn1cbmZ1bmN0aW9uIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgaG9va3MpIHtcbiAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYgJiYgdm5vZGUuY29tcG9uZW50KSB7XG4gICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLCBob29rcyk7XG4gIH0gZWxzZSBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgdm5vZGUuc3NDb250ZW50LnRyYW5zaXRpb24gPSBob29rcy5jbG9uZSh2bm9kZS5zc0NvbnRlbnQpO1xuICAgIHZub2RlLnNzRmFsbGJhY2sudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzRmFsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHZub2RlLnRyYW5zaXRpb24gPSBob29rcztcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkcmVuLCBrZWVwQ29tbWVudCA9IGZhbHNlLCBwYXJlbnRLZXkpIHtcbiAgbGV0IHJldCA9IFtdO1xuICBsZXQga2V5ZWRGcmFnbWVudENvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGNvbnN0IGtleSA9IHBhcmVudEtleSA9PSBudWxsID8gY2hpbGQua2V5IDogU3RyaW5nKHBhcmVudEtleSkgKyBTdHJpbmcoY2hpbGQua2V5ICE9IG51bGwgPyBjaGlsZC5rZXkgOiBpKTtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICAgIGlmIChjaGlsZC5wYXRjaEZsYWcgJiAxMjgpXG4gICAgICAgIGtleWVkRnJhZ21lbnRDb3VudCsrO1xuICAgICAgcmV0ID0gcmV0LmNvbmNhdChcbiAgICAgICAgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkLmNoaWxkcmVuLCBrZWVwQ29tbWVudCwga2V5KVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGtlZXBDb21tZW50IHx8IGNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgIHJldC5wdXNoKGtleSAhPSBudWxsID8gY2xvbmVWTm9kZShjaGlsZCwgeyBrZXkgfSkgOiBjaGlsZCk7XG4gICAgfVxuICB9XG4gIGlmIChrZXllZEZyYWdtZW50Q291bnQgPiAxKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldFtpXS5wYXRjaEZsYWcgPSAtMjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZGVmaW5lQ29tcG9uZW50KG9wdGlvbnMsIGV4dHJhT3B0aW9ucykge1xuICByZXR1cm4gaXNGdW5jdGlvbihvcHRpb25zKSA/IChcbiAgICAvLyAjODMyNjogZXh0ZW5kIGNhbGwgYW5kIG9wdGlvbnMubmFtZSBhY2Nlc3MgYXJlIGNvbnNpZGVyZWQgc2lkZS1lZmZlY3RzXG4gICAgLy8gYnkgUm9sbHVwLCBzbyB3ZSBoYXZlIHRvIHdyYXAgaXQgaW4gYSBwdXJlLWFubm90YXRlZCBJSUZFLlxuICAgIC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZXh0ZW5kKHsgbmFtZTogb3B0aW9ucy5uYW1lIH0sIGV4dHJhT3B0aW9ucywgeyBzZXR1cDogb3B0aW9ucyB9KSkoKVxuICApIDogb3B0aW9ucztcbn1cblxuY29uc3QgaXNBc3luY1dyYXBwZXIgPSAoaSkgPT4gISFpLnR5cGUuX19hc3luY0xvYWRlcjtcbi8qISAjX19OT19TSURFX0VGRkVDVFNfXyAqL1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGRlZmluZUFzeW5jQ29tcG9uZW50KHNvdXJjZSkge1xuICBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XG4gICAgc291cmNlID0geyBsb2FkZXI6IHNvdXJjZSB9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBsb2FkZXIsXG4gICAgbG9hZGluZ0NvbXBvbmVudCxcbiAgICBlcnJvckNvbXBvbmVudCxcbiAgICBkZWxheSA9IDIwMCxcbiAgICB0aW1lb3V0LFxuICAgIC8vIHVuZGVmaW5lZCA9IG5ldmVyIHRpbWVzIG91dFxuICAgIHN1c3BlbnNpYmxlID0gdHJ1ZSxcbiAgICBvbkVycm9yOiB1c2VyT25FcnJvclxuICB9ID0gc291cmNlO1xuICBsZXQgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xuICBsZXQgcmVzb2x2ZWRDb21wO1xuICBsZXQgcmV0cmllcyA9IDA7XG4gIGNvbnN0IHJldHJ5ID0gKCkgPT4ge1xuICAgIHJldHJpZXMrKztcbiAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XG4gICAgcmV0dXJuIGxvYWQoKTtcbiAgfTtcbiAgY29uc3QgbG9hZCA9ICgpID0+IHtcbiAgICBsZXQgdGhpc1JlcXVlc3Q7XG4gICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0IHx8ICh0aGlzUmVxdWVzdCA9IHBlbmRpbmdSZXF1ZXN0ID0gbG9hZGVyKCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgZXJyID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIgOiBuZXcgRXJyb3IoU3RyaW5nKGVycikpO1xuICAgICAgaWYgKHVzZXJPbkVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY29uc3QgdXNlclJldHJ5ID0gKCkgPT4gcmVzb2x2ZShyZXRyeSgpKTtcbiAgICAgICAgICBjb25zdCB1c2VyRmFpbCA9ICgpID0+IHJlamVjdChlcnIpO1xuICAgICAgICAgIHVzZXJPbkVycm9yKGVyciwgdXNlclJldHJ5LCB1c2VyRmFpbCwgcmV0cmllcyArIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9KS50aGVuKChjb21wKSA9PiB7XG4gICAgICBpZiAodGhpc1JlcXVlc3QgIT09IHBlbmRpbmdSZXF1ZXN0ICYmIHBlbmRpbmdSZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBwZW5kaW5nUmVxdWVzdDtcbiAgICAgIH1cbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFjb21wKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYEFzeW5jIGNvbXBvbmVudCBsb2FkZXIgcmVzb2x2ZWQgdG8gdW5kZWZpbmVkLiBJZiB5b3UgYXJlIHVzaW5nIHJldHJ5KCksIG1ha2Ugc3VyZSB0byByZXR1cm4gaXRzIHJldHVybiB2YWx1ZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcCAmJiAoY29tcC5fX2VzTW9kdWxlIHx8IGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gXCJNb2R1bGVcIikpIHtcbiAgICAgICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgICAgIH1cbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNvbXAgJiYgIWlzT2JqZWN0KGNvbXApICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhc3luYyBjb21wb25lbnQgbG9hZCByZXN1bHQ6ICR7Y29tcH1gKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmVkQ29tcCA9IGNvbXA7XG4gICAgICByZXR1cm4gY29tcDtcbiAgICB9KSk7XG4gIH07XG4gIHJldHVybiBkZWZpbmVDb21wb25lbnQoe1xuICAgIG5hbWU6IFwiQXN5bmNDb21wb25lbnRXcmFwcGVyXCIsXG4gICAgX19hc3luY0xvYWRlcjogbG9hZCxcbiAgICBnZXQgX19hc3luY1Jlc29sdmVkKCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVkQ29tcDtcbiAgICB9LFxuICAgIHNldHVwKCkge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICBpZiAocmVzb2x2ZWRDb21wKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBjcmVhdGVJbm5lckNvbXAocmVzb2x2ZWRDb21wLCBpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xuICAgICAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XG4gICAgICAgIGhhbmRsZUVycm9yKFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAxMyxcbiAgICAgICAgICAhZXJyb3JDb21wb25lbnRcbiAgICAgICAgICAvKiBkbyBub3QgdGhyb3cgaW4gZGV2IGlmIHVzZXIgcHJvdmlkZWQgZXJyb3IgY29tcG9uZW50ICovXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgaWYgKHN1c3BlbnNpYmxlICYmIGluc3RhbmNlLnN1c3BlbnNlIHx8IGlzSW5TU1JDb21wb25lbnRTZXR1cCkge1xuICAgICAgICByZXR1cm4gbG9hZCgpLnRoZW4oKGNvbXApID0+IHtcbiAgICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKGNvbXAsIGluc3RhbmNlKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgICByZXR1cm4gKCkgPT4gZXJyb3JDb21wb25lbnQgPyBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xuICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgIH0pIDogbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBsb2FkZWQgPSByZWYoZmFsc2UpO1xuICAgICAgY29uc3QgZXJyb3IgPSByZWYoKTtcbiAgICAgIGNvbnN0IGRlbGF5ZWQgPSByZWYoISFkZWxheSk7XG4gICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgZGVsYXllZC52YWx1ZSA9IGZhbHNlO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICB9XG4gICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICghbG9hZGVkLnZhbHVlICYmICFlcnJvci52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgQXN5bmMgY29tcG9uZW50IHRpbWVkIG91dCBhZnRlciAke3RpbWVvdXR9bXMuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICB9XG4gICAgICBsb2FkKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGxvYWRlZC52YWx1ZSA9IHRydWU7XG4gICAgICAgIGlmIChpbnN0YW5jZS5wYXJlbnQgJiYgaXNLZWVwQWxpdmUoaW5zdGFuY2UucGFyZW50LnZub2RlKSkge1xuICAgICAgICAgIHF1ZXVlSm9iKGluc3RhbmNlLnBhcmVudC51cGRhdGUpO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgZXJyb3IudmFsdWUgPSBlcnI7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChsb2FkZWQudmFsdWUgJiYgcmVzb2x2ZWRDb21wKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvci52YWx1ZSAmJiBlcnJvckNvbXBvbmVudCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xuICAgICAgICAgICAgZXJyb3I6IGVycm9yLnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAobG9hZGluZ0NvbXBvbmVudCAmJiAhZGVsYXllZC52YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShsb2FkaW5nQ29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5uZXJDb21wKGNvbXAsIHBhcmVudCkge1xuICBjb25zdCB7IHJlZjogcmVmMiwgcHJvcHMsIGNoaWxkcmVuLCBjZSB9ID0gcGFyZW50LnZub2RlO1xuICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKGNvbXAsIHByb3BzLCBjaGlsZHJlbik7XG4gIHZub2RlLnJlZiA9IHJlZjI7XG4gIHZub2RlLmNlID0gY2U7XG4gIGRlbGV0ZSBwYXJlbnQudm5vZGUuY2U7XG4gIHJldHVybiB2bm9kZTtcbn1cblxuY29uc3QgaXNLZWVwQWxpdmUgPSAodm5vZGUpID0+IHZub2RlLnR5cGUuX19pc0tlZXBBbGl2ZTtcbmNvbnN0IEtlZXBBbGl2ZUltcGwgPSB7XG4gIG5hbWU6IGBLZWVwQWxpdmVgLFxuICAvLyBNYXJrZXIgZm9yIHNwZWNpYWwgaGFuZGxpbmcgaW5zaWRlIHRoZSByZW5kZXJlci4gV2UgYXJlIG5vdCB1c2luZyBhID09PVxuICAvLyBjaGVjayBkaXJlY3RseSBvbiBLZWVwQWxpdmUgaW4gdGhlIHJlbmRlcmVyLCBiZWNhdXNlIGltcG9ydGluZyBpdCBkaXJlY3RseVxuICAvLyB3b3VsZCBwcmV2ZW50IGl0IGZyb20gYmVpbmcgdHJlZS1zaGFrZW4uXG4gIF9faXNLZWVwQWxpdmU6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogW1N0cmluZywgUmVnRXhwLCBBcnJheV0sXG4gICAgZXhjbHVkZTogW1N0cmluZywgUmVnRXhwLCBBcnJheV0sXG4gICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gIH0sXG4gIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGNvbnN0IHNoYXJlZENvbnRleHQgPSBpbnN0YW5jZS5jdHg7XG4gICAgaWYgKCFzaGFyZWRDb250ZXh0LnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgc2xvdHMuZGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxID8gY2hpbGRyZW5bMF0gOiBjaGlsZHJlbjtcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBrZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsZXQgY3VycmVudCA9IG51bGw7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBpbnN0YW5jZS5fX3ZfY2FjaGUgPSBjYWNoZTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50U3VzcGVuc2UgPSBpbnN0YW5jZS5zdXNwZW5zZTtcbiAgICBjb25zdCB7XG4gICAgICByZW5kZXJlcjoge1xuICAgICAgICBwOiBwYXRjaCxcbiAgICAgICAgbTogbW92ZSxcbiAgICAgICAgdW06IF91bm1vdW50LFxuICAgICAgICBvOiB7IGNyZWF0ZUVsZW1lbnQgfVxuICAgICAgfVxuICAgIH0gPSBzaGFyZWRDb250ZXh0O1xuICAgIGNvbnN0IHN0b3JhZ2VDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHNoYXJlZENvbnRleHQuYWN0aXZhdGUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZTIgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgICBtb3ZlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgMCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgcGF0Y2goXG4gICAgICAgIGluc3RhbmNlMi52bm9kZSxcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBpbnN0YW5jZTIsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgdm5vZGUuc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpbnN0YW5jZTIuaXNEZWFjdGl2YXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoaW5zdGFuY2UyLmEpIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhpbnN0YW5jZTIuYSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdm5vZGVIb29rID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMub25Wbm9kZU1vdW50ZWQ7XG4gICAgICAgIGlmICh2bm9kZUhvb2spIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZTIucGFyZW50LCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlMik7XG4gICAgICB9XG4gICAgfTtcbiAgICBzaGFyZWRDb250ZXh0LmRlYWN0aXZhdGUgPSAodm5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlMiA9IHZub2RlLmNvbXBvbmVudDtcbiAgICAgIG1vdmUodm5vZGUsIHN0b3JhZ2VDb250YWluZXIsIG51bGwsIDEsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpbnN0YW5jZTIuZGEpIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhpbnN0YW5jZTIuZGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVVbm1vdW50ZWQ7XG4gICAgICAgIGlmICh2bm9kZUhvb2spIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZTIucGFyZW50LCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UyLmlzRGVhY3RpdmF0ZWQgPSB0cnVlO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHVubW91bnQodm5vZGUpIHtcbiAgICAgIHJlc2V0U2hhcGVGbGFnKHZub2RlKTtcbiAgICAgIF91bm1vdW50KHZub2RlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcnVuZUNhY2hlKGZpbHRlcikge1xuICAgICAgY2FjaGUuZm9yRWFjaCgodm5vZGUsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh2bm9kZS50eXBlKTtcbiAgICAgICAgaWYgKG5hbWUgJiYgKCFmaWx0ZXIgfHwgIWZpbHRlcihuYW1lKSkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeShrZXkpIHtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgaWYgKCFjdXJyZW50IHx8ICFpc1NhbWVWTm9kZVR5cGUoY2FjaGVkLCBjdXJyZW50KSkge1xuICAgICAgICB1bm1vdW50KGNhY2hlZCk7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgcmVzZXRTaGFwZUZsYWcoY3VycmVudCk7XG4gICAgICB9XG4gICAgICBjYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgIGtleXMuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIHdhdGNoKFxuICAgICAgKCkgPT4gW3Byb3BzLmluY2x1ZGUsIHByb3BzLmV4Y2x1ZGVdLFxuICAgICAgKFtpbmNsdWRlLCBleGNsdWRlXSkgPT4ge1xuICAgICAgICBpbmNsdWRlICYmIHBydW5lQ2FjaGUoKG5hbWUpID0+IG1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpO1xuICAgICAgICBleGNsdWRlICYmIHBydW5lQ2FjaGUoKG5hbWUpID0+ICFtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKTtcbiAgICAgIH0sXG4gICAgICAvLyBwcnVuZSBwb3N0LXJlbmRlciBhZnRlciBgY3VycmVudGAgaGFzIGJlZW4gdXBkYXRlZFxuICAgICAgeyBmbHVzaDogXCJwb3N0XCIsIGRlZXA6IHRydWUgfVxuICAgICk7XG4gICAgbGV0IHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XG4gICAgY29uc3QgY2FjaGVTdWJ0cmVlID0gKCkgPT4ge1xuICAgICAgaWYgKHBlbmRpbmdDYWNoZUtleSAhPSBudWxsKSB7XG4gICAgICAgIGNhY2hlLnNldChwZW5kaW5nQ2FjaGVLZXksIGdldElubmVyQ2hpbGQoaW5zdGFuY2Uuc3ViVHJlZSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgb25Nb3VudGVkKGNhY2hlU3VidHJlZSk7XG4gICAgb25VcGRhdGVkKGNhY2hlU3VidHJlZSk7XG4gICAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcbiAgICAgIGNhY2hlLmZvckVhY2goKGNhY2hlZCkgPT4ge1xuICAgICAgICBjb25zdCB7IHN1YlRyZWUsIHN1c3BlbnNlIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgY29uc3Qgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHN1YlRyZWUpO1xuICAgICAgICBpZiAoY2FjaGVkLnR5cGUgPT09IHZub2RlLnR5cGUgJiYgY2FjaGVkLmtleSA9PT0gdm5vZGUua2V5KSB7XG4gICAgICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xuICAgICAgICAgIGNvbnN0IGRhID0gdm5vZGUuY29tcG9uZW50LmRhO1xuICAgICAgICAgIGRhICYmIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkYSwgc3VzcGVuc2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1bm1vdW50KGNhY2hlZCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcbiAgICAgIGlmICghc2xvdHMuZGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCgpO1xuICAgICAgY29uc3QgcmF3Vk5vZGUgPSBjaGlsZHJlblswXTtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybihgS2VlcEFsaXZlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIGNvbXBvbmVudCBjaGlsZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgfSBlbHNlIGlmICghaXNWTm9kZShyYXdWTm9kZSkgfHwgIShyYXdWTm9kZS5zaGFwZUZsYWcgJiA0KSAmJiAhKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDEyOCkpIHtcbiAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiByYXdWTm9kZTtcbiAgICAgIH1cbiAgICAgIGxldCB2bm9kZSA9IGdldElubmVyQ2hpbGQocmF3Vk5vZGUpO1xuICAgICAgY29uc3QgY29tcCA9IHZub2RlLnR5cGU7XG4gICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShcbiAgICAgICAgaXNBc3luY1dyYXBwZXIodm5vZGUpID8gdm5vZGUudHlwZS5fX2FzeW5jUmVzb2x2ZWQgfHwge30gOiBjb21wXG4gICAgICApO1xuICAgICAgY29uc3QgeyBpbmNsdWRlLCBleGNsdWRlLCBtYXggfSA9IHByb3BzO1xuICAgICAgaWYgKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSB8fCBleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSkge1xuICAgICAgICBjdXJyZW50ID0gdm5vZGU7XG4gICAgICAgIHJldHVybiByYXdWTm9kZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleSA9IHZub2RlLmtleSA9PSBudWxsID8gY29tcCA6IHZub2RlLmtleTtcbiAgICAgIGNvbnN0IGNhY2hlZFZOb2RlID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICBpZiAodm5vZGUuZWwpIHtcbiAgICAgICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICAgICAgaWYgKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgICAgIHJhd1ZOb2RlLnNzQ29udGVudCA9IHZub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwZW5kaW5nQ2FjaGVLZXkgPSBrZXk7XG4gICAgICBpZiAoY2FjaGVkVk5vZGUpIHtcbiAgICAgICAgdm5vZGUuZWwgPSBjYWNoZWRWTm9kZS5lbDtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50ID0gY2FjaGVkVk5vZGUuY29tcG9uZW50O1xuICAgICAgICBpZiAodm5vZGUudHJhbnNpdGlvbikge1xuICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgdm5vZGUudHJhbnNpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IDUxMjtcbiAgICAgICAga2V5cy5kZWxldGUoa2V5KTtcbiAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICAgIGlmIChtYXggJiYga2V5cy5zaXplID4gcGFyc2VJbnQobWF4LCAxMCkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoa2V5cy52YWx1ZXMoKS5uZXh0KCkudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gMjU2O1xuICAgICAgY3VycmVudCA9IHZub2RlO1xuICAgICAgcmV0dXJuIGlzU3VzcGVuc2UocmF3Vk5vZGUudHlwZSkgPyByYXdWTm9kZSA6IHZub2RlO1xuICAgIH07XG4gIH1cbn07XG5jb25zdCBLZWVwQWxpdmUgPSBLZWVwQWxpdmVJbXBsO1xuZnVuY3Rpb24gbWF0Y2hlcyhwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChpc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc29tZSgocCkgPT4gbWF0Y2hlcyhwLCBuYW1lKSk7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdChcIixcIikuaW5jbHVkZXMobmFtZSk7XG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG9uQWN0aXZhdGVkKGhvb2ssIHRhcmdldCkge1xuICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJhXCIsIHRhcmdldCk7XG59XG5mdW5jdGlvbiBvbkRlYWN0aXZhdGVkKGhvb2ssIHRhcmdldCkge1xuICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJkYVwiLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIHR5cGUsIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xuICBjb25zdCB3cmFwcGVkSG9vayA9IGhvb2suX193ZGMgfHwgKGhvb2suX193ZGMgPSAoKSA9PiB7XG4gICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQ7XG4gICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgIGlmIChjdXJyZW50LmlzRGVhY3RpdmF0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gaG9vaygpO1xuICB9KTtcbiAgaW5qZWN0SG9vayh0eXBlLCB3cmFwcGVkSG9vaywgdGFyZ2V0KTtcbiAgaWYgKHRhcmdldCkge1xuICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0LnBhcmVudDtcbiAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50LnBhcmVudCkge1xuICAgICAgaWYgKGlzS2VlcEFsaXZlKGN1cnJlbnQucGFyZW50LnZub2RlKSkge1xuICAgICAgICBpbmplY3RUb0tlZXBBbGl2ZVJvb3Qod3JhcHBlZEhvb2ssIHR5cGUsIHRhcmdldCwgY3VycmVudCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpbmplY3RUb0tlZXBBbGl2ZVJvb3QoaG9vaywgdHlwZSwgdGFyZ2V0LCBrZWVwQWxpdmVSb290KSB7XG4gIGNvbnN0IGluamVjdGVkID0gaW5qZWN0SG9vayhcbiAgICB0eXBlLFxuICAgIGhvb2ssXG4gICAga2VlcEFsaXZlUm9vdCxcbiAgICB0cnVlXG4gICAgLyogcHJlcGVuZCAqL1xuICApO1xuICBvblVubW91bnRlZCgoKSA9PiB7XG4gICAgcmVtb3ZlKGtlZXBBbGl2ZVJvb3RbdHlwZV0sIGluamVjdGVkKTtcbiAgfSwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIHJlc2V0U2hhcGVGbGFnKHZub2RlKSB7XG4gIHZub2RlLnNoYXBlRmxhZyAmPSB+MjU2O1xuICB2bm9kZS5zaGFwZUZsYWcgJj0gfjUxMjtcbn1cbmZ1bmN0aW9uIGdldElubmVyQ2hpbGQodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLnNoYXBlRmxhZyAmIDEyOCA/IHZub2RlLnNzQ29udGVudCA6IHZub2RlO1xufVxuXG5mdW5jdGlvbiBpbmplY3RIb29rKHR5cGUsIGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSwgcHJlcGVuZCA9IGZhbHNlKSB7XG4gIGlmICh0YXJnZXQpIHtcbiAgICBjb25zdCBob29rcyA9IHRhcmdldFt0eXBlXSB8fCAodGFyZ2V0W3R5cGVdID0gW10pO1xuICAgIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dlaCB8fCAoaG9vay5fX3dlaCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICBpZiAodGFyZ2V0LmlzVW5tb3VudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgIHNldEN1cnJlbnRJbnN0YW5jZSh0YXJnZXQpO1xuICAgICAgY29uc3QgcmVzID0gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgdGFyZ2V0LCB0eXBlLCBhcmdzKTtcbiAgICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICAgIGlmIChwcmVwZW5kKSB7XG4gICAgICBob29rcy51bnNoaWZ0KHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaG9va3MucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfVxuICAgIHJldHVybiB3cmFwcGVkSG9vaztcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgYXBpTmFtZSA9IHRvSGFuZGxlcktleShFcnJvclR5cGVTdHJpbmdzW3R5cGVdLnJlcGxhY2UoLyBob29rJC8sIFwiXCIpKTtcbiAgICB3YXJuKFxuICAgICAgYCR7YXBpTmFtZX0gaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZSB0byBiZSBhc3NvY2lhdGVkIHdpdGguIExpZmVjeWNsZSBpbmplY3Rpb24gQVBJcyBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBleGVjdXRpb24gb2Ygc2V0dXAoKS5gICsgKGAgSWYgeW91IGFyZSB1c2luZyBhc3luYyBzZXR1cCgpLCBtYWtlIHN1cmUgdG8gcmVnaXN0ZXIgbGlmZWN5Y2xlIGhvb2tzIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQgc3RhdGVtZW50LmAgKVxuICAgICk7XG4gIH1cbn1cbmNvbnN0IGNyZWF0ZUhvb2sgPSAobGlmZWN5Y2xlKSA9PiAoaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSA9PiAoXG4gIC8vIHBvc3QtY3JlYXRlIGxpZmVjeWNsZSByZWdpc3RyYXRpb25zIGFyZSBub29wcyBkdXJpbmcgU1NSIChleGNlcHQgZm9yIHNlcnZlclByZWZldGNoKVxuICAoIWlzSW5TU1JDb21wb25lbnRTZXR1cCB8fCBsaWZlY3ljbGUgPT09IFwic3BcIikgJiYgaW5qZWN0SG9vayhsaWZlY3ljbGUsICguLi5hcmdzKSA9PiBob29rKC4uLmFyZ3MpLCB0YXJnZXQpXG4pO1xuY29uc3Qgb25CZWZvcmVNb3VudCA9IGNyZWF0ZUhvb2soXCJibVwiKTtcbmNvbnN0IG9uTW91bnRlZCA9IGNyZWF0ZUhvb2soXCJtXCIpO1xuY29uc3Qgb25CZWZvcmVVcGRhdGUgPSBjcmVhdGVIb29rKFwiYnVcIik7XG5jb25zdCBvblVwZGF0ZWQgPSBjcmVhdGVIb29rKFwidVwiKTtcbmNvbnN0IG9uQmVmb3JlVW5tb3VudCA9IGNyZWF0ZUhvb2soXCJidW1cIik7XG5jb25zdCBvblVubW91bnRlZCA9IGNyZWF0ZUhvb2soXCJ1bVwiKTtcbmNvbnN0IG9uU2VydmVyUHJlZmV0Y2ggPSBjcmVhdGVIb29rKFwic3BcIik7XG5jb25zdCBvblJlbmRlclRyaWdnZXJlZCA9IGNyZWF0ZUhvb2soXG4gIFwicnRnXCJcbik7XG5jb25zdCBvblJlbmRlclRyYWNrZWQgPSBjcmVhdGVIb29rKFxuICBcInJ0Y1wiXG4pO1xuZnVuY3Rpb24gb25FcnJvckNhcHR1cmVkKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xuICBpbmplY3RIb29rKFwiZWNcIiwgaG9vaywgdGFyZ2V0KTtcbn1cblxuY29uc3QgQ09NUE9ORU5UUyA9IFwiY29tcG9uZW50c1wiO1xuY29uc3QgRElSRUNUSVZFUyA9IFwiZGlyZWN0aXZlc1wiO1xuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudChuYW1lLCBtYXliZVNlbGZSZWZlcmVuY2UpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldChDT01QT05FTlRTLCBuYW1lLCB0cnVlLCBtYXliZVNlbGZSZWZlcmVuY2UpIHx8IG5hbWU7XG59XG5jb25zdCBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UID0gU3ltYm9sLmZvcihcInYtbmRjXCIpO1xuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIGlmIChpc1N0cmluZyhjb21wb25lbnQpKSB7XG4gICAgcmV0dXJuIHJlc29sdmVBc3NldChDT01QT05FTlRTLCBjb21wb25lbnQsIGZhbHNlKSB8fCBjb21wb25lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudCB8fCBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlRGlyZWN0aXZlKG5hbWUpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldChESVJFQ1RJVkVTLCBuYW1lKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCh0eXBlLCBuYW1lLCB3YXJuTWlzc2luZyA9IHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSA9IGZhbHNlKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIHx8IGN1cnJlbnRJbnN0YW5jZTtcbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcbiAgICBpZiAodHlwZSA9PT0gQ09NUE9ORU5UUykge1xuICAgICAgY29uc3Qgc2VsZk5hbWUgPSBnZXRDb21wb25lbnROYW1lKFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIGZhbHNlXG4gICAgICAgIC8qIGRvIG5vdCBpbmNsdWRlIGluZmVycmVkIG5hbWUgdG8gYXZvaWQgYnJlYWtpbmcgZXhpc3RpbmcgY29kZSAqL1xuICAgICAgKTtcbiAgICAgIGlmIChzZWxmTmFtZSAmJiAoc2VsZk5hbWUgPT09IG5hbWUgfHwgc2VsZk5hbWUgPT09IGNhbWVsaXplKG5hbWUpIHx8IHNlbGZOYW1lID09PSBjYXBpdGFsaXplKGNhbWVsaXplKG5hbWUpKSkpIHtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzID0gKFxuICAgICAgLy8gbG9jYWwgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBjaGVjayBpbnN0YW5jZVt0eXBlXSBmaXJzdCB3aGljaCBpcyByZXNvbHZlZCBmb3Igb3B0aW9ucyBBUElcbiAgICAgIHJlc29sdmUoaW5zdGFuY2VbdHlwZV0gfHwgQ29tcG9uZW50W3R5cGVdLCBuYW1lKSB8fCAvLyBnbG9iYWwgcmVnaXN0cmF0aW9uXG4gICAgICByZXNvbHZlKGluc3RhbmNlLmFwcENvbnRleHRbdHlwZV0sIG5hbWUpXG4gICAgKTtcbiAgICBpZiAoIXJlcyAmJiBtYXliZVNlbGZSZWZlcmVuY2UpIHtcbiAgICAgIHJldHVybiBDb21wb25lbnQ7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICAgIGNvbnN0IGV4dHJhID0gdHlwZSA9PT0gQ09NUE9ORU5UUyA/IGBcbklmIHRoaXMgaXMgYSBuYXRpdmUgY3VzdG9tIGVsZW1lbnQsIG1ha2Ugc3VyZSB0byBleGNsdWRlIGl0IGZyb20gY29tcG9uZW50IHJlc29sdXRpb24gdmlhIGNvbXBpbGVyT3B0aW9ucy5pc0N1c3RvbUVsZW1lbnQuYCA6IGBgO1xuICAgICAgd2FybihgRmFpbGVkIHRvIHJlc29sdmUgJHt0eXBlLnNsaWNlKDAsIC0xKX06ICR7bmFtZX0ke2V4dHJhfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuKFxuICAgICAgYHJlc29sdmUke2NhcGl0YWxpemUodHlwZS5zbGljZSgwLCAtMSkpfSBjYW4gb25seSBiZSB1c2VkIGluIHJlbmRlcigpIG9yIHNldHVwKCkuYFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmUocmVnaXN0cnksIG5hbWUpIHtcbiAgcmV0dXJuIHJlZ2lzdHJ5ICYmIChyZWdpc3RyeVtuYW1lXSB8fCByZWdpc3RyeVtjYW1lbGl6ZShuYW1lKV0gfHwgcmVnaXN0cnlbY2FwaXRhbGl6ZShjYW1lbGl6ZShuYW1lKSldKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTGlzdChzb3VyY2UsIHJlbmRlckl0ZW0sIGNhY2hlLCBpbmRleCkge1xuICBsZXQgcmV0O1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZSAmJiBjYWNoZVtpbmRleF07XG4gIGlmIChpc0FycmF5KHNvdXJjZSkgfHwgaXNTdHJpbmcoc291cmNlKSkge1xuICAgIHJldCA9IG5ldyBBcnJheShzb3VyY2UubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oc291cmNlW2ldLCBpLCB2b2lkIDAsIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIU51bWJlci5pc0ludGVnZXIoc291cmNlKSkge1xuICAgICAgd2FybihgVGhlIHYtZm9yIHJhbmdlIGV4cGVjdCBhbiBpbnRlZ2VyIHZhbHVlIGJ1dCBnb3QgJHtzb3VyY2V9LmApO1xuICAgIH1cbiAgICByZXQgPSBuZXcgQXJyYXkoc291cmNlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZTsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXJJdGVtKGkgKyAxLCBpLCB2b2lkIDAsIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgaWYgKHNvdXJjZVtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICByZXQgPSBBcnJheS5mcm9tKFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIChpdGVtLCBpKSA9PiByZW5kZXJJdGVtKGl0ZW0sIGksIHZvaWQgMCwgY2FjaGVkICYmIGNhY2hlZFtpXSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShzb3VyY2Vba2V5XSwga2V5LCBpLCBjYWNoZWQgJiYgY2FjaGVkW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0ID0gW107XG4gIH1cbiAgaWYgKGNhY2hlKSB7XG4gICAgY2FjaGVbaW5kZXhdID0gcmV0O1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNsb3RzKHNsb3RzLCBkeW5hbWljU2xvdHMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljU2xvdHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzbG90ID0gZHluYW1pY1Nsb3RzW2ldO1xuICAgIGlmIChpc0FycmF5KHNsb3QpKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNsb3QubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc2xvdHNbc2xvdFtqXS5uYW1lXSA9IHNsb3Rbal0uZm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzbG90KSB7XG4gICAgICBzbG90c1tzbG90Lm5hbWVdID0gc2xvdC5rZXkgPyAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCByZXMgPSBzbG90LmZuKC4uLmFyZ3MpO1xuICAgICAgICBpZiAocmVzKVxuICAgICAgICAgIHJlcy5rZXkgPSBzbG90LmtleTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0gOiBzbG90LmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2xvdHM7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclNsb3Qoc2xvdHMsIG5hbWUsIHByb3BzID0ge30sIGZhbGxiYWNrLCBub1Nsb3R0ZWQpIHtcbiAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5pc0NFIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5wYXJlbnQgJiYgaXNBc3luY1dyYXBwZXIoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudCkgJiYgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudC5pc0NFKSB7XG4gICAgaWYgKG5hbWUgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgcHJvcHMubmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFwic2xvdFwiLCBwcm9wcywgZmFsbGJhY2sgJiYgZmFsbGJhY2soKSk7XG4gIH1cbiAgbGV0IHNsb3QgPSBzbG90c1tuYW1lXTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2xvdCAmJiBzbG90Lmxlbmd0aCA+IDEpIHtcbiAgICB3YXJuKFxuICAgICAgYFNTUi1vcHRpbWl6ZWQgc2xvdCBmdW5jdGlvbiBkZXRlY3RlZCBpbiBhIG5vbi1TU1Itb3B0aW1pemVkIHJlbmRlciBmdW5jdGlvbi4gWW91IG5lZWQgdG8gbWFyayB0aGlzIGNvbXBvbmVudCB3aXRoICRkeW5hbWljLXNsb3RzIGluIHRoZSBwYXJlbnQgdGVtcGxhdGUuYFxuICAgICk7XG4gICAgc2xvdCA9ICgpID0+IFtdO1xuICB9XG4gIGlmIChzbG90ICYmIHNsb3QuX2MpIHtcbiAgICBzbG90Ll9kID0gZmFsc2U7XG4gIH1cbiAgb3BlbkJsb2NrKCk7XG4gIGNvbnN0IHZhbGlkU2xvdENvbnRlbnQgPSBzbG90ICYmIGVuc3VyZVZhbGlkVk5vZGUoc2xvdChwcm9wcykpO1xuICBjb25zdCByZW5kZXJlZCA9IGNyZWF0ZUJsb2NrKFxuICAgIEZyYWdtZW50LFxuICAgIHtcbiAgICAgIGtleTogcHJvcHMua2V5IHx8IC8vIHNsb3QgY29udGVudCBhcnJheSBvZiBhIGR5bmFtaWMgY29uZGl0aW9uYWwgc2xvdCBtYXkgaGF2ZSBhIGJyYW5jaFxuICAgICAgLy8ga2V5IGF0dGFjaGVkIGluIHRoZSBgY3JlYXRlU2xvdHNgIGhlbHBlciwgcmVzcGVjdCB0aGF0XG4gICAgICB2YWxpZFNsb3RDb250ZW50ICYmIHZhbGlkU2xvdENvbnRlbnQua2V5IHx8IGBfJHtuYW1lfWBcbiAgICB9LFxuICAgIHZhbGlkU2xvdENvbnRlbnQgfHwgKGZhbGxiYWNrID8gZmFsbGJhY2soKSA6IFtdKSxcbiAgICB2YWxpZFNsb3RDb250ZW50ICYmIHNsb3RzLl8gPT09IDEgPyA2NCA6IC0yXG4gICk7XG4gIGlmICghbm9TbG90dGVkICYmIHJlbmRlcmVkLnNjb3BlSWQpIHtcbiAgICByZW5kZXJlZC5zbG90U2NvcGVJZHMgPSBbcmVuZGVyZWQuc2NvcGVJZCArIFwiLXNcIl07XG4gIH1cbiAgaWYgKHNsb3QgJiYgc2xvdC5fYykge1xuICAgIHNsb3QuX2QgPSB0cnVlO1xuICB9XG4gIHJldHVybiByZW5kZXJlZDtcbn1cbmZ1bmN0aW9uIGVuc3VyZVZhbGlkVk5vZGUodm5vZGVzKSB7XG4gIHJldHVybiB2bm9kZXMuc29tZSgoY2hpbGQpID0+IHtcbiAgICBpZiAoIWlzVk5vZGUoY2hpbGQpKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IENvbW1lbnQpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50ICYmICFlbnN1cmVWYWxpZFZOb2RlKGNoaWxkLmNoaWxkcmVuKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSkgPyB2bm9kZXMgOiBudWxsO1xufVxuXG5mdW5jdGlvbiB0b0hhbmRsZXJzKG9iaiwgcHJlc2VydmVDYXNlSWZOZWNlc3NhcnkpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc09iamVjdChvYmopKSB7XG4gICAgd2Fybihgdi1vbiB3aXRoIG5vIGFyZ3VtZW50IGV4cGVjdHMgYW4gb2JqZWN0IHZhbHVlLmApO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgcmV0W3ByZXNlcnZlQ2FzZUlmTmVjZXNzYXJ5ICYmIC9bQS1aXS8udGVzdChrZXkpID8gYG9uOiR7a2V5fWAgOiB0b0hhbmRsZXJLZXkoa2V5KV0gPSBvYmpba2V5XTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5jb25zdCBnZXRQdWJsaWNJbnN0YW5jZSA9IChpKSA9PiB7XG4gIGlmICghaSlcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKGlzU3RhdGVmdWxDb21wb25lbnQoaSkpXG4gICAgcmV0dXJuIGdldEV4cG9zZVByb3h5KGkpIHx8IGkucHJveHk7XG4gIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShpLnBhcmVudCk7XG59O1xuY29uc3QgcHVibGljUHJvcGVydGllc01hcCA9IChcbiAgLy8gTW92ZSBQVVJFIG1hcmtlciB0byBuZXcgbGluZSB0byB3b3JrYXJvdW5kIGNvbXBpbGVyIGRpc2NhcmRpbmcgaXRcbiAgLy8gZHVlIHRvIHR5cGUgYW5ub3RhdGlvblxuICAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgJDogKGkpID0+IGksXG4gICAgJGVsOiAoaSkgPT4gaS52bm9kZS5lbCxcbiAgICAkZGF0YTogKGkpID0+IGkuZGF0YSxcbiAgICAkcHJvcHM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkucHJvcHMpIDogaS5wcm9wcyxcbiAgICAkYXR0cnM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkuYXR0cnMpIDogaS5hdHRycyxcbiAgICAkc2xvdHM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkuc2xvdHMpIDogaS5zbG90cyxcbiAgICAkcmVmczogKGkpID0+ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaS5yZWZzKSA6IGkucmVmcyxcbiAgICAkcGFyZW50OiAoaSkgPT4gZ2V0UHVibGljSW5zdGFuY2UoaS5wYXJlbnQpLFxuICAgICRyb290OiAoaSkgPT4gZ2V0UHVibGljSW5zdGFuY2UoaS5yb290KSxcbiAgICAkZW1pdDogKGkpID0+IGkuZW1pdCxcbiAgICAkb3B0aW9uczogKGkpID0+IF9fVlVFX09QVElPTlNfQVBJX18gPyByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpKSA6IGkudHlwZSxcbiAgICAkZm9yY2VVcGRhdGU6IChpKSA9PiBpLmYgfHwgKGkuZiA9ICgpID0+IHF1ZXVlSm9iKGkudXBkYXRlKSksXG4gICAgJG5leHRUaWNrOiAoaSkgPT4gaS5uIHx8IChpLm4gPSBuZXh0VGljay5iaW5kKGkucHJveHkpKSxcbiAgICAkd2F0Y2g6IChpKSA9PiBfX1ZVRV9PUFRJT05TX0FQSV9fID8gaW5zdGFuY2VXYXRjaC5iaW5kKGkpIDogTk9PUFxuICB9KVxuKTtcbmNvbnN0IGlzUmVzZXJ2ZWRQcmVmaXggPSAoa2V5KSA9PiBrZXkgPT09IFwiX1wiIHx8IGtleSA9PT0gXCIkXCI7XG5jb25zdCBoYXNTZXR1cEJpbmRpbmcgPSAoc3RhdGUsIGtleSkgPT4gc3RhdGUgIT09IEVNUFRZX09CSiAmJiAhc3RhdGUuX19pc1NjcmlwdFNldHVwICYmIGhhc093bihzdGF0ZSwga2V5KTtcbmNvbnN0IFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyA9IHtcbiAgZ2V0KHsgXzogaW5zdGFuY2UgfSwga2V5KSB7XG4gICAgY29uc3QgeyBjdHgsIHNldHVwU3RhdGUsIGRhdGEsIHByb3BzLCBhY2Nlc3NDYWNoZSwgdHlwZSwgYXBwQ29udGV4dCB9ID0gaW5zdGFuY2U7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5ID09PSBcIl9faXNWdWVcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBub3JtYWxpemVkUHJvcHM7XG4gICAgaWYgKGtleVswXSAhPT0gXCIkXCIpIHtcbiAgICAgIGNvbnN0IG4gPSBhY2Nlc3NDYWNoZVtrZXldO1xuICAgICAgaWYgKG4gIT09IHZvaWQgMCkge1xuICAgICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgICBjYXNlIDEgLyogU0VUVVAgKi86XG4gICAgICAgICAgICByZXR1cm4gc2V0dXBTdGF0ZVtrZXldO1xuICAgICAgICAgIGNhc2UgMiAvKiBEQVRBICovOlxuICAgICAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcbiAgICAgICAgICBjYXNlIDQgLyogQ09OVEVYVCAqLzpcbiAgICAgICAgICAgIHJldHVybiBjdHhba2V5XTtcbiAgICAgICAgICBjYXNlIDMgLyogUFJPUFMgKi86XG4gICAgICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSkge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMSAvKiBTRVRVUCAqLztcbiAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAyIC8qIERBVEEgKi87XG4gICAgICAgIHJldHVybiBkYXRhW2tleV07XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAvLyBvbmx5IGNhY2hlIG90aGVyIHByb3BlcnRpZXMgd2hlbiBpbnN0YW5jZSBoYXMgZGVjbGFyZWQgKHRodXMgc3RhYmxlKVxuICAgICAgICAvLyBwcm9wc1xuICAgICAgICAobm9ybWFsaXplZFByb3BzID0gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdKSAmJiBoYXNPd24obm9ybWFsaXplZFByb3BzLCBrZXkpXG4gICAgICApIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDMgLyogUFJPUFMgKi87XG4gICAgICAgIHJldHVybiBwcm9wc1trZXldO1xuICAgICAgfSBlbHNlIGlmIChjdHggIT09IEVNUFRZX09CSiAmJiBoYXNPd24oY3R4LCBrZXkpKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSA0IC8qIENPTlRFWFQgKi87XG4gICAgICAgIHJldHVybiBjdHhba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoIV9fVlVFX09QVElPTlNfQVBJX18gfHwgc2hvdWxkQ2FjaGVBY2Nlc3MpIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDAgLyogT1RIRVIgKi87XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0dldHRlciA9IHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XTtcbiAgICBsZXQgY3NzTW9kdWxlLCBnbG9iYWxQcm9wZXJ0aWVzO1xuICAgIGlmIChwdWJsaWNHZXR0ZXIpIHtcbiAgICAgIGlmIChrZXkgPT09IFwiJGF0dHJzXCIpIHtcbiAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIsIGtleSk7XG4gICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXkgPT09IFwiJHNsb3RzXCIpIHtcbiAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHVibGljR2V0dGVyKGluc3RhbmNlKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLy8gY3NzIG1vZHVsZSAoaW5qZWN0ZWQgYnkgdnVlLWxvYWRlcilcbiAgICAgIChjc3NNb2R1bGUgPSB0eXBlLl9fY3NzTW9kdWxlcykgJiYgKGNzc01vZHVsZSA9IGNzc01vZHVsZVtrZXldKVxuICAgICkge1xuICAgICAgcmV0dXJuIGNzc01vZHVsZTtcbiAgICB9IGVsc2UgaWYgKGN0eCAhPT0gRU1QVFlfT0JKICYmIGhhc093bihjdHgsIGtleSkpIHtcbiAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSA0IC8qIENPTlRFWFQgKi87XG4gICAgICByZXR1cm4gY3R4W2tleV07XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIC8vIGdsb2JhbCBwcm9wZXJ0aWVzXG4gICAgICBnbG9iYWxQcm9wZXJ0aWVzID0gYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcywgaGFzT3duKGdsb2JhbFByb3BlcnRpZXMsIGtleSlcbiAgICApIHtcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFByb3BlcnRpZXNba2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlICYmICghaXNTdHJpbmcoa2V5KSB8fCAvLyAjMTA5MSBhdm9pZCBpbnRlcm5hbCBpc1JlZi9pc1ZOb2RlIGNoZWNrcyBvbiBjb21wb25lbnQgaW5zdGFuY2UgbGVhZGluZ1xuICAgIC8vIHRvIGluZmluaXRlIHdhcm5pbmcgbG9vcFxuICAgIGtleS5pbmRleE9mKFwiX192XCIpICE9PSAwKSkge1xuICAgICAgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBpc1Jlc2VydmVkUHJlZml4KGtleVswXSkgJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIGtleVxuICAgICAgICAgICl9IG11c3QgYmUgYWNjZXNzZWQgdmlhICRkYXRhIGJlY2F1c2UgaXQgc3RhcnRzIHdpdGggYSByZXNlcnZlZCBjaGFyYWN0ZXIgKFwiJFwiIG9yIFwiX1wiKSBhbmQgaXMgbm90IHByb3hpZWQgb24gdGhlIHJlbmRlciBjb250ZXh0LmBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UgPT09IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IHdhcyBhY2Nlc3NlZCBkdXJpbmcgcmVuZGVyIGJ1dCBpcyBub3QgZGVmaW5lZCBvbiBpbnN0YW5jZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzZXQoeyBfOiBpbnN0YW5jZSB9LCBrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgeyBkYXRhLCBzZXR1cFN0YXRlLCBjdHggfSA9IGluc3RhbmNlO1xuICAgIGlmIChoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSkge1xuICAgICAgc2V0dXBTdGF0ZVtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXAgJiYgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHtcbiAgICAgIHdhcm4oYENhbm5vdCBtdXRhdGUgPHNjcmlwdCBzZXR1cD4gYmluZGluZyBcIiR7a2V5fVwiIGZyb20gT3B0aW9ucyBBUEkuYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcbiAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChoYXNPd24oaW5zdGFuY2UucHJvcHMsIGtleSkpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHJvcCBcIiR7a2V5fVwiLiBQcm9wcyBhcmUgcmVhZG9ubHkuYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChrZXlbMF0gPT09IFwiJFwiICYmIGtleS5zbGljZSgxKSBpbiBpbnN0YW5jZSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgICBgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHVibGljIHByb3BlcnR5IFwiJHtrZXl9XCIuIFByb3BlcnRpZXMgc3RhcnRpbmcgd2l0aCAkIGFyZSByZXNlcnZlZCBhbmQgcmVhZG9ubHkuYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5IGluIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHhba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgaGFzKHtcbiAgICBfOiB7IGRhdGEsIHNldHVwU3RhdGUsIGFjY2Vzc0NhY2hlLCBjdHgsIGFwcENvbnRleHQsIHByb3BzT3B0aW9ucyB9XG4gIH0sIGtleSkge1xuICAgIGxldCBub3JtYWxpemVkUHJvcHM7XG4gICAgcmV0dXJuICEhYWNjZXNzQ2FjaGVba2V5XSB8fCBkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkgfHwgaGFzU2V0dXBCaW5kaW5nKHNldHVwU3RhdGUsIGtleSkgfHwgKG5vcm1hbGl6ZWRQcm9wcyA9IHByb3BzT3B0aW9uc1swXSkgJiYgaGFzT3duKG5vcm1hbGl6ZWRQcm9wcywga2V5KSB8fCBoYXNPd24oY3R4LCBrZXkpIHx8IGhhc093bihwdWJsaWNQcm9wZXJ0aWVzTWFwLCBrZXkpIHx8IGhhc093bihhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLCBrZXkpO1xuICB9LFxuICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgIGlmIChkZXNjcmlwdG9yLmdldCAhPSBudWxsKSB7XG4gICAgICB0YXJnZXQuXy5hY2Nlc3NDYWNoZVtrZXldID0gMDtcbiAgICB9IGVsc2UgaWYgKGhhc093bihkZXNjcmlwdG9yLCBcInZhbHVlXCIpKSB7XG4gICAgICB0aGlzLnNldCh0YXJnZXQsIGtleSwgZGVzY3JpcHRvci52YWx1ZSwgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufTtcbmlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRydWUpIHtcbiAgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLm93bktleXMgPSAodGFyZ2V0KSA9PiB7XG4gICAgd2FybihcbiAgICAgIGBBdm9pZCBhcHAgbG9naWMgdGhhdCByZWxpZXMgb24gZW51bWVyYXRpbmcga2V5cyBvbiBhIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhlIGtleXMgd2lsbCBiZSBlbXB0eSBpbiBwcm9kdWN0aW9uIG1vZGUgdG8gYXZvaWQgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQuYFxuICAgICk7XG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xuICB9O1xufVxuY29uc3QgUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIGV4dGVuZChcbiAge30sXG4gIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyxcbiAge1xuICAgIGdldCh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKGtleSA9PT0gU3ltYm9sLnVuc2NvcGFibGVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMuZ2V0KHRhcmdldCwga2V5LCB0YXJnZXQpO1xuICAgIH0sXG4gICAgaGFzKF8sIGtleSkge1xuICAgICAgY29uc3QgaGFzID0ga2V5WzBdICE9PSBcIl9cIiAmJiAhaXNHbG9iYWxseUFsbG93ZWQoa2V5KTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFoYXMgJiYgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLmhhcyhfLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICBrZXlcbiAgICAgICAgICApfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXyB3aGljaCBpcyBhIHJlc2VydmVkIHByZWZpeCBmb3IgVnVlIGludGVybmFscy5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzO1xuICAgIH1cbiAgfVxuKTtcbmZ1bmN0aW9uIGNyZWF0ZURldlJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcbiAgY29uc3QgdGFyZ2V0ID0ge307XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGBfYCwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQ6ICgpID0+IGluc3RhbmNlXG4gIH0pO1xuICBPYmplY3Qua2V5cyhwdWJsaWNQcm9wZXJ0aWVzTWFwKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiAoKSA9PiBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV0oaW5zdGFuY2UpLFxuICAgICAgLy8gaW50ZXJjZXB0ZWQgYnkgdGhlIHByb3h5IHNvIG5vIG5lZWQgZm9yIGltcGxlbWVudGF0aW9uLFxuICAgICAgLy8gYnV0IG5lZWRlZCB0byBwcmV2ZW50IHNldCBlcnJvcnNcbiAgICAgIHNldDogTk9PUFxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGV4cG9zZVByb3BzT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XG4gIGNvbnN0IHtcbiAgICBjdHgsXG4gICAgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXVxuICB9ID0gaW5zdGFuY2U7XG4gIGlmIChwcm9wc09wdGlvbnMpIHtcbiAgICBPYmplY3Qua2V5cyhwcm9wc09wdGlvbnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBpbnN0YW5jZS5wcm9wc1trZXldLFxuICAgICAgICBzZXQ6IE5PT1BcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBleHBvc2VTZXR1cFN0YXRlT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XG4gIGNvbnN0IHsgY3R4LCBzZXR1cFN0YXRlIH0gPSBpbnN0YW5jZTtcbiAgT2JqZWN0LmtleXModG9SYXcoc2V0dXBTdGF0ZSkpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmICghc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXApIHtcbiAgICAgIGlmIChpc1Jlc2VydmVkUHJlZml4KGtleVswXSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgc2V0dXAoKSByZXR1cm4gcHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIGtleVxuICAgICAgICAgICl9IHNob3VsZCBub3Qgc3RhcnQgd2l0aCBcIiRcIiBvciBcIl9cIiB3aGljaCBhcmUgcmVzZXJ2ZWQgcHJlZml4ZXMgZm9yIFZ1ZSBpbnRlcm5hbHMuYFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHNldHVwU3RhdGVba2V5XSxcbiAgICAgICAgc2V0OiBOT09QXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5jb25zdCB3YXJuUnVudGltZVVzYWdlID0gKG1ldGhvZCkgPT4gd2FybihcbiAgYCR7bWV0aG9kfSgpIGlzIGEgY29tcGlsZXItaGludCBoZWxwZXIgdGhhdCBpcyBvbmx5IHVzYWJsZSBpbnNpZGUgPHNjcmlwdCBzZXR1cD4gb2YgYSBzaW5nbGUgZmlsZSBjb21wb25lbnQuIEl0cyBhcmd1bWVudHMgc2hvdWxkIGJlIGNvbXBpbGVkIGF3YXkgYW5kIHBhc3NpbmcgaXQgYXQgcnVudGltZSBoYXMgbm8gZWZmZWN0LmBcbik7XG5mdW5jdGlvbiBkZWZpbmVQcm9wcygpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVQcm9wc2ApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGVmaW5lRW1pdHMoKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lRW1pdHNgKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGRlZmluZUV4cG9zZShleHBvc2VkKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lRXhwb3NlYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZmluZU9wdGlvbnMob3B0aW9ucykge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZU9wdGlvbnNgKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVmaW5lU2xvdHMoKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lU2xvdHNgKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGRlZmluZU1vZGVsKCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoXCJkZWZpbmVNb2RlbFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gd2l0aERlZmF1bHRzKHByb3BzLCBkZWZhdWx0cykge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYHdpdGhEZWZhdWx0c2ApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdXNlU2xvdHMoKSB7XG4gIHJldHVybiBnZXRDb250ZXh0KCkuc2xvdHM7XG59XG5mdW5jdGlvbiB1c2VBdHRycygpIHtcbiAgcmV0dXJuIGdldENvbnRleHQoKS5hdHRycztcbn1cbmZ1bmN0aW9uIHVzZU1vZGVsKHByb3BzLCBuYW1lLCBvcHRpb25zKSB7XG4gIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWkpIHtcbiAgICB3YXJuKGB1c2VNb2RlbCgpIGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBpbnN0YW5jZS5gKTtcbiAgICByZXR1cm4gcmVmKCk7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWkucHJvcHNPcHRpb25zWzBdW25hbWVdKSB7XG4gICAgd2FybihgdXNlTW9kZWwoKSBjYWxsZWQgd2l0aCBwcm9wIFwiJHtuYW1lfVwiIHdoaWNoIGlzIG5vdCBkZWNsYXJlZC5gKTtcbiAgICByZXR1cm4gcmVmKCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5sb2NhbCkge1xuICAgIGNvbnN0IHByb3h5ID0gcmVmKHByb3BzW25hbWVdKTtcbiAgICB3YXRjaChcbiAgICAgICgpID0+IHByb3BzW25hbWVdLFxuICAgICAgKHYpID0+IHByb3h5LnZhbHVlID0gdlxuICAgICk7XG4gICAgd2F0Y2gocHJveHksICh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHZhbHVlICE9PSBwcm9wc1tuYW1lXSkge1xuICAgICAgICBpLmVtaXQoYHVwZGF0ZToke25hbWV9YCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwcm94eTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgX192X2lzUmVmOiB0cnVlLFxuICAgICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gcHJvcHNbbmFtZV07XG4gICAgICB9LFxuICAgICAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGkuZW1pdChgdXBkYXRlOiR7bmFtZX1gLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcbiAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaSkge1xuICAgIHdhcm4oYHVzZUNvbnRleHQoKSBjYWxsZWQgd2l0aG91dCBhY3RpdmUgaW5zdGFuY2UuYCk7XG4gIH1cbiAgcmV0dXJuIGkuc2V0dXBDb250ZXh0IHx8IChpLnNldHVwQ29udGV4dCA9IGNyZWF0ZVNldHVwQ29udGV4dChpKSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wc09yRW1pdHMocHJvcHMpIHtcbiAgcmV0dXJuIGlzQXJyYXkocHJvcHMpID8gcHJvcHMucmVkdWNlKFxuICAgIChub3JtYWxpemVkLCBwKSA9PiAobm9ybWFsaXplZFtwXSA9IG51bGwsIG5vcm1hbGl6ZWQpLFxuICAgIHt9XG4gICkgOiBwcm9wcztcbn1cbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdHMocmF3LCBkZWZhdWx0cykge1xuICBjb25zdCBwcm9wcyA9IG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhyYXcpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBkZWZhdWx0cykge1xuICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIl9fc2tpcFwiKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGxldCBvcHQgPSBwcm9wc1trZXldO1xuICAgIGlmIChvcHQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpKSB7XG4gICAgICAgIG9wdCA9IHByb3BzW2tleV0gPSB7IHR5cGU6IG9wdCwgZGVmYXVsdDogZGVmYXVsdHNba2V5XSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0LmRlZmF1bHQgPSBkZWZhdWx0c1trZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0ID09PSBudWxsKSB7XG4gICAgICBvcHQgPSBwcm9wc1trZXldID0geyBkZWZhdWx0OiBkZWZhdWx0c1trZXldIH07XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKGBwcm9wcyBkZWZhdWx0IGtleSBcIiR7a2V5fVwiIGhhcyBubyBjb3JyZXNwb25kaW5nIGRlY2xhcmF0aW9uLmApO1xuICAgIH1cbiAgICBpZiAob3B0ICYmIGRlZmF1bHRzW2BfX3NraXBfJHtrZXl9YF0pIHtcbiAgICAgIG9wdC5za2lwRmFjdG9yeSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wcztcbn1cbmZ1bmN0aW9uIG1lcmdlTW9kZWxzKGEsIGIpIHtcbiAgaWYgKCFhIHx8ICFiKVxuICAgIHJldHVybiBhIHx8IGI7XG4gIGlmIChpc0FycmF5KGEpICYmIGlzQXJyYXkoYikpXG4gICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICByZXR1cm4gZXh0ZW5kKHt9LCBub3JtYWxpemVQcm9wc09yRW1pdHMoYSksIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhiKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVQcm9wc1Jlc3RQcm94eShwcm9wcywgZXhjbHVkZWRLZXlzKSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgIGlmICghZXhjbHVkZWRLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXQsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHByb3BzW2tleV1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gd2l0aEFzeW5jQ29udGV4dChnZXRBd2FpdGFibGUpIHtcbiAgY29uc3QgY3R4ID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFjdHgpIHtcbiAgICB3YXJuKFxuICAgICAgYHdpdGhBc3luY0NvbnRleHQgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGN1cnJlbnQgaW5zdGFuY2UuIFRoaXMgaXMgbGlrZWx5IGEgYnVnLmBcbiAgICApO1xuICB9XG4gIGxldCBhd2FpdGFibGUgPSBnZXRBd2FpdGFibGUoKTtcbiAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKGlzUHJvbWlzZShhd2FpdGFibGUpKSB7XG4gICAgYXdhaXRhYmxlID0gYXdhaXRhYmxlLmNhdGNoKChlKSA9PiB7XG4gICAgICBzZXRDdXJyZW50SW5zdGFuY2UoY3R4KTtcbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFthd2FpdGFibGUsICgpID0+IHNldEN1cnJlbnRJbnN0YW5jZShjdHgpXTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIHtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuICh0eXBlLCBrZXkpID0+IHtcbiAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgd2FybihgJHt0eXBlfSBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiAke2NhY2hlW2tleV19LmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZVtrZXldID0gdHlwZTtcbiAgICB9XG4gIH07XG59XG5sZXQgc2hvdWxkQ2FjaGVBY2Nlc3MgPSB0cnVlO1xuZnVuY3Rpb24gYXBwbHlPcHRpb25zKGluc3RhbmNlKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSk7XG4gIGNvbnN0IHB1YmxpY1RoaXMgPSBpbnN0YW5jZS5wcm94eTtcbiAgY29uc3QgY3R4ID0gaW5zdGFuY2UuY3R4O1xuICBzaG91bGRDYWNoZUFjY2VzcyA9IGZhbHNlO1xuICBpZiAob3B0aW9ucy5iZWZvcmVDcmVhdGUpIHtcbiAgICBjYWxsSG9vayhvcHRpb25zLmJlZm9yZUNyZWF0ZSwgaW5zdGFuY2UsIFwiYmNcIik7XG4gIH1cbiAgY29uc3Qge1xuICAgIC8vIHN0YXRlXG4gICAgZGF0YTogZGF0YU9wdGlvbnMsXG4gICAgY29tcHV0ZWQ6IGNvbXB1dGVkT3B0aW9ucyxcbiAgICBtZXRob2RzLFxuICAgIHdhdGNoOiB3YXRjaE9wdGlvbnMsXG4gICAgcHJvdmlkZTogcHJvdmlkZU9wdGlvbnMsXG4gICAgaW5qZWN0OiBpbmplY3RPcHRpb25zLFxuICAgIC8vIGxpZmVjeWNsZVxuICAgIGNyZWF0ZWQsXG4gICAgYmVmb3JlTW91bnQsXG4gICAgbW91bnRlZCxcbiAgICBiZWZvcmVVcGRhdGUsXG4gICAgdXBkYXRlZCxcbiAgICBhY3RpdmF0ZWQsXG4gICAgZGVhY3RpdmF0ZWQsXG4gICAgYmVmb3JlRGVzdHJveSxcbiAgICBiZWZvcmVVbm1vdW50LFxuICAgIGRlc3Ryb3llZCxcbiAgICB1bm1vdW50ZWQsXG4gICAgcmVuZGVyLFxuICAgIHJlbmRlclRyYWNrZWQsXG4gICAgcmVuZGVyVHJpZ2dlcmVkLFxuICAgIGVycm9yQ2FwdHVyZWQsXG4gICAgc2VydmVyUHJlZmV0Y2gsXG4gICAgLy8gcHVibGljIEFQSVxuICAgIGV4cG9zZSxcbiAgICBpbmhlcml0QXR0cnMsXG4gICAgLy8gYXNzZXRzXG4gICAgY29tcG9uZW50cyxcbiAgICBkaXJlY3RpdmVzLFxuICAgIGZpbHRlcnNcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBjcmVhdGVEdXBsaWNhdGVDaGVja2VyKCkgOiBudWxsO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IFtwcm9wc09wdGlvbnNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xuICAgIGlmIChwcm9wc09wdGlvbnMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzT3B0aW9ucykge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJQcm9wc1wiIC8qIFBST1BTICovLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoaW5qZWN0T3B0aW9ucykge1xuICAgIHJlc29sdmVJbmplY3Rpb25zKGluamVjdE9wdGlvbnMsIGN0eCwgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKTtcbiAgfVxuICBpZiAobWV0aG9kcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGNvbnN0IG1ldGhvZEhhbmRsZXIgPSBtZXRob2RzW2tleV07XG4gICAgICBpZiAoaXNGdW5jdGlvbihtZXRob2RIYW5kbGVyKSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IG1ldGhvZEhhbmRsZXIuYmluZChwdWJsaWNUaGlzKSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eFtrZXldID0gbWV0aG9kSGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiTWV0aG9kc1wiIC8qIE1FVEhPRFMgKi8sIGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBNZXRob2QgXCIke2tleX1cIiBoYXMgdHlwZSBcIiR7dHlwZW9mIG1ldGhvZEhhbmRsZXJ9XCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P2BcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGRhdGFPcHRpb25zKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzRnVuY3Rpb24oZGF0YU9wdGlvbnMpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgVGhlIGRhdGEgb3B0aW9uIG11c3QgYmUgYSBmdW5jdGlvbi4gUGxhaW4gb2JqZWN0IHVzYWdlIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGRhdGFPcHRpb25zLmNhbGwocHVibGljVGhpcywgcHVibGljVGhpcyk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNQcm9taXNlKGRhdGEpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgZGF0YSgpIHJldHVybmVkIGEgUHJvbWlzZSAtIG5vdGUgZGF0YSgpIGNhbm5vdCBiZSBhc3luYzsgSWYgeW91IGludGVuZCB0byBwZXJmb3JtIGRhdGEgZmV0Y2hpbmcgYmVmb3JlIGNvbXBvbmVudCByZW5kZXJzLCB1c2UgYXN5bmMgc2V0dXAoKSArIDxTdXNwZW5zZT4uYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGBkYXRhKCkgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLmRhdGEgPSByZWFjdGl2ZShkYXRhKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJEYXRhXCIgLyogREFUQSAqLywga2V5KTtcbiAgICAgICAgICBpZiAoIWlzUmVzZXJ2ZWRQcmVmaXgoa2V5WzBdKSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBkYXRhW2tleV0sXG4gICAgICAgICAgICAgIHNldDogTk9PUFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNob3VsZENhY2hlQWNjZXNzID0gdHJ1ZTtcbiAgaWYgKGNvbXB1dGVkT3B0aW9ucykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkT3B0aW9ucykge1xuICAgICAgY29uc3Qgb3B0ID0gY29tcHV0ZWRPcHRpb25zW2tleV07XG4gICAgICBjb25zdCBnZXQgPSBpc0Z1bmN0aW9uKG9wdCkgPyBvcHQuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKSA6IGlzRnVuY3Rpb24ob3B0LmdldCkgPyBvcHQuZ2V0LmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcykgOiBOT09QO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgZ2V0ID09PSBOT09QKSB7XG4gICAgICAgIHdhcm4oYENvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaGFzIG5vIGdldHRlci5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNldCA9ICFpc0Z1bmN0aW9uKG9wdCkgJiYgaXNGdW5jdGlvbihvcHQuc2V0KSA/IG9wdC5zZXQuYmluZChwdWJsaWNUaGlzKSA6ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyAoKSA9PiB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYFdyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgcmVhZG9ubHkuYFxuICAgICAgICApO1xuICAgICAgfSA6IE5PT1A7XG4gICAgICBjb25zdCBjID0gY29tcHV0ZWQoe1xuICAgICAgICBnZXQsXG4gICAgICAgIHNldFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IGMudmFsdWUsXG4gICAgICAgIHNldDogKHYpID0+IGMudmFsdWUgPSB2XG4gICAgICB9KTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkNvbXB1dGVkXCIgLyogQ09NUFVURUQgKi8sIGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh3YXRjaE9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB3YXRjaE9wdGlvbnMpIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIod2F0Y2hPcHRpb25zW2tleV0sIGN0eCwgcHVibGljVGhpcywga2V5KTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb3ZpZGVPcHRpb25zKSB7XG4gICAgY29uc3QgcHJvdmlkZXMgPSBpc0Z1bmN0aW9uKHByb3ZpZGVPcHRpb25zKSA/IHByb3ZpZGVPcHRpb25zLmNhbGwocHVibGljVGhpcykgOiBwcm92aWRlT3B0aW9ucztcbiAgICBSZWZsZWN0Lm93bktleXMocHJvdmlkZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgcHJvdmlkZShrZXksIHByb3ZpZGVzW2tleV0pO1xuICAgIH0pO1xuICB9XG4gIGlmIChjcmVhdGVkKSB7XG4gICAgY2FsbEhvb2soY3JlYXRlZCwgaW5zdGFuY2UsIFwiY1wiKTtcbiAgfVxuICBmdW5jdGlvbiByZWdpc3RlckxpZmVjeWNsZUhvb2socmVnaXN0ZXIsIGhvb2spIHtcbiAgICBpZiAoaXNBcnJheShob29rKSkge1xuICAgICAgaG9vay5mb3JFYWNoKChfaG9vaykgPT4gcmVnaXN0ZXIoX2hvb2suYmluZChwdWJsaWNUaGlzKSkpO1xuICAgIH0gZWxzZSBpZiAoaG9vaykge1xuICAgICAgcmVnaXN0ZXIoaG9vay5iaW5kKHB1YmxpY1RoaXMpKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlTW91bnQsIGJlZm9yZU1vdW50KTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uTW91bnRlZCwgbW91bnRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZVVwZGF0ZSwgYmVmb3JlVXBkYXRlKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uVXBkYXRlZCwgdXBkYXRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkFjdGl2YXRlZCwgYWN0aXZhdGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uRGVhY3RpdmF0ZWQsIGRlYWN0aXZhdGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uRXJyb3JDYXB0dXJlZCwgZXJyb3JDYXB0dXJlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblJlbmRlclRyYWNrZWQsIHJlbmRlclRyYWNrZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25SZW5kZXJUcmlnZ2VyZWQsIHJlbmRlclRyaWdnZXJlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZVVubW91bnQsIGJlZm9yZVVubW91bnQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25Vbm1vdW50ZWQsIHVubW91bnRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblNlcnZlclByZWZldGNoLCBzZXJ2ZXJQcmVmZXRjaCk7XG4gIGlmIChpc0FycmF5KGV4cG9zZSkpIHtcbiAgICBpZiAoZXhwb3NlLmxlbmd0aCkge1xuICAgICAgY29uc3QgZXhwb3NlZCA9IGluc3RhbmNlLmV4cG9zZWQgfHwgKGluc3RhbmNlLmV4cG9zZWQgPSB7fSk7XG4gICAgICBleHBvc2UuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvc2VkLCBrZXksIHtcbiAgICAgICAgICBnZXQ6ICgpID0+IHB1YmxpY1RoaXNba2V5XSxcbiAgICAgICAgICBzZXQ6ICh2YWwpID0+IHB1YmxpY1RoaXNba2V5XSA9IHZhbFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIWluc3RhbmNlLmV4cG9zZWQpIHtcbiAgICAgIGluc3RhbmNlLmV4cG9zZWQgPSB7fTtcbiAgICB9XG4gIH1cbiAgaWYgKHJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIgPT09IE5PT1ApIHtcbiAgICBpbnN0YW5jZS5yZW5kZXIgPSByZW5kZXI7XG4gIH1cbiAgaWYgKGluaGVyaXRBdHRycyAhPSBudWxsKSB7XG4gICAgaW5zdGFuY2UuaW5oZXJpdEF0dHJzID0gaW5oZXJpdEF0dHJzO1xuICB9XG4gIGlmIChjb21wb25lbnRzKVxuICAgIGluc3RhbmNlLmNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICBpZiAoZGlyZWN0aXZlcylcbiAgICBpbnN0YW5jZS5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbn1cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3Rpb25zKGluamVjdE9wdGlvbnMsIGN0eCwgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzID0gTk9PUCkge1xuICBpZiAoaXNBcnJheShpbmplY3RPcHRpb25zKSkge1xuICAgIGluamVjdE9wdGlvbnMgPSBub3JtYWxpemVJbmplY3QoaW5qZWN0T3B0aW9ucyk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gaW5qZWN0T3B0aW9ucykge1xuICAgIGNvbnN0IG9wdCA9IGluamVjdE9wdGlvbnNba2V5XTtcbiAgICBsZXQgaW5qZWN0ZWQ7XG4gICAgaWYgKGlzT2JqZWN0KG9wdCkpIHtcbiAgICAgIGlmIChcImRlZmF1bHRcIiBpbiBvcHQpIHtcbiAgICAgICAgaW5qZWN0ZWQgPSBpbmplY3QoXG4gICAgICAgICAgb3B0LmZyb20gfHwga2V5LFxuICAgICAgICAgIG9wdC5kZWZhdWx0LFxuICAgICAgICAgIHRydWVcbiAgICAgICAgICAvKiB0cmVhdCBkZWZhdWx0IGZ1bmN0aW9uIGFzIGZhY3RvcnkgKi9cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluamVjdGVkID0gaW5qZWN0KG9wdC5mcm9tIHx8IGtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluamVjdGVkID0gaW5qZWN0KG9wdCk7XG4gICAgfVxuICAgIGlmIChpc1JlZihpbmplY3RlZCkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gaW5qZWN0ZWQudmFsdWUsXG4gICAgICAgIHNldDogKHYpID0+IGluamVjdGVkLnZhbHVlID0gdlxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eFtrZXldID0gaW5qZWN0ZWQ7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJJbmplY3RcIiAvKiBJTkpFQ1QgKi8sIGtleSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjYWxsSG9vayhob29rLCBpbnN0YW5jZSwgdHlwZSkge1xuICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICBpc0FycmF5KGhvb2spID8gaG9vay5tYXAoKGgpID0+IGguYmluZChpbnN0YW5jZS5wcm94eSkpIDogaG9vay5iaW5kKGluc3RhbmNlLnByb3h5KSxcbiAgICBpbnN0YW5jZSxcbiAgICB0eXBlXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyKHJhdywgY3R4LCBwdWJsaWNUaGlzLCBrZXkpIHtcbiAgY29uc3QgZ2V0dGVyID0ga2V5LmluY2x1ZGVzKFwiLlwiKSA/IGNyZWF0ZVBhdGhHZXR0ZXIocHVibGljVGhpcywga2V5KSA6ICgpID0+IHB1YmxpY1RoaXNba2V5XTtcbiAgaWYgKGlzU3RyaW5nKHJhdykpIHtcbiAgICBjb25zdCBoYW5kbGVyID0gY3R4W3Jhd107XG4gICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICAgIHdhdGNoKGdldHRlciwgaGFuZGxlcik7XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3fVwiYCwgaGFuZGxlcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocmF3KSkge1xuICAgIHdhdGNoKGdldHRlciwgcmF3LmJpbmQocHVibGljVGhpcykpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHJhdykpIHtcbiAgICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgICByYXcuZm9yRWFjaCgocikgPT4gY3JlYXRlV2F0Y2hlcihyLCBjdHgsIHB1YmxpY1RoaXMsIGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gaXNGdW5jdGlvbihyYXcuaGFuZGxlcikgPyByYXcuaGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpIDogY3R4W3Jhdy5oYW5kbGVyXTtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICAgIHdhdGNoKGdldHRlciwgaGFuZGxlciwgcmF3KTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB3YXJuKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3LmhhbmRsZXJ9XCJgLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggb3B0aW9uOiBcIiR7a2V5fVwiYCwgcmF3KTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpIHtcbiAgY29uc3QgYmFzZSA9IGluc3RhbmNlLnR5cGU7XG4gIGNvbnN0IHsgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucyB9ID0gYmFzZTtcbiAgY29uc3Qge1xuICAgIG1peGluczogZ2xvYmFsTWl4aW5zLFxuICAgIG9wdGlvbnNDYWNoZTogY2FjaGUsXG4gICAgY29uZmlnOiB7IG9wdGlvbk1lcmdlU3RyYXRlZ2llcyB9XG4gIH0gPSBpbnN0YW5jZS5hcHBDb250ZXh0O1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoYmFzZSk7XG4gIGxldCByZXNvbHZlZDtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJlc29sdmVkID0gY2FjaGVkO1xuICB9IGVsc2UgaWYgKCFnbG9iYWxNaXhpbnMubGVuZ3RoICYmICFtaXhpbnMgJiYgIWV4dGVuZHNPcHRpb25zKSB7XG4gICAge1xuICAgICAgcmVzb2x2ZWQgPSBiYXNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXNvbHZlZCA9IHt9O1xuICAgIGlmIChnbG9iYWxNaXhpbnMubGVuZ3RoKSB7XG4gICAgICBnbG9iYWxNaXhpbnMuZm9yRWFjaChcbiAgICAgICAgKG0pID0+IG1lcmdlT3B0aW9ucyhyZXNvbHZlZCwgbSwgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzLCB0cnVlKVxuICAgICAgKTtcbiAgICB9XG4gICAgbWVyZ2VPcHRpb25zKHJlc29sdmVkLCBiYXNlLCBvcHRpb25NZXJnZVN0cmF0ZWdpZXMpO1xuICB9XG4gIGlmIChpc09iamVjdChiYXNlKSkge1xuICAgIGNhY2hlLnNldChiYXNlLCByZXNvbHZlZCk7XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVkO1xufVxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHRvLCBmcm9tLCBzdHJhdHMsIGFzTWl4aW4gPSBmYWxzZSkge1xuICBjb25zdCB7IG1peGlucywgZXh0ZW5kczogZXh0ZW5kc09wdGlvbnMgfSA9IGZyb207XG4gIGlmIChleHRlbmRzT3B0aW9ucykge1xuICAgIG1lcmdlT3B0aW9ucyh0bywgZXh0ZW5kc09wdGlvbnMsIHN0cmF0cywgdHJ1ZSk7XG4gIH1cbiAgaWYgKG1peGlucykge1xuICAgIG1peGlucy5mb3JFYWNoKFxuICAgICAgKG0pID0+IG1lcmdlT3B0aW9ucyh0bywgbSwgc3RyYXRzLCB0cnVlKVxuICAgICk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xuICAgIGlmIChhc01peGluICYmIGtleSA9PT0gXCJleHBvc2VcIikge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgICBgXCJleHBvc2VcIiBvcHRpb24gaXMgaWdub3JlZCB3aGVuIGRlY2xhcmVkIGluIG1peGlucyBvciBleHRlbmRzLiBJdCBzaG91bGQgb25seSBiZSBkZWNsYXJlZCBpbiB0aGUgYmFzZSBjb21wb25lbnQgaXRzZWxmLmBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0cmF0ID0gaW50ZXJuYWxPcHRpb25NZXJnZVN0cmF0c1trZXldIHx8IHN0cmF0cyAmJiBzdHJhdHNba2V5XTtcbiAgICAgIHRvW2tleV0gPSBzdHJhdCA/IHN0cmF0KHRvW2tleV0sIGZyb21ba2V5XSkgOiBmcm9tW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cbmNvbnN0IGludGVybmFsT3B0aW9uTWVyZ2VTdHJhdHMgPSB7XG4gIGRhdGE6IG1lcmdlRGF0YUZuLFxuICBwcm9wczogbWVyZ2VFbWl0c09yUHJvcHNPcHRpb25zLFxuICBlbWl0czogbWVyZ2VFbWl0c09yUHJvcHNPcHRpb25zLFxuICAvLyBvYmplY3RzXG4gIG1ldGhvZHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgY29tcHV0ZWQ6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgLy8gbGlmZWN5Y2xlXG4gIGJlZm9yZUNyZWF0ZTogbWVyZ2VBc0FycmF5LFxuICBjcmVhdGVkOiBtZXJnZUFzQXJyYXksXG4gIGJlZm9yZU1vdW50OiBtZXJnZUFzQXJyYXksXG4gIG1vdW50ZWQ6IG1lcmdlQXNBcnJheSxcbiAgYmVmb3JlVXBkYXRlOiBtZXJnZUFzQXJyYXksXG4gIHVwZGF0ZWQ6IG1lcmdlQXNBcnJheSxcbiAgYmVmb3JlRGVzdHJveTogbWVyZ2VBc0FycmF5LFxuICBiZWZvcmVVbm1vdW50OiBtZXJnZUFzQXJyYXksXG4gIGRlc3Ryb3llZDogbWVyZ2VBc0FycmF5LFxuICB1bm1vdW50ZWQ6IG1lcmdlQXNBcnJheSxcbiAgYWN0aXZhdGVkOiBtZXJnZUFzQXJyYXksXG4gIGRlYWN0aXZhdGVkOiBtZXJnZUFzQXJyYXksXG4gIGVycm9yQ2FwdHVyZWQ6IG1lcmdlQXNBcnJheSxcbiAgc2VydmVyUHJlZmV0Y2g6IG1lcmdlQXNBcnJheSxcbiAgLy8gYXNzZXRzXG4gIGNvbXBvbmVudHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgZGlyZWN0aXZlczogbWVyZ2VPYmplY3RPcHRpb25zLFxuICAvLyB3YXRjaFxuICB3YXRjaDogbWVyZ2VXYXRjaE9wdGlvbnMsXG4gIC8vIHByb3ZpZGUgLyBpbmplY3RcbiAgcHJvdmlkZTogbWVyZ2VEYXRhRm4sXG4gIGluamVjdDogbWVyZ2VJbmplY3Rcbn07XG5mdW5jdGlvbiBtZXJnZURhdGFGbih0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHtcbiAgICByZXR1cm4gdG87XG4gIH1cbiAgaWYgKCF0bykge1xuICAgIHJldHVybiBmcm9tO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4oKSB7XG4gICAgcmV0dXJuIChleHRlbmQpKFxuICAgICAgaXNGdW5jdGlvbih0bykgPyB0by5jYWxsKHRoaXMsIHRoaXMpIDogdG8sXG4gICAgICBpc0Z1bmN0aW9uKGZyb20pID8gZnJvbS5jYWxsKHRoaXMsIHRoaXMpIDogZnJvbVxuICAgICk7XG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZUluamVjdCh0bywgZnJvbSkge1xuICByZXR1cm4gbWVyZ2VPYmplY3RPcHRpb25zKG5vcm1hbGl6ZUluamVjdCh0byksIG5vcm1hbGl6ZUluamVjdChmcm9tKSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QocmF3KSB7XG4gIGlmIChpc0FycmF5KHJhdykpIHtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzW3Jhd1tpXV0gPSByYXdbaV07XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgcmV0dXJuIHJhdztcbn1cbmZ1bmN0aW9uIG1lcmdlQXNBcnJheSh0bywgZnJvbSkge1xuICByZXR1cm4gdG8gPyBbLi4ubmV3IFNldChbXS5jb25jYXQodG8sIGZyb20pKV0gOiBmcm9tO1xufVxuZnVuY3Rpb24gbWVyZ2VPYmplY3RPcHRpb25zKHRvLCBmcm9tKSB7XG4gIHJldHVybiB0byA/IGV4dGVuZCgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdG8sIGZyb20pIDogZnJvbTtcbn1cbmZ1bmN0aW9uIG1lcmdlRW1pdHNPclByb3BzT3B0aW9ucyh0bywgZnJvbSkge1xuICBpZiAodG8pIHtcbiAgICBpZiAoaXNBcnJheSh0bykgJiYgaXNBcnJheShmcm9tKSkge1xuICAgICAgcmV0dXJuIFsuLi4vKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4udG8sIC4uLmZyb21dKV07XG4gICAgfVxuICAgIHJldHVybiBleHRlbmQoXG4gICAgICAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyh0byksXG4gICAgICBub3JtYWxpemVQcm9wc09yRW1pdHMoZnJvbSAhPSBudWxsID8gZnJvbSA6IHt9KVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZyb207XG4gIH1cbn1cbmZ1bmN0aW9uIG1lcmdlV2F0Y2hPcHRpb25zKHRvLCBmcm9tKSB7XG4gIGlmICghdG8pXG4gICAgcmV0dXJuIGZyb207XG4gIGlmICghZnJvbSlcbiAgICByZXR1cm4gdG87XG4gIGNvbnN0IG1lcmdlZCA9IGV4dGVuZCgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdG8pO1xuICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XG4gICAgbWVyZ2VkW2tleV0gPSBtZXJnZUFzQXJyYXkodG9ba2V5XSwgZnJvbVtrZXldKTtcbiAgfVxuICByZXR1cm4gbWVyZ2VkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBcHBDb250ZXh0KCkge1xuICByZXR1cm4ge1xuICAgIGFwcDogbnVsbCxcbiAgICBjb25maWc6IHtcbiAgICAgIGlzTmF0aXZlVGFnOiBOTyxcbiAgICAgIHBlcmZvcm1hbmNlOiBmYWxzZSxcbiAgICAgIGdsb2JhbFByb3BlcnRpZXM6IHt9LFxuICAgICAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiB7fSxcbiAgICAgIGVycm9ySGFuZGxlcjogdm9pZCAwLFxuICAgICAgd2FybkhhbmRsZXI6IHZvaWQgMCxcbiAgICAgIGNvbXBpbGVyT3B0aW9uczoge31cbiAgICB9LFxuICAgIG1peGluczogW10sXG4gICAgY29tcG9uZW50czoge30sXG4gICAgZGlyZWN0aXZlczoge30sXG4gICAgcHJvdmlkZXM6IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIG9wdGlvbnNDYWNoZTogLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksXG4gICAgcHJvcHNDYWNoZTogLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksXG4gICAgZW1pdHNDYWNoZTogLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKClcbiAgfTtcbn1cbmxldCB1aWQkMSA9IDA7XG5mdW5jdGlvbiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBcHAocm9vdENvbXBvbmVudCwgcm9vdFByb3BzID0gbnVsbCkge1xuICAgIGlmICghaXNGdW5jdGlvbihyb290Q29tcG9uZW50KSkge1xuICAgICAgcm9vdENvbXBvbmVudCA9IGV4dGVuZCh7fSwgcm9vdENvbXBvbmVudCk7XG4gICAgfVxuICAgIGlmIChyb290UHJvcHMgIT0gbnVsbCAmJiAhaXNPYmplY3Qocm9vdFByb3BzKSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGByb290IHByb3BzIHBhc3NlZCB0byBhcHAubW91bnQoKSBtdXN0IGJlIGFuIG9iamVjdC5gKTtcbiAgICAgIHJvb3RQcm9wcyA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVBcHBDb250ZXh0KCk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb250ZXh0LmNvbmZpZywgXCJ1bndyYXBJbmplY3RlZFJlZlwiLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgYXBwLmNvbmZpZy51bndyYXBJbmplY3RlZFJlZiBoYXMgYmVlbiBkZXByZWNhdGVkLiAzLjMgbm93IGFsd2F5cyB1bndyYXBzIGluamVjdGVkIHJlZnMgaW4gT3B0aW9ucyBBUEkuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBpbnN0YWxsZWRQbHVnaW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgbGV0IGlzTW91bnRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGFwcCA9IGNvbnRleHQuYXBwID0ge1xuICAgICAgX3VpZDogdWlkJDErKyxcbiAgICAgIF9jb21wb25lbnQ6IHJvb3RDb21wb25lbnQsXG4gICAgICBfcHJvcHM6IHJvb3RQcm9wcyxcbiAgICAgIF9jb250YWluZXI6IG51bGwsXG4gICAgICBfY29udGV4dDogY29udGV4dCxcbiAgICAgIF9pbnN0YW5jZTogbnVsbCxcbiAgICAgIHZlcnNpb24sXG4gICAgICBnZXQgY29uZmlnKCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5jb25maWc7XG4gICAgICB9LFxuICAgICAgc2V0IGNvbmZpZyh2KSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBhcHAuY29uZmlnIGNhbm5vdCBiZSByZXBsYWNlZC4gTW9kaWZ5IGluZGl2aWR1YWwgb3B0aW9ucyBpbnN0ZWFkLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlKHBsdWdpbiwgLi4ub3B0aW9ucykge1xuICAgICAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5oYXMocGx1Z2luKSkge1xuICAgICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgUGx1Z2luIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwLmApO1xuICAgICAgICB9IGVsc2UgaWYgKHBsdWdpbiAmJiBpc0Z1bmN0aW9uKHBsdWdpbi5pbnN0YWxsKSkge1xuICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XG4gICAgICAgICAgcGx1Z2luLmluc3RhbGwoYXBwLCAuLi5vcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHBsdWdpbikpIHtcbiAgICAgICAgICBpbnN0YWxsZWRQbHVnaW5zLmFkZChwbHVnaW4pO1xuICAgICAgICAgIHBsdWdpbihhcHAsIC4uLm9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYEEgcGx1Z2luIG11c3QgZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0IHdpdGggYW4gXCJpbnN0YWxsXCIgZnVuY3Rpb24uYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBtaXhpbihtaXhpbikge1xuICAgICAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXykge1xuICAgICAgICAgIGlmICghY29udGV4dC5taXhpbnMuaW5jbHVkZXMobWl4aW4pKSB7XG4gICAgICAgICAgICBjb250ZXh0Lm1peGlucy5wdXNoKG1peGluKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIFwiTWl4aW4gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIHRvIHRhcmdldCBhcHBcIiArIChtaXhpbi5uYW1lID8gYDogJHttaXhpbi5uYW1lfWAgOiBcIlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4oXCJNaXhpbnMgYXJlIG9ubHkgYXZhaWxhYmxlIGluIGJ1aWxkcyBzdXBwb3J0aW5nIE9wdGlvbnMgQVBJXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgY29tcG9uZW50KG5hbWUsIGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lLCBjb250ZXh0LmNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5jb21wb25lbnRzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSkge1xuICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgaW4gdGFyZ2V0IGFwcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV0gPSBjb21wb25lbnQ7XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgZGlyZWN0aXZlKG5hbWUsIGRpcmVjdGl2ZSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRpcmVjdGl2ZSkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY29udGV4dC5kaXJlY3RpdmVzW25hbWVdKSB7XG4gICAgICAgICAgd2FybihgRGlyZWN0aXZlIFwiJHtuYW1lfVwiIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBpbiB0YXJnZXQgYXBwLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXSA9IGRpcmVjdGl2ZTtcbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBtb3VudChyb290Q29udGFpbmVyLCBpc0h5ZHJhdGUsIGlzU1ZHKSB7XG4gICAgICAgIGlmICghaXNNb3VudGVkKSB7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgcm9vdENvbnRhaW5lci5fX3Z1ZV9hcHBfXykge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgYFRoZXJlIGlzIGFscmVhZHkgYW4gYXBwIGluc3RhbmNlIG1vdW50ZWQgb24gdGhlIGhvc3QgY29udGFpbmVyLlxuIElmIHlvdSB3YW50IHRvIG1vdW50IGFub3RoZXIgYXBwIG9uIHRoZSBzYW1lIGhvc3QgY29udGFpbmVyLCB5b3UgbmVlZCB0byB1bm1vdW50IHRoZSBwcmV2aW91cyBhcHAgYnkgY2FsbGluZyBcXGBhcHAudW5tb3VudCgpXFxgIGZpcnN0LmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUocm9vdENvbXBvbmVudCwgcm9vdFByb3BzKTtcbiAgICAgICAgICB2bm9kZS5hcHBDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgY29udGV4dC5yZWxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIHJlbmRlcihjbG9uZVZOb2RlKHZub2RlKSwgcm9vdENvbnRhaW5lciwgaXNTVkcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzSHlkcmF0ZSAmJiBoeWRyYXRlKSB7XG4gICAgICAgICAgICBoeWRyYXRlKHZub2RlLCByb290Q29udGFpbmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyKHZub2RlLCByb290Q29udGFpbmVyLCBpc1NWRyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzTW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgYXBwLl9jb250YWluZXIgPSByb290Q29udGFpbmVyO1xuICAgICAgICAgIHJvb3RDb250YWluZXIuX192dWVfYXBwX18gPSBhcHA7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICBhcHAuX2luc3RhbmNlID0gdm5vZGUuY29tcG9uZW50O1xuICAgICAgICAgICAgZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBnZXRFeHBvc2VQcm94eSh2bm9kZS5jb21wb25lbnQpIHx8IHZub2RlLmNvbXBvbmVudC5wcm94eTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBBcHAgaGFzIGFscmVhZHkgYmVlbiBtb3VudGVkLlxuSWYgeW91IHdhbnQgdG8gcmVtb3VudCB0aGUgc2FtZSBhcHAsIG1vdmUgeW91ciBhcHAgY3JlYXRpb24gbG9naWMgaW50byBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIGNyZWF0ZSBmcmVzaCBhcHAgaW5zdGFuY2VzIGZvciBlYWNoIG1vdW50IC0gZS5nLiBcXGBjb25zdCBjcmVhdGVNeUFwcCA9ICgpID0+IGNyZWF0ZUFwcChBcHApXFxgYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1bm1vdW50KCkge1xuICAgICAgICBpZiAoaXNNb3VudGVkKSB7XG4gICAgICAgICAgcmVuZGVyKG51bGwsIGFwcC5fY29udGFpbmVyKTtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgIGFwcC5faW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgZGV2dG9vbHNVbm1vdW50QXBwKGFwcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBhcHAuX2NvbnRhaW5lci5fX3Z1ZV9hcHBfXztcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybihgQ2Fubm90IHVubW91bnQgYW4gYXBwIHRoYXQgaXMgbm90IG1vdW50ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm92aWRlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5IGluIGNvbnRleHQucHJvdmlkZXMpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYEFwcCBhbHJlYWR5IHByb3ZpZGVzIHByb3BlcnR5IHdpdGgga2V5IFwiJHtTdHJpbmcoa2V5KX1cIi4gSXQgd2lsbCBiZSBvdmVyd3JpdHRlbiB3aXRoIHRoZSBuZXcgdmFsdWUuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5wcm92aWRlc1trZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgcnVuV2l0aENvbnRleHQoZm4pIHtcbiAgICAgICAgY3VycmVudEFwcCA9IGFwcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBjdXJyZW50QXBwID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGFwcDtcbiAgfTtcbn1cbmxldCBjdXJyZW50QXBwID0gbnVsbDtcblxuZnVuY3Rpb24gcHJvdmlkZShrZXksIHZhbHVlKSB7XG4gIGlmICghY3VycmVudEluc3RhbmNlKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oYHByb3ZpZGUoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpLmApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXM7XG4gICAgY29uc3QgcGFyZW50UHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucGFyZW50ICYmIGN1cnJlbnRJbnN0YW5jZS5wYXJlbnQucHJvdmlkZXM7XG4gICAgaWYgKHBhcmVudFByb3ZpZGVzID09PSBwcm92aWRlcykge1xuICAgICAgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFByb3ZpZGVzKTtcbiAgICB9XG4gICAgcHJvdmlkZXNba2V5XSA9IHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBpbmplY3Qoa2V5LCBkZWZhdWx0VmFsdWUsIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSA9IGZhbHNlKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgaWYgKGluc3RhbmNlIHx8IGN1cnJlbnRBcHApIHtcbiAgICBjb25zdCBwcm92aWRlcyA9IGluc3RhbmNlID8gaW5zdGFuY2UucGFyZW50ID09IG51bGwgPyBpbnN0YW5jZS52bm9kZS5hcHBDb250ZXh0ICYmIGluc3RhbmNlLnZub2RlLmFwcENvbnRleHQucHJvdmlkZXMgOiBpbnN0YW5jZS5wYXJlbnQucHJvdmlkZXMgOiBjdXJyZW50QXBwLl9jb250ZXh0LnByb3ZpZGVzO1xuICAgIGlmIChwcm92aWRlcyAmJiBrZXkgaW4gcHJvdmlkZXMpIHtcbiAgICAgIHJldHVybiBwcm92aWRlc1trZXldO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpID8gZGVmYXVsdFZhbHVlLmNhbGwoaW5zdGFuY2UgJiYgaW5zdGFuY2UucHJveHkpIDogZGVmYXVsdFZhbHVlO1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihgaW5qZWN0aW9uIFwiJHtTdHJpbmcoa2V5KX1cIiBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuKGBpbmplY3QoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpIG9yIGZ1bmN0aW9uYWwgY29tcG9uZW50cy5gKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFzSW5qZWN0aW9uQ29udGV4dCgpIHtcbiAgcmV0dXJuICEhKGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfHwgY3VycmVudEFwcCk7XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIGlzU3RhdGVmdWwsIGlzU1NSID0gZmFsc2UpIHtcbiAgY29uc3QgcHJvcHMgPSB7fTtcbiAgY29uc3QgYXR0cnMgPSB7fTtcbiAgZGVmKGF0dHJzLCBJbnRlcm5hbE9iamVjdEtleSwgMSk7XG4gIGluc3RhbmNlLnByb3BzRGVmYXVsdHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdKSB7XG4gICAgaWYgKCEoa2V5IGluIHByb3BzKSkge1xuICAgICAgcHJvcHNba2V5XSA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzIHx8IHt9LCBwcm9wcywgaW5zdGFuY2UpO1xuICB9XG4gIGlmIChpc1N0YXRlZnVsKSB7XG4gICAgaW5zdGFuY2UucHJvcHMgPSBpc1NTUiA/IHByb3BzIDogc2hhbGxvd1JlYWN0aXZlKHByb3BzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWluc3RhbmNlLnR5cGUucHJvcHMpIHtcbiAgICAgIGluc3RhbmNlLnByb3BzID0gYXR0cnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLnByb3BzID0gcHJvcHM7XG4gICAgfVxuICB9XG4gIGluc3RhbmNlLmF0dHJzID0gYXR0cnM7XG59XG5mdW5jdGlvbiBpc0luSG1yQ29udGV4dChpbnN0YW5jZSkge1xuICB3aGlsZSAoaW5zdGFuY2UpIHtcbiAgICBpZiAoaW5zdGFuY2UudHlwZS5fX2htcklkKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgaW5zdGFuY2UgPSBpbnN0YW5jZS5wYXJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcmF3UHJldlByb3BzLCBvcHRpbWl6ZWQpIHtcbiAgY29uc3Qge1xuICAgIHByb3BzLFxuICAgIGF0dHJzLFxuICAgIHZub2RlOiB7IHBhdGNoRmxhZyB9XG4gIH0gPSBpbnN0YW5jZTtcbiAgY29uc3QgcmF3Q3VycmVudFByb3BzID0gdG9SYXcocHJvcHMpO1xuICBjb25zdCBbb3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XG4gIGxldCBoYXNBdHRyc0NoYW5nZWQgPSBmYWxzZTtcbiAgaWYgKFxuICAgIC8vIGFsd2F5cyBmb3JjZSBmdWxsIGRpZmYgaW4gZGV2XG4gICAgLy8gLSAjMTk0MiBpZiBobXIgaXMgZW5hYmxlZCB3aXRoIHNmYyBjb21wb25lbnRcbiAgICAvLyAtIHZpdGUjODcyIG5vbi1zZmMgY29tcG9uZW50IHVzZWQgYnkgc2ZjIGNvbXBvbmVudFxuICAgICEoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0luSG1yQ29udGV4dChpbnN0YW5jZSkpICYmIChvcHRpbWl6ZWQgfHwgcGF0Y2hGbGFnID4gMCkgJiYgIShwYXRjaEZsYWcgJiAxNilcbiAgKSB7XG4gICAgaWYgKHBhdGNoRmxhZyAmIDgpIHtcbiAgICAgIGNvbnN0IHByb3BzVG9VcGRhdGUgPSBpbnN0YW5jZS52bm9kZS5keW5hbWljUHJvcHM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGtleSA9IHByb3BzVG9VcGRhdGVbaV07XG4gICAgICAgIGlmIChpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHJhd1Byb3BzW2tleV07XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKGhhc093bihhdHRycywga2V5KSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XG4gICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgICAgIHByb3BzW2NhbWVsaXplZEtleV0gPSByZXNvbHZlUHJvcFZhbHVlKFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICByYXdDdXJyZW50UHJvcHMsXG4gICAgICAgICAgICAgIGNhbWVsaXplZEtleSxcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgICAvKiBpc0Fic2VudCAqL1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XG4gICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKSkge1xuICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGtlYmFiS2V5O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJhd0N1cnJlbnRQcm9wcykge1xuICAgICAgaWYgKCFyYXdQcm9wcyB8fCAvLyBmb3IgY2FtZWxDYXNlXG4gICAgICAhaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmIC8vIGl0J3MgcG9zc2libGUgdGhlIG9yaWdpbmFsIHByb3BzIHdhcyBwYXNzZWQgaW4gYXMga2ViYWItY2FzZVxuICAgICAgLy8gYW5kIGNvbnZlcnRlZCB0byBjYW1lbENhc2UgKCM5NTUpXG4gICAgICAoKGtlYmFiS2V5ID0gaHlwaGVuYXRlKGtleSkpID09PSBrZXkgfHwgIWhhc093bihyYXdQcm9wcywga2ViYWJLZXkpKSkge1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgIGlmIChyYXdQcmV2UHJvcHMgJiYgLy8gZm9yIGNhbWVsQ2FzZVxuICAgICAgICAgIChyYXdQcmV2UHJvcHNba2V5XSAhPT0gdm9pZCAwIHx8IC8vIGZvciBrZWJhYi1jYXNlXG4gICAgICAgICAgcmF3UHJldlByb3BzW2tlYmFiS2V5XSAhPT0gdm9pZCAwKSkge1xuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUoXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgIHJhd0N1cnJlbnRQcm9wcyxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgIC8qIGlzQWJzZW50ICovXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXR0cnMgIT09IHJhd0N1cnJlbnRQcm9wcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgaWYgKCFyYXdQcm9wcyB8fCAhaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmIHRydWUpIHtcbiAgICAgICAgICBkZWxldGUgYXR0cnNba2V5XTtcbiAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChoYXNBdHRyc0NoYW5nZWQpIHtcbiAgICB0cmlnZ2VyKGluc3RhbmNlLCBcInNldFwiLCBcIiRhdHRyc1wiKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMgfHwge30sIHByb3BzLCBpbnN0YW5jZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycykge1xuICBjb25zdCBbb3B0aW9ucywgbmVlZENhc3RLZXlzXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcbiAgbGV0IGhhc0F0dHJzQ2hhbmdlZCA9IGZhbHNlO1xuICBsZXQgcmF3Q2FzdFZhbHVlcztcbiAgaWYgKHJhd1Byb3BzKSB7XG4gICAgZm9yIChsZXQga2V5IGluIHJhd1Byb3BzKSB7XG4gICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcbiAgICAgIGxldCBjYW1lbEtleTtcbiAgICAgIGlmIChvcHRpb25zICYmIGhhc093bihvcHRpb25zLCBjYW1lbEtleSA9IGNhbWVsaXplKGtleSkpKSB7XG4gICAgICAgIGlmICghbmVlZENhc3RLZXlzIHx8ICFuZWVkQ2FzdEtleXMuaW5jbHVkZXMoY2FtZWxLZXkpKSB7XG4gICAgICAgICAgcHJvcHNbY2FtZWxLZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKHJhd0Nhc3RWYWx1ZXMgfHwgKHJhd0Nhc3RWYWx1ZXMgPSB7fSkpW2NhbWVsS2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIGF0dHJzKSB8fCB2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xuICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChuZWVkQ2FzdEtleXMpIHtcbiAgICBjb25zdCByYXdDdXJyZW50UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XG4gICAgY29uc3QgY2FzdFZhbHVlcyA9IHJhd0Nhc3RWYWx1ZXMgfHwgRU1QVFlfT0JKO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVlZENhc3RLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBuZWVkQ2FzdEtleXNbaV07XG4gICAgICBwcm9wc1trZXldID0gcmVzb2x2ZVByb3BWYWx1ZShcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgcmF3Q3VycmVudFByb3BzLFxuICAgICAgICBrZXksXG4gICAgICAgIGNhc3RWYWx1ZXNba2V5XSxcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICFoYXNPd24oY2FzdFZhbHVlcywga2V5KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc0F0dHJzQ2hhbmdlZDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcHJvcHMsIGtleSwgdmFsdWUsIGluc3RhbmNlLCBpc0Fic2VudCkge1xuICBjb25zdCBvcHQgPSBvcHRpb25zW2tleV07XG4gIGlmIChvcHQgIT0gbnVsbCkge1xuICAgIGNvbnN0IGhhc0RlZmF1bHQgPSBoYXNPd24ob3B0LCBcImRlZmF1bHRcIik7XG4gICAgaWYgKGhhc0RlZmF1bHQgJiYgdmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gb3B0LmRlZmF1bHQ7XG4gICAgICBpZiAob3B0LnR5cGUgIT09IEZ1bmN0aW9uICYmICFvcHQuc2tpcEZhY3RvcnkgJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHNEZWZhdWx0cyB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGlmIChrZXkgaW4gcHJvcHNEZWZhdWx0cykge1xuICAgICAgICAgIHZhbHVlID0gcHJvcHNEZWZhdWx0c1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wc0RlZmF1bHRzW2tleV0gPSBkZWZhdWx0VmFsdWUuY2FsbChcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICk7XG4gICAgICAgICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRbMCAvKiBzaG91bGRDYXN0ICovXSkge1xuICAgICAgaWYgKGlzQWJzZW50ICYmICFoYXNEZWZhdWx0KSB7XG4gICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKG9wdFsxIC8qIHNob3VsZENhc3RUcnVlICovXSAmJiAodmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xuICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcbiAgY29uc3QgY2FjaGUgPSBhcHBDb250ZXh0LnByb3BzQ2FjaGU7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChjb21wKTtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgY29uc3QgcmF3ID0gY29tcC5wcm9wcztcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHt9O1xuICBjb25zdCBuZWVkQ2FzdEtleXMgPSBbXTtcbiAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcbiAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcbiAgICBjb25zdCBleHRlbmRQcm9wcyA9IChyYXcyKSA9PiB7XG4gICAgICBoYXNFeHRlbmRzID0gdHJ1ZTtcbiAgICAgIGNvbnN0IFtwcm9wcywga2V5c10gPSBub3JtYWxpemVQcm9wc09wdGlvbnMocmF3MiwgYXBwQ29udGV4dCwgdHJ1ZSk7XG4gICAgICBleHRlbmQobm9ybWFsaXplZCwgcHJvcHMpO1xuICAgICAgaWYgKGtleXMpXG4gICAgICAgIG5lZWRDYXN0S2V5cy5wdXNoKC4uLmtleXMpO1xuICAgIH07XG4gICAgaWYgKCFhc01peGluICYmIGFwcENvbnRleHQubWl4aW5zLmxlbmd0aCkge1xuICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XG4gICAgfVxuICAgIGlmIChjb21wLmV4dGVuZHMpIHtcbiAgICAgIGV4dGVuZFByb3BzKGNvbXAuZXh0ZW5kcyk7XG4gICAgfVxuICAgIGlmIChjb21wLm1peGlucykge1xuICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XG4gICAgfVxuICB9XG4gIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XG4gICAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgICBjYWNoZS5zZXQoY29tcCwgRU1QVFlfQVJSKTtcbiAgICB9XG4gICAgcmV0dXJuIEVNUFRZX0FSUjtcbiAgfVxuICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc1N0cmluZyhyYXdbaV0pKSB7XG4gICAgICAgIHdhcm4oYHByb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC5gLCByYXdbaV0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKHJhd1tpXSk7XG4gICAgICBpZiAodmFsaWRhdGVQcm9wTmFtZShub3JtYWxpemVkS2V5KSkge1xuICAgICAgICBub3JtYWxpemVkW25vcm1hbGl6ZWRLZXldID0gRU1QVFlfT0JKO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChyYXcpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNPYmplY3QocmF3KSkge1xuICAgICAgd2FybihgaW52YWxpZCBwcm9wcyBvcHRpb25zYCwgcmF3KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3KSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XG4gICAgICAgIGNvbnN0IG9wdCA9IHJhd1trZXldO1xuICAgICAgICBjb25zdCBwcm9wID0gbm9ybWFsaXplZFtub3JtYWxpemVkS2V5XSA9IGlzQXJyYXkob3B0KSB8fCBpc0Z1bmN0aW9uKG9wdCkgPyB7IHR5cGU6IG9wdCB9IDogZXh0ZW5kKHt9LCBvcHQpO1xuICAgICAgICBpZiAocHJvcCkge1xuICAgICAgICAgIGNvbnN0IGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xuICAgICAgICAgIGNvbnN0IHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcbiAgICAgICAgICBwcm9wWzAgLyogc2hvdWxkQ2FzdCAqL10gPSBib29sZWFuSW5kZXggPiAtMTtcbiAgICAgICAgICBwcm9wWzEgLyogc2hvdWxkQ2FzdFRydWUgKi9dID0gc3RyaW5nSW5kZXggPCAwIHx8IGJvb2xlYW5JbmRleCA8IHN0cmluZ0luZGV4O1xuICAgICAgICAgIGlmIChib29sZWFuSW5kZXggPiAtMSB8fCBoYXNPd24ocHJvcCwgXCJkZWZhdWx0XCIpKSB7XG4gICAgICAgICAgICBuZWVkQ2FzdEtleXMucHVzaChub3JtYWxpemVkS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzID0gW25vcm1hbGl6ZWQsIG5lZWRDYXN0S2V5c107XG4gIGlmIChpc09iamVjdChjb21wKSkge1xuICAgIGNhY2hlLnNldChjb21wLCByZXMpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BOYW1lKGtleSkge1xuICBpZiAoa2V5WzBdICE9PSBcIiRcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuKGBJbnZhbGlkIHByb3AgbmFtZTogXCIke2tleX1cIiBpcyBhIHJlc2VydmVkIHByb3BlcnR5LmApO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFR5cGUoY3Rvcikge1xuICBjb25zdCBtYXRjaCA9IGN0b3IgJiYgY3Rvci50b1N0cmluZygpLm1hdGNoKC9eXFxzKihmdW5jdGlvbnxjbGFzcykgKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzJdIDogY3RvciA9PT0gbnVsbCA/IFwibnVsbFwiIDogXCJcIjtcbn1cbmZ1bmN0aW9uIGlzU2FtZVR5cGUoYSwgYikge1xuICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKTtcbn1cbmZ1bmN0aW9uIGdldFR5cGVJbmRleCh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGlmIChpc0FycmF5KGV4cGVjdGVkVHlwZXMpKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkVHlwZXMuZmluZEluZGV4KCh0KSA9PiBpc1NhbWVUeXBlKHQsIHR5cGUpKTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKGV4cGVjdGVkVHlwZXMpKSB7XG4gICAgcmV0dXJuIGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlcywgdHlwZSkgPyAwIDogLTE7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhyYXdQcm9wcywgcHJvcHMsIGluc3RhbmNlKSB7XG4gIGNvbnN0IHJlc29sdmVkVmFsdWVzID0gdG9SYXcocHJvcHMpO1xuICBjb25zdCBvcHRpb25zID0gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdO1xuICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgbGV0IG9wdCA9IG9wdGlvbnNba2V5XTtcbiAgICBpZiAob3B0ID09IG51bGwpXG4gICAgICBjb250aW51ZTtcbiAgICB2YWxpZGF0ZVByb3AoXG4gICAgICBrZXksXG4gICAgICByZXNvbHZlZFZhbHVlc1trZXldLFxuICAgICAgb3B0LFxuICAgICAgIWhhc093bihyYXdQcm9wcywga2V5KSAmJiAhaGFzT3duKHJhd1Byb3BzLCBoeXBoZW5hdGUoa2V5KSlcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AobmFtZSwgdmFsdWUsIHByb3AsIGlzQWJzZW50KSB7XG4gIGNvbnN0IHsgdHlwZSwgcmVxdWlyZWQsIHZhbGlkYXRvciwgc2tpcENoZWNrIH0gPSBwcm9wO1xuICBpZiAocmVxdWlyZWQgJiYgaXNBYnNlbnQpIHtcbiAgICB3YXJuKCdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXJlcXVpcmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlICE9IG51bGwgJiYgdHlwZSAhPT0gdHJ1ZSAmJiAhc2tpcENoZWNrKSB7XG4gICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcbiAgICBjb25zdCB0eXBlcyA9IGlzQXJyYXkodHlwZSkgPyB0eXBlIDogW3R5cGVdO1xuICAgIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aCAmJiAhaXNWYWxpZDsgaSsrKSB7XG4gICAgICBjb25zdCB7IHZhbGlkLCBleHBlY3RlZFR5cGUgfSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVzW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChleHBlY3RlZFR5cGUgfHwgXCJcIik7XG4gICAgICBpc1ZhbGlkID0gdmFsaWQ7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgd2FybihnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKHZhbGlkYXRvciAmJiAhdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgIHdhcm4oJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nKTtcbiAgfVxufVxuY29uc3QgaXNTaW1wbGVUeXBlID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIFwiU3RyaW5nLE51bWJlcixCb29sZWFuLEZ1bmN0aW9uLFN5bWJvbCxCaWdJbnRcIlxuKTtcbmZ1bmN0aW9uIGFzc2VydFR5cGUodmFsdWUsIHR5cGUpIHtcbiAgbGV0IHZhbGlkO1xuICBjb25zdCBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoaXNTaW1wbGVUeXBlKGV4cGVjdGVkVHlwZSkpIHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCF2YWxpZCAmJiB0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBcIk9iamVjdFwiKSB7XG4gICAgdmFsaWQgPSBpc09iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBcIkFycmF5XCIpIHtcbiAgICB2YWxpZCA9IGlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJudWxsXCIpIHtcbiAgICB2YWxpZCA9IHZhbHVlID09PSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgbGV0IG1lc3NhZ2UgPSBgSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIiR7bmFtZX1cIi4gRXhwZWN0ZWQgJHtleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKFwiIHwgXCIpfWA7XG4gIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZXNbMF07XG4gIGNvbnN0IHJlY2VpdmVkVHlwZSA9IHRvUmF3VHlwZSh2YWx1ZSk7XG4gIGNvbnN0IGV4cGVjdGVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpO1xuICBjb25zdCByZWNlaXZlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgcmVjZWl2ZWRUeXBlKTtcbiAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmICFpc0Jvb2xlYW4oZXhwZWN0ZWRUeXBlLCByZWNlaXZlZFR5cGUpKSB7XG4gICAgbWVzc2FnZSArPSBgIHdpdGggdmFsdWUgJHtleHBlY3RlZFZhbHVlfWA7XG4gIH1cbiAgbWVzc2FnZSArPSBgLCBnb3QgJHtyZWNlaXZlZFR5cGV9IGA7XG4gIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gYHdpdGggdmFsdWUgJHtyZWNlaXZlZFZhbHVlfS5gO1xuICB9XG4gIHJldHVybiBtZXNzYWdlO1xufVxuZnVuY3Rpb24gc3R5bGVWYWx1ZSh2YWx1ZSwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gXCJTdHJpbmdcIikge1xuICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcIk51bWJlclwiKSB7XG4gICAgcmV0dXJuIGAke051bWJlcih2YWx1ZSl9YDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYCR7dmFsdWV9YDtcbiAgfVxufVxuZnVuY3Rpb24gaXNFeHBsaWNhYmxlKHR5cGUpIHtcbiAgY29uc3QgZXhwbGljaXRUeXBlcyA9IFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIl07XG4gIHJldHVybiBleHBsaWNpdFR5cGVzLnNvbWUoKGVsZW0pID0+IHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbSk7XG59XG5mdW5jdGlvbiBpc0Jvb2xlYW4oLi4uYXJncykge1xuICByZXR1cm4gYXJncy5zb21lKChlbGVtKSA9PiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09IFwiYm9vbGVhblwiKTtcbn1cblxuY29uc3QgaXNJbnRlcm5hbEtleSA9IChrZXkpID0+IGtleVswXSA9PT0gXCJfXCIgfHwga2V5ID09PSBcIiRzdGFibGVcIjtcbmNvbnN0IG5vcm1hbGl6ZVNsb3RWYWx1ZSA9ICh2YWx1ZSkgPT4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAobm9ybWFsaXplVk5vZGUpIDogW25vcm1hbGl6ZVZOb2RlKHZhbHVlKV07XG5jb25zdCBub3JtYWxpemVTbG90ID0gKGtleSwgcmF3U2xvdCwgY3R4KSA9PiB7XG4gIGlmIChyYXdTbG90Ll9uKSB7XG4gICAgcmV0dXJuIHJhd1Nsb3Q7XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXplZCA9IHdpdGhDdHgoKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjdXJyZW50SW5zdGFuY2UpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBTbG90IFwiJHtrZXl9XCIgaW52b2tlZCBvdXRzaWRlIG9mIHRoZSByZW5kZXIgZnVuY3Rpb246IHRoaXMgd2lsbCBub3QgdHJhY2sgZGVwZW5kZW5jaWVzIHVzZWQgaW4gdGhlIHNsb3QuIEludm9rZSB0aGUgc2xvdCBmdW5jdGlvbiBpbnNpZGUgdGhlIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVTbG90VmFsdWUocmF3U2xvdCguLi5hcmdzKSk7XG4gIH0sIGN0eCk7XG4gIG5vcm1hbGl6ZWQuX2MgPSBmYWxzZTtcbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59O1xuY29uc3Qgbm9ybWFsaXplT2JqZWN0U2xvdHMgPSAocmF3U2xvdHMsIHNsb3RzLCBpbnN0YW5jZSkgPT4ge1xuICBjb25zdCBjdHggPSByYXdTbG90cy5fY3R4O1xuICBmb3IgKGNvbnN0IGtleSBpbiByYXdTbG90cykge1xuICAgIGlmIChpc0ludGVybmFsS2V5KGtleSkpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCB2YWx1ZSA9IHJhd1Nsb3RzW2tleV07XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICBzbG90c1trZXldID0gbm9ybWFsaXplU2xvdChrZXksIHZhbHVlLCBjdHgpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdHJ1ZSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBOb24tZnVuY3Rpb24gdmFsdWUgZW5jb3VudGVyZWQgZm9yIHNsb3QgXCIke2tleX1cIi4gUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZSh2YWx1ZSk7XG4gICAgICBzbG90c1trZXldID0gKCkgPT4gbm9ybWFsaXplZDtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBub3JtYWxpemVWTm9kZVNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbikgPT4ge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNLZWVwQWxpdmUoaW5zdGFuY2Uudm5vZGUpICYmIHRydWUpIHtcbiAgICB3YXJuKFxuICAgICAgYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3IgZGVmYXVsdCBzbG90LiBQcmVmZXIgZnVuY3Rpb24gc2xvdHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gXG4gICAgKTtcbiAgfVxuICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplU2xvdFZhbHVlKGNoaWxkcmVuKTtcbiAgaW5zdGFuY2Uuc2xvdHMuZGVmYXVsdCA9ICgpID0+IG5vcm1hbGl6ZWQ7XG59O1xuY29uc3QgaW5pdFNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbikgPT4ge1xuICBpZiAoaW5zdGFuY2Uudm5vZGUuc2hhcGVGbGFnICYgMzIpIHtcbiAgICBjb25zdCB0eXBlID0gY2hpbGRyZW4uXztcbiAgICBpZiAodHlwZSkge1xuICAgICAgaW5zdGFuY2Uuc2xvdHMgPSB0b1JhdyhjaGlsZHJlbik7XG4gICAgICBkZWYoY2hpbGRyZW4sIFwiX1wiLCB0eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9ybWFsaXplT2JqZWN0U2xvdHMoXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBpbnN0YW5jZS5zbG90cyA9IHt9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2Uuc2xvdHMgPSB7fTtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcbiAgICB9XG4gIH1cbiAgZGVmKGluc3RhbmNlLnNsb3RzLCBJbnRlcm5hbE9iamVjdEtleSwgMSk7XG59O1xuY29uc3QgdXBkYXRlU2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpID0+IHtcbiAgY29uc3QgeyB2bm9kZSwgc2xvdHMgfSA9IGluc3RhbmNlO1xuICBsZXQgbmVlZERlbGV0aW9uQ2hlY2sgPSB0cnVlO1xuICBsZXQgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0gRU1QVFlfT0JKO1xuICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMzIpIHtcbiAgICBjb25zdCB0eXBlID0gY2hpbGRyZW4uXztcbiAgICBpZiAodHlwZSkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZykge1xuICAgICAgICBleHRlbmQoc2xvdHMsIGNoaWxkcmVuKTtcbiAgICAgICAgdHJpZ2dlcihpbnN0YW5jZSwgXCJzZXRcIiwgXCIkc2xvdHNcIik7XG4gICAgICB9IGVsc2UgaWYgKG9wdGltaXplZCAmJiB0eXBlID09PSAxKSB7XG4gICAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHRlbmQoc2xvdHMsIGNoaWxkcmVuKTtcbiAgICAgICAgaWYgKCFvcHRpbWl6ZWQgJiYgdHlwZSA9PT0gMSkge1xuICAgICAgICAgIGRlbGV0ZSBzbG90cy5fO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gIWNoaWxkcmVuLiRzdGFibGU7XG4gICAgICBub3JtYWxpemVPYmplY3RTbG90cyhjaGlsZHJlbiwgc2xvdHMpO1xuICAgIH1cbiAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbikge1xuICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcbiAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSB7IGRlZmF1bHQ6IDEgfTtcbiAgfVxuICBpZiAobmVlZERlbGV0aW9uQ2hlY2spIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xuICAgICAgaWYgKCFpc0ludGVybmFsS2V5KGtleSkgJiYgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0W2tleV0gPT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgc2xvdHNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFJlZihyYXdSZWYsIG9sZFJhd1JlZiwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCBpc1VubW91bnQgPSBmYWxzZSkge1xuICBpZiAoaXNBcnJheShyYXdSZWYpKSB7XG4gICAgcmF3UmVmLmZvckVhY2goXG4gICAgICAociwgaSkgPT4gc2V0UmVmKFxuICAgICAgICByLFxuICAgICAgICBvbGRSYXdSZWYgJiYgKGlzQXJyYXkob2xkUmF3UmVmKSA/IG9sZFJhd1JlZltpXSA6IG9sZFJhd1JlZiksXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgaXNVbm1vdW50XG4gICAgICApXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlzQXN5bmNXcmFwcGVyKHZub2RlKSAmJiAhaXNVbm1vdW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlZlZhbHVlID0gdm5vZGUuc2hhcGVGbGFnICYgNCA/IGdldEV4cG9zZVByb3h5KHZub2RlLmNvbXBvbmVudCkgfHwgdm5vZGUuY29tcG9uZW50LnByb3h5IDogdm5vZGUuZWw7XG4gIGNvbnN0IHZhbHVlID0gaXNVbm1vdW50ID8gbnVsbCA6IHJlZlZhbHVlO1xuICBjb25zdCB7IGk6IG93bmVyLCByOiByZWYgfSA9IHJhd1JlZjtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIW93bmVyKSB7XG4gICAgd2FybihcbiAgICAgIGBNaXNzaW5nIHJlZiBvd25lciBjb250ZXh0LiByZWYgY2Fubm90IGJlIHVzZWQgb24gaG9pc3RlZCB2bm9kZXMuIEEgdm5vZGUgd2l0aCByZWYgbXVzdCBiZSBjcmVhdGVkIGluc2lkZSB0aGUgcmVuZGVyIGZ1bmN0aW9uLmBcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvbGRSZWYgPSBvbGRSYXdSZWYgJiYgb2xkUmF3UmVmLnI7XG4gIGNvbnN0IHJlZnMgPSBvd25lci5yZWZzID09PSBFTVBUWV9PQkogPyBvd25lci5yZWZzID0ge30gOiBvd25lci5yZWZzO1xuICBjb25zdCBzZXR1cFN0YXRlID0gb3duZXIuc2V0dXBTdGF0ZTtcbiAgaWYgKG9sZFJlZiAhPSBudWxsICYmIG9sZFJlZiAhPT0gcmVmKSB7XG4gICAgaWYgKGlzU3RyaW5nKG9sZFJlZikpIHtcbiAgICAgIHJlZnNbb2xkUmVmXSA9IG51bGw7XG4gICAgICBpZiAoaGFzT3duKHNldHVwU3RhdGUsIG9sZFJlZikpIHtcbiAgICAgICAgc2V0dXBTdGF0ZVtvbGRSZWZdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUmVmKG9sZFJlZikpIHtcbiAgICAgIG9sZFJlZi52YWx1ZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIGlmIChpc0Z1bmN0aW9uKHJlZikpIHtcbiAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcocmVmLCBvd25lciwgMTIsIFt2YWx1ZSwgcmVmc10pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IF9pc1N0cmluZyA9IGlzU3RyaW5nKHJlZik7XG4gICAgY29uc3QgX2lzUmVmID0gaXNSZWYocmVmKTtcbiAgICBpZiAoX2lzU3RyaW5nIHx8IF9pc1JlZikge1xuICAgICAgY29uc3QgZG9TZXQgPSAoKSA9PiB7XG4gICAgICAgIGlmIChyYXdSZWYuZikge1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gX2lzU3RyaW5nID8gaGFzT3duKHNldHVwU3RhdGUsIHJlZikgPyBzZXR1cFN0YXRlW3JlZl0gOiByZWZzW3JlZl0gOiByZWYudmFsdWU7XG4gICAgICAgICAgaWYgKGlzVW5tb3VudCkge1xuICAgICAgICAgICAgaXNBcnJheShleGlzdGluZykgJiYgcmVtb3ZlKGV4aXN0aW5nLCByZWZWYWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaXNBcnJheShleGlzdGluZykpIHtcbiAgICAgICAgICAgICAgaWYgKF9pc1N0cmluZykge1xuICAgICAgICAgICAgICAgIHJlZnNbcmVmXSA9IFtyZWZWYWx1ZV07XG4gICAgICAgICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCByZWYpKSB7XG4gICAgICAgICAgICAgICAgICBzZXR1cFN0YXRlW3JlZl0gPSByZWZzW3JlZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZi52YWx1ZSA9IFtyZWZWYWx1ZV07XG4gICAgICAgICAgICAgICAgaWYgKHJhd1JlZi5rKVxuICAgICAgICAgICAgICAgICAgcmVmc1tyYXdSZWYua10gPSByZWYudmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWV4aXN0aW5nLmluY2x1ZGVzKHJlZlZhbHVlKSkge1xuICAgICAgICAgICAgICBleGlzdGluZy5wdXNoKHJlZlZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoX2lzU3RyaW5nKSB7XG4gICAgICAgICAgcmVmc1tyZWZdID0gdmFsdWU7XG4gICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCByZWYpKSB7XG4gICAgICAgICAgICBzZXR1cFN0YXRlW3JlZl0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoX2lzUmVmKSB7XG4gICAgICAgICAgcmVmLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgaWYgKHJhd1JlZi5rKVxuICAgICAgICAgICAgcmVmc1tyYXdSZWYua10gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybihcIkludmFsaWQgdGVtcGxhdGUgcmVmIHR5cGU6XCIsIHJlZiwgYCgke3R5cGVvZiByZWZ9KWApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRvU2V0LmlkID0gLTE7XG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkb1NldCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9TZXQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oXCJJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOlwiLCByZWYsIGAoJHt0eXBlb2YgcmVmfSlgKTtcbiAgICB9XG4gIH1cbn1cblxubGV0IGhhc01pc21hdGNoID0gZmFsc2U7XG5jb25zdCBpc1NWR0NvbnRhaW5lciA9IChjb250YWluZXIpID0+IC9zdmcvLnRlc3QoY29udGFpbmVyLm5hbWVzcGFjZVVSSSkgJiYgY29udGFpbmVyLnRhZ05hbWUgIT09IFwiZm9yZWlnbk9iamVjdFwiO1xuY29uc3QgaXNDb21tZW50ID0gKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDggLyogQ09NTUVOVCAqLztcbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyhyZW5kZXJlckludGVybmFscykge1xuICBjb25zdCB7XG4gICAgbXQ6IG1vdW50Q29tcG9uZW50LFxuICAgIHA6IHBhdGNoLFxuICAgIG86IHtcbiAgICAgIHBhdGNoUHJvcCxcbiAgICAgIGNyZWF0ZVRleHQsXG4gICAgICBuZXh0U2libGluZyxcbiAgICAgIHBhcmVudE5vZGUsXG4gICAgICByZW1vdmUsXG4gICAgICBpbnNlcnQsXG4gICAgICBjcmVhdGVDb21tZW50XG4gICAgfVxuICB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gIGNvbnN0IGh5ZHJhdGUgPSAodm5vZGUsIGNvbnRhaW5lcikgPT4ge1xuICAgIGlmICghY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgICBgQXR0ZW1wdGluZyB0byBoeWRyYXRlIGV4aXN0aW5nIG1hcmt1cCBidXQgY29udGFpbmVyIGlzIGVtcHR5LiBQZXJmb3JtaW5nIGZ1bGwgbW91bnQgaW5zdGVhZC5gXG4gICAgICApO1xuICAgICAgcGF0Y2gobnVsbCwgdm5vZGUsIGNvbnRhaW5lcik7XG4gICAgICBmbHVzaFBvc3RGbHVzaENicygpO1xuICAgICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBoYXNNaXNtYXRjaCA9IGZhbHNlO1xuICAgIGh5ZHJhdGVOb2RlKGNvbnRhaW5lci5maXJzdENoaWxkLCB2bm9kZSwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcbiAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XG4gICAgaWYgKGhhc01pc21hdGNoICYmIHRydWUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEh5ZHJhdGlvbiBjb21wbGV0ZWQgYnV0IGNvbnRhaW5zIG1pc21hdGNoZXMuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBoeWRyYXRlTm9kZSA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IGlzRnJhZ21lbnRTdGFydCA9IGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09IFwiW1wiO1xuICAgIGNvbnN0IG9uTWlzbWF0Y2ggPSAoKSA9PiBoYW5kbGVNaXNtYXRjaChcbiAgICAgIG5vZGUsXG4gICAgICB2bm9kZSxcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgaXNGcmFnbWVudFN0YXJ0XG4gICAgKTtcbiAgICBjb25zdCB7IHR5cGUsIHJlZiwgc2hhcGVGbGFnLCBwYXRjaEZsYWcgfSA9IHZub2RlO1xuICAgIGxldCBkb21UeXBlID0gbm9kZS5ub2RlVHlwZTtcbiAgICB2bm9kZS5lbCA9IG5vZGU7XG4gICAgaWYgKHBhdGNoRmxhZyA9PT0gLTIpIHtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgbGV0IG5leHROb2RlID0gbnVsbDtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgVGV4dDpcbiAgICAgICAgaWYgKGRvbVR5cGUgIT09IDMgLyogVEVYVCAqLykge1xuICAgICAgICAgIGlmICh2bm9kZS5jaGlsZHJlbiA9PT0gXCJcIikge1xuICAgICAgICAgICAgaW5zZXJ0KHZub2RlLmVsID0gY3JlYXRlVGV4dChcIlwiKSwgcGFyZW50Tm9kZShub2RlKSwgbm9kZSk7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobm9kZS5kYXRhICE9PSB2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgICAgICAgICBgSHlkcmF0aW9uIHRleHQgbWlzbWF0Y2g6XG4tIFNlcnZlciByZW5kZXJlZDogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICBub2RlLmRhdGFcbiAgICAgICAgICAgICAgKX1cbi0gQ2xpZW50IHJlbmRlcmVkOiAke0pTT04uc3RyaW5naWZ5KHZub2RlLmNoaWxkcmVuKX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvbW1lbnQ6XG4gICAgICAgIGlmIChkb21UeXBlICE9PSA4IC8qIENPTU1FTlQgKi8gfHwgaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgaWYgKG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInRlbXBsYXRlXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSB2bm9kZS5lbC5jb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICByZXBsYWNlTm9kZShjb250ZW50LCBub2RlLCBwYXJlbnRDb21wb25lbnQpO1xuICAgICAgICAgICAgdm5vZGUuZWwgPSBub2RlID0gY29udGVudDtcbiAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0aWM6XG4gICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICBub2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgZG9tVHlwZSA9IG5vZGUubm9kZVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbVR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyB8fCBkb21UeXBlID09PSAzIC8qIFRFWFQgKi8pIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgY29uc3QgbmVlZFRvQWRvcHRDb250ZW50ID0gIXZub2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZub2RlLnN0YXRpY0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChuZWVkVG9BZG9wdENvbnRlbnQpXG4gICAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuICs9IG5leHROb2RlLm5vZGVUeXBlID09PSAxIC8qIEVMRU1FTlQgKi8gPyBuZXh0Tm9kZS5vdXRlckhUTUwgOiBuZXh0Tm9kZS5kYXRhO1xuICAgICAgICAgICAgaWYgKGkgPT09IHZub2RlLnN0YXRpY0NvdW50IC0gMSkge1xuICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBuZXh0Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobmV4dE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXNGcmFnbWVudFN0YXJ0ID8gbmV4dFNpYmxpbmcobmV4dE5vZGUpIDogbmV4dE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25NaXNtYXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGcmFnbWVudDpcbiAgICAgICAgaWYgKCFpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IGh5ZHJhdGVGcmFnbWVudChcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxKSB7XG4gICAgICAgICAgaWYgKChkb21UeXBlICE9PSAxIC8qIEVMRU1FTlQgKi8gfHwgdm5vZGUudHlwZS50b0xvd2VyQ2FzZSgpICE9PSBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkgJiYgIWlzVGVtcGxhdGVOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA2KSB7XG4gICAgICAgICAgdm5vZGUuc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzO1xuICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XG4gICAgICAgICAgaWYgKGlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBsb2NhdGVDbG9zaW5nQW5jaG9yKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gXCJ0ZWxlcG9ydCBzdGFydFwiKSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IGxvY2F0ZUNsb3NpbmdBbmNob3Iobm9kZSwgbm9kZS5kYXRhLCBcInRlbGVwb3J0IGVuZFwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbW91bnRDb21wb25lbnQoXG4gICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lciksXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpc0FzeW5jV3JhcHBlcih2bm9kZSkpIHtcbiAgICAgICAgICAgIGxldCBzdWJUcmVlO1xuICAgICAgICAgICAgaWYgKGlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgICAgICBzdWJUcmVlID0gY3JlYXRlVk5vZGUoRnJhZ21lbnQpO1xuICAgICAgICAgICAgICBzdWJUcmVlLmFuY2hvciA9IG5leHROb2RlID8gbmV4dE5vZGUucHJldmlvdXNTaWJsaW5nIDogY29udGFpbmVyLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1YlRyZWUgPSBub2RlLm5vZGVUeXBlID09PSAzID8gY3JlYXRlVGV4dFZOb2RlKFwiXCIpIDogY3JlYXRlVk5vZGUoXCJkaXZcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJUcmVlLmVsID0gbm9kZTtcbiAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudC5zdWJUcmVlID0gc3ViVHJlZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gOCAvKiBDT01NRU5UICovKSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSB2bm9kZS50eXBlLmh5ZHJhdGUoXG4gICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgICAgcmVuZGVyZXJJbnRlcm5hbHMsXG4gICAgICAgICAgICAgIGh5ZHJhdGVDaGlsZHJlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSB2bm9kZS50eXBlLmh5ZHJhdGUoXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHQ29udGFpbmVyKHBhcmVudE5vZGUobm9kZSkpLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgICAgcmVuZGVyZXJJbnRlcm5hbHMsXG4gICAgICAgICAgICBoeWRyYXRlTm9kZVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4oXCJJbnZhbGlkIEhvc3RWTm9kZSB0eXBlOlwiLCB0eXBlLCBgKCR7dHlwZW9mIHR5cGV9KWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgc2V0UmVmKHJlZiwgbnVsbCwgcGFyZW50U3VzcGVuc2UsIHZub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHROb2RlO1xuICB9O1xuICBjb25zdCBoeWRyYXRlRWxlbWVudCA9IChlbCwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xuICAgIGNvbnN0IHsgdHlwZSwgcHJvcHMsIHBhdGNoRmxhZywgc2hhcGVGbGFnLCBkaXJzLCB0cmFuc2l0aW9uIH0gPSB2bm9kZTtcbiAgICBjb25zdCBmb3JjZVBhdGNoVmFsdWUgPSB0eXBlID09PSBcImlucHV0XCIgJiYgZGlycyB8fCB0eXBlID09PSBcIm9wdGlvblwiO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IGZvcmNlUGF0Y2hWYWx1ZSB8fCBwYXRjaEZsYWcgIT09IC0xKSB7XG4gICAgICBpZiAoZGlycykge1xuICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiY3JlYXRlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcykge1xuICAgICAgICBpZiAoZm9yY2VQYXRjaFZhbHVlIHx8ICFvcHRpbWl6ZWQgfHwgcGF0Y2hGbGFnICYgKDE2IHwgMzIpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZVBhdGNoVmFsdWUgJiYga2V5LmVuZHNXaXRoKFwidmFsdWVcIikgfHwgaXNPbihrZXkpICYmICFpc1Jlc2VydmVkUHJvcChrZXkpKSB7XG4gICAgICAgICAgICAgIHBhdGNoUHJvcChcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBwcm9wc1trZXldLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcHMub25DbGljaykge1xuICAgICAgICAgIHBhdGNoUHJvcChcbiAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgXCJvbkNsaWNrXCIsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcHJvcHMub25DbGljayxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IHZub2RlSG9va3M7XG4gICAgICBpZiAodm5vZGVIb29rcyA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkge1xuICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rcywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICB9XG4gICAgICBsZXQgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgPSBmYWxzZTtcbiAgICAgIGlmIChpc1RlbXBsYXRlTm9kZShlbCkpIHtcbiAgICAgICAgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgPSBuZWVkVHJhbnNpdGlvbihwYXJlbnRTdXNwZW5zZSwgdHJhbnNpdGlvbikgJiYgcGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC52bm9kZS5wcm9wcyAmJiBwYXJlbnRDb21wb25lbnQudm5vZGUucHJvcHMuYXBwZWFyO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gZWwuY29udGVudC5maXJzdENoaWxkO1xuICAgICAgICBpZiAobmVlZENhbGxUcmFuc2l0aW9uSG9va3MpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJlcGxhY2VOb2RlKGNvbnRlbnQsIGVsLCBwYXJlbnRDb21wb25lbnQpO1xuICAgICAgICB2bm9kZS5lbCA9IGVsID0gY29udGVudDtcbiAgICAgIH1cbiAgICAgIGlmIChkaXJzKSB7XG4gICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJiZWZvcmVNb3VudFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICgodm5vZGVIb29rcyA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSB8fCBkaXJzIHx8IG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzKSB7XG4gICAgICAgIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKCgpID0+IHtcbiAgICAgICAgICB2bm9kZUhvb2tzICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2tzLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgICAgICBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyAmJiB0cmFuc2l0aW9uLmVudGVyKGVsKTtcbiAgICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJtb3VudGVkXCIpO1xuICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9XG4gICAgICBpZiAoc2hhcGVGbGFnICYgMTYgJiYgLy8gc2tpcCBpZiBlbGVtZW50IGhhcyBpbm5lckhUTUwgLyB0ZXh0Q29udGVudFxuICAgICAgIShwcm9wcyAmJiAocHJvcHMuaW5uZXJIVE1MIHx8IHByb3BzLnRleHRDb250ZW50KSkpIHtcbiAgICAgICAgbGV0IG5leHQgPSBoeWRyYXRlQ2hpbGRyZW4oXG4gICAgICAgICAgZWwuZmlyc3RDaGlsZCxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBlbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFoYXNXYXJuZWQpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIGBIeWRyYXRpb24gY2hpbGRyZW4gbWlzbWF0Y2ggaW4gPCR7dm5vZGUudHlwZX0+OiBzZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBtb3JlIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGN1ciA9IG5leHQ7XG4gICAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgcmVtb3ZlKGN1cik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgOCkge1xuICAgICAgICBpZiAoZWwudGV4dENvbnRlbnQgIT09IHZub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihcbiAgICAgICAgICAgIGBIeWRyYXRpb24gdGV4dCBjb250ZW50IG1pc21hdGNoIGluIDwke3Zub2RlLnR5cGV9Pjpcbi0gU2VydmVyIHJlbmRlcmVkOiAke2VsLnRleHRDb250ZW50fVxuLSBDbGllbnQgcmVuZGVyZWQ6ICR7dm5vZGUuY2hpbGRyZW59YFxuICAgICAgICAgICk7XG4gICAgICAgICAgZWwudGV4dENvbnRlbnQgPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWwubmV4dFNpYmxpbmc7XG4gIH07XG4gIGNvbnN0IGh5ZHJhdGVDaGlsZHJlbiA9IChub2RlLCBwYXJlbnRWTm9kZSwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXBhcmVudFZOb2RlLmR5bmFtaWNDaGlsZHJlbjtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFZOb2RlLmNoaWxkcmVuO1xuICAgIGNvbnN0IGwgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgbGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCB2bm9kZSA9IG9wdGltaXplZCA/IGNoaWxkcmVuW2ldIDogY2hpbGRyZW5baV0gPSBub3JtYWxpemVWTm9kZShjaGlsZHJlbltpXSk7XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBub2RlID0gaHlkcmF0ZU5vZGUoXG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICh2bm9kZS50eXBlID09PSBUZXh0ICYmICF2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWhhc1dhcm5lZCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIGluIDwke2NvbnRhaW5lci50YWdOYW1lLnRvTG93ZXJDYXNlKCl9Pjogc2VydmVyIHJlbmRlcmVkIGVsZW1lbnQgY29udGFpbnMgZmV3ZXIgY2hpbGQgbm9kZXMgdGhhbiBjbGllbnQgdmRvbS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lciksXG4gICAgICAgICAgc2xvdFNjb3BlSWRzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9O1xuICBjb25zdCBoeWRyYXRlRnJhZ21lbnQgPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgeyBzbG90U2NvcGVJZHM6IGZyYWdtZW50U2xvdFNjb3BlSWRzIH0gPSB2bm9kZTtcbiAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcbiAgICAgIHNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcyA/IHNsb3RTY29wZUlkcy5jb25jYXQoZnJhZ21lbnRTbG90U2NvcGVJZHMpIDogZnJhZ21lbnRTbG90U2NvcGVJZHM7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XG4gICAgY29uc3QgbmV4dCA9IGh5ZHJhdGVDaGlsZHJlbihcbiAgICAgIG5leHRTaWJsaW5nKG5vZGUpLFxuICAgICAgdm5vZGUsXG4gICAgICBjb250YWluZXIsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgIG9wdGltaXplZFxuICAgICk7XG4gICAgaWYgKG5leHQgJiYgaXNDb21tZW50KG5leHQpICYmIG5leHQuZGF0YSA9PT0gXCJdXCIpIHtcbiAgICAgIHJldHVybiBuZXh0U2libGluZyh2bm9kZS5hbmNob3IgPSBuZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgaW5zZXJ0KHZub2RlLmFuY2hvciA9IGNyZWF0ZUNvbW1lbnQoYF1gKSwgY29udGFpbmVyLCBuZXh0KTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaGFuZGxlTWlzbWF0Y2ggPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgaXNGcmFnbWVudCkgPT4ge1xuICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oXG4gICAgICBgSHlkcmF0aW9uIG5vZGUgbWlzbWF0Y2g6XG4tIENsaWVudCB2bm9kZTpgLFxuICAgICAgdm5vZGUudHlwZSxcbiAgICAgIGBcbi0gU2VydmVyIHJlbmRlcmVkIERPTTpgLFxuICAgICAgbm9kZSxcbiAgICAgIG5vZGUubm9kZVR5cGUgPT09IDMgLyogVEVYVCAqLyA/IGAodGV4dClgIDogaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gXCJbXCIgPyBgKHN0YXJ0IG9mIGZyYWdtZW50KWAgOiBgYFxuICAgICk7XG4gICAgdm5vZGUuZWwgPSBudWxsO1xuICAgIGlmIChpc0ZyYWdtZW50KSB7XG4gICAgICBjb25zdCBlbmQgPSBsb2NhdGVDbG9zaW5nQW5jaG9yKG5vZGUpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgbmV4dDIgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgaWYgKG5leHQyICYmIG5leHQyICE9PSBlbmQpIHtcbiAgICAgICAgICByZW1vdmUobmV4dDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5leHQgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xuICAgIHJlbW92ZShub2RlKTtcbiAgICBwYXRjaChcbiAgICAgIG51bGwsXG4gICAgICB2bm9kZSxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIG5leHQsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lciksXG4gICAgICBzbG90U2NvcGVJZHNcbiAgICApO1xuICAgIHJldHVybiBuZXh0O1xuICB9O1xuICBjb25zdCBsb2NhdGVDbG9zaW5nQW5jaG9yID0gKG5vZGUsIG9wZW4gPSBcIltcIiwgY2xvc2UgPSBcIl1cIikgPT4ge1xuICAgIGxldCBtYXRjaCA9IDA7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIG5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgIGlmIChub2RlICYmIGlzQ29tbWVudChub2RlKSkge1xuICAgICAgICBpZiAobm9kZS5kYXRhID09PSBvcGVuKVxuICAgICAgICAgIG1hdGNoKys7XG4gICAgICAgIGlmIChub2RlLmRhdGEgPT09IGNsb3NlKSB7XG4gICAgICAgICAgaWYgKG1hdGNoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9O1xuICBjb25zdCByZXBsYWNlTm9kZSA9IChuZXdOb2RlLCBvbGROb2RlLCBwYXJlbnRDb21wb25lbnQpID0+IHtcbiAgICBjb25zdCBwYXJlbnROb2RlMiA9IG9sZE5vZGUucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50Tm9kZTIpIHtcbiAgICAgIHBhcmVudE5vZGUyLnJlcGxhY2VDaGlsZChuZXdOb2RlLCBvbGROb2RlKTtcbiAgICB9XG4gICAgbGV0IHBhcmVudCA9IHBhcmVudENvbXBvbmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LnZub2RlLmVsID09PSBvbGROb2RlKSB7XG4gICAgICAgIHBhcmVudC52bm9kZS5lbCA9IG5ld05vZGU7XG4gICAgICAgIHBhcmVudC5zdWJUcmVlLmVsID0gbmV3Tm9kZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICB9O1xuICBjb25zdCBpc1RlbXBsYXRlTm9kZSA9IChub2RlKSA9PiB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZW1wbGF0ZVwiO1xuICB9O1xuICByZXR1cm4gW2h5ZHJhdGUsIGh5ZHJhdGVOb2RlXTtcbn1cblxubGV0IHN1cHBvcnRlZDtcbmxldCBwZXJmO1xuZnVuY3Rpb24gc3RhcnRNZWFzdXJlKGluc3RhbmNlLCB0eXBlKSB7XG4gIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5wZXJmb3JtYW5jZSAmJiBpc1N1cHBvcnRlZCgpKSB7XG4gICAgcGVyZi5tYXJrKGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBkZXZ0b29sc1BlcmZTdGFydChpbnN0YW5jZSwgdHlwZSwgaXNTdXBwb3J0ZWQoKSA/IHBlcmYubm93KCkgOiBEYXRlLm5vdygpKTtcbiAgfVxufVxuZnVuY3Rpb24gZW5kTWVhc3VyZShpbnN0YW5jZSwgdHlwZSkge1xuICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xuICAgIGNvbnN0IHN0YXJ0VGFnID0gYHZ1ZS0ke3R5cGV9LSR7aW5zdGFuY2UudWlkfWA7XG4gICAgY29uc3QgZW5kVGFnID0gc3RhcnRUYWcgKyBgOmVuZGA7XG4gICAgcGVyZi5tYXJrKGVuZFRhZyk7XG4gICAgcGVyZi5tZWFzdXJlKFxuICAgICAgYDwke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIGluc3RhbmNlLnR5cGUpfT4gJHt0eXBlfWAsXG4gICAgICBzdGFydFRhZyxcbiAgICAgIGVuZFRhZ1xuICAgICk7XG4gICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBkZXZ0b29sc1BlcmZFbmQoaW5zdGFuY2UsIHR5cGUsIGlzU3VwcG9ydGVkKCkgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICBpZiAoc3VwcG9ydGVkICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gc3VwcG9ydGVkO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5wZXJmb3JtYW5jZSkge1xuICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgcGVyZiA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgfSBlbHNlIHtcbiAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gc3VwcG9ydGVkO1xufVxuXG5mdW5jdGlvbiBpbml0RmVhdHVyZUZsYWdzKCkge1xuICBjb25zdCBuZWVkV2FybiA9IFtdO1xuICBpZiAodHlwZW9mIF9fVlVFX09QVElPTlNfQVBJX18gIT09IFwiYm9vbGVhblwiKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBuZWVkV2Fybi5wdXNoKGBfX1ZVRV9PUFRJT05TX0FQSV9fYCk7XG4gICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX09QVElPTlNfQVBJX18gPSB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgX19WVUVfUFJPRF9ERVZUT09MU19fICE9PSBcImJvb2xlYW5cIikge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbmVlZFdhcm4ucHVzaChgX19WVUVfUFJPRF9ERVZUT09MU19fYCk7XG4gICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX1BST0RfREVWVE9PTFNfXyA9IGZhbHNlO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG5lZWRXYXJuLmxlbmd0aCkge1xuICAgIGNvbnN0IG11bHRpID0gbmVlZFdhcm4ubGVuZ3RoID4gMTtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgRmVhdHVyZSBmbGFnJHttdWx0aSA/IGBzYCA6IGBgfSAke25lZWRXYXJuLmpvaW4oXCIsIFwiKX0gJHttdWx0aSA/IGBhcmVgIDogYGlzYH0gbm90IGV4cGxpY2l0bHkgZGVmaW5lZC4gWW91IGFyZSBydW5uaW5nIHRoZSBlc20tYnVuZGxlciBidWlsZCBvZiBWdWUsIHdoaWNoIGV4cGVjdHMgdGhlc2UgY29tcGlsZS10aW1lIGZlYXR1cmUgZmxhZ3MgdG8gYmUgZ2xvYmFsbHkgaW5qZWN0ZWQgdmlhIHRoZSBidW5kbGVyIGNvbmZpZyBpbiBvcmRlciB0byBnZXQgYmV0dGVyIHRyZWUtc2hha2luZyBpbiB0aGUgcHJvZHVjdGlvbiBidW5kbGUuXG5cbkZvciBtb3JlIGRldGFpbHMsIHNlZSBodHRwczovL2xpbmsudnVlanMub3JnL2ZlYXR1cmUtZmxhZ3MuYFxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgcXVldWVQb3N0UmVuZGVyRWZmZWN0ID0gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UgO1xuZnVuY3Rpb24gY3JlYXRlUmVuZGVyZXIob3B0aW9ucykge1xuICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIob3B0aW9ucykge1xuICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyk7XG59XG5mdW5jdGlvbiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucywgY3JlYXRlSHlkcmF0aW9uRm5zKSB7XG4gIHtcbiAgICBpbml0RmVhdHVyZUZsYWdzKCk7XG4gIH1cbiAgY29uc3QgdGFyZ2V0ID0gZ2V0R2xvYmFsVGhpcygpO1xuICB0YXJnZXQuX19WVUVfXyA9IHRydWU7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgIHNldERldnRvb2xzSG9vayh0YXJnZXQuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXywgdGFyZ2V0KTtcbiAgfVxuICBjb25zdCB7XG4gICAgaW5zZXJ0OiBob3N0SW5zZXJ0LFxuICAgIHJlbW92ZTogaG9zdFJlbW92ZSxcbiAgICBwYXRjaFByb3A6IGhvc3RQYXRjaFByb3AsXG4gICAgY3JlYXRlRWxlbWVudDogaG9zdENyZWF0ZUVsZW1lbnQsXG4gICAgY3JlYXRlVGV4dDogaG9zdENyZWF0ZVRleHQsXG4gICAgY3JlYXRlQ29tbWVudDogaG9zdENyZWF0ZUNvbW1lbnQsXG4gICAgc2V0VGV4dDogaG9zdFNldFRleHQsXG4gICAgc2V0RWxlbWVudFRleHQ6IGhvc3RTZXRFbGVtZW50VGV4dCxcbiAgICBwYXJlbnROb2RlOiBob3N0UGFyZW50Tm9kZSxcbiAgICBuZXh0U2libGluZzogaG9zdE5leHRTaWJsaW5nLFxuICAgIHNldFNjb3BlSWQ6IGhvc3RTZXRTY29wZUlkID0gTk9PUCxcbiAgICBpbnNlcnRTdGF0aWNDb250ZW50OiBob3N0SW5zZXJ0U3RhdGljQ29udGVudFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcGF0Y2ggPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciA9IG51bGwsIHBhcmVudENvbXBvbmVudCA9IG51bGwsIHBhcmVudFN1c3BlbnNlID0gbnVsbCwgaXNTVkcgPSBmYWxzZSwgc2xvdFNjb3BlSWRzID0gbnVsbCwgb3B0aW1pemVkID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0htclVwZGF0aW5nID8gZmFsc2UgOiAhIW4yLmR5bmFtaWNDaGlsZHJlbikgPT4ge1xuICAgIGlmIChuMSA9PT0gbjIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG4xICYmICFpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xuICAgICAgYW5jaG9yID0gZ2V0TmV4dEhvc3ROb2RlKG4xKTtcbiAgICAgIHVubW91bnQobjEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgbjEgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobjIucGF0Y2hGbGFnID09PSAtMikge1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICBuMi5keW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7IHR5cGUsIHJlZiwgc2hhcGVGbGFnIH0gPSBuMjtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgVGV4dDpcbiAgICAgICAgcHJvY2Vzc1RleHQobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDb21tZW50OlxuICAgICAgICBwcm9jZXNzQ29tbWVudE5vZGUobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0aWM6XG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICAgICAgbW91bnRTdGF0aWNOb2RlKG4yLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcpO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwYXRjaFN0YXRpY05vZGUobjEsIG4yLCBjb250YWluZXIsIGlzU1ZHKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIHByb2Nlc3NGcmFnbWVudChcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEpIHtcbiAgICAgICAgICBwcm9jZXNzRWxlbWVudChcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA2KSB7XG4gICAgICAgICAgcHJvY2Vzc0NvbXBvbmVudChcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgICAgIHR5cGUucHJvY2VzcyhcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgICAgaW50ZXJuYWxzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgICAgICB0eXBlLnByb2Nlc3MoXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgIGludGVybmFsc1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4oXCJJbnZhbGlkIFZOb2RlIHR5cGU6XCIsIHR5cGUsIGAoJHt0eXBlb2YgdHlwZX0pYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlZiAhPSBudWxsICYmIHBhcmVudENvbXBvbmVudCkge1xuICAgICAgc2V0UmVmKHJlZiwgbjEgJiYgbjEucmVmLCBwYXJlbnRTdXNwZW5zZSwgbjIgfHwgbjEsICFuMik7XG4gICAgfVxuICB9O1xuICBjb25zdCBwcm9jZXNzVGV4dCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKSA9PiB7XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGhvc3RJbnNlcnQoXG4gICAgICAgIG4yLmVsID0gaG9zdENyZWF0ZVRleHQobjIuY2hpbGRyZW4pLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvclxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZWwgPSBuMi5lbCA9IG4xLmVsO1xuICAgICAgaWYgKG4yLmNoaWxkcmVuICE9PSBuMS5jaGlsZHJlbikge1xuICAgICAgICBob3N0U2V0VGV4dChlbCwgbjIuY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJvY2Vzc0NvbW1lbnROb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpID0+IHtcbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgaG9zdEluc2VydChcbiAgICAgICAgbjIuZWwgPSBob3N0Q3JlYXRlQ29tbWVudChuMi5jaGlsZHJlbiB8fCBcIlwiKSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3JcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudFN0YXRpY05vZGUgPSAobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRykgPT4ge1xuICAgIFtuMi5lbCwgbjIuYW5jaG9yXSA9IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50KFxuICAgICAgbjIuY2hpbGRyZW4sXG4gICAgICBjb250YWluZXIsXG4gICAgICBhbmNob3IsXG4gICAgICBpc1NWRyxcbiAgICAgIG4yLmVsLFxuICAgICAgbjIuYW5jaG9yXG4gICAgKTtcbiAgfTtcbiAgY29uc3QgcGF0Y2hTdGF0aWNOb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBpc1NWRykgPT4ge1xuICAgIGlmIChuMi5jaGlsZHJlbiAhPT0gbjEuY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IGhvc3ROZXh0U2libGluZyhuMS5hbmNob3IpO1xuICAgICAgcmVtb3ZlU3RhdGljTm9kZShuMSk7XG4gICAgICBbbjIuZWwsIG4yLmFuY2hvcl0gPSBob3N0SW5zZXJ0U3RhdGljQ29udGVudChcbiAgICAgICAgbjIuY2hpbGRyZW4sXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBpc1NWR1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbjIuZWwgPSBuMS5lbDtcbiAgICAgIG4yLmFuY2hvciA9IG4xLmFuY2hvcjtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdmVTdGF0aWNOb2RlID0gKHsgZWwsIGFuY2hvciB9LCBjb250YWluZXIsIG5leHRTaWJsaW5nKSA9PiB7XG4gICAgbGV0IG5leHQ7XG4gICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcbiAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoZWwpO1xuICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBuZXh0U2libGluZyk7XG4gICAgICBlbCA9IG5leHQ7XG4gICAgfVxuICAgIGhvc3RJbnNlcnQoYW5jaG9yLCBjb250YWluZXIsIG5leHRTaWJsaW5nKTtcbiAgfTtcbiAgY29uc3QgcmVtb3ZlU3RhdGljTm9kZSA9ICh7IGVsLCBhbmNob3IgfSkgPT4ge1xuICAgIGxldCBuZXh0O1xuICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gYW5jaG9yKSB7XG4gICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGVsKTtcbiAgICAgIGhvc3RSZW1vdmUoZWwpO1xuICAgICAgZWwgPSBuZXh0O1xuICAgIH1cbiAgICBob3N0UmVtb3ZlKGFuY2hvcik7XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NFbGVtZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGlzU1ZHID0gaXNTVkcgfHwgbjIudHlwZSA9PT0gXCJzdmdcIjtcbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgbW91bnRFbGVtZW50KFxuICAgICAgICBuMixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIGlzU1ZHLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0Y2hFbGVtZW50KFxuICAgICAgICBuMSxcbiAgICAgICAgbjIsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIGlzU1ZHLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdW50RWxlbWVudCA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGxldCBlbDtcbiAgICBsZXQgdm5vZGVIb29rO1xuICAgIGNvbnN0IHsgdHlwZSwgcHJvcHMsIHNoYXBlRmxhZywgdHJhbnNpdGlvbiwgZGlycyB9ID0gdm5vZGU7XG4gICAgZWwgPSB2bm9kZS5lbCA9IGhvc3RDcmVhdGVFbGVtZW50KFxuICAgICAgdm5vZGUudHlwZSxcbiAgICAgIGlzU1ZHLFxuICAgICAgcHJvcHMgJiYgcHJvcHMuaXMsXG4gICAgICBwcm9wc1xuICAgICk7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDgpIHtcbiAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgdm5vZGUuY2hpbGRyZW4pO1xuICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgIHZub2RlLmNoaWxkcmVuLFxuICAgICAgICBlbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgaXNTVkcgJiYgdHlwZSAhPT0gXCJmb3JlaWduT2JqZWN0XCIsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZGlycykge1xuICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImNyZWF0ZWRcIik7XG4gICAgfVxuICAgIHNldFNjb3BlSWQoZWwsIHZub2RlLCB2bm9kZS5zY29wZUlkLCBzbG90U2NvcGVJZHMsIHBhcmVudENvbXBvbmVudCk7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICBpZiAoa2V5ICE9PSBcInZhbHVlXCIgJiYgIWlzUmVzZXJ2ZWRQcm9wKGtleSkpIHtcbiAgICAgICAgICBob3N0UGF0Y2hQcm9wKFxuICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcHJvcHNba2V5XSxcbiAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIHVubW91bnRDaGlsZHJlblxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChcInZhbHVlXCIgaW4gcHJvcHMpIHtcbiAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJ2YWx1ZVwiLCBudWxsLCBwcm9wcy52YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodm5vZGVIb29rID0gcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSB7XG4gICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbCwgXCJfX3Zub2RlXCIsIHtcbiAgICAgICAgdmFsdWU6IHZub2RlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsIFwiX192dWVQYXJlbnRDb21wb25lbnRcIiwge1xuICAgICAgICB2YWx1ZTogcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkaXJzKSB7XG4gICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiYmVmb3JlTW91bnRcIik7XG4gICAgfVxuICAgIGNvbnN0IG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzID0gbmVlZFRyYW5zaXRpb24ocGFyZW50U3VzcGVuc2UsIHRyYW5zaXRpb24pO1xuICAgIGlmIChuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xuICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgfVxuICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSB8fCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyB8fCBkaXJzKSB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzICYmIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJtb3VudGVkXCIpO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0U2NvcGVJZCA9IChlbCwgdm5vZGUsIHNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KSA9PiB7XG4gICAgaWYgKHNjb3BlSWQpIHtcbiAgICAgIGhvc3RTZXRTY29wZUlkKGVsLCBzY29wZUlkKTtcbiAgICB9XG4gICAgaWYgKHNsb3RTY29wZUlkcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbG90U2NvcGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaG9zdFNldFNjb3BlSWQoZWwsIHNsb3RTY29wZUlkc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgIGxldCBzdWJUcmVlID0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWU7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzdWJUcmVlLnBhdGNoRmxhZyA+IDAgJiYgc3ViVHJlZS5wYXRjaEZsYWcgJiAyMDQ4KSB7XG4gICAgICAgIHN1YlRyZWUgPSBmaWx0ZXJTaW5nbGVSb290KHN1YlRyZWUuY2hpbGRyZW4pIHx8IHN1YlRyZWU7XG4gICAgICB9XG4gICAgICBpZiAodm5vZGUgPT09IHN1YlRyZWUpIHtcbiAgICAgICAgY29uc3QgcGFyZW50Vk5vZGUgPSBwYXJlbnRDb21wb25lbnQudm5vZGU7XG4gICAgICAgIHNldFNjb3BlSWQoXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgcGFyZW50Vk5vZGUsXG4gICAgICAgICAgcGFyZW50Vk5vZGUuc2NvcGVJZCxcbiAgICAgICAgICBwYXJlbnRWTm9kZS5zbG90U2NvcGVJZHMsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LnBhcmVudFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRDaGlsZHJlbiA9IChjaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgc3RhcnQgPSAwKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjaGlsZHJlbltpXSkgOiBub3JtYWxpemVWTm9kZShjaGlsZHJlbltpXSk7XG4gICAgICBwYXRjaChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY2hpbGQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwYXRjaEVsZW1lbnQgPSAobjEsIG4yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBlbCA9IG4yLmVsID0gbjEuZWw7XG4gICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4sIGRpcnMgfSA9IG4yO1xuICAgIHBhdGNoRmxhZyB8PSBuMS5wYXRjaEZsYWcgJiAxNjtcbiAgICBjb25zdCBvbGRQcm9wcyA9IG4xLnByb3BzIHx8IEVNUFRZX09CSjtcbiAgICBjb25zdCBuZXdQcm9wcyA9IG4yLnByb3BzIHx8IEVNUFRZX09CSjtcbiAgICBsZXQgdm5vZGVIb29rO1xuICAgIHBhcmVudENvbXBvbmVudCAmJiB0b2dnbGVSZWN1cnNlKHBhcmVudENvbXBvbmVudCwgZmFsc2UpO1xuICAgIGlmICh2bm9kZUhvb2sgPSBuZXdQcm9wcy5vblZub2RlQmVmb3JlVXBkYXRlKSB7XG4gICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIG4yLCBuMSk7XG4gICAgfVxuICAgIGlmIChkaXJzKSB7XG4gICAgICBpbnZva2VEaXJlY3RpdmVIb29rKG4yLCBuMSwgcGFyZW50Q29tcG9uZW50LCBcImJlZm9yZVVwZGF0ZVwiKTtcbiAgICB9XG4gICAgcGFyZW50Q29tcG9uZW50ICYmIHRvZ2dsZVJlY3Vyc2UocGFyZW50Q29tcG9uZW50LCB0cnVlKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgICBwYXRjaEZsYWcgPSAwO1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBhcmVDaGlsZHJlblNWRyA9IGlzU1ZHICYmIG4yLnR5cGUgIT09IFwiZm9yZWlnbk9iamVjdFwiO1xuICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihcbiAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICAgIGVsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBhcmVDaGlsZHJlblNWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzXG4gICAgICApO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIW9wdGltaXplZCkge1xuICAgICAgcGF0Y2hDaGlsZHJlbihcbiAgICAgICAgbjEsXG4gICAgICAgIG4yLFxuICAgICAgICBlbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgYXJlQ2hpbGRyZW5TVkcsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XG4gICAgICBpZiAocGF0Y2hGbGFnICYgMTYpIHtcbiAgICAgICAgcGF0Y2hQcm9wcyhcbiAgICAgICAgICBlbCxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBvbGRQcm9wcyxcbiAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkdcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiAyKSB7XG4gICAgICAgICAgaWYgKG9sZFByb3BzLmNsYXNzICE9PSBuZXdQcm9wcy5jbGFzcykge1xuICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJjbGFzc1wiLCBudWxsLCBuZXdQcm9wcy5jbGFzcywgaXNTVkcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgNCkge1xuICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIFwic3R5bGVcIiwgb2xkUHJvcHMuc3R5bGUsIG5ld1Byb3BzLnN0eWxlLCBpc1NWRyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDgpIHtcbiAgICAgICAgICBjb25zdCBwcm9wc1RvVXBkYXRlID0gbjIuZHluYW1pY1Byb3BzO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBvbGRQcm9wc1trZXldO1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5ld1Byb3BzW2tleV07XG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gcHJldiB8fCBrZXkgPT09IFwidmFsdWVcIikge1xuICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBwcmV2LFxuICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgICAgICAgbjEuY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhdGNoRmxhZyAmIDEpIHtcbiAgICAgICAgaWYgKG4xLmNoaWxkcmVuICE9PSBuMi5jaGlsZHJlbikge1xuICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgbjIuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghb3B0aW1pemVkICYmIGR5bmFtaWNDaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICBwYXRjaFByb3BzKFxuICAgICAgICBlbCxcbiAgICAgICAgbjIsXG4gICAgICAgIG9sZFByb3BzLFxuICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgaXNTVkdcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICgodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZVVwZGF0ZWQpIHx8IGRpcnMpIHtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIG4yLCBuMSk7XG4gICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayhuMiwgbjEsIHBhcmVudENvbXBvbmVudCwgXCJ1cGRhdGVkXCIpO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hCbG9ja0NoaWxkcmVuID0gKG9sZENoaWxkcmVuLCBuZXdDaGlsZHJlbiwgZmFsbGJhY2tDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBvbGRWTm9kZSA9IG9sZENoaWxkcmVuW2ldO1xuICAgICAgY29uc3QgbmV3Vk5vZGUgPSBuZXdDaGlsZHJlbltpXTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IChcbiAgICAgICAgLy8gb2xkVk5vZGUgbWF5IGJlIGFuIGVycm9yZWQgYXN5bmMgc2V0dXAoKSBjb21wb25lbnQgaW5zaWRlIFN1c3BlbnNlXG4gICAgICAgIC8vIHdoaWNoIHdpbGwgbm90IGhhdmUgYSBtb3VudGVkIGVsZW1lbnRcbiAgICAgICAgb2xkVk5vZGUuZWwgJiYgLy8gLSBJbiB0aGUgY2FzZSBvZiBhIEZyYWdtZW50LCB3ZSBuZWVkIHRvIHByb3ZpZGUgdGhlIGFjdHVhbCBwYXJlbnRcbiAgICAgICAgLy8gb2YgdGhlIEZyYWdtZW50IGl0c2VsZiBzbyBpdCBjYW4gbW92ZSBpdHMgY2hpbGRyZW4uXG4gICAgICAgIChvbGRWTm9kZS50eXBlID09PSBGcmFnbWVudCB8fCAvLyAtIEluIHRoZSBjYXNlIG9mIGRpZmZlcmVudCBub2RlcywgdGhlcmUgaXMgZ29pbmcgdG8gYmUgYSByZXBsYWNlbWVudFxuICAgICAgICAvLyB3aGljaCBhbHNvIHJlcXVpcmVzIHRoZSBjb3JyZWN0IHBhcmVudCBjb250YWluZXJcbiAgICAgICAgIWlzU2FtZVZOb2RlVHlwZShvbGRWTm9kZSwgbmV3Vk5vZGUpIHx8IC8vIC0gSW4gdGhlIGNhc2Ugb2YgYSBjb21wb25lbnQsIGl0IGNvdWxkIGNvbnRhaW4gYW55dGhpbmcuXG4gICAgICAgIG9sZFZOb2RlLnNoYXBlRmxhZyAmICg2IHwgNjQpKSA/IGhvc3RQYXJlbnROb2RlKG9sZFZOb2RlLmVsKSA6IChcbiAgICAgICAgICAvLyBJbiBvdGhlciBjYXNlcywgdGhlIHBhcmVudCBjb250YWluZXIgaXMgbm90IGFjdHVhbGx5IHVzZWQgc28gd2VcbiAgICAgICAgICAvLyBqdXN0IHBhc3MgdGhlIGJsb2NrIGVsZW1lbnQgaGVyZSB0byBhdm9pZCBhIERPTSBwYXJlbnROb2RlIGNhbGwuXG4gICAgICAgICAgZmFsbGJhY2tDb250YWluZXJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHBhdGNoKFxuICAgICAgICBvbGRWTm9kZSxcbiAgICAgICAgbmV3Vk5vZGUsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgaXNTVkcsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoUHJvcHMgPSAoZWwsIHZub2RlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKSA9PiB7XG4gICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcykge1xuICAgICAgaWYgKG9sZFByb3BzICE9PSBFTVBUWV9PQkopIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICAgICAgICBpZiAoIWlzUmVzZXJ2ZWRQcm9wKGtleSkgJiYgIShrZXkgaW4gbmV3UHJvcHMpKSB7XG4gICAgICAgICAgICBob3N0UGF0Y2hQcm9wKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICBvbGRQcm9wc1trZXldLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIG5ld1Byb3BzKSB7XG4gICAgICAgIGlmIChpc1Jlc2VydmVkUHJvcChrZXkpKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBuZXh0ID0gbmV3UHJvcHNba2V5XTtcbiAgICAgICAgY29uc3QgcHJldiA9IG9sZFByb3BzW2tleV07XG4gICAgICAgIGlmIChuZXh0ICE9PSBwcmV2ICYmIGtleSAhPT0gXCJ2YWx1ZVwiKSB7XG4gICAgICAgICAgaG9zdFBhdGNoUHJvcChcbiAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgcHJldixcbiAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW5cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIG5ld1Byb3BzKSB7XG4gICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIFwidmFsdWVcIiwgb2xkUHJvcHMudmFsdWUsIG5ld1Byb3BzLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NGcmFnbWVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBmcmFnbWVudFN0YXJ0QW5jaG9yID0gbjIuZWwgPSBuMSA/IG4xLmVsIDogaG9zdENyZWF0ZVRleHQoXCJcIik7XG4gICAgY29uc3QgZnJhZ21lbnRFbmRBbmNob3IgPSBuMi5hbmNob3IgPSBuMSA/IG4xLmFuY2hvciA6IGhvc3RDcmVhdGVUZXh0KFwiXCIpO1xuICAgIGxldCB7IHBhdGNoRmxhZywgZHluYW1pY0NoaWxkcmVuLCBzbG90U2NvcGVJZHM6IGZyYWdtZW50U2xvdFNjb3BlSWRzIH0gPSBuMjtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAvLyAjNTUyMyBkZXYgcm9vdCBmcmFnbWVudCBtYXkgaW5oZXJpdCBkaXJlY3RpdmVzXG4gICAgKGlzSG1yVXBkYXRpbmcgfHwgcGF0Y2hGbGFnICYgMjA0OCkpIHtcbiAgICAgIHBhdGNoRmxhZyA9IDA7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChmcmFnbWVudFNsb3RTY29wZUlkcykge1xuICAgICAgc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzID8gc2xvdFNjb3BlSWRzLmNvbmNhdChmcmFnbWVudFNsb3RTY29wZUlkcykgOiBmcmFnbWVudFNsb3RTY29wZUlkcztcbiAgICB9XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGhvc3RJbnNlcnQoZnJhZ21lbnRTdGFydEFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgaG9zdEluc2VydChmcmFnbWVudEVuZEFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgbW91bnRDaGlsZHJlbihcbiAgICAgICAgbjIuY2hpbGRyZW4sXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgZnJhZ21lbnRFbmRBbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIGlzU1ZHLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBhdGNoRmxhZyA+IDAgJiYgcGF0Y2hGbGFnICYgNjQgJiYgZHluYW1pY0NoaWxkcmVuICYmIC8vICMyNzE1IHRoZSBwcmV2aW91cyBmcmFnbWVudCBjb3VsZCd2ZSBiZWVuIGEgQkFJTGVkIG9uZSBhcyBhIHJlc3VsdFxuICAgICAgLy8gb2YgcmVuZGVyU2xvdCgpIHdpdGggbm8gdmFsaWQgY2hpbGRyZW5cbiAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4oXG4gICAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkc1xuICAgICAgICApO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAvLyAjMjA4MCBpZiB0aGUgc3RhYmxlIGZyYWdtZW50IGhhcyBhIGtleSwgaXQncyBhIDx0ZW1wbGF0ZSB2LWZvcj4gdGhhdCBtYXlcbiAgICAgICAgICAvLyAgZ2V0IG1vdmVkIGFyb3VuZC4gTWFrZSBzdXJlIGFsbCByb290IGxldmVsIHZub2RlcyBpbmhlcml0IGVsLlxuICAgICAgICAgIC8vICMyMTM0IG9yIGlmIGl0J3MgYSBjb21wb25lbnQgcm9vdCwgaXQgbWF5IGFsc28gZ2V0IG1vdmVkIGFyb3VuZFxuICAgICAgICAgIC8vIGFzIHRoZSBjb21wb25lbnQgaXMgYmVpbmcgbW92ZWQuXG4gICAgICAgICAgbjIua2V5ICE9IG51bGwgfHwgcGFyZW50Q29tcG9uZW50ICYmIG4yID09PSBwYXJlbnRDb21wb25lbnQuc3ViVHJlZVxuICAgICAgICApIHtcbiAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgIC8qIHNoYWxsb3cgKi9cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRjaENoaWxkcmVuKFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBmcmFnbWVudEVuZEFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJvY2Vzc0NvbXBvbmVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBuMi5zbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHM7XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGlmIChuMi5zaGFwZUZsYWcgJiA1MTIpIHtcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5hY3RpdmF0ZShcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW91bnRDb21wb25lbnQoXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZUNvbXBvbmVudChuMSwgbjIsIG9wdGltaXplZCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudENvbXBvbmVudCA9IChpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSAoaW5pdGlhbFZOb2RlLmNvbXBvbmVudCA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKFxuICAgICAgaW5pdGlhbFZOb2RlLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgcGFyZW50U3VzcGVuc2VcbiAgICApKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpbnN0YW5jZS50eXBlLl9faG1ySWQpIHtcbiAgICAgIHJlZ2lzdGVySE1SKGluc3RhbmNlKTtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChpbml0aWFsVk5vZGUpO1xuICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgbW91bnRgKTtcbiAgICB9XG4gICAgaWYgKGlzS2VlcEFsaXZlKGluaXRpYWxWTm9kZSkpIHtcbiAgICAgIGluc3RhbmNlLmN0eC5yZW5kZXJlciA9IGludGVybmFscztcbiAgICB9XG4gICAge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgaW5pdGApO1xuICAgICAgfVxuICAgICAgc2V0dXBDb21wb25lbnQoaW5zdGFuY2UpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGluaXRgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLmFzeW5jRGVwKSB7XG4gICAgICBwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5yZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QpO1xuICAgICAgaWYgKCFpbml0aWFsVk5vZGUuZWwpIHtcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBpbnN0YW5jZS5zdWJUcmVlID0gY3JlYXRlVk5vZGUoQ29tbWVudCk7XG4gICAgICAgIHByb2Nlc3NDb21tZW50Tm9kZShudWxsLCBwbGFjZWhvbGRlciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXR1cFJlbmRlckVmZmVjdChcbiAgICAgIGluc3RhbmNlLFxuICAgICAgaW5pdGlhbFZOb2RlLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgYW5jaG9yLFxuICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICBpc1NWRyxcbiAgICAgIG9wdGltaXplZFxuICAgICk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgbW91bnRgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHVwZGF0ZUNvbXBvbmVudCA9IChuMSwgbjIsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gbjIuY29tcG9uZW50ID0gbjEuY29tcG9uZW50O1xuICAgIGlmIChzaG91bGRVcGRhdGVDb21wb25lbnQobjEsIG4yLCBvcHRpbWl6ZWQpKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuYXN5bmNEZXAgJiYgIWluc3RhbmNlLmFzeW5jUmVzb2x2ZWQpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQobjIpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbjIsIG9wdGltaXplZCk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0YW5jZS5uZXh0ID0gbjI7XG4gICAgICAgIGludmFsaWRhdGVKb2IoaW5zdGFuY2UudXBkYXRlKTtcbiAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICBpbnN0YW5jZS52bm9kZSA9IG4yO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0dXBSZW5kZXJFZmZlY3QgPSAoaW5zdGFuY2UsIGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgY29tcG9uZW50VXBkYXRlRm4gPSAoKSA9PiB7XG4gICAgICBpZiAoIWluc3RhbmNlLmlzTW91bnRlZCkge1xuICAgICAgICBsZXQgdm5vZGVIb29rO1xuICAgICAgICBjb25zdCB7IGVsLCBwcm9wcyB9ID0gaW5pdGlhbFZOb2RlO1xuICAgICAgICBjb25zdCB7IGJtLCBtLCBwYXJlbnQgfSA9IGluc3RhbmNlO1xuICAgICAgICBjb25zdCBpc0FzeW5jV3JhcHBlclZOb2RlID0gaXNBc3luY1dyYXBwZXIoaW5pdGlhbFZOb2RlKTtcbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgZmFsc2UpO1xuICAgICAgICBpZiAoYm0pIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhibSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0FzeW5jV3JhcHBlclZOb2RlICYmICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XG4gICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBpbml0aWFsVk5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xuICAgICAgICBpZiAoZWwgJiYgaHlkcmF0ZU5vZGUpIHtcbiAgICAgICAgICBjb25zdCBoeWRyYXRlU3ViVHJlZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHlkcmF0ZU5vZGUoXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICBpbnN0YW5jZS5zdWJUcmVlLFxuICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGlzQXN5bmNXcmFwcGVyVk5vZGUpIHtcbiAgICAgICAgICAgIGluaXRpYWxWTm9kZS50eXBlLl9fYXN5bmNMb2FkZXIoKS50aGVuKFxuICAgICAgICAgICAgICAvLyBub3RlOiB3ZSBhcmUgbW92aW5nIHRoZSByZW5kZXIgY2FsbCBpbnRvIGFuIGFzeW5jIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAvLyB3aGljaCBtZWFucyBpdCB3b24ndCB0cmFjayBkZXBlbmRlbmNpZXMgLSBidXQgaXQncyBvayBiZWNhdXNlXG4gICAgICAgICAgICAgIC8vIGEgc2VydmVyLXJlbmRlcmVkIGFzeW5jIHdyYXBwZXIgaXMgYWxyZWFkeSBpbiByZXNvbHZlZCBzdGF0ZVxuICAgICAgICAgICAgICAvLyBhbmQgaXQgd2lsbCBuZXZlciBuZWVkIHRvIGNoYW5nZS5cbiAgICAgICAgICAgICAgKCkgPT4gIWluc3RhbmNlLmlzVW5tb3VudGVkICYmIGh5ZHJhdGVTdWJUcmVlKClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh5ZHJhdGVTdWJUcmVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc3ViVHJlZSA9IGluc3RhbmNlLnN1YlRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKTtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgc3ViVHJlZSxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWR1xuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbml0aWFsVk5vZGUuZWwgPSBzdWJUcmVlLmVsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KG0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXN5bmNXcmFwcGVyVk5vZGUgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSkge1xuICAgICAgICAgIGNvbnN0IHNjb3BlZEluaXRpYWxWTm9kZSA9IGluaXRpYWxWTm9kZTtcbiAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoXG4gICAgICAgICAgICAoKSA9PiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIHNjb3BlZEluaXRpYWxWTm9kZSksXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXRpYWxWTm9kZS5zaGFwZUZsYWcgJiAyNTYgfHwgcGFyZW50ICYmIGlzQXN5bmNXcmFwcGVyKHBhcmVudC52bm9kZSkgJiYgcGFyZW50LnZub2RlLnNoYXBlRmxhZyAmIDI1Nikge1xuICAgICAgICAgIGluc3RhbmNlLmEgJiYgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGluc3RhbmNlLmEsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpbml0aWFsVk5vZGUgPSBjb250YWluZXIgPSBhbmNob3IgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHsgbmV4dCwgYnUsIHUsIHBhcmVudCwgdm5vZGUgfSA9IGluc3RhbmNlO1xuICAgICAgICBsZXQgb3JpZ2luTmV4dCA9IG5leHQ7XG4gICAgICAgIGxldCB2bm9kZUhvb2s7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG5leHQgfHwgaW5zdGFuY2Uudm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIGZhbHNlKTtcbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICBuZXh0LmVsID0gdm5vZGUuZWw7XG4gICAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuZXh0LCBvcHRpbWl6ZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQgPSB2bm9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnUpIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhidSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZub2RlSG9vayA9IG5leHQucHJvcHMgJiYgbmV4dC5wcm9wcy5vblZub2RlQmVmb3JlVXBkYXRlKSB7XG4gICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBuZXh0LCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dFRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldlRyZWUgPSBpbnN0YW5jZS5zdWJUcmVlO1xuICAgICAgICBpbnN0YW5jZS5zdWJUcmVlID0gbmV4dFRyZWU7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcbiAgICAgICAgfVxuICAgICAgICBwYXRjaChcbiAgICAgICAgICBwcmV2VHJlZSxcbiAgICAgICAgICBuZXh0VHJlZSxcbiAgICAgICAgICAvLyBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBpZiBpdCdzIGluIGEgdGVsZXBvcnRcbiAgICAgICAgICBob3N0UGFyZW50Tm9kZShwcmV2VHJlZS5lbCksXG4gICAgICAgICAgLy8gYW5jaG9yIG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIGZyYWdtZW50XG4gICAgICAgICAgZ2V0TmV4dEhvc3ROb2RlKHByZXZUcmVlKSxcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpc1NWR1xuICAgICAgICApO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICB9XG4gICAgICAgIG5leHQuZWwgPSBuZXh0VHJlZS5lbDtcbiAgICAgICAgaWYgKG9yaWdpbk5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIG5leHRUcmVlLmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodSkge1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCh1LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZub2RlSG9vayA9IG5leHQucHJvcHMgJiYgbmV4dC5wcm9wcy5vblZub2RlVXBkYXRlZCkge1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChcbiAgICAgICAgICAgICgpID0+IGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgbmV4dCwgdm5vZGUpLFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2VcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBlZmZlY3QgPSBpbnN0YW5jZS5lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoXG4gICAgICBjb21wb25lbnRVcGRhdGVGbixcbiAgICAgICgpID0+IHF1ZXVlSm9iKHVwZGF0ZSksXG4gICAgICBpbnN0YW5jZS5zY29wZVxuICAgICAgLy8gdHJhY2sgaXQgaW4gY29tcG9uZW50J3MgZWZmZWN0IHNjb3BlXG4gICAgKTtcbiAgICBjb25zdCB1cGRhdGUgPSBpbnN0YW5jZS51cGRhdGUgPSAoKSA9PiBlZmZlY3QucnVuKCk7XG4gICAgdXBkYXRlLmlkID0gaW5zdGFuY2UudWlkO1xuICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBlZmZlY3Qub25UcmFjayA9IGluc3RhbmNlLnJ0YyA/IChlKSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGMsIGUpIDogdm9pZCAwO1xuICAgICAgZWZmZWN0Lm9uVHJpZ2dlciA9IGluc3RhbmNlLnJ0ZyA/IChlKSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGcsIGUpIDogdm9pZCAwO1xuICAgICAgdXBkYXRlLm93bmVySW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICB9XG4gICAgdXBkYXRlKCk7XG4gIH07XG4gIGNvbnN0IHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlciA9IChpbnN0YW5jZSwgbmV4dFZOb2RlLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBuZXh0Vk5vZGUuY29tcG9uZW50ID0gaW5zdGFuY2U7XG4gICAgY29uc3QgcHJldlByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHM7XG4gICAgaW5zdGFuY2Uudm5vZGUgPSBuZXh0Vk5vZGU7XG4gICAgaW5zdGFuY2UubmV4dCA9IG51bGw7XG4gICAgdXBkYXRlUHJvcHMoaW5zdGFuY2UsIG5leHRWTm9kZS5wcm9wcywgcHJldlByb3BzLCBvcHRpbWl6ZWQpO1xuICAgIHVwZGF0ZVNsb3RzKGluc3RhbmNlLCBuZXh0Vk5vZGUuY2hpbGRyZW4sIG9wdGltaXplZCk7XG4gICAgcGF1c2VUcmFja2luZygpO1xuICAgIGZsdXNoUHJlRmx1c2hDYnMoKTtcbiAgICByZXNldFRyYWNraW5nKCk7XG4gIH07XG4gIGNvbnN0IHBhdGNoQ2hpbGRyZW4gPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCBjMSA9IG4xICYmIG4xLmNoaWxkcmVuO1xuICAgIGNvbnN0IHByZXZTaGFwZUZsYWcgPSBuMSA/IG4xLnNoYXBlRmxhZyA6IDA7XG4gICAgY29uc3QgYzIgPSBuMi5jaGlsZHJlbjtcbiAgICBjb25zdCB7IHBhdGNoRmxhZywgc2hhcGVGbGFnIH0gPSBuMjtcbiAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xuICAgICAgaWYgKHBhdGNoRmxhZyAmIDEyOCkge1xuICAgICAgICBwYXRjaEtleWVkQ2hpbGRyZW4oXG4gICAgICAgICAgYzEsXG4gICAgICAgICAgYzIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHBhdGNoRmxhZyAmIDI1Nikge1xuICAgICAgICBwYXRjaFVua2V5ZWRDaGlsZHJlbihcbiAgICAgICAgICBjMSxcbiAgICAgICAgICBjMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDgpIHtcbiAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChjMiAhPT0gYzEpIHtcbiAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGNvbnRhaW5lciwgYzIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihcbiAgICAgICAgICAgIGMxLFxuICAgICAgICAgICAgYzIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDgpIHtcbiAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoY29udGFpbmVyLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICAgICAgYzIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hVbmtleWVkQ2hpbGRyZW4gPSAoYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgYzEgPSBjMSB8fCBFTVBUWV9BUlI7XG4gICAgYzIgPSBjMiB8fCBFTVBUWV9BUlI7XG4gICAgY29uc3Qgb2xkTGVuZ3RoID0gYzEubGVuZ3RoO1xuICAgIGNvbnN0IG5ld0xlbmd0aCA9IGMyLmxlbmd0aDtcbiAgICBjb25zdCBjb21tb25MZW5ndGggPSBNYXRoLm1pbihvbGRMZW5ndGgsIG5ld0xlbmd0aCk7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvbW1vbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKTtcbiAgICAgIHBhdGNoKFxuICAgICAgICBjMVtpXSxcbiAgICAgICAgbmV4dENoaWxkLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIGlzU1ZHLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG9sZExlbmd0aCA+IG5ld0xlbmd0aCkge1xuICAgICAgdW5tb3VudENoaWxkcmVuKFxuICAgICAgICBjMSxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGNvbW1vbkxlbmd0aFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW91bnRDaGlsZHJlbihcbiAgICAgICAgYzIsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgIGNvbW1vbkxlbmd0aFxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoS2V5ZWRDaGlsZHJlbiA9IChjMSwgYzIsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgbDIgPSBjMi5sZW5ndGg7XG4gICAgbGV0IGUxID0gYzEubGVuZ3RoIC0gMTtcbiAgICBsZXQgZTIgPSBsMiAtIDE7XG4gICAgd2hpbGUgKGkgPD0gZTEgJiYgaSA8PSBlMikge1xuICAgICAgY29uc3QgbjEgPSBjMVtpXTtcbiAgICAgIGNvbnN0IG4yID0gYzJbaV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltpXSkgOiBub3JtYWxpemVWTm9kZShjMltpXSk7XG4gICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgICB3aGlsZSAoaSA8PSBlMSAmJiBpIDw9IGUyKSB7XG4gICAgICBjb25zdCBuMSA9IGMxW2UxXTtcbiAgICAgIGNvbnN0IG4yID0gYzJbZTJdID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbZTJdKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2UyXSk7XG4gICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZTEtLTtcbiAgICAgIGUyLS07XG4gICAgfVxuICAgIGlmIChpID4gZTEpIHtcbiAgICAgIGlmIChpIDw9IGUyKSB7XG4gICAgICAgIGNvbnN0IG5leHRQb3MgPSBlMiArIDE7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRQb3MgPCBsMiA/IGMyW25leHRQb3NdLmVsIDogcGFyZW50QW5jaG9yO1xuICAgICAgICB3aGlsZSAoaSA8PSBlMikge1xuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGMyW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpID4gZTIpIHtcbiAgICAgIHdoaWxlIChpIDw9IGUxKSB7XG4gICAgICAgIHVubW91bnQoYzFbaV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHMxID0gaTtcbiAgICAgIGNvbnN0IHMyID0gaTtcbiAgICAgIGNvbnN0IGtleVRvTmV3SW5kZXhNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChpID0gczI7IGkgPD0gZTI7IGkrKykge1xuICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKTtcbiAgICAgICAgaWYgKG5leHRDaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGtleVRvTmV3SW5kZXhNYXAuaGFzKG5leHRDaGlsZC5rZXkpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICBgRHVwbGljYXRlIGtleXMgZm91bmQgZHVyaW5nIHVwZGF0ZTpgLFxuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShuZXh0Q2hpbGQua2V5KSxcbiAgICAgICAgICAgICAgYE1ha2Ugc3VyZSBrZXlzIGFyZSB1bmlxdWUuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5VG9OZXdJbmRleE1hcC5zZXQobmV4dENoaWxkLmtleSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBqO1xuICAgICAgbGV0IHBhdGNoZWQgPSAwO1xuICAgICAgY29uc3QgdG9CZVBhdGNoZWQgPSBlMiAtIHMyICsgMTtcbiAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xuICAgICAgbGV0IG1heE5ld0luZGV4U29GYXIgPSAwO1xuICAgICAgY29uc3QgbmV3SW5kZXhUb09sZEluZGV4TWFwID0gbmV3IEFycmF5KHRvQmVQYXRjaGVkKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0b0JlUGF0Y2hlZDsgaSsrKVxuICAgICAgICBuZXdJbmRleFRvT2xkSW5kZXhNYXBbaV0gPSAwO1xuICAgICAgZm9yIChpID0gczE7IGkgPD0gZTE7IGkrKykge1xuICAgICAgICBjb25zdCBwcmV2Q2hpbGQgPSBjMVtpXTtcbiAgICAgICAgaWYgKHBhdGNoZWQgPj0gdG9CZVBhdGNoZWQpIHtcbiAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0luZGV4O1xuICAgICAgICBpZiAocHJldkNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3SW5kZXggPSBrZXlUb05ld0luZGV4TWFwLmdldChwcmV2Q2hpbGQua2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGogPSBzMjsgaiA8PSBlMjsgaisrKSB7XG4gICAgICAgICAgICBpZiAobmV3SW5kZXhUb09sZEluZGV4TWFwW2ogLSBzMl0gPT09IDAgJiYgaXNTYW1lVk5vZGVUeXBlKHByZXZDaGlsZCwgYzJbal0pKSB7XG4gICAgICAgICAgICAgIG5ld0luZGV4ID0gajtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdJbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdW5tb3VudChwcmV2Q2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0luZGV4VG9PbGRJbmRleE1hcFtuZXdJbmRleCAtIHMyXSA9IGkgKyAxO1xuICAgICAgICAgIGlmIChuZXdJbmRleCA+PSBtYXhOZXdJbmRleFNvRmFyKSB7XG4gICAgICAgICAgICBtYXhOZXdJbmRleFNvRmFyID0gbmV3SW5kZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBwcmV2Q2hpbGQsXG4gICAgICAgICAgICBjMltuZXdJbmRleF0sXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgICAgcGF0Y2hlZCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZSA9IG1vdmVkID8gZ2V0U2VxdWVuY2UobmV3SW5kZXhUb09sZEluZGV4TWFwKSA6IEVNUFRZX0FSUjtcbiAgICAgIGogPSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZS5sZW5ndGggLSAxO1xuICAgICAgZm9yIChpID0gdG9CZVBhdGNoZWQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSBzMiArIGk7XG4gICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IGMyW25leHRJbmRleF07XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRJbmRleCArIDEgPCBsMiA/IGMyW25leHRJbmRleCArIDFdLmVsIDogcGFyZW50QW5jaG9yO1xuICAgICAgICBpZiAobmV3SW5kZXhUb09sZEluZGV4TWFwW2ldID09PSAwKSB7XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbmV4dENoaWxkLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAobW92ZWQpIHtcbiAgICAgICAgICBpZiAoaiA8IDAgfHwgaSAhPT0gaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2Vbal0pIHtcbiAgICAgICAgICAgIG1vdmUobmV4dENoaWxkLCBjb250YWluZXIsIGFuY2hvciwgMik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdmUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSwgcGFyZW50U3VzcGVuc2UgPSBudWxsKSA9PiB7XG4gICAgY29uc3QgeyBlbCwgdHlwZSwgdHJhbnNpdGlvbiwgY2hpbGRyZW4sIHNoYXBlRmxhZyB9ID0gdm5vZGU7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDYpIHtcbiAgICAgIG1vdmUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgIHZub2RlLnN1c3BlbnNlLm1vdmUoY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICB0eXBlLm1vdmUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpbnRlcm5hbHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbW92ZShjaGlsZHJlbltpXSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcbiAgICAgIH1cbiAgICAgIGhvc3RJbnNlcnQodm5vZGUuYW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcbiAgICAgIG1vdmVTdGF0aWNOb2RlKHZub2RlLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5lZWRUcmFuc2l0aW9uMiA9IG1vdmVUeXBlICE9PSAyICYmIHNoYXBlRmxhZyAmIDEgJiYgdHJhbnNpdGlvbjtcbiAgICBpZiAobmVlZFRyYW5zaXRpb24yKSB7XG4gICAgICBpZiAobW92ZVR5cGUgPT09IDApIHtcbiAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHRyYW5zaXRpb24uZW50ZXIoZWwpLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IGxlYXZlLCBkZWxheUxlYXZlLCBhZnRlckxlYXZlIH0gPSB0cmFuc2l0aW9uO1xuICAgICAgICBjb25zdCByZW1vdmUyID0gKCkgPT4gaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgbGVhdmUoZWwsICgpID0+IHtcbiAgICAgICAgICAgIHJlbW92ZTIoKTtcbiAgICAgICAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgICAgICAgIGRlbGF5TGVhdmUoZWwsIHJlbW92ZTIsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVyZm9ybUxlYXZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdW5tb3VudCA9ICh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICByZWYsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgIHNoYXBlRmxhZyxcbiAgICAgIHBhdGNoRmxhZyxcbiAgICAgIGRpcnNcbiAgICB9ID0gdm5vZGU7XG4gICAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICBzZXRSZWYocmVmLCBudWxsLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgMjU2KSB7XG4gICAgICBwYXJlbnRDb21wb25lbnQuY3R4LmRlYWN0aXZhdGUodm5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaG91bGRJbnZva2VEaXJzID0gc2hhcGVGbGFnICYgMSAmJiBkaXJzO1xuICAgIGNvbnN0IHNob3VsZEludm9rZVZub2RlSG9vayA9ICFpc0FzeW5jV3JhcHBlcih2bm9kZSk7XG4gICAgbGV0IHZub2RlSG9vaztcbiAgICBpZiAoc2hvdWxkSW52b2tlVm5vZGVIb29rICYmICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlVW5tb3VudCkpIHtcbiAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgNikge1xuICAgICAgdW5tb3VudENvbXBvbmVudCh2bm9kZS5jb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgICAgdm5vZGUuc3VzcGVuc2UudW5tb3VudChwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkSW52b2tlRGlycykge1xuICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiYmVmb3JlVW5tb3VudFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgICB2bm9kZS50eXBlLnJlbW92ZShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgIGludGVybmFscyxcbiAgICAgICAgICBkb1JlbW92ZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChkeW5hbWljQ2hpbGRyZW4gJiYgLy8gIzExNTM6IGZhc3QgcGF0aCBzaG91bGQgbm90IGJlIHRha2VuIGZvciBub24tc3RhYmxlICh2LWZvcikgZnJhZ21lbnRzXG4gICAgICAodHlwZSAhPT0gRnJhZ21lbnQgfHwgcGF0Y2hGbGFnID4gMCAmJiBwYXRjaEZsYWcgJiA2NCkpIHtcbiAgICAgICAgdW5tb3VudENoaWxkcmVuKFxuICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBGcmFnbWVudCAmJiBwYXRjaEZsYWcgJiAoMTI4IHwgMjU2KSB8fCAhb3B0aW1pemVkICYmIHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgIHVubW91bnRDaGlsZHJlbihjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9XG4gICAgICBpZiAoZG9SZW1vdmUpIHtcbiAgICAgICAgcmVtb3ZlKHZub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNob3VsZEludm9rZVZub2RlSG9vayAmJiAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZVVubW91bnRlZCkgfHwgc2hvdWxkSW52b2tlRGlycykge1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICBzaG91bGRJbnZva2VEaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJ1bm1vdW50ZWRcIik7XG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZW1vdmUgPSAodm5vZGUpID0+IHtcbiAgICBjb25zdCB7IHR5cGUsIGVsLCBhbmNob3IsIHRyYW5zaXRpb24gfSA9IHZub2RlO1xuICAgIGlmICh0eXBlID09PSBGcmFnbWVudCkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdm5vZGUucGF0Y2hGbGFnID4gMCAmJiB2bm9kZS5wYXRjaEZsYWcgJiAyMDQ4ICYmIHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkKSB7XG4gICAgICAgIHZub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IENvbW1lbnQpIHtcbiAgICAgICAgICAgIGhvc3RSZW1vdmUoY2hpbGQuZWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmUoY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVGcmFnbWVudChlbCwgYW5jaG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xuICAgICAgcmVtb3ZlU3RhdGljTm9kZSh2bm9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBlcmZvcm1SZW1vdmUgPSAoKSA9PiB7XG4gICAgICBob3N0UmVtb3ZlKGVsKTtcbiAgICAgIGlmICh0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCAmJiB0cmFuc2l0aW9uLmFmdGVyTGVhdmUpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5hZnRlckxlYXZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMSAmJiB0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCkge1xuICAgICAgY29uc3QgeyBsZWF2ZSwgZGVsYXlMZWF2ZSB9ID0gdHJhbnNpdGlvbjtcbiAgICAgIGNvbnN0IHBlcmZvcm1MZWF2ZSA9ICgpID0+IGxlYXZlKGVsLCBwZXJmb3JtUmVtb3ZlKTtcbiAgICAgIGlmIChkZWxheUxlYXZlKSB7XG4gICAgICAgIGRlbGF5TGVhdmUodm5vZGUuZWwsIHBlcmZvcm1SZW1vdmUsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZXJmb3JtTGVhdmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVyZm9ybVJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVtb3ZlRnJhZ21lbnQgPSAoY3VyLCBlbmQpID0+IHtcbiAgICBsZXQgbmV4dDtcbiAgICB3aGlsZSAoY3VyICE9PSBlbmQpIHtcbiAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoY3VyKTtcbiAgICAgIGhvc3RSZW1vdmUoY3VyKTtcbiAgICAgIGN1ciA9IG5leHQ7XG4gICAgfVxuICAgIGhvc3RSZW1vdmUoZW5kKTtcbiAgfTtcbiAgY29uc3QgdW5tb3VudENvbXBvbmVudCA9IChpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKSA9PiB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XG4gICAgICB1bnJlZ2lzdGVySE1SKGluc3RhbmNlKTtcbiAgICB9XG4gICAgY29uc3QgeyBidW0sIHNjb3BlLCB1cGRhdGUsIHN1YlRyZWUsIHVtIH0gPSBpbnN0YW5jZTtcbiAgICBpZiAoYnVtKSB7XG4gICAgICBpbnZva2VBcnJheUZucyhidW0pO1xuICAgIH1cbiAgICBzY29wZS5zdG9wKCk7XG4gICAgaWYgKHVwZGF0ZSkge1xuICAgICAgdXBkYXRlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgdW5tb3VudChzdWJUcmVlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcbiAgICB9XG4gICAgaWYgKHVtKSB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodW0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICB9XG4gICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgIGluc3RhbmNlLmlzVW5tb3VudGVkID0gdHJ1ZTtcbiAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgaWYgKHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiYgIXBhcmVudFN1c3BlbnNlLmlzVW5tb3VudGVkICYmIGluc3RhbmNlLmFzeW5jRGVwICYmICFpbnN0YW5jZS5hc3luY1Jlc29sdmVkICYmIGluc3RhbmNlLnN1c3BlbnNlSWQgPT09IHBhcmVudFN1c3BlbnNlLnBlbmRpbmdJZCkge1xuICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcy0tO1xuICAgICAgaWYgKHBhcmVudFN1c3BlbnNlLmRlcHMgPT09IDApIHtcbiAgICAgICAgcGFyZW50U3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZChpbnN0YW5jZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCB1bm1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlLCBzdGFydCA9IDApID0+IHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdW5tb3VudChjaGlsZHJlbltpXSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUsIG9wdGltaXplZCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBnZXROZXh0SG9zdE5vZGUgPSAodm5vZGUpID0+IHtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNikge1xuICAgICAgcmV0dXJuIGdldE5leHRIb3N0Tm9kZSh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgIHJldHVybiB2bm9kZS5zdXNwZW5zZS5uZXh0KCk7XG4gICAgfVxuICAgIHJldHVybiBob3N0TmV4dFNpYmxpbmcodm5vZGUuYW5jaG9yIHx8IHZub2RlLmVsKTtcbiAgfTtcbiAgY29uc3QgcmVuZGVyID0gKHZub2RlLCBjb250YWluZXIsIGlzU1ZHKSA9PiB7XG4gICAgaWYgKHZub2RlID09IG51bGwpIHtcbiAgICAgIGlmIChjb250YWluZXIuX3Zub2RlKSB7XG4gICAgICAgIHVubW91bnQoY29udGFpbmVyLl92bm9kZSwgbnVsbCwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGNoKGNvbnRhaW5lci5fdm5vZGUgfHwgbnVsbCwgdm5vZGUsIGNvbnRhaW5lciwgbnVsbCwgbnVsbCwgbnVsbCwgaXNTVkcpO1xuICAgIH1cbiAgICBmbHVzaFByZUZsdXNoQ2JzKCk7XG4gICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcbiAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XG4gIH07XG4gIGNvbnN0IGludGVybmFscyA9IHtcbiAgICBwOiBwYXRjaCxcbiAgICB1bTogdW5tb3VudCxcbiAgICBtOiBtb3ZlLFxuICAgIHI6IHJlbW92ZSxcbiAgICBtdDogbW91bnRDb21wb25lbnQsXG4gICAgbWM6IG1vdW50Q2hpbGRyZW4sXG4gICAgcGM6IHBhdGNoQ2hpbGRyZW4sXG4gICAgcGJjOiBwYXRjaEJsb2NrQ2hpbGRyZW4sXG4gICAgbjogZ2V0TmV4dEhvc3ROb2RlLFxuICAgIG86IG9wdGlvbnNcbiAgfTtcbiAgbGV0IGh5ZHJhdGU7XG4gIGxldCBoeWRyYXRlTm9kZTtcbiAgaWYgKGNyZWF0ZUh5ZHJhdGlvbkZucykge1xuICAgIFtoeWRyYXRlLCBoeWRyYXRlTm9kZV0gPSBjcmVhdGVIeWRyYXRpb25GbnMoXG4gICAgICBpbnRlcm5hbHNcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVuZGVyLFxuICAgIGh5ZHJhdGUsXG4gICAgY3JlYXRlQXBwOiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKVxuICB9O1xufVxuZnVuY3Rpb24gdG9nZ2xlUmVjdXJzZSh7IGVmZmVjdCwgdXBkYXRlIH0sIGFsbG93ZWQpIHtcbiAgZWZmZWN0LmFsbG93UmVjdXJzZSA9IHVwZGF0ZS5hbGxvd1JlY3Vyc2UgPSBhbGxvd2VkO1xufVxuZnVuY3Rpb24gbmVlZFRyYW5zaXRpb24ocGFyZW50U3VzcGVuc2UsIHRyYW5zaXRpb24pIHtcbiAgcmV0dXJuICghcGFyZW50U3VzcGVuc2UgfHwgcGFyZW50U3VzcGVuc2UgJiYgIXBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpICYmIHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkO1xufVxuZnVuY3Rpb24gdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHNoYWxsb3cgPSBmYWxzZSkge1xuICBjb25zdCBjaDEgPSBuMS5jaGlsZHJlbjtcbiAgY29uc3QgY2gyID0gbjIuY2hpbGRyZW47XG4gIGlmIChpc0FycmF5KGNoMSkgJiYgaXNBcnJheShjaDIpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaDEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMxID0gY2gxW2ldO1xuICAgICAgbGV0IGMyID0gY2gyW2ldO1xuICAgICAgaWYgKGMyLnNoYXBlRmxhZyAmIDEgJiYgIWMyLmR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgICBpZiAoYzIucGF0Y2hGbGFnIDw9IDAgfHwgYzIucGF0Y2hGbGFnID09PSAzMikge1xuICAgICAgICAgIGMyID0gY2gyW2ldID0gY2xvbmVJZk1vdW50ZWQoY2gyW2ldKTtcbiAgICAgICAgICBjMi5lbCA9IGMxLmVsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2hhbGxvdylcbiAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKGMxLCBjMik7XG4gICAgICB9XG4gICAgICBpZiAoYzIudHlwZSA9PT0gVGV4dCkge1xuICAgICAgICBjMi5lbCA9IGMxLmVsO1xuICAgICAgfVxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgYzIudHlwZSA9PT0gQ29tbWVudCAmJiAhYzIuZWwpIHtcbiAgICAgICAgYzIuZWwgPSBjMS5lbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNlcXVlbmNlKGFycikge1xuICBjb25zdCBwID0gYXJyLnNsaWNlKCk7XG4gIGNvbnN0IHJlc3VsdCA9IFswXTtcbiAgbGV0IGksIGosIHUsIHYsIGM7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGFyckkgPSBhcnJbaV07XG4gICAgaWYgKGFyckkgIT09IDApIHtcbiAgICAgIGogPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGFycltqXSA8IGFyckkpIHtcbiAgICAgICAgcFtpXSA9IGo7XG4gICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHUgPSAwO1xuICAgICAgdiA9IHJlc3VsdC5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKHUgPCB2KSB7XG4gICAgICAgIGMgPSB1ICsgdiA+PiAxO1xuICAgICAgICBpZiAoYXJyW3Jlc3VsdFtjXV0gPCBhcnJJKSB7XG4gICAgICAgICAgdSA9IGMgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHYgPSBjO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYXJySSA8IGFycltyZXN1bHRbdV1dKSB7XG4gICAgICAgIGlmICh1ID4gMCkge1xuICAgICAgICAgIHBbaV0gPSByZXN1bHRbdSAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFt1XSA9IGk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHUgPSByZXN1bHQubGVuZ3RoO1xuICB2ID0gcmVzdWx0W3UgLSAxXTtcbiAgd2hpbGUgKHUtLSA+IDApIHtcbiAgICByZXN1bHRbdV0gPSB2O1xuICAgIHYgPSBwW3ZdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IGlzVGVsZXBvcnQgPSAodHlwZSkgPT4gdHlwZS5fX2lzVGVsZXBvcnQ7XG5jb25zdCBpc1RlbGVwb3J0RGlzYWJsZWQgPSAocHJvcHMpID0+IHByb3BzICYmIChwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy5kaXNhYmxlZCA9PT0gXCJcIik7XG5jb25zdCBpc1RhcmdldFNWRyA9ICh0YXJnZXQpID0+IHR5cGVvZiBTVkdFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7XG5jb25zdCByZXNvbHZlVGFyZ2V0ID0gKHByb3BzLCBzZWxlY3QpID0+IHtcbiAgY29uc3QgdGFyZ2V0U2VsZWN0b3IgPSBwcm9wcyAmJiBwcm9wcy50bztcbiAgaWYgKGlzU3RyaW5nKHRhcmdldFNlbGVjdG9yKSkge1xuICAgIGlmICghc2VsZWN0KSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oXG4gICAgICAgIGBDdXJyZW50IHJlbmRlcmVyIGRvZXMgbm90IHN1cHBvcnQgc3RyaW5nIHRhcmdldCBmb3IgVGVsZXBvcnRzLiAobWlzc2luZyBxdWVyeVNlbGVjdG9yIHJlbmRlcmVyIG9wdGlvbilgXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHNlbGVjdCh0YXJnZXRTZWxlY3Rvcik7XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oXG4gICAgICAgICAgYEZhaWxlZCB0byBsb2NhdGUgVGVsZXBvcnQgdGFyZ2V0IHdpdGggc2VsZWN0b3IgXCIke3RhcmdldFNlbGVjdG9yfVwiLiBOb3RlIHRoZSB0YXJnZXQgZWxlbWVudCBtdXN0IGV4aXN0IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQgLSBpLmUuIHRoZSB0YXJnZXQgY2Fubm90IGJlIHJlbmRlcmVkIGJ5IHRoZSBjb21wb25lbnQgaXRzZWxmLCBhbmQgaWRlYWxseSBzaG91bGQgYmUgb3V0c2lkZSBvZiB0aGUgZW50aXJlIFZ1ZSBjb21wb25lbnQgdHJlZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhdGFyZ2V0U2VsZWN0b3IgJiYgIWlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcbiAgICAgIHdhcm4oYEludmFsaWQgVGVsZXBvcnQgdGFyZ2V0OiAke3RhcmdldFNlbGVjdG9yfWApO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0U2VsZWN0b3I7XG4gIH1cbn07XG5jb25zdCBUZWxlcG9ydEltcGwgPSB7XG4gIF9faXNUZWxlcG9ydDogdHJ1ZSxcbiAgcHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIGludGVybmFscykge1xuICAgIGNvbnN0IHtcbiAgICAgIG1jOiBtb3VudENoaWxkcmVuLFxuICAgICAgcGM6IHBhdGNoQ2hpbGRyZW4sXG4gICAgICBwYmM6IHBhdGNoQmxvY2tDaGlsZHJlbixcbiAgICAgIG86IHsgaW5zZXJ0LCBxdWVyeVNlbGVjdG9yLCBjcmVhdGVUZXh0LCBjcmVhdGVDb21tZW50IH1cbiAgICB9ID0gaW50ZXJuYWxzO1xuICAgIGNvbnN0IGRpc2FibGVkID0gaXNUZWxlcG9ydERpc2FibGVkKG4yLnByb3BzKTtcbiAgICBsZXQgeyBzaGFwZUZsYWcsIGNoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4gfSA9IG4yO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gbjIuZWwgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gY3JlYXRlQ29tbWVudChcInRlbGVwb3J0IHN0YXJ0XCIpIDogY3JlYXRlVGV4dChcIlwiKTtcbiAgICAgIGNvbnN0IG1haW5BbmNob3IgPSBuMi5hbmNob3IgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gY3JlYXRlQ29tbWVudChcInRlbGVwb3J0IGVuZFwiKSA6IGNyZWF0ZVRleHQoXCJcIik7XG4gICAgICBpbnNlcnQocGxhY2Vob2xkZXIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIGluc2VydChtYWluQW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICBjb25zdCB0YXJnZXQgPSBuMi50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KG4yLnByb3BzLCBxdWVyeVNlbGVjdG9yKTtcbiAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IG4yLnRhcmdldEFuY2hvciA9IGNyZWF0ZVRleHQoXCJcIik7XG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGluc2VydCh0YXJnZXRBbmNob3IsIHRhcmdldCk7XG4gICAgICAgIGlzU1ZHID0gaXNTVkcgfHwgaXNUYXJnZXRTVkcodGFyZ2V0KTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhZGlzYWJsZWQpIHtcbiAgICAgICAgd2FybihcIkludmFsaWQgVGVsZXBvcnQgdGFyZ2V0IG9uIG1vdW50OlwiLCB0YXJnZXQsIGAoJHt0eXBlb2YgdGFyZ2V0fSlgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vdW50ID0gKGNvbnRhaW5lcjIsIGFuY2hvcjIpID0+IHtcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgICAgbW91bnRDaGlsZHJlbihcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgY29udGFpbmVyMixcbiAgICAgICAgICAgIGFuY2hvcjIsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICBtb3VudChjb250YWluZXIsIG1haW5BbmNob3IpO1xuICAgICAgfSBlbHNlIGlmICh0YXJnZXQpIHtcbiAgICAgICAgbW91bnQodGFyZ2V0LCB0YXJnZXRBbmNob3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgY29uc3QgbWFpbkFuY2hvciA9IG4yLmFuY2hvciA9IG4xLmFuY2hvcjtcbiAgICAgIGNvbnN0IHRhcmdldCA9IG4yLnRhcmdldCA9IG4xLnRhcmdldDtcbiAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IG4yLnRhcmdldEFuY2hvciA9IG4xLnRhcmdldEFuY2hvcjtcbiAgICAgIGNvbnN0IHdhc0Rpc2FibGVkID0gaXNUZWxlcG9ydERpc2FibGVkKG4xLnByb3BzKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRDb250YWluZXIgPSB3YXNEaXNhYmxlZCA/IGNvbnRhaW5lciA6IHRhcmdldDtcbiAgICAgIGNvbnN0IGN1cnJlbnRBbmNob3IgPSB3YXNEaXNhYmxlZCA/IG1haW5BbmNob3IgOiB0YXJnZXRBbmNob3I7XG4gICAgICBpc1NWRyA9IGlzU1ZHIHx8IGlzVGFyZ2V0U1ZHKHRhcmdldCk7XG4gICAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihcbiAgICAgICAgICBuMS5keW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIGN1cnJlbnRDb250YWluZXIsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkc1xuICAgICAgICApO1xuICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMiwgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKCFvcHRpbWl6ZWQpIHtcbiAgICAgICAgcGF0Y2hDaGlsZHJlbihcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjdXJyZW50Q29udGFpbmVyLFxuICAgICAgICAgIGN1cnJlbnRBbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIGlmICghd2FzRGlzYWJsZWQpIHtcbiAgICAgICAgICBtb3ZlVGVsZXBvcnQoXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIG1haW5BbmNob3IsXG4gICAgICAgICAgICBpbnRlcm5hbHMsXG4gICAgICAgICAgICAxXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobjIucHJvcHMgJiYgbjEucHJvcHMgJiYgbjIucHJvcHMudG8gIT09IG4xLnByb3BzLnRvKSB7XG4gICAgICAgICAgICBuMi5wcm9wcy50byA9IG4xLnByb3BzLnRvO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKChuMi5wcm9wcyAmJiBuMi5wcm9wcy50bykgIT09IChuMS5wcm9wcyAmJiBuMS5wcm9wcy50bykpIHtcbiAgICAgICAgICBjb25zdCBuZXh0VGFyZ2V0ID0gbjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChcbiAgICAgICAgICAgIG4yLnByb3BzLFxuICAgICAgICAgICAgcXVlcnlTZWxlY3RvclxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG5leHRUYXJnZXQpIHtcbiAgICAgICAgICAgIG1vdmVUZWxlcG9ydChcbiAgICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICAgIG5leHRUYXJnZXQsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIGludGVybmFscyxcbiAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gdXBkYXRlOlwiLFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIGAoJHt0eXBlb2YgdGFyZ2V0fSlgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh3YXNEaXNhYmxlZCkge1xuICAgICAgICAgIG1vdmVUZWxlcG9ydChcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgdGFyZ2V0QW5jaG9yLFxuICAgICAgICAgICAgaW50ZXJuYWxzLFxuICAgICAgICAgICAgMVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlQ3NzVmFycyhuMik7XG4gIH0sXG4gIHJlbW92ZSh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkLCB7IHVtOiB1bm1vdW50LCBvOiB7IHJlbW92ZTogaG9zdFJlbW92ZSB9IH0sIGRvUmVtb3ZlKSB7XG4gICAgY29uc3QgeyBzaGFwZUZsYWcsIGNoaWxkcmVuLCBhbmNob3IsIHRhcmdldEFuY2hvciwgdGFyZ2V0LCBwcm9wcyB9ID0gdm5vZGU7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgaG9zdFJlbW92ZSh0YXJnZXRBbmNob3IpO1xuICAgIH1cbiAgICBkb1JlbW92ZSAmJiBob3N0UmVtb3ZlKGFuY2hvcik7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICBjb25zdCBzaG91bGRSZW1vdmUgPSBkb1JlbW92ZSB8fCAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgdW5tb3VudChcbiAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgc2hvdWxkUmVtb3ZlLFxuICAgICAgICAgICEhY2hpbGQuZHluYW1pY0NoaWxkcmVuXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3ZlOiBtb3ZlVGVsZXBvcnQsXG4gIGh5ZHJhdGU6IGh5ZHJhdGVUZWxlcG9ydFxufTtcbmZ1bmN0aW9uIG1vdmVUZWxlcG9ydCh2bm9kZSwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIHsgbzogeyBpbnNlcnQgfSwgbTogbW92ZSB9LCBtb3ZlVHlwZSA9IDIpIHtcbiAgaWYgKG1vdmVUeXBlID09PSAwKSB7XG4gICAgaW5zZXJ0KHZub2RlLnRhcmdldEFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICB9XG4gIGNvbnN0IHsgZWwsIGFuY2hvciwgc2hhcGVGbGFnLCBjaGlsZHJlbiwgcHJvcHMgfSA9IHZub2RlO1xuICBjb25zdCBpc1Jlb3JkZXIgPSBtb3ZlVHlwZSA9PT0gMjtcbiAgaWYgKGlzUmVvcmRlcikge1xuICAgIGluc2VydChlbCwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICB9XG4gIGlmICghaXNSZW9yZGVyIHx8IGlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcbiAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbW92ZShcbiAgICAgICAgICBjaGlsZHJlbltpXSxcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgcGFyZW50QW5jaG9yLFxuICAgICAgICAgIDJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGlzUmVvcmRlcikge1xuICAgIGluc2VydChhbmNob3IsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gaHlkcmF0ZVRlbGVwb3J0KG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwge1xuICBvOiB7IG5leHRTaWJsaW5nLCBwYXJlbnROb2RlLCBxdWVyeVNlbGVjdG9yIH1cbn0sIGh5ZHJhdGVDaGlsZHJlbikge1xuICBjb25zdCB0YXJnZXQgPSB2bm9kZS50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KFxuICAgIHZub2RlLnByb3BzLFxuICAgIHF1ZXJ5U2VsZWN0b3JcbiAgKTtcbiAgaWYgKHRhcmdldCkge1xuICAgIGNvbnN0IHRhcmdldE5vZGUgPSB0YXJnZXQuX2xwYSB8fCB0YXJnZXQuZmlyc3RDaGlsZDtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIGlmIChpc1RlbGVwb3J0RGlzYWJsZWQodm5vZGUucHJvcHMpKSB7XG4gICAgICAgIHZub2RlLmFuY2hvciA9IGh5ZHJhdGVDaGlsZHJlbihcbiAgICAgICAgICBuZXh0U2libGluZyhub2RlKSxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBwYXJlbnROb2RlKG5vZGUpLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHZub2RlLnRhcmdldEFuY2hvciA9IHRhcmdldE5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5hbmNob3IgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgbGV0IHRhcmdldEFuY2hvciA9IHRhcmdldE5vZGU7XG4gICAgICAgIHdoaWxlICh0YXJnZXRBbmNob3IpIHtcbiAgICAgICAgICB0YXJnZXRBbmNob3IgPSBuZXh0U2libGluZyh0YXJnZXRBbmNob3IpO1xuICAgICAgICAgIGlmICh0YXJnZXRBbmNob3IgJiYgdGFyZ2V0QW5jaG9yLm5vZGVUeXBlID09PSA4ICYmIHRhcmdldEFuY2hvci5kYXRhID09PSBcInRlbGVwb3J0IGFuY2hvclwiKSB7XG4gICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSB0YXJnZXRBbmNob3I7XG4gICAgICAgICAgICB0YXJnZXQuX2xwYSA9IHZub2RlLnRhcmdldEFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS50YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGh5ZHJhdGVDaGlsZHJlbihcbiAgICAgICAgICB0YXJnZXROb2RlLFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVDc3NWYXJzKHZub2RlKTtcbiAgfVxuICByZXR1cm4gdm5vZGUuYW5jaG9yICYmIG5leHRTaWJsaW5nKHZub2RlLmFuY2hvcik7XG59XG5jb25zdCBUZWxlcG9ydCA9IFRlbGVwb3J0SW1wbDtcbmZ1bmN0aW9uIHVwZGF0ZUNzc1ZhcnModm5vZGUpIHtcbiAgY29uc3QgY3R4ID0gdm5vZGUuY3R4O1xuICBpZiAoY3R4ICYmIGN0eC51dCkge1xuICAgIGxldCBub2RlID0gdm5vZGUuY2hpbGRyZW5bMF0uZWw7XG4gICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPT0gdm5vZGUudGFyZ2V0QW5jaG9yKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSlcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXYtb3duZXJcIiwgY3R4LnVpZCk7XG4gICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICB9XG4gICAgY3R4LnV0KCk7XG4gIH1cbn1cblxuY29uc3QgRnJhZ21lbnQgPSBTeW1ib2wuZm9yKFwidi1mZ3RcIik7XG5jb25zdCBUZXh0ID0gU3ltYm9sLmZvcihcInYtdHh0XCIpO1xuY29uc3QgQ29tbWVudCA9IFN5bWJvbC5mb3IoXCJ2LWNtdFwiKTtcbmNvbnN0IFN0YXRpYyA9IFN5bWJvbC5mb3IoXCJ2LXN0Y1wiKTtcbmNvbnN0IGJsb2NrU3RhY2sgPSBbXTtcbmxldCBjdXJyZW50QmxvY2sgPSBudWxsO1xuZnVuY3Rpb24gb3BlbkJsb2NrKGRpc2FibGVUcmFja2luZyA9IGZhbHNlKSB7XG4gIGJsb2NrU3RhY2sucHVzaChjdXJyZW50QmxvY2sgPSBkaXNhYmxlVHJhY2tpbmcgPyBudWxsIDogW10pO1xufVxuZnVuY3Rpb24gY2xvc2VCbG9jaygpIHtcbiAgYmxvY2tTdGFjay5wb3AoKTtcbiAgY3VycmVudEJsb2NrID0gYmxvY2tTdGFja1tibG9ja1N0YWNrLmxlbmd0aCAtIDFdIHx8IG51bGw7XG59XG5sZXQgaXNCbG9ja1RyZWVFbmFibGVkID0gMTtcbmZ1bmN0aW9uIHNldEJsb2NrVHJhY2tpbmcodmFsdWUpIHtcbiAgaXNCbG9ja1RyZWVFbmFibGVkICs9IHZhbHVlO1xufVxuZnVuY3Rpb24gc2V0dXBCbG9jayh2bm9kZSkge1xuICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPSBpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwID8gY3VycmVudEJsb2NrIHx8IEVNUFRZX0FSUiA6IG51bGw7XG4gIGNsb3NlQmxvY2soKTtcbiAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgY3VycmVudEJsb2NrKSB7XG4gICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xuICB9XG4gIHJldHVybiB2bm9kZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRCbG9jayh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCBzaGFwZUZsYWcpIHtcbiAgcmV0dXJuIHNldHVwQmxvY2soXG4gICAgY3JlYXRlQmFzZVZOb2RlKFxuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBwYXRjaEZsYWcsXG4gICAgICBkeW5hbWljUHJvcHMsXG4gICAgICBzaGFwZUZsYWcsXG4gICAgICB0cnVlXG4gICAgICAvKiBpc0Jsb2NrICovXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlQmxvY2sodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcykge1xuICByZXR1cm4gc2V0dXBCbG9jayhcbiAgICBjcmVhdGVWTm9kZShcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcGF0Y2hGbGFnLFxuICAgICAgZHluYW1pY1Byb3BzLFxuICAgICAgdHJ1ZVxuICAgICAgLyogaXNCbG9jazogcHJldmVudCBhIGJsb2NrIGZyb20gdHJhY2tpbmcgaXRzZWxmICovXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gaXNWTm9kZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPyB2YWx1ZS5fX3ZfaXNWTm9kZSA9PT0gdHJ1ZSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBuMi5zaGFwZUZsYWcgJiA2ICYmIGhtckRpcnR5Q29tcG9uZW50cy5oYXMobjIudHlwZSkpIHtcbiAgICBuMS5zaGFwZUZsYWcgJj0gfjI1NjtcbiAgICBuMi5zaGFwZUZsYWcgJj0gfjUxMjtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG4xLnR5cGUgPT09IG4yLnR5cGUgJiYgbjEua2V5ID09PSBuMi5rZXk7XG59XG5sZXQgdm5vZGVBcmdzVHJhbnNmb3JtZXI7XG5mdW5jdGlvbiB0cmFuc2Zvcm1WTm9kZUFyZ3ModHJhbnNmb3JtZXIpIHtcbiAgdm5vZGVBcmdzVHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lcjtcbn1cbmNvbnN0IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm0gPSAoLi4uYXJncykgPT4ge1xuICByZXR1cm4gX2NyZWF0ZVZOb2RlKFxuICAgIC4uLnZub2RlQXJnc1RyYW5zZm9ybWVyID8gdm5vZGVBcmdzVHJhbnNmb3JtZXIoYXJncywgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSA6IGFyZ3NcbiAgKTtcbn07XG5jb25zdCBJbnRlcm5hbE9iamVjdEtleSA9IGBfX3ZJbnRlcm5hbGA7XG5jb25zdCBub3JtYWxpemVLZXkgPSAoeyBrZXkgfSkgPT4ga2V5ICE9IG51bGwgPyBrZXkgOiBudWxsO1xuY29uc3Qgbm9ybWFsaXplUmVmID0gKHtcbiAgcmVmLFxuICByZWZfa2V5LFxuICByZWZfZm9yXG59KSA9PiB7XG4gIGlmICh0eXBlb2YgcmVmID09PSBcIm51bWJlclwiKSB7XG4gICAgcmVmID0gXCJcIiArIHJlZjtcbiAgfVxuICByZXR1cm4gcmVmICE9IG51bGwgPyBpc1N0cmluZyhyZWYpIHx8IGlzUmVmKHJlZikgfHwgaXNGdW5jdGlvbihyZWYpID8geyBpOiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIHI6IHJlZiwgazogcmVmX2tleSwgZjogISFyZWZfZm9yIH0gOiByZWYgOiBudWxsO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VWTm9kZSh0eXBlLCBwcm9wcyA9IG51bGwsIGNoaWxkcmVuID0gbnVsbCwgcGF0Y2hGbGFnID0gMCwgZHluYW1pY1Byb3BzID0gbnVsbCwgc2hhcGVGbGFnID0gdHlwZSA9PT0gRnJhZ21lbnQgPyAwIDogMSwgaXNCbG9ja05vZGUgPSBmYWxzZSwgbmVlZEZ1bGxDaGlsZHJlbk5vcm1hbGl6YXRpb24gPSBmYWxzZSkge1xuICBjb25zdCB2bm9kZSA9IHtcbiAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcbiAgICBfX3Zfc2tpcDogdHJ1ZSxcbiAgICB0eXBlLFxuICAgIHByb3BzLFxuICAgIGtleTogcHJvcHMgJiYgbm9ybWFsaXplS2V5KHByb3BzKSxcbiAgICByZWY6IHByb3BzICYmIG5vcm1hbGl6ZVJlZihwcm9wcyksXG4gICAgc2NvcGVJZDogY3VycmVudFNjb3BlSWQsXG4gICAgc2xvdFNjb3BlSWRzOiBudWxsLFxuICAgIGNoaWxkcmVuLFxuICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICBzdXNwZW5zZTogbnVsbCxcbiAgICBzc0NvbnRlbnQ6IG51bGwsXG4gICAgc3NGYWxsYmFjazogbnVsbCxcbiAgICBkaXJzOiBudWxsLFxuICAgIHRyYW5zaXRpb246IG51bGwsXG4gICAgZWw6IG51bGwsXG4gICAgYW5jaG9yOiBudWxsLFxuICAgIHRhcmdldDogbnVsbCxcbiAgICB0YXJnZXRBbmNob3I6IG51bGwsXG4gICAgc3RhdGljQ291bnQ6IDAsXG4gICAgc2hhcGVGbGFnLFxuICAgIHBhdGNoRmxhZyxcbiAgICBkeW5hbWljUHJvcHMsXG4gICAgZHluYW1pY0NoaWxkcmVuOiBudWxsLFxuICAgIGFwcENvbnRleHQ6IG51bGwsXG4gICAgY3R4OiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2VcbiAgfTtcbiAgaWYgKG5lZWRGdWxsQ2hpbGRyZW5Ob3JtYWxpemF0aW9uKSB7XG4gICAgbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuKTtcbiAgICBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICB0eXBlLm5vcm1hbGl6ZSh2bm9kZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNoaWxkcmVuKSB7XG4gICAgdm5vZGUuc2hhcGVGbGFnIHw9IGlzU3RyaW5nKGNoaWxkcmVuKSA/IDggOiAxNjtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB2bm9kZS5rZXkgIT09IHZub2RlLmtleSkge1xuICAgIHdhcm4oYFZOb2RlIGNyZWF0ZWQgd2l0aCBpbnZhbGlkIGtleSAoTmFOKS4gVk5vZGUgdHlwZTpgLCB2bm9kZS50eXBlKTtcbiAgfVxuICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiAvLyBhdm9pZCBhIGJsb2NrIG5vZGUgZnJvbSB0cmFja2luZyBpdHNlbGZcbiAgIWlzQmxvY2tOb2RlICYmIC8vIGhhcyBjdXJyZW50IHBhcmVudCBibG9ja1xuICBjdXJyZW50QmxvY2sgJiYgLy8gcHJlc2VuY2Ugb2YgYSBwYXRjaCBmbGFnIGluZGljYXRlcyB0aGlzIG5vZGUgbmVlZHMgcGF0Y2hpbmcgb24gdXBkYXRlcy5cbiAgLy8gY29tcG9uZW50IG5vZGVzIGFsc28gc2hvdWxkIGFsd2F5cyBiZSBwYXRjaGVkLCBiZWNhdXNlIGV2ZW4gaWYgdGhlXG4gIC8vIGNvbXBvbmVudCBkb2Vzbid0IG5lZWQgdG8gdXBkYXRlLCBpdCBuZWVkcyB0byBwZXJzaXN0IHRoZSBpbnN0YW5jZSBvbiB0b1xuICAvLyB0aGUgbmV4dCB2bm9kZSBzbyB0aGF0IGl0IGNhbiBiZSBwcm9wZXJseSB1bm1vdW50ZWQgbGF0ZXIuXG4gICh2bm9kZS5wYXRjaEZsYWcgPiAwIHx8IHNoYXBlRmxhZyAmIDYpICYmIC8vIHRoZSBFVkVOVFMgZmxhZyBpcyBvbmx5IGZvciBoeWRyYXRpb24gYW5kIGlmIGl0IGlzIHRoZSBvbmx5IGZsYWcsIHRoZVxuICAvLyB2bm9kZSBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgZHluYW1pYyBkdWUgdG8gaGFuZGxlciBjYWNoaW5nLlxuICB2bm9kZS5wYXRjaEZsYWcgIT09IDMyKSB7XG4gICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xuICB9XG4gIHJldHVybiB2bm9kZTtcbn1cbmNvbnN0IGNyZWF0ZVZOb2RlID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm0gOiBfY3JlYXRlVk5vZGU7XG5mdW5jdGlvbiBfY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMgPSBudWxsLCBjaGlsZHJlbiA9IG51bGwsIHBhdGNoRmxhZyA9IDAsIGR5bmFtaWNQcm9wcyA9IG51bGwsIGlzQmxvY2tOb2RlID0gZmFsc2UpIHtcbiAgaWYgKCF0eXBlIHx8IHR5cGUgPT09IE5VTExfRFlOQU1JQ19DT01QT05FTlQpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhdHlwZSkge1xuICAgICAgd2FybihgSW52YWxpZCB2bm9kZSB0eXBlIHdoZW4gY3JlYXRpbmcgdm5vZGU6ICR7dHlwZX0uYCk7XG4gICAgfVxuICAgIHR5cGUgPSBDb21tZW50O1xuICB9XG4gIGlmIChpc1ZOb2RlKHR5cGUpKSB7XG4gICAgY29uc3QgY2xvbmVkID0gY2xvbmVWTm9kZShcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIHRydWVcbiAgICAgIC8qIG1lcmdlUmVmOiB0cnVlICovXG4gICAgKTtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKGNsb25lZCwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiAhaXNCbG9ja05vZGUgJiYgY3VycmVudEJsb2NrKSB7XG4gICAgICBpZiAoY2xvbmVkLnNoYXBlRmxhZyAmIDYpIHtcbiAgICAgICAgY3VycmVudEJsb2NrW2N1cnJlbnRCbG9jay5pbmRleE9mKHR5cGUpXSA9IGNsb25lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRCbG9jay5wdXNoKGNsb25lZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNsb25lZC5wYXRjaEZsYWcgfD0gLTI7XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuICBpZiAoaXNDbGFzc0NvbXBvbmVudCh0eXBlKSkge1xuICAgIHR5cGUgPSB0eXBlLl9fdmNjT3B0cztcbiAgfVxuICBpZiAocHJvcHMpIHtcbiAgICBwcm9wcyA9IGd1YXJkUmVhY3RpdmVQcm9wcyhwcm9wcyk7XG4gICAgbGV0IHsgY2xhc3M6IGtsYXNzLCBzdHlsZSB9ID0gcHJvcHM7XG4gICAgaWYgKGtsYXNzICYmICFpc1N0cmluZyhrbGFzcykpIHtcbiAgICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3Qoc3R5bGUpKSB7XG4gICAgICBpZiAoaXNQcm94eShzdHlsZSkgJiYgIWlzQXJyYXkoc3R5bGUpKSB7XG4gICAgICAgIHN0eWxlID0gZXh0ZW5kKHt9LCBzdHlsZSk7XG4gICAgICB9XG4gICAgICBwcm9wcy5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2hhcGVGbGFnID0gaXNTdHJpbmcodHlwZSkgPyAxIDogaXNTdXNwZW5zZSh0eXBlKSA/IDEyOCA6IGlzVGVsZXBvcnQodHlwZSkgPyA2NCA6IGlzT2JqZWN0KHR5cGUpID8gNCA6IGlzRnVuY3Rpb24odHlwZSkgPyAyIDogMDtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2hhcGVGbGFnICYgNCAmJiBpc1Byb3h5KHR5cGUpKSB7XG4gICAgdHlwZSA9IHRvUmF3KHR5cGUpO1xuICAgIHdhcm4oXG4gICAgICBgVnVlIHJlY2VpdmVkIGEgQ29tcG9uZW50IHdoaWNoIHdhcyBtYWRlIGEgcmVhY3RpdmUgb2JqZWN0LiBUaGlzIGNhbiBsZWFkIHRvIHVubmVjZXNzYXJ5IHBlcmZvcm1hbmNlIG92ZXJoZWFkLCBhbmQgc2hvdWxkIGJlIGF2b2lkZWQgYnkgbWFya2luZyB0aGUgY29tcG9uZW50IHdpdGggXFxgbWFya1Jhd1xcYCBvciB1c2luZyBcXGBzaGFsbG93UmVmXFxgIGluc3RlYWQgb2YgXFxgcmVmXFxgLmAsXG4gICAgICBgXG5Db21wb25lbnQgdGhhdCB3YXMgbWFkZSByZWFjdGl2ZTogYCxcbiAgICAgIHR5cGVcbiAgICApO1xuICB9XG4gIHJldHVybiBjcmVhdGVCYXNlVk5vZGUoXG4gICAgdHlwZSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBwYXRjaEZsYWcsXG4gICAgZHluYW1pY1Byb3BzLFxuICAgIHNoYXBlRmxhZyxcbiAgICBpc0Jsb2NrTm9kZSxcbiAgICB0cnVlXG4gICk7XG59XG5mdW5jdGlvbiBndWFyZFJlYWN0aXZlUHJvcHMocHJvcHMpIHtcbiAgaWYgKCFwcm9wcylcbiAgICByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGlzUHJveHkocHJvcHMpIHx8IEludGVybmFsT2JqZWN0S2V5IGluIHByb3BzID8gZXh0ZW5kKHt9LCBwcm9wcykgOiBwcm9wcztcbn1cbmZ1bmN0aW9uIGNsb25lVk5vZGUodm5vZGUsIGV4dHJhUHJvcHMsIG1lcmdlUmVmID0gZmFsc2UpIHtcbiAgY29uc3QgeyBwcm9wcywgcmVmLCBwYXRjaEZsYWcsIGNoaWxkcmVuIH0gPSB2bm9kZTtcbiAgY29uc3QgbWVyZ2VkUHJvcHMgPSBleHRyYVByb3BzID8gbWVyZ2VQcm9wcyhwcm9wcyB8fCB7fSwgZXh0cmFQcm9wcykgOiBwcm9wcztcbiAgY29uc3QgY2xvbmVkID0ge1xuICAgIF9fdl9pc1ZOb2RlOiB0cnVlLFxuICAgIF9fdl9za2lwOiB0cnVlLFxuICAgIHR5cGU6IHZub2RlLnR5cGUsXG4gICAgcHJvcHM6IG1lcmdlZFByb3BzLFxuICAgIGtleTogbWVyZ2VkUHJvcHMgJiYgbm9ybWFsaXplS2V5KG1lcmdlZFByb3BzKSxcbiAgICByZWY6IGV4dHJhUHJvcHMgJiYgZXh0cmFQcm9wcy5yZWYgPyAoXG4gICAgICAvLyAjMjA3OCBpbiB0aGUgY2FzZSBvZiA8Y29tcG9uZW50IDppcz1cInZub2RlXCIgcmVmPVwiZXh0cmFcIi8+XG4gICAgICAvLyBpZiB0aGUgdm5vZGUgaXRzZWxmIGFscmVhZHkgaGFzIGEgcmVmLCBjbG9uZVZOb2RlIHdpbGwgbmVlZCB0byBtZXJnZVxuICAgICAgLy8gdGhlIHJlZnMgc28gdGhlIHNpbmdsZSB2bm9kZSBjYW4gYmUgc2V0IG9uIG11bHRpcGxlIHJlZnNcbiAgICAgIG1lcmdlUmVmICYmIHJlZiA/IGlzQXJyYXkocmVmKSA/IHJlZi5jb25jYXQobm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpKSA6IFtyZWYsIG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKV0gOiBub3JtYWxpemVSZWYoZXh0cmFQcm9wcylcbiAgICApIDogcmVmLFxuICAgIHNjb3BlSWQ6IHZub2RlLnNjb3BlSWQsXG4gICAgc2xvdFNjb3BlSWRzOiB2bm9kZS5zbG90U2NvcGVJZHMsXG4gICAgY2hpbGRyZW46ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgcGF0Y2hGbGFnID09PSAtMSAmJiBpc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuLm1hcChkZWVwQ2xvbmVWTm9kZSkgOiBjaGlsZHJlbixcbiAgICB0YXJnZXQ6IHZub2RlLnRhcmdldCxcbiAgICB0YXJnZXRBbmNob3I6IHZub2RlLnRhcmdldEFuY2hvcixcbiAgICBzdGF0aWNDb3VudDogdm5vZGUuc3RhdGljQ291bnQsXG4gICAgc2hhcGVGbGFnOiB2bm9kZS5zaGFwZUZsYWcsXG4gICAgLy8gaWYgdGhlIHZub2RlIGlzIGNsb25lZCB3aXRoIGV4dHJhIHByb3BzLCB3ZSBjYW4gbm8gbG9uZ2VyIGFzc3VtZSBpdHNcbiAgICAvLyBleGlzdGluZyBwYXRjaCBmbGFnIHRvIGJlIHJlbGlhYmxlIGFuZCBuZWVkIHRvIGFkZCB0aGUgRlVMTF9QUk9QUyBmbGFnLlxuICAgIC8vIG5vdGU6IHByZXNlcnZlIGZsYWcgZm9yIGZyYWdtZW50cyBzaW5jZSB0aGV5IHVzZSB0aGUgZmxhZyBmb3IgY2hpbGRyZW5cbiAgICAvLyBmYXN0IHBhdGhzIG9ubHkuXG4gICAgcGF0Y2hGbGFnOiBleHRyYVByb3BzICYmIHZub2RlLnR5cGUgIT09IEZyYWdtZW50ID8gcGF0Y2hGbGFnID09PSAtMSA/IDE2IDogcGF0Y2hGbGFnIHwgMTYgOiBwYXRjaEZsYWcsXG4gICAgZHluYW1pY1Byb3BzOiB2bm9kZS5keW5hbWljUHJvcHMsXG4gICAgZHluYW1pY0NoaWxkcmVuOiB2bm9kZS5keW5hbWljQ2hpbGRyZW4sXG4gICAgYXBwQ29udGV4dDogdm5vZGUuYXBwQ29udGV4dCxcbiAgICBkaXJzOiB2bm9kZS5kaXJzLFxuICAgIHRyYW5zaXRpb246IHZub2RlLnRyYW5zaXRpb24sXG4gICAgLy8gVGhlc2Ugc2hvdWxkIHRlY2huaWNhbGx5IG9ubHkgYmUgbm9uLW51bGwgb24gbW91bnRlZCBWTm9kZXMuIEhvd2V2ZXIsXG4gICAgLy8gdGhleSAqc2hvdWxkKiBiZSBjb3BpZWQgZm9yIGtlcHQtYWxpdmUgdm5vZGVzLiBTbyB3ZSBqdXN0IGFsd2F5cyBjb3B5XG4gICAgLy8gdGhlbSBzaW5jZSB0aGVtIGJlaW5nIG5vbi1udWxsIGR1cmluZyBhIG1vdW50IGRvZXNuJ3QgYWZmZWN0IHRoZSBsb2dpYyBhc1xuICAgIC8vIHRoZXkgd2lsbCBzaW1wbHkgYmUgb3ZlcndyaXR0ZW4uXG4gICAgY29tcG9uZW50OiB2bm9kZS5jb21wb25lbnQsXG4gICAgc3VzcGVuc2U6IHZub2RlLnN1c3BlbnNlLFxuICAgIHNzQ29udGVudDogdm5vZGUuc3NDb250ZW50ICYmIGNsb25lVk5vZGUodm5vZGUuc3NDb250ZW50KSxcbiAgICBzc0ZhbGxiYWNrOiB2bm9kZS5zc0ZhbGxiYWNrICYmIGNsb25lVk5vZGUodm5vZGUuc3NGYWxsYmFjayksXG4gICAgZWw6IHZub2RlLmVsLFxuICAgIGFuY2hvcjogdm5vZGUuYW5jaG9yLFxuICAgIGN0eDogdm5vZGUuY3R4LFxuICAgIGNlOiB2bm9kZS5jZVxuICB9O1xuICByZXR1cm4gY2xvbmVkO1xufVxuZnVuY3Rpb24gZGVlcENsb25lVk5vZGUodm5vZGUpIHtcbiAgY29uc3QgY2xvbmVkID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gIGlmIChpc0FycmF5KHZub2RlLmNoaWxkcmVuKSkge1xuICAgIGNsb25lZC5jaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuLm1hcChkZWVwQ2xvbmVWTm9kZSk7XG4gIH1cbiAgcmV0dXJuIGNsb25lZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSh0ZXh0ID0gXCIgXCIsIGZsYWcgPSAwKSB7XG4gIHJldHVybiBjcmVhdGVWTm9kZShUZXh0LCBudWxsLCB0ZXh0LCBmbGFnKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY1ZOb2RlKGNvbnRlbnQsIG51bWJlck9mTm9kZXMpIHtcbiAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShTdGF0aWMsIG51bGwsIGNvbnRlbnQpO1xuICB2bm9kZS5zdGF0aWNDb3VudCA9IG51bWJlck9mTm9kZXM7XG4gIHJldHVybiB2bm9kZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRWTm9kZSh0ZXh0ID0gXCJcIiwgYXNCbG9jayA9IGZhbHNlKSB7XG4gIHJldHVybiBhc0Jsb2NrID8gKG9wZW5CbG9jaygpLCBjcmVhdGVCbG9jayhDb21tZW50LCBudWxsLCB0ZXh0KSkgOiBjcmVhdGVWTm9kZShDb21tZW50LCBudWxsLCB0ZXh0KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVZOb2RlKGNoaWxkKSB7XG4gIGlmIChjaGlsZCA9PSBudWxsIHx8IHR5cGVvZiBjaGlsZCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gY3JlYXRlVk5vZGUoQ29tbWVudCk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShjaGlsZCkpIHtcbiAgICByZXR1cm4gY3JlYXRlVk5vZGUoXG4gICAgICBGcmFnbWVudCxcbiAgICAgIG51bGwsXG4gICAgICAvLyAjMzY2NiwgYXZvaWQgcmVmZXJlbmNlIHBvbGx1dGlvbiB3aGVuIHJldXNpbmcgdm5vZGVcbiAgICAgIGNoaWxkLnNsaWNlKClcbiAgICApO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaGlsZCA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBjbG9uZUlmTW91bnRlZChjaGlsZCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFRleHQsIG51bGwsIFN0cmluZyhjaGlsZCkpO1xuICB9XG59XG5mdW5jdGlvbiBjbG9uZUlmTW91bnRlZChjaGlsZCkge1xuICByZXR1cm4gY2hpbGQuZWwgPT09IG51bGwgJiYgY2hpbGQucGF0Y2hGbGFnICE9PSAtMSB8fCBjaGlsZC5tZW1vID8gY2hpbGQgOiBjbG9uZVZOb2RlKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbikge1xuICBsZXQgdHlwZSA9IDA7XG4gIGNvbnN0IHsgc2hhcGVGbGFnIH0gPSB2bm9kZTtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICB0eXBlID0gMTY7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcIm9iamVjdFwiKSB7XG4gICAgaWYgKHNoYXBlRmxhZyAmICgxIHwgNjQpKSB7XG4gICAgICBjb25zdCBzbG90ID0gY2hpbGRyZW4uZGVmYXVsdDtcbiAgICAgIGlmIChzbG90KSB7XG4gICAgICAgIHNsb3QuX2MgJiYgKHNsb3QuX2QgPSBmYWxzZSk7XG4gICAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBzbG90KCkpO1xuICAgICAgICBzbG90Ll9jICYmIChzbG90Ll9kID0gdHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGUgPSAzMjtcbiAgICAgIGNvbnN0IHNsb3RGbGFnID0gY2hpbGRyZW4uXztcbiAgICAgIGlmICghc2xvdEZsYWcgJiYgIShJbnRlcm5hbE9iamVjdEtleSBpbiBjaGlsZHJlbikpIHtcbiAgICAgICAgY2hpbGRyZW4uX2N0eCA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgICAgIH0gZWxzZSBpZiAoc2xvdEZsYWcgPT09IDMgJiYgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSB7XG4gICAgICAgIGlmIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2Uuc2xvdHMuXyA9PT0gMSkge1xuICAgICAgICAgIGNoaWxkcmVuLl8gPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoaWxkcmVuLl8gPSAyO1xuICAgICAgICAgIHZub2RlLnBhdGNoRmxhZyB8PSAxMDI0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oY2hpbGRyZW4pKSB7XG4gICAgY2hpbGRyZW4gPSB7IGRlZmF1bHQ6IGNoaWxkcmVuLCBfY3R4OiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfTtcbiAgICB0eXBlID0gMzI7XG4gIH0gZWxzZSB7XG4gICAgY2hpbGRyZW4gPSBTdHJpbmcoY2hpbGRyZW4pO1xuICAgIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgdHlwZSA9IDE2O1xuICAgICAgY2hpbGRyZW4gPSBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGUgPSA4O1xuICAgIH1cbiAgfVxuICB2bm9kZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB2bm9kZS5zaGFwZUZsYWcgfD0gdHlwZTtcbn1cbmZ1bmN0aW9uIG1lcmdlUHJvcHMoLi4uYXJncykge1xuICBjb25zdCByZXQgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9NZXJnZSA9IGFyZ3NbaV07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdG9NZXJnZSkge1xuICAgICAgaWYgKGtleSA9PT0gXCJjbGFzc1wiKSB7XG4gICAgICAgIGlmIChyZXQuY2xhc3MgIT09IHRvTWVyZ2UuY2xhc3MpIHtcbiAgICAgICAgICByZXQuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhbcmV0LmNsYXNzLCB0b01lcmdlLmNsYXNzXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInN0eWxlXCIpIHtcbiAgICAgICAgcmV0LnN0eWxlID0gbm9ybWFsaXplU3R5bGUoW3JldC5zdHlsZSwgdG9NZXJnZS5zdHlsZV0pO1xuICAgICAgfSBlbHNlIGlmIChpc09uKGtleSkpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSByZXRba2V5XTtcbiAgICAgICAgY29uc3QgaW5jb21pbmcgPSB0b01lcmdlW2tleV07XG4gICAgICAgIGlmIChpbmNvbWluZyAmJiBleGlzdGluZyAhPT0gaW5jb21pbmcgJiYgIShpc0FycmF5KGV4aXN0aW5nKSAmJiBleGlzdGluZy5pbmNsdWRlcyhpbmNvbWluZykpKSB7XG4gICAgICAgICAgcmV0W2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgaW5jb21pbmcpIDogaW5jb21pbmc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ICE9PSBcIlwiKSB7XG4gICAgICAgIHJldFtrZXldID0gdG9NZXJnZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gaW52b2tlVk5vZGVIb29rKGhvb2ssIGluc3RhbmNlLCB2bm9kZSwgcHJldlZOb2RlID0gbnVsbCkge1xuICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgNywgW1xuICAgIHZub2RlLFxuICAgIHByZXZWTm9kZVxuICBdKTtcbn1cblxuY29uc3QgZW1wdHlBcHBDb250ZXh0ID0gY3JlYXRlQXBwQ29udGV4dCgpO1xubGV0IHVpZCA9IDA7XG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZSh2bm9kZSwgcGFyZW50LCBzdXNwZW5zZSkge1xuICBjb25zdCB0eXBlID0gdm5vZGUudHlwZTtcbiAgY29uc3QgYXBwQ29udGV4dCA9IChwYXJlbnQgPyBwYXJlbnQuYXBwQ29udGV4dCA6IHZub2RlLmFwcENvbnRleHQpIHx8IGVtcHR5QXBwQ29udGV4dDtcbiAgY29uc3QgaW5zdGFuY2UgPSB7XG4gICAgdWlkOiB1aWQrKyxcbiAgICB2bm9kZSxcbiAgICB0eXBlLFxuICAgIHBhcmVudCxcbiAgICBhcHBDb250ZXh0LFxuICAgIHJvb3Q6IG51bGwsXG4gICAgLy8gdG8gYmUgaW1tZWRpYXRlbHkgc2V0XG4gICAgbmV4dDogbnVsbCxcbiAgICBzdWJUcmVlOiBudWxsLFxuICAgIC8vIHdpbGwgYmUgc2V0IHN5bmNocm9ub3VzbHkgcmlnaHQgYWZ0ZXIgY3JlYXRpb25cbiAgICBlZmZlY3Q6IG51bGwsXG4gICAgdXBkYXRlOiBudWxsLFxuICAgIC8vIHdpbGwgYmUgc2V0IHN5bmNocm9ub3VzbHkgcmlnaHQgYWZ0ZXIgY3JlYXRpb25cbiAgICBzY29wZTogbmV3IEVmZmVjdFNjb3BlKFxuICAgICAgdHJ1ZVxuICAgICAgLyogZGV0YWNoZWQgKi9cbiAgICApLFxuICAgIHJlbmRlcjogbnVsbCxcbiAgICBwcm94eTogbnVsbCxcbiAgICBleHBvc2VkOiBudWxsLFxuICAgIGV4cG9zZVByb3h5OiBudWxsLFxuICAgIHdpdGhQcm94eTogbnVsbCxcbiAgICBwcm92aWRlczogcGFyZW50ID8gcGFyZW50LnByb3ZpZGVzIDogT2JqZWN0LmNyZWF0ZShhcHBDb250ZXh0LnByb3ZpZGVzKSxcbiAgICBhY2Nlc3NDYWNoZTogbnVsbCxcbiAgICByZW5kZXJDYWNoZTogW10sXG4gICAgLy8gbG9jYWwgcmVzb2x2ZWQgYXNzZXRzXG4gICAgY29tcG9uZW50czogbnVsbCxcbiAgICBkaXJlY3RpdmVzOiBudWxsLFxuICAgIC8vIHJlc29sdmVkIHByb3BzIGFuZCBlbWl0cyBvcHRpb25zXG4gICAgcHJvcHNPcHRpb25zOiBub3JtYWxpemVQcm9wc09wdGlvbnModHlwZSwgYXBwQ29udGV4dCksXG4gICAgZW1pdHNPcHRpb25zOiBub3JtYWxpemVFbWl0c09wdGlvbnModHlwZSwgYXBwQ29udGV4dCksXG4gICAgLy8gZW1pdFxuICAgIGVtaXQ6IG51bGwsXG4gICAgLy8gdG8gYmUgc2V0IGltbWVkaWF0ZWx5XG4gICAgZW1pdHRlZDogbnVsbCxcbiAgICAvLyBwcm9wcyBkZWZhdWx0IHZhbHVlXG4gICAgcHJvcHNEZWZhdWx0czogRU1QVFlfT0JKLFxuICAgIC8vIGluaGVyaXRBdHRyc1xuICAgIGluaGVyaXRBdHRyczogdHlwZS5pbmhlcml0QXR0cnMsXG4gICAgLy8gc3RhdGVcbiAgICBjdHg6IEVNUFRZX09CSixcbiAgICBkYXRhOiBFTVBUWV9PQkosXG4gICAgcHJvcHM6IEVNUFRZX09CSixcbiAgICBhdHRyczogRU1QVFlfT0JKLFxuICAgIHNsb3RzOiBFTVBUWV9PQkosXG4gICAgcmVmczogRU1QVFlfT0JKLFxuICAgIHNldHVwU3RhdGU6IEVNUFRZX09CSixcbiAgICBzZXR1cENvbnRleHQ6IG51bGwsXG4gICAgYXR0cnNQcm94eTogbnVsbCxcbiAgICBzbG90c1Byb3h5OiBudWxsLFxuICAgIC8vIHN1c3BlbnNlIHJlbGF0ZWRcbiAgICBzdXNwZW5zZSxcbiAgICBzdXNwZW5zZUlkOiBzdXNwZW5zZSA/IHN1c3BlbnNlLnBlbmRpbmdJZCA6IDAsXG4gICAgYXN5bmNEZXA6IG51bGwsXG4gICAgYXN5bmNSZXNvbHZlZDogZmFsc2UsXG4gICAgLy8gbGlmZWN5Y2xlIGhvb2tzXG4gICAgLy8gbm90IHVzaW5nIGVudW1zIGhlcmUgYmVjYXVzZSBpdCByZXN1bHRzIGluIGNvbXB1dGVkIHByb3BlcnRpZXNcbiAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgIGlzVW5tb3VudGVkOiBmYWxzZSxcbiAgICBpc0RlYWN0aXZhdGVkOiBmYWxzZSxcbiAgICBiYzogbnVsbCxcbiAgICBjOiBudWxsLFxuICAgIGJtOiBudWxsLFxuICAgIG06IG51bGwsXG4gICAgYnU6IG51bGwsXG4gICAgdTogbnVsbCxcbiAgICB1bTogbnVsbCxcbiAgICBidW06IG51bGwsXG4gICAgZGE6IG51bGwsXG4gICAgYTogbnVsbCxcbiAgICBydGc6IG51bGwsXG4gICAgcnRjOiBudWxsLFxuICAgIGVjOiBudWxsLFxuICAgIHNwOiBudWxsXG4gIH07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaW5zdGFuY2UuY3R4ID0gY3JlYXRlRGV2UmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2UuY3R4ID0geyBfOiBpbnN0YW5jZSB9O1xuICB9XG4gIGluc3RhbmNlLnJvb3QgPSBwYXJlbnQgPyBwYXJlbnQucm9vdCA6IGluc3RhbmNlO1xuICBpbnN0YW5jZS5lbWl0ID0gZW1pdC5iaW5kKG51bGwsIGluc3RhbmNlKTtcbiAgaWYgKHZub2RlLmNlKSB7XG4gICAgdm5vZGUuY2UoaW5zdGFuY2UpO1xuICB9XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmxldCBjdXJyZW50SW5zdGFuY2UgPSBudWxsO1xuY29uc3QgZ2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4gY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbmxldCBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZTtcbmxldCBnbG9iYWxDdXJyZW50SW5zdGFuY2VTZXR0ZXJzO1xubGV0IHNldHRlcnNLZXkgPSBcIl9fVlVFX0lOU1RBTkNFX1NFVFRFUlNfX1wiO1xue1xuICBpZiAoIShnbG9iYWxDdXJyZW50SW5zdGFuY2VTZXR0ZXJzID0gZ2V0R2xvYmFsVGhpcygpW3NldHRlcnNLZXldKSkge1xuICAgIGdsb2JhbEN1cnJlbnRJbnN0YW5jZVNldHRlcnMgPSBnZXRHbG9iYWxUaGlzKClbc2V0dGVyc0tleV0gPSBbXTtcbiAgfVxuICBnbG9iYWxDdXJyZW50SW5zdGFuY2VTZXR0ZXJzLnB1c2goKGkpID0+IGN1cnJlbnRJbnN0YW5jZSA9IGkpO1xuICBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZSA9IChpbnN0YW5jZSkgPT4ge1xuICAgIGlmIChnbG9iYWxDdXJyZW50SW5zdGFuY2VTZXR0ZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGdsb2JhbEN1cnJlbnRJbnN0YW5jZVNldHRlcnMuZm9yRWFjaCgocykgPT4gcyhpbnN0YW5jZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbG9iYWxDdXJyZW50SW5zdGFuY2VTZXR0ZXJzWzBdKGluc3RhbmNlKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBzZXRDdXJyZW50SW5zdGFuY2UgPSAoaW5zdGFuY2UpID0+IHtcbiAgaW50ZXJuYWxTZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICBpbnN0YW5jZS5zY29wZS5vbigpO1xufTtcbmNvbnN0IHVuc2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4ge1xuICBjdXJyZW50SW5zdGFuY2UgJiYgY3VycmVudEluc3RhbmNlLnNjb3BlLm9mZigpO1xuICBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZShudWxsKTtcbn07XG5jb25zdCBpc0J1aWx0SW5UYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcInNsb3QsY29tcG9uZW50XCIpO1xuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUsIGNvbmZpZykge1xuICBjb25zdCBhcHBJc05hdGl2ZVRhZyA9IGNvbmZpZy5pc05hdGl2ZVRhZyB8fCBOTztcbiAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBhcHBJc05hdGl2ZVRhZyhuYW1lKSkge1xuICAgIHdhcm4oXG4gICAgICBcIkRvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgaWQ6IFwiICsgbmFtZVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlLnZub2RlLnNoYXBlRmxhZyAmIDQ7XG59XG5sZXQgaXNJblNTUkNvbXBvbmVudFNldHVwID0gZmFsc2U7XG5mdW5jdGlvbiBzZXR1cENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IgPSBmYWxzZSkge1xuICBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBpc1NTUjtcbiAgY29uc3QgeyBwcm9wcywgY2hpbGRyZW4gfSA9IGluc3RhbmNlLnZub2RlO1xuICBjb25zdCBpc1N0YXRlZnVsID0gaXNTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSk7XG4gIGluaXRQcm9wcyhpbnN0YW5jZSwgcHJvcHMsIGlzU3RhdGVmdWwsIGlzU1NSKTtcbiAgaW5pdFNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XG4gIGNvbnN0IHNldHVwUmVzdWx0ID0gaXNTdGF0ZWZ1bCA/IHNldHVwU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSKSA6IHZvaWQgMDtcbiAgaXNJblNTUkNvbXBvbmVudFNldHVwID0gZmFsc2U7XG4gIHJldHVybiBzZXR1cFJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNldHVwU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpZiAoQ29tcG9uZW50Lm5hbWUpIHtcbiAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShDb21wb25lbnQubmFtZSwgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcpO1xuICAgIH1cbiAgICBpZiAoQ29tcG9uZW50LmNvbXBvbmVudHMpIHtcbiAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmNvbXBvbmVudHMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZXNbaV0sIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKENvbXBvbmVudC5kaXJlY3RpdmVzKSB7XG4gICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKENvbXBvbmVudC5kaXJlY3RpdmVzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKENvbXBvbmVudC5jb21waWxlck9wdGlvbnMgJiYgaXNSdW50aW1lT25seSgpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgXCJjb21waWxlck9wdGlvbnNcIiBpcyBvbmx5IHN1cHBvcnRlZCB3aGVuIHVzaW5nIGEgYnVpbGQgb2YgVnVlIHRoYXQgaW5jbHVkZXMgdGhlIHJ1bnRpbWUgY29tcGlsZXIuIFNpbmNlIHlvdSBhcmUgdXNpbmcgYSBydW50aW1lLW9ubHkgYnVpbGQsIHRoZSBvcHRpb25zIHNob3VsZCBiZSBwYXNzZWQgdmlhIHlvdXIgYnVpbGQgdG9vbCBjb25maWcgaW5zdGVhZC5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpbnN0YW5jZS5hY2Nlc3NDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpbnN0YW5jZS5wcm94eSA9IG1hcmtSYXcobmV3IFByb3h5KGluc3RhbmNlLmN0eCwgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzKSk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgZXhwb3NlUHJvcHNPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xuICB9XG4gIGNvbnN0IHsgc2V0dXAgfSA9IENvbXBvbmVudDtcbiAgaWYgKHNldHVwKSB7XG4gICAgY29uc3Qgc2V0dXBDb250ZXh0ID0gaW5zdGFuY2Uuc2V0dXBDb250ZXh0ID0gc2V0dXAubGVuZ3RoID4gMSA/IGNyZWF0ZVNldHVwQ29udGV4dChpbnN0YW5jZSkgOiBudWxsO1xuICAgIHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgcGF1c2VUcmFja2luZygpO1xuICAgIGNvbnN0IHNldHVwUmVzdWx0ID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKFxuICAgICAgc2V0dXAsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDAsXG4gICAgICBbISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShpbnN0YW5jZS5wcm9wcykgOiBpbnN0YW5jZS5wcm9wcywgc2V0dXBDb250ZXh0XVxuICAgICk7XG4gICAgcmVzZXRUcmFja2luZygpO1xuICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgaWYgKGlzUHJvbWlzZShzZXR1cFJlc3VsdCkpIHtcbiAgICAgIHNldHVwUmVzdWx0LnRoZW4odW5zZXRDdXJyZW50SW5zdGFuY2UsIHVuc2V0Q3VycmVudEluc3RhbmNlKTtcbiAgICAgIGlmIChpc1NTUikge1xuICAgICAgICByZXR1cm4gc2V0dXBSZXN1bHQudGhlbigocmVzb2x2ZWRSZXN1bHQpID0+IHtcbiAgICAgICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgcmVzb2x2ZWRSZXN1bHQsIGlzU1NSKTtcbiAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCBpbnN0YW5jZSwgMCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdGFuY2UuYXN5bmNEZXAgPSBzZXR1cFJlc3VsdDtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWluc3RhbmNlLnN1c3BlbnNlKSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IChfYSA9IENvbXBvbmVudC5uYW1lKSAhPSBudWxsID8gX2EgOiBcIkFub255bW91c1wiO1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgQ29tcG9uZW50IDwke25hbWV9Pjogc2V0dXAgZnVuY3Rpb24gcmV0dXJuZWQgYSBwcm9taXNlLCBidXQgbm8gPFN1c3BlbnNlPiBib3VuZGFyeSB3YXMgZm91bmQgaW4gdGhlIHBhcmVudCBjb21wb25lbnQgdHJlZS4gQSBjb21wb25lbnQgd2l0aCBhc3luYyBzZXR1cCgpIG11c3QgYmUgbmVzdGVkIGluIGEgPFN1c3BlbnNlPiBpbiBvcmRlciB0byBiZSByZW5kZXJlZC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgc2V0dXBSZXN1bHQsIGlzU1NSKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUikge1xuICBpZiAoaXNGdW5jdGlvbihzZXR1cFJlc3VsdCkpIHtcbiAgICBpZiAoaW5zdGFuY2UudHlwZS5fX3NzcklubGluZVJlbmRlcikge1xuICAgICAgaW5zdGFuY2Uuc3NyUmVuZGVyID0gc2V0dXBSZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLnJlbmRlciA9IHNldHVwUmVzdWx0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChzZXR1cFJlc3VsdCkpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc1ZOb2RlKHNldHVwUmVzdWx0KSkge1xuICAgICAgd2FybihcbiAgICAgICAgYHNldHVwKCkgc2hvdWxkIG5vdCByZXR1cm4gVk5vZGVzIGRpcmVjdGx5IC0gcmV0dXJuIGEgcmVuZGVyIGZ1bmN0aW9uIGluc3RlYWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBpbnN0YW5jZS5kZXZ0b29sc1Jhd1NldHVwU3RhdGUgPSBzZXR1cFJlc3VsdDtcbiAgICB9XG4gICAgaW5zdGFuY2Uuc2V0dXBTdGF0ZSA9IHByb3h5UmVmcyhzZXR1cFJlc3VsdCk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGV4cG9zZVNldHVwU3RhdGVPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNldHVwUmVzdWx0ICE9PSB2b2lkIDApIHtcbiAgICB3YXJuKFxuICAgICAgYHNldHVwKCkgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuIFJlY2VpdmVkOiAke3NldHVwUmVzdWx0ID09PSBudWxsID8gXCJudWxsXCIgOiB0eXBlb2Ygc2V0dXBSZXN1bHR9YFxuICAgICk7XG4gIH1cbiAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSKTtcbn1cbmxldCBjb21waWxlO1xubGV0IGluc3RhbGxXaXRoUHJveHk7XG5mdW5jdGlvbiByZWdpc3RlclJ1bnRpbWVDb21waWxlcihfY29tcGlsZSkge1xuICBjb21waWxlID0gX2NvbXBpbGU7XG4gIGluc3RhbGxXaXRoUHJveHkgPSAoaSkgPT4ge1xuICAgIGlmIChpLnJlbmRlci5fcmMpIHtcbiAgICAgIGkud2l0aFByb3h5ID0gbmV3IFByb3h5KGkuY3R4LCBSdW50aW1lQ29tcGlsZWRQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMpO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IGlzUnVudGltZU9ubHkgPSAoKSA9PiAhY29tcGlsZTtcbmZ1bmN0aW9uIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUiwgc2tpcE9wdGlvbnMpIHtcbiAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcbiAgaWYgKCFpbnN0YW5jZS5yZW5kZXIpIHtcbiAgICBpZiAoIWlzU1NSICYmIGNvbXBpbGUgJiYgIUNvbXBvbmVudC5yZW5kZXIpIHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gQ29tcG9uZW50LnRlbXBsYXRlIHx8IHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKS50ZW1wbGF0ZTtcbiAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGNvbXBpbGVgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGlzQ3VzdG9tRWxlbWVudCwgY29tcGlsZXJPcHRpb25zIH0gPSBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZztcbiAgICAgICAgY29uc3QgeyBkZWxpbWl0ZXJzLCBjb21waWxlck9wdGlvbnM6IGNvbXBvbmVudENvbXBpbGVyT3B0aW9ucyB9ID0gQ29tcG9uZW50O1xuICAgICAgICBjb25zdCBmaW5hbENvbXBpbGVyT3B0aW9ucyA9IGV4dGVuZChcbiAgICAgICAgICBleHRlbmQoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlzQ3VzdG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgZGVsaW1pdGVyc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBpbGVyT3B0aW9uc1xuICAgICAgICAgICksXG4gICAgICAgICAgY29tcG9uZW50Q29tcGlsZXJPcHRpb25zXG4gICAgICAgICk7XG4gICAgICAgIENvbXBvbmVudC5yZW5kZXIgPSBjb21waWxlKHRlbXBsYXRlLCBmaW5hbENvbXBpbGVyT3B0aW9ucyk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGNvbXBpbGVgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpbnN0YW5jZS5yZW5kZXIgPSBDb21wb25lbnQucmVuZGVyIHx8IE5PT1A7XG4gICAgaWYgKGluc3RhbGxXaXRoUHJveHkpIHtcbiAgICAgIGluc3RhbGxXaXRoUHJveHkoaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiB0cnVlKSB7XG4gICAgc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgdHJ5IHtcbiAgICAgIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgfVxuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFDb21wb25lbnQucmVuZGVyICYmIGluc3RhbmNlLnJlbmRlciA9PT0gTk9PUCAmJiAhaXNTU1IpIHtcbiAgICBpZiAoIWNvbXBpbGUgJiYgQ29tcG9uZW50LnRlbXBsYXRlKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgQ29tcG9uZW50IHByb3ZpZGVkIHRlbXBsYXRlIG9wdGlvbiBidXQgcnVudGltZSBjb21waWxhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgVnVlLmAgKyAoYCBDb25maWd1cmUgeW91ciBidW5kbGVyIHRvIGFsaWFzIFwidnVlXCIgdG8gXCJ2dWUvZGlzdC92dWUuZXNtLWJ1bmRsZXIuanNcIi5gIClcbiAgICAgICAgLyogc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oYENvbXBvbmVudCBpcyBtaXNzaW5nIHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbi5gKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEF0dHJzUHJveHkoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlLmF0dHJzUHJveHkgfHwgKGluc3RhbmNlLmF0dHJzUHJveHkgPSBuZXcgUHJveHkoXG4gICAgaW5zdGFuY2UuYXR0cnMsXG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHtcbiAgICAgIGdldCh0YXJnZXQsIGtleSkge1xuICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiwgXCIkYXR0cnNcIik7XG4gICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICAgIH0sXG4gICAgICBzZXQoKSB7XG4gICAgICAgIHdhcm4oYHNldHVwQ29udGV4dC5hdHRycyBpcyByZWFkb25seS5gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIGRlbGV0ZVByb3BlcnR5KCkge1xuICAgICAgICB3YXJuKGBzZXR1cENvbnRleHQuYXR0cnMgaXMgcmVhZG9ubHkuYCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IDoge1xuICAgICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICAgIHRyYWNrKGluc3RhbmNlLCBcImdldFwiLCBcIiRhdHRyc1wiKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgKSk7XG59XG5mdW5jdGlvbiBnZXRTbG90c1Byb3h5KGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZS5zbG90c1Byb3h5IHx8IChpbnN0YW5jZS5zbG90c1Byb3h5ID0gbmV3IFByb3h5KGluc3RhbmNlLnNsb3RzLCB7XG4gICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiwgXCIkc2xvdHNcIik7XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gICAgfVxuICB9KSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIHtcbiAgY29uc3QgZXhwb3NlID0gKGV4cG9zZWQpID0+IHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgaWYgKGluc3RhbmNlLmV4cG9zZWQpIHtcbiAgICAgICAgd2FybihgZXhwb3NlKCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UgcGVyIHNldHVwKCkuYCk7XG4gICAgICB9XG4gICAgICBpZiAoZXhwb3NlZCAhPSBudWxsKSB7XG4gICAgICAgIGxldCBleHBvc2VkVHlwZSA9IHR5cGVvZiBleHBvc2VkO1xuICAgICAgICBpZiAoZXhwb3NlZFR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShleHBvc2VkKSkge1xuICAgICAgICAgICAgZXhwb3NlZFR5cGUgPSBcImFycmF5XCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1JlZihleHBvc2VkKSkge1xuICAgICAgICAgICAgZXhwb3NlZFR5cGUgPSBcInJlZlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwb3NlZFR5cGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYGV4cG9zZSgpIHNob3VsZCBiZSBwYXNzZWQgYSBwbGFpbiBvYmplY3QsIHJlY2VpdmVkICR7ZXhwb3NlZFR5cGV9LmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGluc3RhbmNlLmV4cG9zZWQgPSBleHBvc2VkIHx8IHt9O1xuICB9O1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgIGdldCBhdHRycygpIHtcbiAgICAgICAgcmV0dXJuIGdldEF0dHJzUHJveHkoaW5zdGFuY2UpO1xuICAgICAgfSxcbiAgICAgIGdldCBzbG90cygpIHtcbiAgICAgICAgcmV0dXJuIGdldFNsb3RzUHJveHkoaW5zdGFuY2UpO1xuICAgICAgfSxcbiAgICAgIGdldCBlbWl0KCkge1xuICAgICAgICByZXR1cm4gKGV2ZW50LCAuLi5hcmdzKSA9PiBpbnN0YW5jZS5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBleHBvc2VcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0IGF0dHJzKCkge1xuICAgICAgICByZXR1cm4gZ2V0QXR0cnNQcm94eShpbnN0YW5jZSk7XG4gICAgICB9LFxuICAgICAgc2xvdHM6IGluc3RhbmNlLnNsb3RzLFxuICAgICAgZW1pdDogaW5zdGFuY2UuZW1pdCxcbiAgICAgIGV4cG9zZVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEV4cG9zZVByb3h5KGluc3RhbmNlKSB7XG4gIGlmIChpbnN0YW5jZS5leHBvc2VkKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLmV4cG9zZVByb3h5IHx8IChpbnN0YW5jZS5leHBvc2VQcm94eSA9IG5ldyBQcm94eShwcm94eVJlZnMobWFya1JhdyhpbnN0YW5jZS5leHBvc2VkKSksIHtcbiAgICAgIGdldCh0YXJnZXQsIGtleSkge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldCkge1xuICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgaW4gcHVibGljUHJvcGVydGllc01hcCkge1xuICAgICAgICAgIHJldHVybiBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV0oaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGFzKHRhcmdldCwga2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgaW4gdGFyZ2V0IHx8IGtleSBpbiBwdWJsaWNQcm9wZXJ0aWVzTWFwO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxufVxuY29uc3QgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbmNvbnN0IGNsYXNzaWZ5ID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoY2xhc3NpZnlSRSwgKGMpID0+IGMudG9VcHBlckNhc2UoKSkucmVwbGFjZSgvWy1fXS9nLCBcIlwiKTtcbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50LCBpbmNsdWRlSW5mZXJyZWQgPSB0cnVlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKENvbXBvbmVudCkgPyBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgOiBDb21wb25lbnQubmFtZSB8fCBpbmNsdWRlSW5mZXJyZWQgJiYgQ29tcG9uZW50Ll9fbmFtZTtcbn1cbmZ1bmN0aW9uIGZvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIENvbXBvbmVudCwgaXNSb290ID0gZmFsc2UpIHtcbiAgbGV0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCk7XG4gIGlmICghbmFtZSAmJiBDb21wb25lbnQuX19maWxlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBDb21wb25lbnQuX19maWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLlxcdyskLyk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBuYW1lID0gbWF0Y2hbMV07XG4gICAgfVxuICB9XG4gIGlmICghbmFtZSAmJiBpbnN0YW5jZSAmJiBpbnN0YW5jZS5wYXJlbnQpIHtcbiAgICBjb25zdCBpbmZlckZyb21SZWdpc3RyeSA9IChyZWdpc3RyeSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVnaXN0cnkpIHtcbiAgICAgICAgaWYgKHJlZ2lzdHJ5W2tleV0gPT09IENvbXBvbmVudCkge1xuICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIG5hbWUgPSBpbmZlckZyb21SZWdpc3RyeShcbiAgICAgIGluc3RhbmNlLmNvbXBvbmVudHMgfHwgaW5zdGFuY2UucGFyZW50LnR5cGUuY29tcG9uZW50c1xuICAgICkgfHwgaW5mZXJGcm9tUmVnaXN0cnkoaW5zdGFuY2UuYXBwQ29udGV4dC5jb21wb25lbnRzKTtcbiAgfVxuICByZXR1cm4gbmFtZSA/IGNsYXNzaWZ5KG5hbWUpIDogaXNSb290ID8gYEFwcGAgOiBgQW5vbnltb3VzYDtcbn1cbmZ1bmN0aW9uIGlzQ2xhc3NDb21wb25lbnQodmFsdWUpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpICYmIFwiX192Y2NPcHRzXCIgaW4gdmFsdWU7XG59XG5cbmNvbnN0IGNvbXB1dGVkID0gKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zKSA9PiB7XG4gIHJldHVybiBjb21wdXRlZCQxKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zLCBpc0luU1NSQ29tcG9uZW50U2V0dXApO1xufTtcblxuZnVuY3Rpb24gaCh0eXBlLCBwcm9wc09yQ2hpbGRyZW4sIGNoaWxkcmVuKSB7XG4gIGNvbnN0IGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICBpZiAobCA9PT0gMikge1xuICAgIGlmIChpc09iamVjdChwcm9wc09yQ2hpbGRyZW4pICYmICFpc0FycmF5KHByb3BzT3JDaGlsZHJlbikpIHtcbiAgICAgIGlmIChpc1ZOb2RlKHByb3BzT3JDaGlsZHJlbikpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG51bGwsIFtwcm9wc09yQ2hpbGRyZW5dKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbnVsbCwgcHJvcHNPckNoaWxkcmVuKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGwgPiAzKSB7XG4gICAgICBjaGlsZHJlbiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgfSBlbHNlIGlmIChsID09PSAzICYmIGlzVk5vZGUoY2hpbGRyZW4pKSB7XG4gICAgICBjaGlsZHJlbiA9IFtjaGlsZHJlbl07XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4sIGNoaWxkcmVuKTtcbiAgfVxufVxuXG5jb25zdCBzc3JDb250ZXh0S2V5ID0gU3ltYm9sLmZvcihcInYtc2N4XCIpO1xuY29uc3QgdXNlU1NSQ29udGV4dCA9ICgpID0+IHtcbiAge1xuICAgIGNvbnN0IGN0eCA9IGluamVjdChzc3JDb250ZXh0S2V5KTtcbiAgICBpZiAoIWN0eCkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgICBgU2VydmVyIHJlbmRlcmluZyBjb250ZXh0IG5vdCBwcm92aWRlZC4gTWFrZSBzdXJlIHRvIG9ubHkgY2FsbCB1c2VTU1JDb250ZXh0KCkgY29uZGl0aW9uYWxseSBpbiB0aGUgc2VydmVyIGJ1aWxkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjdHg7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzU2hhbGxvdyh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNTaGFsbG93XCJdKTtcbn1cblxuZnVuY3Rpb24gaW5pdEN1c3RvbUZvcm1hdHRlcigpIHtcbiAgaWYgKCEhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdnVlU3R5bGUgPSB7IHN0eWxlOiBcImNvbG9yOiMzYmE3NzZcIiB9O1xuICBjb25zdCBudW1iZXJTdHlsZSA9IHsgc3R5bGU6IFwiY29sb3I6IzBiMWJjOVwiIH07XG4gIGNvbnN0IHN0cmluZ1N0eWxlID0geyBzdHlsZTogXCJjb2xvcjojYjYyZTI0XCIgfTtcbiAgY29uc3Qga2V5d29yZFN0eWxlID0geyBzdHlsZTogXCJjb2xvcjojOWQyODhjXCIgfTtcbiAgY29uc3QgZm9ybWF0dGVyID0ge1xuICAgIGhlYWRlcihvYmopIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChvYmouX19pc1Z1ZSkge1xuICAgICAgICByZXR1cm4gW1wiZGl2XCIsIHZ1ZVN0eWxlLCBgVnVlSW5zdGFuY2VgXTtcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWYob2JqKSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge30sXG4gICAgICAgICAgW1wic3BhblwiLCB2dWVTdHlsZSwgZ2VuUmVmRmxhZyhvYmopXSxcbiAgICAgICAgICBcIjxcIixcbiAgICAgICAgICBmb3JtYXRWYWx1ZShvYmoudmFsdWUpLFxuICAgICAgICAgIGA+YFxuICAgICAgICBdO1xuICAgICAgfSBlbHNlIGlmIChpc1JlYWN0aXZlKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIFtcInNwYW5cIiwgdnVlU3R5bGUsIGlzU2hhbGxvdyhvYmopID8gXCJTaGFsbG93UmVhY3RpdmVcIiA6IFwiUmVhY3RpdmVcIl0sXG4gICAgICAgICAgXCI8XCIsXG4gICAgICAgICAgZm9ybWF0VmFsdWUob2JqKSxcbiAgICAgICAgICBgPiR7aXNSZWFkb25seShvYmopID8gYCAocmVhZG9ubHkpYCA6IGBgfWBcbiAgICAgICAgXTtcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWFkb25seShvYmopKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBbXCJzcGFuXCIsIHZ1ZVN0eWxlLCBpc1NoYWxsb3cob2JqKSA/IFwiU2hhbGxvd1JlYWRvbmx5XCIgOiBcIlJlYWRvbmx5XCJdLFxuICAgICAgICAgIFwiPFwiLFxuICAgICAgICAgIGZvcm1hdFZhbHVlKG9iaiksXG4gICAgICAgICAgXCI+XCJcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgaGFzQm9keShvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgb2JqLl9faXNWdWU7XG4gICAgfSxcbiAgICBib2R5KG9iaikge1xuICAgICAgaWYgKG9iaiAmJiBvYmouX19pc1Z1ZSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge30sXG4gICAgICAgICAgLi4uZm9ybWF0SW5zdGFuY2Uob2JqLiQpXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBmb3JtYXRJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgIGNvbnN0IGJsb2NrcyA9IFtdO1xuICAgIGlmIChpbnN0YW5jZS50eXBlLnByb3BzICYmIGluc3RhbmNlLnByb3BzKSB7XG4gICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKFwicHJvcHNcIiwgdG9SYXcoaW5zdGFuY2UucHJvcHMpKSk7XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZS5zZXR1cFN0YXRlICE9PSBFTVBUWV9PQkopIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJzZXR1cFwiLCBpbnN0YW5jZS5zZXR1cFN0YXRlKSk7XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZS5kYXRhICE9PSBFTVBUWV9PQkopIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJkYXRhXCIsIHRvUmF3KGluc3RhbmNlLmRhdGEpKSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbXB1dGVkID0gZXh0cmFjdEtleXMoaW5zdGFuY2UsIFwiY29tcHV0ZWRcIik7XG4gICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKFwiY29tcHV0ZWRcIiwgY29tcHV0ZWQpKTtcbiAgICB9XG4gICAgY29uc3QgaW5qZWN0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgXCJpbmplY3RcIik7XG4gICAgaWYgKGluamVjdGVkKSB7XG4gICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKFwiaW5qZWN0ZWRcIiwgaW5qZWN0ZWQpKTtcbiAgICB9XG4gICAgYmxvY2tzLnB1c2goW1xuICAgICAgXCJkaXZcIixcbiAgICAgIHt9LFxuICAgICAgW1xuICAgICAgICBcInNwYW5cIixcbiAgICAgICAge1xuICAgICAgICAgIHN0eWxlOiBrZXl3b3JkU3R5bGUuc3R5bGUgKyBcIjtvcGFjaXR5OjAuNjZcIlxuICAgICAgICB9LFxuICAgICAgICBcIiQgKGludGVybmFsKTogXCJcbiAgICAgIF0sXG4gICAgICBbXCJvYmplY3RcIiwgeyBvYmplY3Q6IGluc3RhbmNlIH1dXG4gICAgXSk7XG4gICAgcmV0dXJuIGJsb2NrcztcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZUJsb2NrKHR5cGUsIHRhcmdldCkge1xuICAgIHRhcmdldCA9IGV4dGVuZCh7fSwgdGFyZ2V0KTtcbiAgICBpZiAoIU9iamVjdC5rZXlzKHRhcmdldCkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gW1wic3BhblwiLCB7fV07XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICBcImRpdlwiLFxuICAgICAgeyBzdHlsZTogXCJsaW5lLWhlaWdodDoxLjI1ZW07bWFyZ2luLWJvdHRvbTowLjZlbVwiIH0sXG4gICAgICBbXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdHlsZTogXCJjb2xvcjojNDc2NTgyXCJcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZVxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHN0eWxlOiBcInBhZGRpbmctbGVmdDoxLjI1ZW1cIlxuICAgICAgICB9LFxuICAgICAgICAuLi5PYmplY3Qua2V5cyh0YXJnZXQpLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIFtcInNwYW5cIiwga2V5d29yZFN0eWxlLCBrZXkgKyBcIjogXCJdLFxuICAgICAgICAgICAgZm9ybWF0VmFsdWUodGFyZ2V0W2tleV0sIGZhbHNlKVxuICAgICAgICAgIF07XG4gICAgICAgIH0pXG4gICAgICBdXG4gICAgXTtcbiAgfVxuICBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh2LCBhc1JhdyA9IHRydWUpIHtcbiAgICBpZiAodHlwZW9mIHYgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIG51bWJlclN0eWxlLCB2XTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gW1wic3BhblwiLCBzdHJpbmdTdHlsZSwgSlNPTi5zdHJpbmdpZnkodildO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gW1wic3BhblwiLCBrZXl3b3JkU3R5bGUsIHZdO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodikpIHtcbiAgICAgIHJldHVybiBbXCJvYmplY3RcIiwgeyBvYmplY3Q6IGFzUmF3ID8gdG9SYXcodikgOiB2IH1dO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW1wic3BhblwiLCBzdHJpbmdTdHlsZSwgU3RyaW5nKHYpXTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZXh0cmFjdEtleXMoaW5zdGFuY2UsIHR5cGUpIHtcbiAgICBjb25zdCBDb21wID0gaW5zdGFuY2UudHlwZTtcbiAgICBpZiAoaXNGdW5jdGlvbihDb21wKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBleHRyYWN0ZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnN0YW5jZS5jdHgpIHtcbiAgICAgIGlmIChpc0tleU9mVHlwZShDb21wLCBrZXksIHR5cGUpKSB7XG4gICAgICAgIGV4dHJhY3RlZFtrZXldID0gaW5zdGFuY2UuY3R4W2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHRyYWN0ZWQ7XG4gIH1cbiAgZnVuY3Rpb24gaXNLZXlPZlR5cGUoQ29tcCwga2V5LCB0eXBlKSB7XG4gICAgY29uc3Qgb3B0cyA9IENvbXBbdHlwZV07XG4gICAgaWYgKGlzQXJyYXkob3B0cykgJiYgb3B0cy5pbmNsdWRlcyhrZXkpIHx8IGlzT2JqZWN0KG9wdHMpICYmIGtleSBpbiBvcHRzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKENvbXAuZXh0ZW5kcyAmJiBpc0tleU9mVHlwZShDb21wLmV4dGVuZHMsIGtleSwgdHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoQ29tcC5taXhpbnMgJiYgQ29tcC5taXhpbnMuc29tZSgobSkgPT4gaXNLZXlPZlR5cGUobSwga2V5LCB0eXBlKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZW5SZWZGbGFnKHYpIHtcbiAgICBpZiAoaXNTaGFsbG93KHYpKSB7XG4gICAgICByZXR1cm4gYFNoYWxsb3dSZWZgO1xuICAgIH1cbiAgICBpZiAodi5lZmZlY3QpIHtcbiAgICAgIHJldHVybiBgQ29tcHV0ZWRSZWZgO1xuICAgIH1cbiAgICByZXR1cm4gYFJlZmA7XG4gIH1cbiAgaWYgKHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMpIHtcbiAgICB3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzLnB1c2goZm9ybWF0dGVyKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzID0gW2Zvcm1hdHRlcl07XG4gIH1cbn1cblxuZnVuY3Rpb24gd2l0aE1lbW8obWVtbywgcmVuZGVyLCBjYWNoZSwgaW5kZXgpIHtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGVbaW5kZXhdO1xuICBpZiAoY2FjaGVkICYmIGlzTWVtb1NhbWUoY2FjaGVkLCBtZW1vKSkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgY29uc3QgcmV0ID0gcmVuZGVyKCk7XG4gIHJldC5tZW1vID0gbWVtby5zbGljZSgpO1xuICByZXR1cm4gY2FjaGVbaW5kZXhdID0gcmV0O1xufVxuZnVuY3Rpb24gaXNNZW1vU2FtZShjYWNoZWQsIG1lbW8pIHtcbiAgY29uc3QgcHJldiA9IGNhY2hlZC5tZW1vO1xuICBpZiAocHJldi5sZW5ndGggIT0gbWVtby5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGhhc0NoYW5nZWQocHJldltpXSwgbWVtb1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgY3VycmVudEJsb2NrKSB7XG4gICAgY3VycmVudEJsb2NrLnB1c2goY2FjaGVkKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuY29uc3QgdmVyc2lvbiA9IFwiMy4zLjdcIjtcbmNvbnN0IF9zc3JVdGlscyA9IHtcbiAgY3JlYXRlQ29tcG9uZW50SW5zdGFuY2UsXG4gIHNldHVwQ29tcG9uZW50LFxuICByZW5kZXJDb21wb25lbnRSb290LFxuICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsXG4gIGlzVk5vZGU6IGlzVk5vZGUsXG4gIG5vcm1hbGl6ZVZOb2RlXG59O1xuY29uc3Qgc3NyVXRpbHMgPSBfc3NyVXRpbHMgO1xuY29uc3QgcmVzb2x2ZUZpbHRlciA9IG51bGw7XG5jb25zdCBjb21wYXRVdGlscyA9IG51bGw7XG5cbmV4cG9ydCB7IEJhc2VUcmFuc2l0aW9uLCBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycywgQ29tbWVudCwgRnJhZ21lbnQsIEtlZXBBbGl2ZSwgU3RhdGljLCBTdXNwZW5zZSwgVGVsZXBvcnQsIFRleHQsIGFzc2VydE51bWJlciwgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcsIGNhbGxXaXRoRXJyb3JIYW5kbGluZywgY2xvbmVWTm9kZSwgY29tcGF0VXRpbHMsIGNvbXB1dGVkLCBjcmVhdGVCbG9jaywgY3JlYXRlQ29tbWVudFZOb2RlLCBjcmVhdGVFbGVtZW50QmxvY2ssIGNyZWF0ZUJhc2VWTm9kZSBhcyBjcmVhdGVFbGVtZW50Vk5vZGUsIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyLCBjcmVhdGVQcm9wc1Jlc3RQcm94eSwgY3JlYXRlUmVuZGVyZXIsIGNyZWF0ZVNsb3RzLCBjcmVhdGVTdGF0aWNWTm9kZSwgY3JlYXRlVGV4dFZOb2RlLCBjcmVhdGVWTm9kZSwgZGVmaW5lQXN5bmNDb21wb25lbnQsIGRlZmluZUNvbXBvbmVudCwgZGVmaW5lRW1pdHMsIGRlZmluZUV4cG9zZSwgZGVmaW5lTW9kZWwsIGRlZmluZU9wdGlvbnMsIGRlZmluZVByb3BzLCBkZWZpbmVTbG90cywgZGV2dG9vbHMsIGdldEN1cnJlbnRJbnN0YW5jZSwgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuLCBndWFyZFJlYWN0aXZlUHJvcHMsIGgsIGhhbmRsZUVycm9yLCBoYXNJbmplY3Rpb25Db250ZXh0LCBpbml0Q3VzdG9tRm9ybWF0dGVyLCBpbmplY3QsIGlzTWVtb1NhbWUsIGlzUnVudGltZU9ubHksIGlzVk5vZGUsIG1lcmdlRGVmYXVsdHMsIG1lcmdlTW9kZWxzLCBtZXJnZVByb3BzLCBuZXh0VGljaywgb25BY3RpdmF0ZWQsIG9uQmVmb3JlTW91bnQsIG9uQmVmb3JlVW5tb3VudCwgb25CZWZvcmVVcGRhdGUsIG9uRGVhY3RpdmF0ZWQsIG9uRXJyb3JDYXB0dXJlZCwgb25Nb3VudGVkLCBvblJlbmRlclRyYWNrZWQsIG9uUmVuZGVyVHJpZ2dlcmVkLCBvblNlcnZlclByZWZldGNoLCBvblVubW91bnRlZCwgb25VcGRhdGVkLCBvcGVuQmxvY2ssIHBvcFNjb3BlSWQsIHByb3ZpZGUsIHB1c2hTY29wZUlkLCBxdWV1ZVBvc3RGbHVzaENiLCByZWdpc3RlclJ1bnRpbWVDb21waWxlciwgcmVuZGVyTGlzdCwgcmVuZGVyU2xvdCwgcmVzb2x2ZUNvbXBvbmVudCwgcmVzb2x2ZURpcmVjdGl2ZSwgcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQsIHJlc29sdmVGaWx0ZXIsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MsIHNldEJsb2NrVHJhY2tpbmcsIHNldERldnRvb2xzSG9vaywgc2V0VHJhbnNpdGlvbkhvb2tzLCBzc3JDb250ZXh0S2V5LCBzc3JVdGlscywgdG9IYW5kbGVycywgdHJhbnNmb3JtVk5vZGVBcmdzLCB1c2VBdHRycywgdXNlTW9kZWwsIHVzZVNTUkNvbnRleHQsIHVzZVNsb3RzLCB1c2VUcmFuc2l0aW9uU3RhdGUsIHZlcnNpb24sIHdhcm4sIHdhdGNoLCB3YXRjaEVmZmVjdCwgd2F0Y2hQb3N0RWZmZWN0LCB3YXRjaFN5bmNFZmZlY3QsIHdpdGhBc3luY0NvbnRleHQsIHdpdGhDdHgsIHdpdGhEZWZhdWx0cywgd2l0aERpcmVjdGl2ZXMsIHdpdGhNZW1vLCB3aXRoU2NvcGVJZCB9O1xuIiwiaW1wb3J0IHsgaCwgQmFzZVRyYW5zaXRpb24sIEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLCBhc3NlcnROdW1iZXIsIHdhcm4sIGNhbWVsaXplLCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgZGVmaW5lQ29tcG9uZW50LCBuZXh0VGljaywgY3JlYXRlVk5vZGUsIGdldEN1cnJlbnRJbnN0YW5jZSwgd2F0Y2hQb3N0RWZmZWN0LCBvbk1vdW50ZWQsIG9uVW5tb3VudGVkLCBGcmFnbWVudCwgU3RhdGljLCB1c2VUcmFuc2l0aW9uU3RhdGUsIG9uVXBkYXRlZCwgdG9SYXcsIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbiwgc2V0VHJhbnNpdGlvbkhvb2tzLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzLCBpc1J1bnRpbWVPbmx5LCBjcmVhdGVSZW5kZXJlciwgY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIgfSBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XG5pbXBvcnQgeyBleHRlbmQsIGlzT2JqZWN0LCB0b051bWJlciwgaXNBcnJheSwgaXNTdHJpbmcsIGh5cGhlbmF0ZSwgY2FwaXRhbGl6ZSwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGluY2x1ZGVCb29sZWFuQXR0ciwgaXNPbiwgaXNNb2RlbExpc3RlbmVyLCBpc0Z1bmN0aW9uLCBjYW1lbGl6ZSBhcyBjYW1lbGl6ZSQxLCBFTVBUWV9PQkosIGxvb3NlVG9OdW1iZXIsIGxvb3NlSW5kZXhPZiwgaXNTZXQsIGxvb3NlRXF1YWwsIGludm9rZUFycmF5Rm5zLCBpc0hUTUxUYWcsIGlzU1ZHVGFnIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5jb25zdCBzdmdOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcbmNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogbnVsbDtcbmNvbnN0IHRlbXBsYXRlQ29udGFpbmVyID0gZG9jICYmIC8qIEBfX1BVUkVfXyAqLyBkb2MuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuY29uc3Qgbm9kZU9wcyA9IHtcbiAgaW5zZXJ0OiAoY2hpbGQsIHBhcmVudCwgYW5jaG9yKSA9PiB7XG4gICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgYW5jaG9yIHx8IG51bGwpO1xuICB9LFxuICByZW1vdmU6IChjaGlsZCkgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9IGNoaWxkLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnQ6ICh0YWcsIGlzU1ZHLCBpcywgcHJvcHMpID0+IHtcbiAgICBjb25zdCBlbCA9IGlzU1ZHID8gZG9jLmNyZWF0ZUVsZW1lbnROUyhzdmdOUywgdGFnKSA6IGRvYy5jcmVhdGVFbGVtZW50KHRhZywgaXMgPyB7IGlzIH0gOiB2b2lkIDApO1xuICAgIGlmICh0YWcgPT09IFwic2VsZWN0XCIgJiYgcHJvcHMgJiYgcHJvcHMubXVsdGlwbGUgIT0gbnVsbCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIiwgcHJvcHMubXVsdGlwbGUpO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG4gIH0sXG4gIGNyZWF0ZVRleHQ6ICh0ZXh0KSA9PiBkb2MuY3JlYXRlVGV4dE5vZGUodGV4dCksXG4gIGNyZWF0ZUNvbW1lbnQ6ICh0ZXh0KSA9PiBkb2MuY3JlYXRlQ29tbWVudCh0ZXh0KSxcbiAgc2V0VGV4dDogKG5vZGUsIHRleHQpID0+IHtcbiAgICBub2RlLm5vZGVWYWx1ZSA9IHRleHQ7XG4gIH0sXG4gIHNldEVsZW1lbnRUZXh0OiAoZWwsIHRleHQpID0+IHtcbiAgICBlbC50ZXh0Q29udGVudCA9IHRleHQ7XG4gIH0sXG4gIHBhcmVudE5vZGU6IChub2RlKSA9PiBub2RlLnBhcmVudE5vZGUsXG4gIG5leHRTaWJsaW5nOiAobm9kZSkgPT4gbm9kZS5uZXh0U2libGluZyxcbiAgcXVlcnlTZWxlY3RvcjogKHNlbGVjdG9yKSA9PiBkb2MucXVlcnlTZWxlY3RvcihzZWxlY3RvciksXG4gIHNldFNjb3BlSWQoZWwsIGlkKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGlkLCBcIlwiKTtcbiAgfSxcbiAgLy8gX19VTlNBRkVfX1xuICAvLyBSZWFzb246IGlubmVySFRNTC5cbiAgLy8gU3RhdGljIGNvbnRlbnQgaGVyZSBjYW4gb25seSBjb21lIGZyb20gY29tcGlsZWQgdGVtcGxhdGVzLlxuICAvLyBBcyBsb25nIGFzIHRoZSB1c2VyIG9ubHkgdXNlcyB0cnVzdGVkIHRlbXBsYXRlcywgdGhpcyBpcyBzYWZlLlxuICBpbnNlcnRTdGF0aWNDb250ZW50KGNvbnRlbnQsIHBhcmVudCwgYW5jaG9yLCBpc1NWRywgc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IGJlZm9yZSA9IGFuY2hvciA/IGFuY2hvci5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkO1xuICAgIGlmIChzdGFydCAmJiAoc3RhcnQgPT09IGVuZCB8fCBzdGFydC5uZXh0U2libGluZykpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoc3RhcnQuY2xvbmVOb2RlKHRydWUpLCBhbmNob3IpO1xuICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCB8fCAhKHN0YXJ0ID0gc3RhcnQubmV4dFNpYmxpbmcpKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0ZW1wbGF0ZUNvbnRhaW5lci5pbm5lckhUTUwgPSBpc1NWRyA/IGA8c3ZnPiR7Y29udGVudH08L3N2Zz5gIDogY29udGVudDtcbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVDb250YWluZXIuY29udGVudDtcbiAgICAgIGlmIChpc1NWRykge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gdGVtcGxhdGUuZmlyc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKHdyYXBwZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIHRlbXBsYXRlLmFwcGVuZENoaWxkKHdyYXBwZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcGxhdGUucmVtb3ZlQ2hpbGQod3JhcHBlcik7XG4gICAgICB9XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRlbXBsYXRlLCBhbmNob3IpO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgLy8gZmlyc3RcbiAgICAgIGJlZm9yZSA/IGJlZm9yZS5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkLFxuICAgICAgLy8gbGFzdFxuICAgICAgYW5jaG9yID8gYW5jaG9yLnByZXZpb3VzU2libGluZyA6IHBhcmVudC5sYXN0Q2hpbGRcbiAgICBdO1xuICB9XG59O1xuXG5jb25zdCBUUkFOU0lUSU9OID0gXCJ0cmFuc2l0aW9uXCI7XG5jb25zdCBBTklNQVRJT04gPSBcImFuaW1hdGlvblwiO1xuY29uc3QgdnRjS2V5ID0gU3ltYm9sKFwiX3Z0Y1wiKTtcbmNvbnN0IFRyYW5zaXRpb24gPSAocHJvcHMsIHsgc2xvdHMgfSkgPT4gaChCYXNlVHJhbnNpdGlvbiwgcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhwcm9wcyksIHNsb3RzKTtcblRyYW5zaXRpb24uZGlzcGxheU5hbWUgPSBcIlRyYW5zaXRpb25cIjtcbmNvbnN0IERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBjc3M6IHtcbiAgICB0eXBlOiBCb29sZWFuLFxuICAgIGRlZmF1bHQ6IHRydWVcbiAgfSxcbiAgZHVyYXRpb246IFtTdHJpbmcsIE51bWJlciwgT2JqZWN0XSxcbiAgZW50ZXJGcm9tQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyRnJvbUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVGcm9tQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZ1xufTtcbmNvbnN0IFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSBUcmFuc2l0aW9uLnByb3BzID0gLyogQF9fUFVSRV9fICovIGV4dGVuZChcbiAge30sXG4gIEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLFxuICBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzXG4pO1xuY29uc3QgY2FsbEhvb2sgPSAoaG9vaywgYXJncyA9IFtdKSA9PiB7XG4gIGlmIChpc0FycmF5KGhvb2spKSB7XG4gICAgaG9vay5mb3JFYWNoKChoMikgPT4gaDIoLi4uYXJncykpO1xuICB9IGVsc2UgaWYgKGhvb2spIHtcbiAgICBob29rKC4uLmFyZ3MpO1xuICB9XG59O1xuY29uc3QgaGFzRXhwbGljaXRDYWxsYmFjayA9IChob29rKSA9PiB7XG4gIHJldHVybiBob29rID8gaXNBcnJheShob29rKSA/IGhvb2suc29tZSgoaDIpID0+IGgyLmxlbmd0aCA+IDEpIDogaG9vay5sZW5ndGggPiAxIDogZmFsc2U7XG59O1xuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcykge1xuICBjb25zdCBiYXNlUHJvcHMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcmF3UHJvcHMpIHtcbiAgICBpZiAoIShrZXkgaW4gRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycykpIHtcbiAgICAgIGJhc2VQcm9wc1trZXldID0gcmF3UHJvcHNba2V5XTtcbiAgICB9XG4gIH1cbiAgaWYgKHJhd1Byb3BzLmNzcyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gYmFzZVByb3BzO1xuICB9XG4gIGNvbnN0IHtcbiAgICBuYW1lID0gXCJ2XCIsXG4gICAgdHlwZSxcbiAgICBkdXJhdGlvbixcbiAgICBlbnRlckZyb21DbGFzcyA9IGAke25hbWV9LWVudGVyLWZyb21gLFxuICAgIGVudGVyQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci1hY3RpdmVgLFxuICAgIGVudGVyVG9DbGFzcyA9IGAke25hbWV9LWVudGVyLXRvYCxcbiAgICBhcHBlYXJGcm9tQ2xhc3MgPSBlbnRlckZyb21DbGFzcyxcbiAgICBhcHBlYXJBY3RpdmVDbGFzcyA9IGVudGVyQWN0aXZlQ2xhc3MsXG4gICAgYXBwZWFyVG9DbGFzcyA9IGVudGVyVG9DbGFzcyxcbiAgICBsZWF2ZUZyb21DbGFzcyA9IGAke25hbWV9LWxlYXZlLWZyb21gLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS1hY3RpdmVgLFxuICAgIGxlYXZlVG9DbGFzcyA9IGAke25hbWV9LWxlYXZlLXRvYFxuICB9ID0gcmF3UHJvcHM7XG4gIGNvbnN0IGR1cmF0aW9ucyA9IG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgY29uc3QgZW50ZXJEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMF07XG4gIGNvbnN0IGxlYXZlRHVyYXRpb24gPSBkdXJhdGlvbnMgJiYgZHVyYXRpb25zWzFdO1xuICBjb25zdCB7XG4gICAgb25CZWZvcmVFbnRlcixcbiAgICBvbkVudGVyLFxuICAgIG9uRW50ZXJDYW5jZWxsZWQsXG4gICAgb25MZWF2ZSxcbiAgICBvbkxlYXZlQ2FuY2VsbGVkLFxuICAgIG9uQmVmb3JlQXBwZWFyID0gb25CZWZvcmVFbnRlcixcbiAgICBvbkFwcGVhciA9IG9uRW50ZXIsXG4gICAgb25BcHBlYXJDYW5jZWxsZWQgPSBvbkVudGVyQ2FuY2VsbGVkXG4gIH0gPSBiYXNlUHJvcHM7XG4gIGNvbnN0IGZpbmlzaEVudGVyID0gKGVsLCBpc0FwcGVhciwgZG9uZSkgPT4ge1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzKTtcbiAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyQWN0aXZlQ2xhc3MgOiBlbnRlckFjdGl2ZUNsYXNzKTtcbiAgICBkb25lICYmIGRvbmUoKTtcbiAgfTtcbiAgY29uc3QgZmluaXNoTGVhdmUgPSAoZWwsIGRvbmUpID0+IHtcbiAgICBlbC5faXNMZWF2aW5nID0gZmFsc2U7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgZG9uZSAmJiBkb25lKCk7XG4gIH07XG4gIGNvbnN0IG1ha2VFbnRlckhvb2sgPSAoaXNBcHBlYXIpID0+IHtcbiAgICByZXR1cm4gKGVsLCBkb25lKSA9PiB7XG4gICAgICBjb25zdCBob29rID0gaXNBcHBlYXIgPyBvbkFwcGVhciA6IG9uRW50ZXI7XG4gICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoRW50ZXIoZWwsIGlzQXBwZWFyLCBkb25lKTtcbiAgICAgIGNhbGxIb29rKGhvb2ssIFtlbCwgcmVzb2x2ZV0pO1xuICAgICAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhckZyb21DbGFzcyA6IGVudGVyRnJvbUNsYXNzKTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xuICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2soaG9vaykpIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGVudGVyRHVyYXRpb24sIHJlc29sdmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuICByZXR1cm4gZXh0ZW5kKGJhc2VQcm9wcywge1xuICAgIG9uQmVmb3JlRW50ZXIoZWwpIHtcbiAgICAgIGNhbGxIb29rKG9uQmVmb3JlRW50ZXIsIFtlbF0pO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBlbnRlckZyb21DbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyQWN0aXZlQ2xhc3MpO1xuICAgIH0sXG4gICAgb25CZWZvcmVBcHBlYXIoZWwpIHtcbiAgICAgIGNhbGxIb29rKG9uQmVmb3JlQXBwZWFyLCBbZWxdKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyRnJvbUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyQWN0aXZlQ2xhc3MpO1xuICAgIH0sXG4gICAgb25FbnRlcjogbWFrZUVudGVySG9vayhmYWxzZSksXG4gICAgb25BcHBlYXI6IG1ha2VFbnRlckhvb2sodHJ1ZSksXG4gICAgb25MZWF2ZShlbCwgZG9uZSkge1xuICAgICAgZWwuX2lzTGVhdmluZyA9IHRydWU7XG4gICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoTGVhdmUoZWwsIGRvbmUpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XG4gICAgICBmb3JjZVJlZmxvdygpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgIGlmICghZWwuX2lzTGVhdmluZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2sob25MZWF2ZSkpIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGxlYXZlRHVyYXRpb24sIHJlc29sdmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNhbGxIb29rKG9uTGVhdmUsIFtlbCwgcmVzb2x2ZV0pO1xuICAgIH0sXG4gICAgb25FbnRlckNhbmNlbGxlZChlbCkge1xuICAgICAgZmluaXNoRW50ZXIoZWwsIGZhbHNlKTtcbiAgICAgIGNhbGxIb29rKG9uRW50ZXJDYW5jZWxsZWQsIFtlbF0pO1xuICAgIH0sXG4gICAgb25BcHBlYXJDYW5jZWxsZWQoZWwpIHtcbiAgICAgIGZpbmlzaEVudGVyKGVsLCB0cnVlKTtcbiAgICAgIGNhbGxIb29rKG9uQXBwZWFyQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICB9LFxuICAgIG9uTGVhdmVDYW5jZWxsZWQoZWwpIHtcbiAgICAgIGZpbmlzaExlYXZlKGVsKTtcbiAgICAgIGNhbGxIb29rKG9uTGVhdmVDYW5jZWxsZWQsIFtlbF0pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVEdXJhdGlvbihkdXJhdGlvbikge1xuICBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGR1cmF0aW9uKSkge1xuICAgIHJldHVybiBbTnVtYmVyT2YoZHVyYXRpb24uZW50ZXIpLCBOdW1iZXJPZihkdXJhdGlvbi5sZWF2ZSldO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG4gPSBOdW1iZXJPZihkdXJhdGlvbik7XG4gICAgcmV0dXJuIFtuLCBuXTtcbiAgfVxufVxuZnVuY3Rpb24gTnVtYmVyT2YodmFsKSB7XG4gIGNvbnN0IHJlcyA9IHRvTnVtYmVyKHZhbCk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgYXNzZXJ0TnVtYmVyKHJlcywgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgZHVyYXRpb25cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgY2xzKSB7XG4gIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGMpID0+IGMgJiYgZWwuY2xhc3NMaXN0LmFkZChjKSk7XG4gIChlbFt2dGNLZXldIHx8IChlbFt2dGNLZXldID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSkpLmFkZChjbHMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcbiAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgoYykgPT4gYyAmJiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcbiAgY29uc3QgX3Z0YyA9IGVsW3Z0Y0tleV07XG4gIGlmIChfdnRjKSB7XG4gICAgX3Z0Yy5kZWxldGUoY2xzKTtcbiAgICBpZiAoIV92dGMuc2l6ZSkge1xuICAgICAgZWxbdnRjS2V5XSA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG5leHRGcmFtZShjYikge1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7XG4gIH0pO1xufVxubGV0IGVuZElkID0gMDtcbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgZXhwZWN0ZWRUeXBlLCBleHBsaWNpdFRpbWVvdXQsIHJlc29sdmUpIHtcbiAgY29uc3QgaWQgPSBlbC5fZW5kSWQgPSArK2VuZElkO1xuICBjb25zdCByZXNvbHZlSWZOb3RTdGFsZSA9ICgpID0+IHtcbiAgICBpZiAoaWQgPT09IGVsLl9lbmRJZCkge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH1cbiAgfTtcbiAgaWYgKGV4cGxpY2l0VGltZW91dCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmVJZk5vdFN0YWxlLCBleHBsaWNpdFRpbWVvdXQpO1xuICB9XG4gIGNvbnN0IHsgdHlwZSwgdGltZW91dCwgcHJvcENvdW50IH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgaWYgKCF0eXBlKSB7XG4gICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgfVxuICBjb25zdCBlbmRFdmVudCA9IHR5cGUgKyBcImVuZFwiO1xuICBsZXQgZW5kZWQgPSAwO1xuICBjb25zdCBlbmQgPSAoKSA9PiB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgb25FbmQpO1xuICAgIHJlc29sdmVJZk5vdFN0YWxlKCk7XG4gIH07XG4gIGNvbnN0IG9uRW5kID0gKGUpID0+IHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsICYmICsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIG9uRW5kKTtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICBjb25zdCBnZXRTdHlsZVByb3BlcnRpZXMgPSAoa2V5KSA9PiAoc3R5bGVzW2tleV0gfHwgXCJcIikuc3BsaXQoXCIsIFwiKTtcbiAgY29uc3QgdHJhbnNpdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtUUkFOU0lUSU9OfURlbGF5YCk7XG4gIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbnMgPSBnZXRTdHlsZVByb3BlcnRpZXMoYCR7VFJBTlNJVElPTn1EdXJhdGlvbmApO1xuICBjb25zdCB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIGNvbnN0IGFuaW1hdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtBTklNQVRJT059RGVsYXlgKTtcbiAgY29uc3QgYW5pbWF0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke0FOSU1BVElPTn1EdXJhdGlvbmApO1xuICBjb25zdCBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG4gIGxldCB0eXBlID0gbnVsbDtcbiAgbGV0IHRpbWVvdXQgPSAwO1xuICBsZXQgcHJvcENvdW50ID0gMDtcbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMCA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dCA/IFRSQU5TSVRJT04gOiBBTklNQVRJT04gOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGUgPyB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGggOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoIDogMDtcbiAgfVxuICBjb25zdCBoYXNUcmFuc2Zvcm0gPSB0eXBlID09PSBUUkFOU0lUSU9OICYmIC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS8udGVzdChcbiAgICBnZXRTdHlsZVByb3BlcnRpZXMoYCR7VFJBTlNJVElPTn1Qcm9wZXJ0eWApLnRvU3RyaW5nKClcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIHRpbWVvdXQsXG4gICAgcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VGltZW91dChkZWxheXMsIGR1cmF0aW9ucykge1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KC4uLmR1cmF0aW9ucy5tYXAoKGQsIGkpID0+IHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSkpKTtcbn1cbmZ1bmN0aW9uIHRvTXMocykge1xuICBpZiAocyA9PT0gXCJhdXRvXCIpXG4gICAgcmV0dXJuIDA7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZShcIixcIiwgXCIuXCIpKSAqIDFlMztcbn1cbmZ1bmN0aW9uIGZvcmNlUmVmbG93KCkge1xuICByZXR1cm4gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIHBhdGNoQ2xhc3MoZWwsIHZhbHVlLCBpc1NWRykge1xuICBjb25zdCB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsW3Z0Y0tleV07XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHZhbHVlID0gKHZhbHVlID8gW3ZhbHVlLCAuLi50cmFuc2l0aW9uQ2xhc3Nlc10gOiBbLi4udHJhbnNpdGlvbkNsYXNzZXNdKS5qb2luKFwiIFwiKTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICB9IGVsc2UgaWYgKGlzU1ZHKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGVsLmNsYXNzTmFtZSA9IHZhbHVlO1xuICB9XG59XG5cbmNvbnN0IHZTaG93T2xkS2V5ID0gU3ltYm9sKFwiX3ZvZFwiKTtcbmNvbnN0IHZTaG93ID0ge1xuICBiZWZvcmVNb3VudChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xuICAgIGVsW3ZTaG93T2xkS2V5XSA9IGVsLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgdmFsdWUpIHtcbiAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XG4gICAgfVxuICB9LFxuICBtb3VudGVkKGVsLCB7IHZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgdmFsdWUpIHtcbiAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgIH1cbiAgfSxcbiAgdXBkYXRlZChlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcbiAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICAgICAgc2V0RGlzcGxheShlbCwgdHJ1ZSk7XG4gICAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNpdGlvbi5sZWF2ZShlbCwgKCkgPT4ge1xuICAgICAgICAgIHNldERpc3BsYXkoZWwsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZVVubW91bnQoZWwsIHsgdmFsdWUgfSkge1xuICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNldERpc3BsYXkoZWwsIHZhbHVlKSB7XG4gIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsW3ZTaG93T2xkS2V5XSA6IFwibm9uZVwiO1xufVxuZnVuY3Rpb24gaW5pdFZTaG93Rm9yU1NSKCkge1xuICB2U2hvdy5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0pID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4geyBzdHlsZTogeyBkaXNwbGF5OiBcIm5vbmVcIiB9IH07XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXRjaFN0eWxlKGVsLCBwcmV2LCBuZXh0KSB7XG4gIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gIGNvbnN0IGlzQ3NzU3RyaW5nID0gaXNTdHJpbmcobmV4dCk7XG4gIGlmIChuZXh0ICYmICFpc0Nzc1N0cmluZykge1xuICAgIGlmIChwcmV2ICYmICFpc1N0cmluZyhwcmV2KSkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJldikge1xuICAgICAgICBpZiAobmV4dFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXh0KSB7XG4gICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCBuZXh0W2tleV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjdXJyZW50RGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKGlzQ3NzU3RyaW5nKSB7XG4gICAgICBpZiAocHJldiAhPT0gbmV4dCkge1xuICAgICAgICBzdHlsZS5jc3NUZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByZXYpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgIH1cbiAgICBpZiAodlNob3dPbGRLZXkgaW4gZWwpIHtcbiAgICAgIHN0eWxlLmRpc3BsYXkgPSBjdXJyZW50RGlzcGxheTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IHNlbWljb2xvblJFID0gL1teXFxcXF07XFxzKiQvO1xuY29uc3QgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbmZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlLCBuYW1lLCB2YWwpIHtcbiAgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgIHZhbC5mb3JFYWNoKCh2KSA9PiBzZXRTdHlsZShzdHlsZSwgbmFtZSwgdikpO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWwgPT0gbnVsbClcbiAgICAgIHZhbCA9IFwiXCI7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGlmIChzZW1pY29sb25SRS50ZXN0KHZhbCkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgVW5leHBlY3RlZCBzZW1pY29sb24gYXQgdGhlIGVuZCBvZiAnJHtuYW1lfScgc3R5bGUgdmFsdWU6ICcke3ZhbH0nYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKFwiLS1cIikpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZWZpeGVkID0gYXV0b1ByZWZpeChzdHlsZSwgbmFtZSk7XG4gICAgICBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgICAgIHN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgIGh5cGhlbmF0ZShwcmVmaXhlZCksXG4gICAgICAgICAgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsIFwiXCIpLFxuICAgICAgICAgIFwiaW1wb3J0YW50XCJcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlW3ByZWZpeGVkXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNvbnN0IHByZWZpeGVzID0gW1wiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIl07XG5jb25zdCBwcmVmaXhDYWNoZSA9IHt9O1xuZnVuY3Rpb24gYXV0b1ByZWZpeChzdHlsZSwgcmF3TmFtZSkge1xuICBjb25zdCBjYWNoZWQgPSBwcmVmaXhDYWNoZVtyYXdOYW1lXTtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgbGV0IG5hbWUgPSBjYW1lbGl6ZShyYXdOYW1lKTtcbiAgaWYgKG5hbWUgIT09IFwiZmlsdGVyXCIgJiYgbmFtZSBpbiBzdHlsZSkge1xuICAgIHJldHVybiBwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IG5hbWU7XG4gIH1cbiAgbmFtZSA9IGNhcGl0YWxpemUobmFtZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgbmFtZTtcbiAgICBpZiAocHJlZml4ZWQgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IHByZWZpeGVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmF3TmFtZTtcbn1cblxuY29uc3QgeGxpbmtOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiO1xuZnVuY3Rpb24gcGF0Y2hBdHRyKGVsLCBrZXksIHZhbHVlLCBpc1NWRywgaW5zdGFuY2UpIHtcbiAgaWYgKGlzU1ZHICYmIGtleS5zdGFydHNXaXRoKFwieGxpbms6XCIpKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleS5zbGljZSg2LCBrZXkubGVuZ3RoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpc0Jvb2xlYW4gPSBpc1NwZWNpYWxCb29sZWFuQXR0cihrZXkpO1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IGlzQm9vbGVhbiAmJiAhaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzQm9vbGVhbiA/IFwiXCIgOiB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhdGNoRE9NUHJvcChlbCwga2V5LCB2YWx1ZSwgcHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pIHtcbiAgaWYgKGtleSA9PT0gXCJpbm5lckhUTUxcIiB8fCBrZXkgPT09IFwidGV4dENvbnRlbnRcIikge1xuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHVubW91bnRDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgICBlbFtrZXldID0gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGFnID0gZWwudGFnTmFtZTtcbiAgaWYgKGtleSA9PT0gXCJ2YWx1ZVwiICYmIHRhZyAhPT0gXCJQUk9HUkVTU1wiICYmIC8vIGN1c3RvbSBlbGVtZW50cyBtYXkgdXNlIF92YWx1ZSBpbnRlcm5hbGx5XG4gICF0YWcuaW5jbHVkZXMoXCItXCIpKSB7XG4gICAgZWwuX3ZhbHVlID0gdmFsdWU7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0YWcgPT09IFwiT1BUSU9OXCIgPyBlbC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSA6IGVsLnZhbHVlO1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTtcbiAgICBpZiAob2xkVmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbmVlZFJlbW92ZSA9IGZhbHNlO1xuICBpZiAodmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgZWxba2V5XTtcbiAgICBpZiAodHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHZhbHVlID0gaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgbmVlZFJlbW92ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICB2YWx1ZSA9IDA7XG4gICAgICBuZWVkUmVtb3ZlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBlbFtrZXldID0gdmFsdWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhbmVlZFJlbW92ZSkge1xuICAgICAgd2FybihcbiAgICAgICAgYEZhaWxlZCBzZXR0aW5nIHByb3AgXCIke2tleX1cIiBvbiA8JHt0YWcudG9Mb3dlckNhc2UoKX0+OiB2YWx1ZSAke3ZhbHVlfSBpcyBpbnZhbGlkLmAsXG4gICAgICAgIGVcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIG5lZWRSZW1vdmUgJiYgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5jb25zdCB2ZWlLZXkgPSBTeW1ib2woXCJfdmVpXCIpO1xuZnVuY3Rpb24gcGF0Y2hFdmVudChlbCwgcmF3TmFtZSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIGluc3RhbmNlID0gbnVsbCkge1xuICBjb25zdCBpbnZva2VycyA9IGVsW3ZlaUtleV0gfHwgKGVsW3ZlaUtleV0gPSB7fSk7XG4gIGNvbnN0IGV4aXN0aW5nSW52b2tlciA9IGludm9rZXJzW3Jhd05hbWVdO1xuICBpZiAobmV4dFZhbHVlICYmIGV4aXN0aW5nSW52b2tlcikge1xuICAgIGV4aXN0aW5nSW52b2tlci52YWx1ZSA9IG5leHRWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBbbmFtZSwgb3B0aW9uc10gPSBwYXJzZU5hbWUocmF3TmFtZSk7XG4gICAgaWYgKG5leHRWYWx1ZSkge1xuICAgICAgY29uc3QgaW52b2tlciA9IGludm9rZXJzW3Jhd05hbWVdID0gY3JlYXRlSW52b2tlcihuZXh0VmFsdWUsIGluc3RhbmNlKTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGludm9rZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdJbnZva2VyKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBleGlzdGluZ0ludm9rZXIsIG9wdGlvbnMpO1xuICAgICAgaW52b2tlcnNbcmF3TmFtZV0gPSB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5jb25zdCBvcHRpb25zTW9kaWZpZXJSRSA9IC8oPzpPbmNlfFBhc3NpdmV8Q2FwdHVyZSkkLztcbmZ1bmN0aW9uIHBhcnNlTmFtZShuYW1lKSB7XG4gIGxldCBvcHRpb25zO1xuICBpZiAob3B0aW9uc01vZGlmaWVyUkUudGVzdChuYW1lKSkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgICBsZXQgbTtcbiAgICB3aGlsZSAobSA9IG5hbWUubWF0Y2gob3B0aW9uc01vZGlmaWVyUkUpKSB7XG4gICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCBuYW1lLmxlbmd0aCAtIG1bMF0ubGVuZ3RoKTtcbiAgICAgIG9wdGlvbnNbbVswXS50b0xvd2VyQ2FzZSgpXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGNvbnN0IGV2ZW50ID0gbmFtZVsyXSA9PT0gXCI6XCIgPyBuYW1lLnNsaWNlKDMpIDogaHlwaGVuYXRlKG5hbWUuc2xpY2UoMikpO1xuICByZXR1cm4gW2V2ZW50LCBvcHRpb25zXTtcbn1cbmxldCBjYWNoZWROb3cgPSAwO1xuY29uc3QgcCA9IC8qIEBfX1BVUkVfXyAqLyBQcm9taXNlLnJlc29sdmUoKTtcbmNvbnN0IGdldE5vdyA9ICgpID0+IGNhY2hlZE5vdyB8fCAocC50aGVuKCgpID0+IGNhY2hlZE5vdyA9IDApLCBjYWNoZWROb3cgPSBEYXRlLm5vdygpKTtcbmZ1bmN0aW9uIGNyZWF0ZUludm9rZXIoaW5pdGlhbFZhbHVlLCBpbnN0YW5jZSkge1xuICBjb25zdCBpbnZva2VyID0gKGUpID0+IHtcbiAgICBpZiAoIWUuX3Z0cykge1xuICAgICAgZS5fdnRzID0gRGF0ZS5ub3coKTtcbiAgICB9IGVsc2UgaWYgKGUuX3Z0cyA8PSBpbnZva2VyLmF0dGFjaGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgcGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSwgaW52b2tlci52YWx1ZSksXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDUsXG4gICAgICBbZV1cbiAgICApO1xuICB9O1xuICBpbnZva2VyLnZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBpbnZva2VyLmF0dGFjaGVkID0gZ2V0Tm93KCk7XG4gIHJldHVybiBpbnZva2VyO1xufVxuZnVuY3Rpb24gcGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSwgdmFsdWUpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxTdG9wID0gZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb247XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSAoKSA9PiB7XG4gICAgICBvcmlnaW5hbFN0b3AuY2FsbChlKTtcbiAgICAgIGUuX3N0b3BwZWQgPSB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIHZhbHVlLm1hcCgoZm4pID0+IChlMikgPT4gIWUyLl9zdG9wcGVkICYmIGZuICYmIGZuKGUyKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmNvbnN0IG5hdGl2ZU9uUkUgPSAvXm9uW2Etel0vO1xuY29uc3QgcGF0Y2hQcm9wID0gKGVsLCBrZXksIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBpc1NWRyA9IGZhbHNlLCBwcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbikgPT4ge1xuICBpZiAoa2V5ID09PSBcImNsYXNzXCIpIHtcbiAgICBwYXRjaENsYXNzKGVsLCBuZXh0VmFsdWUsIGlzU1ZHKTtcbiAgfSBlbHNlIGlmIChrZXkgPT09IFwic3R5bGVcIikge1xuICAgIHBhdGNoU3R5bGUoZWwsIHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc09uKGtleSkpIHtcbiAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpKSB7XG4gICAgICBwYXRjaEV2ZW50KGVsLCBrZXksIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBwYXJlbnRDb21wb25lbnQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChrZXlbMF0gPT09IFwiLlwiID8gKGtleSA9IGtleS5zbGljZSgxKSwgdHJ1ZSkgOiBrZXlbMF0gPT09IFwiXlwiID8gKGtleSA9IGtleS5zbGljZSgxKSwgZmFsc2UpIDogc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcpKSB7XG4gICAgcGF0Y2hET01Qcm9wKFxuICAgICAgZWwsXG4gICAgICBrZXksXG4gICAgICBuZXh0VmFsdWUsXG4gICAgICBwcmV2Q2hpbGRyZW4sXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgIHVubW91bnRDaGlsZHJlblxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGtleSA9PT0gXCJ0cnVlLXZhbHVlXCIpIHtcbiAgICAgIGVsLl90cnVlVmFsdWUgPSBuZXh0VmFsdWU7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiZmFsc2UtdmFsdWVcIikge1xuICAgICAgZWwuX2ZhbHNlVmFsdWUgPSBuZXh0VmFsdWU7XG4gICAgfVxuICAgIHBhdGNoQXR0cihlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNob3VsZFNldEFzUHJvcChlbCwga2V5LCB2YWx1ZSwgaXNTVkcpIHtcbiAgaWYgKGlzU1ZHKSB7XG4gICAgaWYgKGtleSA9PT0gXCJpbm5lckhUTUxcIiB8fCBrZXkgPT09IFwidGV4dENvbnRlbnRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChrZXkgaW4gZWwgJiYgbmF0aXZlT25SRS50ZXN0KGtleSkgJiYgaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJzcGVsbGNoZWNrXCIgfHwga2V5ID09PSBcImRyYWdnYWJsZVwiIHx8IGtleSA9PT0gXCJ0cmFuc2xhdGVcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcImZvcm1cIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcImxpc3RcIiAmJiBlbC50YWdOYW1lID09PSBcIklOUFVUXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJ0eXBlXCIgJiYgZWwudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChuYXRpdmVPblJFLnRlc3Qoa2V5KSAmJiBpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGtleSBpbiBlbDtcbn1cblxuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudChvcHRpb25zLCBoeWRyYXRlMikge1xuICBjb25zdCBDb21wID0gZGVmaW5lQ29tcG9uZW50KG9wdGlvbnMpO1xuICBjbGFzcyBWdWVDdXN0b21FbGVtZW50IGV4dGVuZHMgVnVlRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoaW5pdGlhbFByb3BzKSB7XG4gICAgICBzdXBlcihDb21wLCBpbml0aWFsUHJvcHMsIGh5ZHJhdGUyKTtcbiAgICB9XG4gIH1cbiAgVnVlQ3VzdG9tRWxlbWVudC5kZWYgPSBDb21wO1xuICByZXR1cm4gVnVlQ3VzdG9tRWxlbWVudDtcbn1cbi8qISAjX19OT19TSURFX0VGRkVDVFNfXyAqL1xuY29uc3QgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudCA9IC8qIEBfX05PX1NJREVfRUZGRUNUU19fICovIChvcHRpb25zKSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gZGVmaW5lQ3VzdG9tRWxlbWVudChvcHRpb25zLCBoeWRyYXRlKTtcbn07XG5jb25zdCBCYXNlQ2xhc3MgPSB0eXBlb2YgSFRNTEVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBIVE1MRWxlbWVudCA6IGNsYXNzIHtcbn07XG5jbGFzcyBWdWVFbGVtZW50IGV4dGVuZHMgQmFzZUNsYXNzIHtcbiAgY29uc3RydWN0b3IoX2RlZiwgX3Byb3BzID0ge30sIGh5ZHJhdGUyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9kZWYgPSBfZGVmO1xuICAgIHRoaXMuX3Byb3BzID0gX3Byb3BzO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZXNvbHZlZCA9IGZhbHNlO1xuICAgIHRoaXMuX251bWJlclByb3BzID0gbnVsbDtcbiAgICB0aGlzLl9vYiA9IG51bGw7XG4gICAgaWYgKHRoaXMuc2hhZG93Um9vdCAmJiBoeWRyYXRlMikge1xuICAgICAgaHlkcmF0ZTIodGhpcy5fY3JlYXRlVk5vZGUoKSwgdGhpcy5zaGFkb3dSb290KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYEN1c3RvbSBlbGVtZW50IGhhcyBwcmUtcmVuZGVyZWQgZGVjbGFyYXRpdmUgc2hhZG93IHJvb3QgYnV0IGlzIG5vdCBkZWZpbmVkIGFzIGh5ZHJhdGFibGUuIFVzZSBcXGBkZWZpbmVTU1JDdXN0b21FbGVtZW50XFxgLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogXCJvcGVuXCIgfSk7XG4gICAgICBpZiAoIXRoaXMuX2RlZi5fX2FzeW5jTG9hZGVyKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVQcm9wcyh0aGlzLl9kZWYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xuICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgIGlmICh0aGlzLl9yZXNvbHZlZCkge1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVEZWYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuX29iKSB7XG4gICAgICB0aGlzLl9vYi5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLl9vYiA9IG51bGw7XG4gICAgfVxuICAgIG5leHRUaWNrKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgIHJlbmRlcihudWxsLCB0aGlzLnNoYWRvd1Jvb3QpO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIHJlc29sdmUgaW5uZXIgY29tcG9uZW50IGRlZmluaXRpb24gKGhhbmRsZSBwb3NzaWJsZSBhc3luYyBjb21wb25lbnQpXG4gICAqL1xuICBfcmVzb2x2ZURlZigpIHtcbiAgICB0aGlzLl9yZXNvbHZlZCA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3NldEF0dHIodGhpcy5hdHRyaWJ1dGVzW2ldLm5hbWUpO1xuICAgIH1cbiAgICB0aGlzLl9vYiA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnMpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fc2V0QXR0cihtLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX29iLm9ic2VydmUodGhpcywgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xuICAgIGNvbnN0IHJlc29sdmUgPSAoZGVmLCBpc0FzeW5jID0gZmFsc2UpID0+IHtcbiAgICAgIGNvbnN0IHsgcHJvcHMsIHN0eWxlcyB9ID0gZGVmO1xuICAgICAgbGV0IG51bWJlclByb3BzO1xuICAgICAgaWYgKHByb3BzICYmICFpc0FycmF5KHByb3BzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICAgIGNvbnN0IG9wdCA9IHByb3BzW2tleV07XG4gICAgICAgICAgaWYgKG9wdCA9PT0gTnVtYmVyIHx8IG9wdCAmJiBvcHQudHlwZSA9PT0gTnVtYmVyKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluIHRoaXMuX3Byb3BzKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Byb3BzW2tleV0gPSB0b051bWJlcih0aGlzLl9wcm9wc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChudW1iZXJQcm9wcyB8fCAobnVtYmVyUHJvcHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSkpW2NhbWVsaXplJDEoa2V5KV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fbnVtYmVyUHJvcHMgPSBudW1iZXJQcm9wcztcbiAgICAgIGlmIChpc0FzeW5jKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVQcm9wcyhkZWYpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYXBwbHlTdHlsZXMoc3R5bGVzKTtcbiAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgIH07XG4gICAgY29uc3QgYXN5bmNEZWYgPSB0aGlzLl9kZWYuX19hc3luY0xvYWRlcjtcbiAgICBpZiAoYXN5bmNEZWYpIHtcbiAgICAgIGFzeW5jRGVmKCkudGhlbigoZGVmKSA9PiByZXNvbHZlKGRlZiwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlKHRoaXMuX2RlZik7XG4gICAgfVxuICB9XG4gIF9yZXNvbHZlUHJvcHMoZGVmKSB7XG4gICAgY29uc3QgeyBwcm9wcyB9ID0gZGVmO1xuICAgIGNvbnN0IGRlY2xhcmVkUHJvcEtleXMgPSBpc0FycmF5KHByb3BzKSA/IHByb3BzIDogT2JqZWN0LmtleXMocHJvcHMgfHwge30pO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMpKSB7XG4gICAgICBpZiAoa2V5WzBdICE9PSBcIl9cIiAmJiBkZWNsYXJlZFByb3BLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgdGhpcy5fc2V0UHJvcChrZXksIHRoaXNba2V5XSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBkZWNsYXJlZFByb3BLZXlzLm1hcChjYW1lbGl6ZSQxKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByb3Aoa2V5KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbCkge1xuICAgICAgICAgIHRoaXMuX3NldFByb3Aoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX3NldEF0dHIoa2V5KSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoa2V5KTtcbiAgICBjb25zdCBjYW1lbEtleSA9IGNhbWVsaXplJDEoa2V5KTtcbiAgICBpZiAodGhpcy5fbnVtYmVyUHJvcHMgJiYgdGhpcy5fbnVtYmVyUHJvcHNbY2FtZWxLZXldKSB7XG4gICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0UHJvcChjYW1lbEtleSwgdmFsdWUsIGZhbHNlKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZ2V0UHJvcChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvcHNba2V5XTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2V0UHJvcChrZXksIHZhbCwgc2hvdWxkUmVmbGVjdCA9IHRydWUsIHNob3VsZFVwZGF0ZSA9IHRydWUpIHtcbiAgICBpZiAodmFsICE9PSB0aGlzLl9wcm9wc1trZXldKSB7XG4gICAgICB0aGlzLl9wcm9wc1trZXldID0gdmFsO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZSAmJiB0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRSZWZsZWN0KSB7XG4gICAgICAgIGlmICh2YWwgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSwgXCJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSksIHZhbCArIFwiXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKCF2YWwpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3VwZGF0ZSgpIHtcbiAgICByZW5kZXIodGhpcy5fY3JlYXRlVk5vZGUoKSwgdGhpcy5zaGFkb3dSb290KTtcbiAgfVxuICBfY3JlYXRlVk5vZGUoKSB7XG4gICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZSh0aGlzLl9kZWYsIGV4dGVuZCh7fSwgdGhpcy5fcHJvcHMpKTtcbiAgICBpZiAoIXRoaXMuX2luc3RhbmNlKSB7XG4gICAgICB2bm9kZS5jZSA9IChpbnN0YW5jZSkgPT4ge1xuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICBpbnN0YW5jZS5pc0NFID0gdHJ1ZTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBpbnN0YW5jZS5jZVJlbG9hZCA9IChuZXdTdHlsZXMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdHlsZXMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc3R5bGVzLmZvckVhY2goKHMpID0+IHRoaXMuc2hhZG93Um9vdC5yZW1vdmVDaGlsZChzKSk7XG4gICAgICAgICAgICAgIHRoaXMuX3N0eWxlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYXBwbHlTdHlsZXMobmV3U3R5bGVzKTtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzcGF0Y2ggPSAoZXZlbnQsIGFyZ3MpID0+IHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoZXZlbnQsIHtcbiAgICAgICAgICAgICAgZGV0YWlsOiBhcmdzXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICAgIGluc3RhbmNlLmVtaXQgPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBkaXNwYXRjaChldmVudCwgYXJncyk7XG4gICAgICAgICAgaWYgKGh5cGhlbmF0ZShldmVudCkgIT09IGV2ZW50KSB7XG4gICAgICAgICAgICBkaXNwYXRjaChoeXBoZW5hdGUoZXZlbnQpLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzO1xuICAgICAgICB3aGlsZSAocGFyZW50ID0gcGFyZW50ICYmIChwYXJlbnQucGFyZW50Tm9kZSB8fCBwYXJlbnQuaG9zdCkpIHtcbiAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgVnVlRWxlbWVudCkge1xuICAgICAgICAgICAgaW5zdGFuY2UucGFyZW50ID0gcGFyZW50Ll9pbnN0YW5jZTtcbiAgICAgICAgICAgIGluc3RhbmNlLnByb3ZpZGVzID0gcGFyZW50Ll9pbnN0YW5jZS5wcm92aWRlcztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlO1xuICB9XG4gIF9hcHBseVN0eWxlcyhzdHlsZXMpIHtcbiAgICBpZiAoc3R5bGVzKSB7XG4gICAgICBzdHlsZXMuZm9yRWFjaCgoY3NzKSA9PiB7XG4gICAgICAgIGNvbnN0IHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICAgIHMudGV4dENvbnRlbnQgPSBjc3M7XG4gICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChzKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAodGhpcy5fc3R5bGVzIHx8ICh0aGlzLl9zdHlsZXMgPSBbXSkpLnB1c2gocyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VDc3NNb2R1bGUobmFtZSA9IFwiJHN0eWxlXCIpIHtcbiAge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGB1c2VDc3NNb2R1bGUgbXVzdCBiZSBjYWxsZWQgaW5zaWRlIHNldHVwKClgKTtcbiAgICAgIHJldHVybiBFTVBUWV9PQko7XG4gICAgfVxuICAgIGNvbnN0IG1vZHVsZXMgPSBpbnN0YW5jZS50eXBlLl9fY3NzTW9kdWxlcztcbiAgICBpZiAoIW1vZHVsZXMpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGVzIGluamVjdGVkLmApO1xuICAgICAgcmV0dXJuIEVNUFRZX09CSjtcbiAgICB9XG4gICAgY29uc3QgbW9kID0gbW9kdWxlc1tuYW1lXTtcbiAgICBpZiAoIW1vZCkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZSBuYW1lZCBcIiR7bmFtZX1cIi5gKTtcbiAgICAgIHJldHVybiBFTVBUWV9PQko7XG4gICAgfVxuICAgIHJldHVybiBtb2Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlQ3NzVmFycyhnZXR0ZXIpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKCFpbnN0YW5jZSkge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgdXNlQ3NzVmFycyBpcyBjYWxsZWQgd2l0aG91dCBjdXJyZW50IGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UuYCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHVwZGF0ZVRlbGVwb3J0cyA9IGluc3RhbmNlLnV0ID0gKHZhcnMgPSBnZXR0ZXIoaW5zdGFuY2UucHJveHkpKSA9PiB7XG4gICAgQXJyYXkuZnJvbShcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLXYtb3duZXI9XCIke2luc3RhbmNlLnVpZH1cIl1gKVxuICAgICkuZm9yRWFjaCgobm9kZSkgPT4gc2V0VmFyc09uTm9kZShub2RlLCB2YXJzKSk7XG4gIH07XG4gIGNvbnN0IHNldFZhcnMgPSAoKSA9PiB7XG4gICAgY29uc3QgdmFycyA9IGdldHRlcihpbnN0YW5jZS5wcm94eSk7XG4gICAgc2V0VmFyc09uVk5vZGUoaW5zdGFuY2Uuc3ViVHJlZSwgdmFycyk7XG4gICAgdXBkYXRlVGVsZXBvcnRzKHZhcnMpO1xuICB9O1xuICB3YXRjaFBvc3RFZmZlY3Qoc2V0VmFycyk7XG4gIG9uTW91bnRlZCgoKSA9PiB7XG4gICAgY29uc3Qgb2IgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihzZXRWYXJzKTtcbiAgICBvYi5vYnNlcnZlKGluc3RhbmNlLnN1YlRyZWUuZWwucGFyZW50Tm9kZSwgeyBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgb25Vbm1vdW50ZWQoKCkgPT4gb2IuZGlzY29ubmVjdCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzZXRWYXJzT25WTm9kZSh2bm9kZSwgdmFycykge1xuICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgY29uc3Qgc3VzcGVuc2UgPSB2bm9kZS5zdXNwZW5zZTtcbiAgICB2bm9kZSA9IHN1c3BlbnNlLmFjdGl2ZUJyYW5jaDtcbiAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJiAhc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcbiAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaCgoKSA9PiB7XG4gICAgICAgIHNldFZhcnNPblZOb2RlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgdmFycyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKHZub2RlLmNvbXBvbmVudCkge1xuICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50LnN1YlRyZWU7XG4gIH1cbiAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEgJiYgdm5vZGUuZWwpIHtcbiAgICBzZXRWYXJzT25Ob2RlKHZub2RlLmVsLCB2YXJzKTtcbiAgfSBlbHNlIGlmICh2bm9kZS50eXBlID09PSBGcmFnbWVudCkge1xuICAgIHZub2RlLmNoaWxkcmVuLmZvckVhY2goKGMpID0+IHNldFZhcnNPblZOb2RlKGMsIHZhcnMpKTtcbiAgfSBlbHNlIGlmICh2bm9kZS50eXBlID09PSBTdGF0aWMpIHtcbiAgICBsZXQgeyBlbCwgYW5jaG9yIH0gPSB2bm9kZTtcbiAgICB3aGlsZSAoZWwpIHtcbiAgICAgIHNldFZhcnNPbk5vZGUoZWwsIHZhcnMpO1xuICAgICAgaWYgKGVsID09PSBhbmNob3IpXG4gICAgICAgIGJyZWFrO1xuICAgICAgZWwgPSBlbC5uZXh0U2libGluZztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFZhcnNPbk5vZGUoZWwsIHZhcnMpIHtcbiAgaWYgKGVsLm5vZGVUeXBlID09PSAxKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YXJzKSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShgLS0ke2tleX1gLCB2YXJzW2tleV0pO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBwb3NpdGlvbk1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgbmV3UG9zaXRpb25NYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IG1vdmVDYktleSA9IFN5bWJvbChcIl9tb3ZlQ2JcIik7XG5jb25zdCBlbnRlckNiS2V5ID0gU3ltYm9sKFwiX2VudGVyQ2JcIik7XG5jb25zdCBUcmFuc2l0aW9uR3JvdXBJbXBsID0ge1xuICBuYW1lOiBcIlRyYW5zaXRpb25Hcm91cFwiLFxuICBwcm9wczogLyogQF9fUFVSRV9fICovIGV4dGVuZCh7fSwgVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycywge1xuICAgIHRhZzogU3RyaW5nLFxuICAgIG1vdmVDbGFzczogU3RyaW5nXG4gIH0pLFxuICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBjb25zdCBzdGF0ZSA9IHVzZVRyYW5zaXRpb25TdGF0ZSgpO1xuICAgIGxldCBwcmV2Q2hpbGRyZW47XG4gICAgbGV0IGNoaWxkcmVuO1xuICAgIG9uVXBkYXRlZCgoKSA9PiB7XG4gICAgICBpZiAoIXByZXZDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbW92ZUNsYXNzID0gcHJvcHMubW92ZUNsYXNzIHx8IGAke3Byb3BzLm5hbWUgfHwgXCJ2XCJ9LW1vdmVgO1xuICAgICAgaWYgKCFoYXNDU1NUcmFuc2Zvcm0oXG4gICAgICAgIHByZXZDaGlsZHJlblswXS5lbCxcbiAgICAgICAgaW5zdGFuY2Uudm5vZGUuZWwsXG4gICAgICAgIG1vdmVDbGFzc1xuICAgICAgKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwcmV2Q2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgICBwcmV2Q2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgICBjb25zdCBtb3ZlZENoaWxkcmVuID0gcHJldkNoaWxkcmVuLmZpbHRlcihhcHBseVRyYW5zbGF0aW9uKTtcbiAgICAgIGZvcmNlUmVmbG93KCk7XG4gICAgICBtb3ZlZENoaWxkcmVuLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgY29uc3QgZWwgPSBjLmVsO1xuICAgICAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IHN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IFwiXCI7XG4gICAgICAgIGNvbnN0IGNiID0gZWxbbW92ZUNiS2V5XSA9IChlKSA9PiB7XG4gICAgICAgICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IGVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIGNiKTtcbiAgICAgICAgICAgIGVsW21vdmVDYktleV0gPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgY2IpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IHJhd1Byb3BzID0gdG9SYXcocHJvcHMpO1xuICAgICAgY29uc3QgY3NzVHJhbnNpdGlvblByb3BzID0gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcyk7XG4gICAgICBsZXQgdGFnID0gcmF3UHJvcHMudGFnIHx8IEZyYWdtZW50O1xuICAgICAgcHJldkNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgPyBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oc2xvdHMuZGVmYXVsdCgpKSA6IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoY2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgIHJlc29sdmVUcmFuc2l0aW9uSG9va3MoY2hpbGQsIGNzc1RyYW5zaXRpb25Qcm9wcywgc3RhdGUsIGluc3RhbmNlKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4oYDxUcmFuc2l0aW9uR3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IHByZXZDaGlsZHJlbltpXTtcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgIHJlc29sdmVUcmFuc2l0aW9uSG9va3MoY2hpbGQsIGNzc1RyYW5zaXRpb25Qcm9wcywgc3RhdGUsIGluc3RhbmNlKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcG9zaXRpb25NYXAuc2V0KGNoaWxkLCBjaGlsZC5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0YWcsIG51bGwsIGNoaWxkcmVuKTtcbiAgICB9O1xuICB9XG59O1xuY29uc3QgcmVtb3ZlTW9kZSA9IChwcm9wcykgPT4gZGVsZXRlIHByb3BzLm1vZGU7XG4vKiBAX19QVVJFX18gKi8gcmVtb3ZlTW9kZShUcmFuc2l0aW9uR3JvdXBJbXBsLnByb3BzKTtcbmNvbnN0IFRyYW5zaXRpb25Hcm91cCA9IFRyYW5zaXRpb25Hcm91cEltcGw7XG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyhjKSB7XG4gIGNvbnN0IGVsID0gYy5lbDtcbiAgaWYgKGVsW21vdmVDYktleV0pIHtcbiAgICBlbFttb3ZlQ2JLZXldKCk7XG4gIH1cbiAgaWYgKGVsW2VudGVyQ2JLZXldKSB7XG4gICAgZWxbZW50ZXJDYktleV0oKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24oYykge1xuICBuZXdQb3NpdGlvbk1hcC5zZXQoYywgYy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG59XG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uKGMpIHtcbiAgY29uc3Qgb2xkUG9zID0gcG9zaXRpb25NYXAuZ2V0KGMpO1xuICBjb25zdCBuZXdQb3MgPSBuZXdQb3NpdGlvbk1hcC5nZXQoYyk7XG4gIGNvbnN0IGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgY29uc3QgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgY29uc3QgcyA9IGMuZWwuc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLndlYmtpdFRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtkeH1weCwke2R5fXB4KWA7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSBcIjBzXCI7XG4gICAgcmV0dXJuIGM7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc0NTU1RyYW5zZm9ybShlbCwgcm9vdCwgbW92ZUNsYXNzKSB7XG4gIGNvbnN0IGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gIGNvbnN0IF92dGMgPSBlbFt2dGNLZXldO1xuICBpZiAoX3Z0Yykge1xuICAgIF92dGMuZm9yRWFjaCgoY2xzKSA9PiB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKChjKSA9PiBjICYmIGNsb25lLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xuICAgIH0pO1xuICB9XG4gIG1vdmVDbGFzcy5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGMpID0+IGMgJiYgY2xvbmUuY2xhc3NMaXN0LmFkZChjKSk7XG4gIGNsb25lLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgY29uc3QgY29udGFpbmVyID0gcm9vdC5ub2RlVHlwZSA9PT0gMSA/IHJvb3QgOiByb290LnBhcmVudE5vZGU7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjbG9uZSk7XG4gIGNvbnN0IHsgaGFzVHJhbnNmb3JtIH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjbG9uZSk7XG4gIHJldHVybiBoYXNUcmFuc2Zvcm07XG59XG5cbmNvbnN0IGdldE1vZGVsQXNzaWduZXIgPSAodm5vZGUpID0+IHtcbiAgY29uc3QgZm4gPSB2bm9kZS5wcm9wc1tcIm9uVXBkYXRlOm1vZGVsVmFsdWVcIl0gfHwgZmFsc2U7XG4gIHJldHVybiBpc0FycmF5KGZuKSA/ICh2YWx1ZSkgPT4gaW52b2tlQXJyYXlGbnMoZm4sIHZhbHVlKSA6IGZuO1xufTtcbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kKGUpIHtcbiAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gIGlmICh0YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgdGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIpKTtcbiAgfVxufVxuY29uc3QgYXNzaWduS2V5ID0gU3ltYm9sKFwiX2Fzc2lnblwiKTtcbmNvbnN0IHZNb2RlbFRleHQgPSB7XG4gIGNyZWF0ZWQoZWwsIHsgbW9kaWZpZXJzOiB7IGxhenksIHRyaW0sIG51bWJlciB9IH0sIHZub2RlKSB7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIGNvbnN0IGNhc3RUb051bWJlciA9IG51bWJlciB8fCB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50eXBlID09PSBcIm51bWJlclwiO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIGxhenkgPyBcImNoYW5nZVwiIDogXCJpbnB1dFwiLCAoZSkgPT4ge1xuICAgICAgaWYgKGUudGFyZ2V0LmNvbXBvc2luZylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGV0IGRvbVZhbHVlID0gZWwudmFsdWU7XG4gICAgICBpZiAodHJpbSkge1xuICAgICAgICBkb21WYWx1ZSA9IGRvbVZhbHVlLnRyaW0oKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYXN0VG9OdW1iZXIpIHtcbiAgICAgICAgZG9tVmFsdWUgPSBsb29zZVRvTnVtYmVyKGRvbVZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsW2Fzc2lnbktleV0oZG9tVmFsdWUpO1xuICAgIH0pO1xuICAgIGlmICh0cmltKSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICAgIGVsLnZhbHVlID0gZWwudmFsdWUudHJpbSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghbGF6eSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjb21wb3NpdGlvbnN0YXJ0XCIsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNvbXBvc2l0aW9uZW5kXCIsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgfVxuICB9LFxuICAvLyBzZXQgdmFsdWUgb24gbW91bnRlZCBzbyBpdCdzIGFmdGVyIG1pbi9tYXggZm9yIHR5cGU9XCJyYW5nZVwiXG4gIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSkge1xuICAgIGVsLnZhbHVlID0gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGVsLCB7IHZhbHVlLCBtb2RpZmllcnM6IHsgbGF6eSwgdHJpbSwgbnVtYmVyIH0gfSwgdm5vZGUpIHtcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgaWYgKGVsLmNvbXBvc2luZylcbiAgICAgIHJldHVybjtcbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZWwgJiYgZWwudHlwZSAhPT0gXCJyYW5nZVwiKSB7XG4gICAgICBpZiAobGF6eSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHJpbSAmJiBlbC52YWx1ZS50cmltKCkgPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgobnVtYmVyIHx8IGVsLnR5cGUgPT09IFwibnVtYmVyXCIpICYmIGxvb3NlVG9OdW1iZXIoZWwudmFsdWUpID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTtcbiAgICBpZiAoZWwudmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IHZNb2RlbENoZWNrYm94ID0ge1xuICAvLyAjNDA5NiBhcnJheSBjaGVja2JveGVzIG5lZWQgdG8gYmUgZGVlcCB0cmF2ZXJzZWRcbiAgZGVlcDogdHJ1ZSxcbiAgY3JlYXRlZChlbCwgXywgdm5vZGUpIHtcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbW9kZWxWYWx1ZSA9IGVsLl9tb2RlbFZhbHVlO1xuICAgICAgY29uc3QgZWxlbWVudFZhbHVlID0gZ2V0VmFsdWUoZWwpO1xuICAgICAgY29uc3QgY2hlY2tlZCA9IGVsLmNoZWNrZWQ7XG4gICAgICBjb25zdCBhc3NpZ24gPSBlbFthc3NpZ25LZXldO1xuICAgICAgaWYgKGlzQXJyYXkobW9kZWxWYWx1ZSkpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBsb29zZUluZGV4T2YobW9kZWxWYWx1ZSwgZWxlbWVudFZhbHVlKTtcbiAgICAgICAgY29uc3QgZm91bmQgPSBpbmRleCAhPT0gLTE7XG4gICAgICAgIGlmIChjaGVja2VkICYmICFmb3VuZCkge1xuICAgICAgICAgIGFzc2lnbihtb2RlbFZhbHVlLmNvbmNhdChlbGVtZW50VmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmICghY2hlY2tlZCAmJiBmb3VuZCkge1xuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gWy4uLm1vZGVsVmFsdWVdO1xuICAgICAgICAgIGZpbHRlcmVkLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgYXNzaWduKGZpbHRlcmVkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1NldChtb2RlbFZhbHVlKSkge1xuICAgICAgICBjb25zdCBjbG9uZWQgPSBuZXcgU2V0KG1vZGVsVmFsdWUpO1xuICAgICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgIGNsb25lZC5hZGQoZWxlbWVudFZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9uZWQuZGVsZXRlKGVsZW1lbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduKGNsb25lZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3NpZ24oZ2V0Q2hlY2tib3hWYWx1ZShlbCwgY2hlY2tlZCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICAvLyBzZXQgaW5pdGlhbCBjaGVja2VkIG9uIG1vdW50IHRvIHdhaXQgZm9yIHRydWUtdmFsdWUvZmFsc2UtdmFsdWVcbiAgbW91bnRlZDogc2V0Q2hlY2tlZCxcbiAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBzZXRDaGVja2VkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBzZXRDaGVja2VkKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xuICBlbC5fbW9kZWxWYWx1ZSA9IHZhbHVlO1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBlbC5jaGVja2VkID0gbG9vc2VJbmRleE9mKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSkgPiAtMTtcbiAgfSBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICBlbC5jaGVja2VkID0gdmFsdWUuaGFzKHZub2RlLnByb3BzLnZhbHVlKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgZ2V0Q2hlY2tib3hWYWx1ZShlbCwgdHJ1ZSkpO1xuICB9XG59XG5jb25zdCB2TW9kZWxSYWRpbyA9IHtcbiAgY3JlYXRlZChlbCwgeyB2YWx1ZSB9LCB2bm9kZSkge1xuICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSk7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIGVsW2Fzc2lnbktleV0oZ2V0VmFsdWUoZWwpKTtcbiAgICB9KTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IHZNb2RlbFNlbGVjdCA9IHtcbiAgLy8gPHNlbGVjdCBtdWx0aXBsZT4gdmFsdWUgbmVlZCB0byBiZSBkZWVwIHRyYXZlcnNlZFxuICBkZWVwOiB0cnVlLFxuICBjcmVhdGVkKGVsLCB7IHZhbHVlLCBtb2RpZmllcnM6IHsgbnVtYmVyIH0gfSwgdm5vZGUpIHtcbiAgICBjb25zdCBpc1NldE1vZGVsID0gaXNTZXQodmFsdWUpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGVsLm9wdGlvbnMsIChvKSA9PiBvLnNlbGVjdGVkKS5tYXAoXG4gICAgICAgIChvKSA9PiBudW1iZXIgPyBsb29zZVRvTnVtYmVyKGdldFZhbHVlKG8pKSA6IGdldFZhbHVlKG8pXG4gICAgICApO1xuICAgICAgZWxbYXNzaWduS2V5XShcbiAgICAgICAgZWwubXVsdGlwbGUgPyBpc1NldE1vZGVsID8gbmV3IFNldChzZWxlY3RlZFZhbCkgOiBzZWxlY3RlZFZhbCA6IHNlbGVjdGVkVmFsWzBdXG4gICAgICApO1xuICAgIH0pO1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgfSxcbiAgLy8gc2V0IHZhbHVlIGluIG1vdW50ZWQgJiB1cGRhdGVkIGJlY2F1c2UgPHNlbGVjdD4gcmVsaWVzIG9uIGl0cyBjaGlsZHJlblxuICAvLyA8b3B0aW9uPnMuXG4gIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSkge1xuICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShlbCwgX2JpbmRpbmcsIHZub2RlKSB7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICB9LFxuICB1cGRhdGVkKGVsLCB7IHZhbHVlIH0pIHtcbiAgICBzZXRTZWxlY3RlZChlbCwgdmFsdWUpO1xuICB9XG59O1xuZnVuY3Rpb24gc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKSB7XG4gIGNvbnN0IGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIWlzQXJyYXkodmFsdWUpICYmICFpc1NldCh2YWx1ZSkpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oXG4gICAgICBgPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPiBleHBlY3RzIGFuIEFycmF5IG9yIFNldCB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgJHtPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKX0uYFxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAobGV0IGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGNvbnN0IG9wdGlvblZhbHVlID0gZ2V0VmFsdWUob3B0aW9uKTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgb3B0aW9uVmFsdWUpID4gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZS5oYXMob3B0aW9uVmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpXG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlICYmIGVsLnNlbGVjdGVkSW5kZXggIT09IC0xKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5mdW5jdGlvbiBnZXRWYWx1ZShlbCkge1xuICByZXR1cm4gXCJfdmFsdWVcIiBpbiBlbCA/IGVsLl92YWx1ZSA6IGVsLnZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0Q2hlY2tib3hWYWx1ZShlbCwgY2hlY2tlZCkge1xuICBjb25zdCBrZXkgPSBjaGVja2VkID8gXCJfdHJ1ZVZhbHVlXCIgOiBcIl9mYWxzZVZhbHVlXCI7XG4gIHJldHVybiBrZXkgaW4gZWwgPyBlbFtrZXldIDogY2hlY2tlZDtcbn1cbmNvbnN0IHZNb2RlbER5bmFtaWMgPSB7XG4gIGNyZWF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIG51bGwsIFwiY3JlYXRlZFwiKTtcbiAgfSxcbiAgbW91bnRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgbnVsbCwgXCJtb3VudGVkXCIpO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpIHtcbiAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCBcImJlZm9yZVVwZGF0ZVwiKTtcbiAgfSxcbiAgdXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSkge1xuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsIFwidXBkYXRlZFwiKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljTW9kZWwodGFnTmFtZSwgdHlwZSkge1xuICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICBjYXNlIFwiU0VMRUNUXCI6XG4gICAgICByZXR1cm4gdk1vZGVsU2VsZWN0O1xuICAgIGNhc2UgXCJURVhUQVJFQVwiOlxuICAgICAgcmV0dXJuIHZNb2RlbFRleHQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiY2hlY2tib3hcIjpcbiAgICAgICAgICByZXR1cm4gdk1vZGVsQ2hlY2tib3g7XG4gICAgICAgIGNhc2UgXCJyYWRpb1wiOlxuICAgICAgICAgIHJldHVybiB2TW9kZWxSYWRpbztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdk1vZGVsVGV4dDtcbiAgICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgaG9vaykge1xuICBjb25zdCBtb2RlbFRvVXNlID0gcmVzb2x2ZUR5bmFtaWNNb2RlbChcbiAgICBlbC50YWdOYW1lLFxuICAgIHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGVcbiAgKTtcbiAgY29uc3QgZm4gPSBtb2RlbFRvVXNlW2hvb2tdO1xuICBmbiAmJiBmbihlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSk7XG59XG5mdW5jdGlvbiBpbml0Vk1vZGVsRm9yU1NSKCkge1xuICB2TW9kZWxUZXh0LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSkgPT4gKHsgdmFsdWUgfSk7XG4gIHZNb2RlbFJhZGlvLmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSwgdm5vZGUpID0+IHtcbiAgICBpZiAodm5vZGUucHJvcHMgJiYgbG9vc2VFcXVhbCh2bm9kZS5wcm9wcy52YWx1ZSwgdmFsdWUpKSB7XG4gICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XG4gICAgfVxuICB9O1xuICB2TW9kZWxDaGVja2JveC5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0sIHZub2RlKSA9PiB7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAodm5vZGUucHJvcHMgJiYgbG9vc2VJbmRleE9mKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSkgPiAtMSkge1xuICAgICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICAgIGlmICh2bm9kZS5wcm9wcyAmJiB2YWx1ZS5oYXModm5vZGUucHJvcHMudmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XG4gICAgfVxuICB9O1xuICB2TW9kZWxEeW5hbWljLmdldFNTUlByb3BzID0gKGJpbmRpbmcsIHZub2RlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2bm9kZS50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1vZGVsVG9Vc2UgPSByZXNvbHZlRHluYW1pY01vZGVsKFxuICAgICAgLy8gcmVzb2x2ZUR5bmFtaWNNb2RlbCBleHBlY3RzIGFuIHVwcGVyY2FzZSB0YWcgbmFtZSwgYnV0IHZub2RlLnR5cGUgaXMgbG93ZXJjYXNlXG4gICAgICB2bm9kZS50eXBlLnRvVXBwZXJDYXNlKCksXG4gICAgICB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50eXBlXG4gICAgKTtcbiAgICBpZiAobW9kZWxUb1VzZS5nZXRTU1JQcm9wcykge1xuICAgICAgcmV0dXJuIG1vZGVsVG9Vc2UuZ2V0U1NSUHJvcHMoYmluZGluZywgdm5vZGUpO1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3Qgc3lzdGVtTW9kaWZpZXJzID0gW1wiY3RybFwiLCBcInNoaWZ0XCIsIFwiYWx0XCIsIFwibWV0YVwiXTtcbmNvbnN0IG1vZGlmaWVyR3VhcmRzID0ge1xuICBzdG9wOiAoZSkgPT4gZS5zdG9wUHJvcGFnYXRpb24oKSxcbiAgcHJldmVudDogKGUpID0+IGUucHJldmVudERlZmF1bHQoKSxcbiAgc2VsZjogKGUpID0+IGUudGFyZ2V0ICE9PSBlLmN1cnJlbnRUYXJnZXQsXG4gIGN0cmw6IChlKSA9PiAhZS5jdHJsS2V5LFxuICBzaGlmdDogKGUpID0+ICFlLnNoaWZ0S2V5LFxuICBhbHQ6IChlKSA9PiAhZS5hbHRLZXksXG4gIG1ldGE6IChlKSA9PiAhZS5tZXRhS2V5LFxuICBsZWZ0OiAoZSkgPT4gXCJidXR0b25cIiBpbiBlICYmIGUuYnV0dG9uICE9PSAwLFxuICBtaWRkbGU6IChlKSA9PiBcImJ1dHRvblwiIGluIGUgJiYgZS5idXR0b24gIT09IDEsXG4gIHJpZ2h0OiAoZSkgPT4gXCJidXR0b25cIiBpbiBlICYmIGUuYnV0dG9uICE9PSAyLFxuICBleGFjdDogKGUsIG1vZGlmaWVycykgPT4gc3lzdGVtTW9kaWZpZXJzLnNvbWUoKG0pID0+IGVbYCR7bX1LZXlgXSAmJiAhbW9kaWZpZXJzLmluY2x1ZGVzKG0pKVxufTtcbmNvbnN0IHdpdGhNb2RpZmllcnMgPSAoZm4sIG1vZGlmaWVycykgPT4ge1xuICByZXR1cm4gKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGd1YXJkID0gbW9kaWZpZXJHdWFyZHNbbW9kaWZpZXJzW2ldXTtcbiAgICAgIGlmIChndWFyZCAmJiBndWFyZChldmVudCwgbW9kaWZpZXJzKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gZm4oZXZlbnQsIC4uLmFyZ3MpO1xuICB9O1xufTtcbmNvbnN0IGtleU5hbWVzID0ge1xuICBlc2M6IFwiZXNjYXBlXCIsXG4gIHNwYWNlOiBcIiBcIixcbiAgdXA6IFwiYXJyb3ctdXBcIixcbiAgbGVmdDogXCJhcnJvdy1sZWZ0XCIsXG4gIHJpZ2h0OiBcImFycm93LXJpZ2h0XCIsXG4gIGRvd246IFwiYXJyb3ctZG93blwiLFxuICBkZWxldGU6IFwiYmFja3NwYWNlXCJcbn07XG5jb25zdCB3aXRoS2V5cyA9IChmbiwgbW9kaWZpZXJzKSA9PiB7XG4gIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICBpZiAoIShcImtleVwiIGluIGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBldmVudEtleSA9IGh5cGhlbmF0ZShldmVudC5rZXkpO1xuICAgIGlmIChtb2RpZmllcnMuc29tZSgoaykgPT4gayA9PT0gZXZlbnRLZXkgfHwga2V5TmFtZXNba10gPT09IGV2ZW50S2V5KSkge1xuICAgICAgcmV0dXJuIGZuKGV2ZW50KTtcbiAgICB9XG4gIH07XG59O1xuXG5jb25zdCByZW5kZXJlck9wdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKHsgcGF0Y2hQcm9wIH0sIG5vZGVPcHMpO1xubGV0IHJlbmRlcmVyO1xubGV0IGVuYWJsZWRIeWRyYXRpb24gPSBmYWxzZTtcbmZ1bmN0aW9uIGVuc3VyZVJlbmRlcmVyKCkge1xuICByZXR1cm4gcmVuZGVyZXIgfHwgKHJlbmRlcmVyID0gY3JlYXRlUmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKSk7XG59XG5mdW5jdGlvbiBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpIHtcbiAgcmVuZGVyZXIgPSBlbmFibGVkSHlkcmF0aW9uID8gcmVuZGVyZXIgOiBjcmVhdGVIeWRyYXRpb25SZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpO1xuICBlbmFibGVkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgcmV0dXJuIHJlbmRlcmVyO1xufVxuY29uc3QgcmVuZGVyID0gKC4uLmFyZ3MpID0+IHtcbiAgZW5zdXJlUmVuZGVyZXIoKS5yZW5kZXIoLi4uYXJncyk7XG59O1xuY29uc3QgaHlkcmF0ZSA9ICguLi5hcmdzKSA9PiB7XG4gIGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkuaHlkcmF0ZSguLi5hcmdzKTtcbn07XG5jb25zdCBjcmVhdGVBcHAgPSAoLi4uYXJncykgPT4ge1xuICBjb25zdCBhcHAgPSBlbnN1cmVSZW5kZXJlcigpLmNyZWF0ZUFwcCguLi5hcmdzKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApO1xuICAgIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCk7XG4gIH1cbiAgY29uc3QgeyBtb3VudCB9ID0gYXBwO1xuICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXJPclNlbGVjdG9yKTtcbiAgICBpZiAoIWNvbnRhaW5lcilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBjb21wb25lbnQgPSBhcHAuX2NvbXBvbmVudDtcbiAgICBpZiAoIWlzRnVuY3Rpb24oY29tcG9uZW50KSAmJiAhY29tcG9uZW50LnJlbmRlciAmJiAhY29tcG9uZW50LnRlbXBsYXRlKSB7XG4gICAgICBjb21wb25lbnQudGVtcGxhdGUgPSBjb250YWluZXIuaW5uZXJIVE1MO1xuICAgIH1cbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gXCJcIjtcbiAgICBjb25zdCBwcm94eSA9IG1vdW50KGNvbnRhaW5lciwgZmFsc2UsIGNvbnRhaW5lciBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpO1xuICAgIGlmIChjb250YWluZXIgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICBjb250YWluZXIucmVtb3ZlQXR0cmlidXRlKFwidi1jbG9ha1wiKTtcbiAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLXYtYXBwXCIsIFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG4gIHJldHVybiBhcHA7XG59O1xuY29uc3QgY3JlYXRlU1NSQXBwID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3QgYXBwID0gZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKS5jcmVhdGVBcHAoLi4uYXJncyk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKTtcbiAgICBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApO1xuICB9XG4gIGNvbnN0IHsgbW91bnQgfSA9IGFwcDtcbiAgYXBwLm1vdW50ID0gKGNvbnRhaW5lck9yU2VsZWN0b3IpID0+IHtcbiAgICBjb25zdCBjb250YWluZXIgPSBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyT3JTZWxlY3Rvcik7XG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIG1vdW50KGNvbnRhaW5lciwgdHJ1ZSwgY29udGFpbmVyIGluc3RhbmNlb2YgU1ZHRWxlbWVudCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gYXBwO1xufTtcbmZ1bmN0aW9uIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgXCJpc05hdGl2ZVRhZ1wiLCB7XG4gICAgdmFsdWU6ICh0YWcpID0+IGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHVGFnKHRhZyksXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xufVxuZnVuY3Rpb24gaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKSB7XG4gIGlmIChpc1J1bnRpbWVPbmx5KCkpIHtcbiAgICBjb25zdCBpc0N1c3RvbUVsZW1lbnQgPSBhcHAuY29uZmlnLmlzQ3VzdG9tRWxlbWVudDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgXCJpc0N1c3RvbUVsZW1lbnRcIiwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gaXNDdXN0b21FbGVtZW50O1xuICAgICAgfSxcbiAgICAgIHNldCgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgVGhlIFxcYGlzQ3VzdG9tRWxlbWVudFxcYCBjb25maWcgb3B0aW9uIGlzIGRlcHJlY2F0ZWQuIFVzZSBcXGBjb21waWxlck9wdGlvbnMuaXNDdXN0b21FbGVtZW50XFxgIGluc3RlYWQuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGNvbXBpbGVyT3B0aW9ucyA9IGFwcC5jb25maWcuY29tcGlsZXJPcHRpb25zO1xuICAgIGNvbnN0IG1zZyA9IGBUaGUgXFxgY29tcGlsZXJPcHRpb25zXFxgIGNvbmZpZyBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyBhIGJ1aWxkIG9mIFZ1ZS5qcyB0aGF0IGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyIChha2EgXCJmdWxsIGJ1aWxkXCIpLiBTaW5jZSB5b3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQsIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBtdXN0IGJlIHBhc3NlZCB0byBcXGBAdnVlL2NvbXBpbGVyLWRvbVxcYCBpbiB0aGUgYnVpbGQgc2V0dXAgaW5zdGVhZC5cbi0gRm9yIHZ1ZS1sb2FkZXI6IHBhc3MgaXQgdmlhIHZ1ZS1sb2FkZXIncyBcXGBjb21waWxlck9wdGlvbnNcXGAgbG9hZGVyIG9wdGlvbi5cbi0gRm9yIHZ1ZS1jbGk6IHNlZSBodHRwczovL2NsaS52dWVqcy5vcmcvZ3VpZGUvd2VicGFjay5odG1sI21vZGlmeWluZy1vcHRpb25zLW9mLWEtbG9hZGVyXG4tIEZvciB2aXRlOiBwYXNzIGl0IHZpYSBAdml0ZWpzL3BsdWdpbi12dWUgb3B0aW9ucy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS1wbHVnaW4tdnVlL3RyZWUvbWFpbi9wYWNrYWdlcy9wbHVnaW4tdnVlI2V4YW1wbGUtZm9yLXBhc3Npbmctb3B0aW9ucy10by12dWVjb21waWxlci1zZmNgO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCBcImNvbXBpbGVyT3B0aW9uc1wiLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgcmV0dXJuIGNvbXBpbGVyT3B0aW9ucztcbiAgICAgIH0sXG4gICAgICBzZXQoKSB7XG4gICAgICAgIHdhcm4obXNnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoaXNTdHJpbmcoY29udGFpbmVyKSkge1xuICAgIGNvbnN0IHJlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhcmVzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgRmFpbGVkIHRvIG1vdW50IGFwcDogbW91bnQgdGFyZ2V0IHNlbGVjdG9yIFwiJHtjb250YWluZXJ9XCIgcmV0dXJuZWQgbnVsbC5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdpbmRvdy5TaGFkb3dSb290ICYmIGNvbnRhaW5lciBpbnN0YW5jZW9mIHdpbmRvdy5TaGFkb3dSb290ICYmIGNvbnRhaW5lci5tb2RlID09PSBcImNsb3NlZFwiKSB7XG4gICAgd2FybihcbiAgICAgIGBtb3VudGluZyBvbiBhIFNoYWRvd1Jvb3Qgd2l0aCBcXGB7bW9kZTogXCJjbG9zZWRcIn1cXGAgbWF5IGxlYWQgdG8gdW5wcmVkaWN0YWJsZSBidWdzYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNvbnRhaW5lcjtcbn1cbmxldCBzc3JEaXJlY3RpdmVJbml0aWFsaXplZCA9IGZhbHNlO1xuY29uc3QgaW5pdERpcmVjdGl2ZXNGb3JTU1IgPSAoKSA9PiB7XG4gIGlmICghc3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQpIHtcbiAgICBzc3JEaXJlY3RpdmVJbml0aWFsaXplZCA9IHRydWU7XG4gICAgaW5pdFZNb2RlbEZvclNTUigpO1xuICAgIGluaXRWU2hvd0ZvclNTUigpO1xuICB9XG59IDtcblxuZXhwb3J0IHsgVHJhbnNpdGlvbiwgVHJhbnNpdGlvbkdyb3VwLCBWdWVFbGVtZW50LCBjcmVhdGVBcHAsIGNyZWF0ZVNTUkFwcCwgZGVmaW5lQ3VzdG9tRWxlbWVudCwgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudCwgaHlkcmF0ZSwgaW5pdERpcmVjdGl2ZXNGb3JTU1IsIHJlbmRlciwgdXNlQ3NzTW9kdWxlLCB1c2VDc3NWYXJzLCB2TW9kZWxDaGVja2JveCwgdk1vZGVsRHluYW1pYywgdk1vZGVsUmFkaW8sIHZNb2RlbFNlbGVjdCwgdk1vZGVsVGV4dCwgdlNob3csIHdpdGhLZXlzLCB3aXRoTW9kaWZpZXJzIH07XG4iLCJmdW5jdGlvbiBtYWtlTWFwKHN0ciwgZXhwZWN0c0xvd2VyQ2FzZSkge1xuICBjb25zdCBtYXAgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3QgbGlzdCA9IHN0ci5zcGxpdChcIixcIik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2UgPyAodmFsKSA9PiAhIW1hcFt2YWwudG9Mb3dlckNhc2UoKV0gOiAodmFsKSA9PiAhIW1hcFt2YWxdO1xufVxuXG5jb25zdCBFTVBUWV9PQkogPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gT2JqZWN0LmZyZWV6ZSh7fSkgOiB7fTtcbmNvbnN0IEVNUFRZX0FSUiA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBPYmplY3QuZnJlZXplKFtdKSA6IFtdO1xuY29uc3QgTk9PUCA9ICgpID0+IHtcbn07XG5jb25zdCBOTyA9ICgpID0+IGZhbHNlO1xuY29uc3Qgb25SRSA9IC9eb25bXmEtel0vO1xuY29uc3QgaXNPbiA9IChrZXkpID0+IG9uUkUudGVzdChrZXkpO1xuY29uc3QgaXNNb2RlbExpc3RlbmVyID0gKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoXCJvblVwZGF0ZTpcIik7XG5jb25zdCBleHRlbmQgPSBPYmplY3QuYXNzaWduO1xuY29uc3QgcmVtb3ZlID0gKGFyciwgZWwpID0+IHtcbiAgY29uc3QgaSA9IGFyci5pbmRleE9mKGVsKTtcbiAgaWYgKGkgPiAtMSkge1xuICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gIH1cbn07XG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5jb25zdCBoYXNPd24gPSAodmFsLCBrZXkpID0+IGhhc093blByb3BlcnR5LmNhbGwodmFsLCBrZXkpO1xuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5jb25zdCBpc01hcCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgTWFwXVwiO1xuY29uc3QgaXNTZXQgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IFNldF1cIjtcbmNvbnN0IGlzRGF0ZSA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgRGF0ZV1cIjtcbmNvbnN0IGlzUmVnRXhwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBSZWdFeHBdXCI7XG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiO1xuY29uc3QgaXNTeW1ib2wgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN5bWJvbFwiO1xuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIjtcbmNvbnN0IGlzUHJvbWlzZSA9ICh2YWwpID0+IHtcbiAgcmV0dXJuIChpc09iamVjdCh2YWwpIHx8IGlzRnVuY3Rpb24odmFsKSkgJiYgaXNGdW5jdGlvbih2YWwudGhlbikgJiYgaXNGdW5jdGlvbih2YWwuY2F0Y2gpO1xufTtcbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHRvVHlwZVN0cmluZyA9ICh2YWx1ZSkgPT4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5jb25zdCB0b1Jhd1R5cGUgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIHRvVHlwZVN0cmluZyh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xufTtcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbmNvbnN0IGlzSW50ZWdlcktleSA9IChrZXkpID0+IGlzU3RyaW5nKGtleSkgJiYga2V5ICE9PSBcIk5hTlwiICYmIGtleVswXSAhPT0gXCItXCIgJiYgXCJcIiArIHBhcnNlSW50KGtleSwgMTApID09PSBrZXk7XG5jb25zdCBpc1Jlc2VydmVkUHJvcCA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICAvLyB0aGUgbGVhZGluZyBjb21tYSBpcyBpbnRlbnRpb25hbCBzbyBlbXB0eSBzdHJpbmcgXCJcIiBpcyBhbHNvIGluY2x1ZGVkXG4gIFwiLGtleSxyZWYscmVmX2ZvcixyZWZfa2V5LG9uVm5vZGVCZWZvcmVNb3VudCxvblZub2RlTW91bnRlZCxvblZub2RlQmVmb3JlVXBkYXRlLG9uVm5vZGVVcGRhdGVkLG9uVm5vZGVCZWZvcmVVbm1vdW50LG9uVm5vZGVVbm1vdW50ZWRcIlxuKTtcbmNvbnN0IGlzQnVpbHRJbkRpcmVjdGl2ZSA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBcImJpbmQsY2xvYWssZWxzZS1pZixlbHNlLGZvcixodG1sLGlmLG1vZGVsLG9uLG9uY2UscHJlLHNob3csc2xvdCx0ZXh0LG1lbW9cIlxuKTtcbmNvbnN0IGNhY2hlU3RyaW5nRnVuY3Rpb24gPSAoZm4pID0+IHtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChzdHIpID0+IHtcbiAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcbiAgfTtcbn07XG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuY29uc3QgY2FtZWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiBjID8gYy50b1VwcGVyQ2FzZSgpIDogXCJcIik7XG59KTtcbmNvbnN0IGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbmNvbnN0IGh5cGhlbmF0ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oXG4gIChzdHIpID0+IHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpXG4pO1xuY29uc3QgY2FwaXRhbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufSk7XG5jb25zdCB0b0hhbmRsZXJLZXkgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcbiAgY29uc3QgcyA9IHN0ciA/IGBvbiR7Y2FwaXRhbGl6ZShzdHIpfWAgOiBgYDtcbiAgcmV0dXJuIHM7XG59KTtcbmNvbnN0IGhhc0NoYW5nZWQgPSAodmFsdWUsIG9sZFZhbHVlKSA9PiAhT2JqZWN0LmlzKHZhbHVlLCBvbGRWYWx1ZSk7XG5jb25zdCBpbnZva2VBcnJheUZucyA9IChmbnMsIGFyZykgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIGZuc1tpXShhcmcpO1xuICB9XG59O1xuY29uc3QgZGVmID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWVcbiAgfSk7XG59O1xuY29uc3QgbG9vc2VUb051bWJlciA9ICh2YWwpID0+IHtcbiAgY29uc3QgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbn07XG5jb25zdCB0b051bWJlciA9ICh2YWwpID0+IHtcbiAgY29uc3QgbiA9IGlzU3RyaW5nKHZhbCkgPyBOdW1iZXIodmFsKSA6IE5hTjtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbn07XG5sZXQgX2dsb2JhbFRoaXM7XG5jb25zdCBnZXRHbG9iYWxUaGlzID0gKCkgPT4ge1xuICByZXR1cm4gX2dsb2JhbFRoaXMgfHwgKF9nbG9iYWxUaGlzID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSk7XG59O1xuY29uc3QgaWRlbnRSRSA9IC9eW18kYS16QS1aXFx4QTAtXFx1RkZGRl1bXyRhLXpBLVowLTlcXHhBMC1cXHVGRkZGXSokLztcbmZ1bmN0aW9uIGdlblByb3BzQWNjZXNzRXhwKG5hbWUpIHtcbiAgcmV0dXJuIGlkZW50UkUudGVzdChuYW1lKSA/IGBfX3Byb3BzLiR7bmFtZX1gIDogYF9fcHJvcHNbJHtKU09OLnN0cmluZ2lmeShuYW1lKX1dYDtcbn1cblxuY29uc3QgUGF0Y2hGbGFnTmFtZXMgPSB7XG4gIFsxXTogYFRFWFRgLFxuICBbMl06IGBDTEFTU2AsXG4gIFs0XTogYFNUWUxFYCxcbiAgWzhdOiBgUFJPUFNgLFxuICBbMTZdOiBgRlVMTF9QUk9QU2AsXG4gIFszMl06IGBIWURSQVRFX0VWRU5UU2AsXG4gIFs2NF06IGBTVEFCTEVfRlJBR01FTlRgLFxuICBbMTI4XTogYEtFWUVEX0ZSQUdNRU5UYCxcbiAgWzI1Nl06IGBVTktFWUVEX0ZSQUdNRU5UYCxcbiAgWzUxMl06IGBORUVEX1BBVENIYCxcbiAgWzEwMjRdOiBgRFlOQU1JQ19TTE9UU2AsXG4gIFsyMDQ4XTogYERFVl9ST09UX0ZSQUdNRU5UYCxcbiAgWy0xXTogYEhPSVNURURgLFxuICBbLTJdOiBgQkFJTGBcbn07XG5cbmNvbnN0IHNsb3RGbGFnc1RleHQgPSB7XG4gIFsxXTogXCJTVEFCTEVcIixcbiAgWzJdOiBcIkRZTkFNSUNcIixcbiAgWzNdOiBcIkZPUldBUkRFRFwiXG59O1xuXG5jb25zdCBHTE9CQUxTX0FMTE9XRUQgPSBcIkluZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4scGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLEJpZ0ludCxjb25zb2xlXCI7XG5jb25zdCBpc0dsb2JhbGx5QWxsb3dlZCA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKEdMT0JBTFNfQUxMT1dFRCk7XG5jb25zdCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQgPSBpc0dsb2JhbGx5QWxsb3dlZDtcblxuY29uc3QgcmFuZ2UgPSAyO1xuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUoc291cmNlLCBzdGFydCA9IDAsIGVuZCA9IHNvdXJjZS5sZW5ndGgpIHtcbiAgbGV0IGxpbmVzID0gc291cmNlLnNwbGl0KC8oXFxyP1xcbikvKTtcbiAgY29uc3QgbmV3bGluZVNlcXVlbmNlcyA9IGxpbmVzLmZpbHRlcigoXywgaWR4KSA9PiBpZHggJSAyID09PSAxKTtcbiAgbGluZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMCk7XG4gIGxldCBjb3VudCA9IDA7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgKG5ld2xpbmVTZXF1ZW5jZXNbaV0gJiYgbmV3bGluZVNlcXVlbmNlc1tpXS5sZW5ndGggfHwgMCk7XG4gICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XG4gICAgICBmb3IgKGxldCBqID0gaSAtIHJhbmdlOyBqIDw9IGkgKyByYW5nZSB8fCBlbmQgPiBjb3VudDsgaisrKSB7XG4gICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbGluZSA9IGogKyAxO1xuICAgICAgICByZXMucHVzaChcbiAgICAgICAgICBgJHtsaW5lfSR7XCIgXCIucmVwZWF0KE1hdGgubWF4KDMgLSBTdHJpbmcobGluZSkubGVuZ3RoLCAwKSl9fCAgJHtsaW5lc1tqXX1gXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG5ld0xpbmVTZXFMZW5ndGggPSBuZXdsaW5lU2VxdWVuY2VzW2pdICYmIG5ld2xpbmVTZXF1ZW5jZXNbal0ubGVuZ3RoIHx8IDA7XG4gICAgICAgIGlmIChqID09PSBpKSB7XG4gICAgICAgICAgY29uc3QgcGFkID0gc3RhcnQgLSAoY291bnQgLSAobGluZUxlbmd0aCArIG5ld0xpbmVTZXFMZW5ndGgpKTtcbiAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyBcIiBcIi5yZXBlYXQocGFkKSArIFwiXlwiLnJlcGVhdChsZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChqID4gaSkge1xuICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpLCAxKTtcbiAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgXCJeXCIucmVwZWF0KGxlbmd0aCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXMuam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUodmFsdWUpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW2ldO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGlzU3RyaW5nKGl0ZW0pID8gcGFyc2VTdHJpbmdTdHlsZShpdGVtKSA6IG5vcm1hbGl6ZVN0eWxlKGl0ZW0pO1xuICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbm9ybWFsaXplZCkge1xuICAgICAgICAgIHJlc1trZXldID0gbm9ybWFsaXplZFtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpIHx8IGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuY29uc3QgbGlzdERlbGltaXRlclJFID0gLzsoPyFbXihdKlxcKSkvZztcbmNvbnN0IHByb3BlcnR5RGVsaW1pdGVyUkUgPSAvOihbXl0rKS87XG5jb25zdCBzdHlsZUNvbW1lbnRSRSA9IC9cXC9cXCpbXl0qP1xcKlxcLy9nO1xuZnVuY3Rpb24gcGFyc2VTdHJpbmdTdHlsZShjc3NUZXh0KSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBjc3NUZXh0LnJlcGxhY2Uoc3R5bGVDb21tZW50UkUsIFwiXCIpLnNwbGl0KGxpc3REZWxpbWl0ZXJSRSkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBjb25zdCB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyUkUpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJldFt0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlTdHlsZShzdHlsZXMpIHtcbiAgbGV0IHJldCA9IFwiXCI7XG4gIGlmICghc3R5bGVzIHx8IGlzU3RyaW5nKHN0eWxlcykpIHtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIHN0eWxlcykge1xuICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzW2tleV07XG4gICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGtleS5zdGFydHNXaXRoKGAtLWApID8ga2V5IDogaHlwaGVuYXRlKGtleSk7XG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldCArPSBgJHtub3JtYWxpemVkS2V5fToke3ZhbHVlfTtgO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3ModmFsdWUpIHtcbiAgbGV0IHJlcyA9IFwiXCI7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXMgPSB2YWx1ZTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVDbGFzcyh2YWx1ZVtpXSk7XG4gICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICByZXMgKz0gbm9ybWFsaXplZCArIFwiIFwiO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVtuYW1lXSkge1xuICAgICAgICByZXMgKz0gbmFtZSArIFwiIFwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzLnRyaW0oKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzKHByb3BzKSB7XG4gIGlmICghcHJvcHMpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCB7IGNsYXNzOiBrbGFzcywgc3R5bGUgfSA9IHByb3BzO1xuICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xuICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xuICB9XG4gIGlmIChzdHlsZSkge1xuICAgIHByb3BzLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xuICB9XG4gIHJldHVybiBwcm9wcztcbn1cblxuY29uc3QgSFRNTF9UQUdTID0gXCJodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSxhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoZ3JvdXAsaDEsaDIsaDMsaDQsaDUsaDYsbmF2LHNlY3Rpb24sZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ1YnkscyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbixvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLGRldGFpbHMsZGlhbG9nLG1lbnUsc3VtbWFyeSx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdFwiO1xuY29uc3QgU1ZHX1RBR1MgPSBcInN2ZyxhbmltYXRlLGFuaW1hdGVNb3Rpb24sYW5pbWF0ZVRyYW5zZm9ybSxjaXJjbGUsY2xpcFBhdGgsY29sb3ItcHJvZmlsZSxkZWZzLGRlc2MsZGlzY2FyZCxlbGxpcHNlLGZlQmxlbmQsZmVDb2xvck1hdHJpeCxmZUNvbXBvbmVudFRyYW5zZmVyLGZlQ29tcG9zaXRlLGZlQ29udm9sdmVNYXRyaXgsZmVEaWZmdXNlTGlnaHRpbmcsZmVEaXNwbGFjZW1lbnRNYXAsZmVEaXN0YW50TGlnaHQsZmVEcm9wU2hhZG93LGZlRmxvb2QsZmVGdW5jQSxmZUZ1bmNCLGZlRnVuY0csZmVGdW5jUixmZUdhdXNzaWFuQmx1cixmZUltYWdlLGZlTWVyZ2UsZmVNZXJnZU5vZGUsZmVNb3JwaG9sb2d5LGZlT2Zmc2V0LGZlUG9pbnRMaWdodCxmZVNwZWN1bGFyTGlnaHRpbmcsZmVTcG90TGlnaHQsZmVUaWxlLGZlVHVyYnVsZW5jZSxmaWx0ZXIsZm9yZWlnbk9iamVjdCxnLGhhdGNoLGhhdGNocGF0aCxpbWFnZSxsaW5lLGxpbmVhckdyYWRpZW50LG1hcmtlcixtYXNrLG1lc2gsbWVzaGdyYWRpZW50LG1lc2hwYXRjaCxtZXNocm93LG1ldGFkYXRhLG1wYXRoLHBhdGgscGF0dGVybixwb2x5Z29uLHBvbHlsaW5lLHJhZGlhbEdyYWRpZW50LHJlY3Qsc2V0LHNvbGlkY29sb3Isc3RvcCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dFBhdGgsdGl0bGUsdHNwYW4sdW5rbm93bix1c2Usdmlld1wiO1xuY29uc3QgVk9JRF9UQUdTID0gXCJhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGhyLGltZyxpbnB1dCxsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdiclwiO1xuY29uc3QgaXNIVE1MVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoSFRNTF9UQUdTKTtcbmNvbnN0IGlzU1ZHVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoU1ZHX1RBR1MpO1xuY29uc3QgaXNWb2lkVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoVk9JRF9UQUdTKTtcblxuY29uc3Qgc3BlY2lhbEJvb2xlYW5BdHRycyA9IGBpdGVtc2NvcGUsYWxsb3dmdWxsc2NyZWVuLGZvcm1ub3ZhbGlkYXRlLGlzbWFwLG5vbW9kdWxlLG5vdmFsaWRhdGUscmVhZG9ubHlgO1xuY29uc3QgaXNTcGVjaWFsQm9vbGVhbkF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzKTtcbmNvbnN0IGlzQm9vbGVhbkF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgc3BlY2lhbEJvb2xlYW5BdHRycyArIGAsYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNvbnRyb2xzLGRlZmF1bHQsZGVmZXIsZGlzYWJsZWQsaGlkZGVuLGluZXJ0LGxvb3Asb3BlbixyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3MsY2hlY2tlZCxtdXRlZCxtdWx0aXBsZSxzZWxlY3RlZGBcbik7XG5mdW5jdGlvbiBpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgfHwgdmFsdWUgPT09IFwiXCI7XG59XG5jb25zdCB1bnNhZmVBdHRyQ2hhclJFID0gL1s+Lz1cIidcXHUwMDA5XFx1MDAwYVxcdTAwMGNcXHUwMDIwXS87XG5jb25zdCBhdHRyVmFsaWRhdGlvbkNhY2hlID0ge307XG5mdW5jdGlvbiBpc1NTUlNhZmVBdHRyTmFtZShuYW1lKSB7XG4gIGlmIChhdHRyVmFsaWRhdGlvbkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV07XG4gIH1cbiAgY29uc3QgaXNVbnNhZmUgPSB1bnNhZmVBdHRyQ2hhclJFLnRlc3QobmFtZSk7XG4gIGlmIChpc1Vuc2FmZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoYHVuc2FmZSBhdHRyaWJ1dGUgbmFtZTogJHtuYW1lfWApO1xuICB9XG4gIHJldHVybiBhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdID0gIWlzVW5zYWZlO1xufVxuY29uc3QgcHJvcHNUb0F0dHJNYXAgPSB7XG4gIGFjY2VwdENoYXJzZXQ6IFwiYWNjZXB0LWNoYXJzZXRcIixcbiAgY2xhc3NOYW1lOiBcImNsYXNzXCIsXG4gIGh0bWxGb3I6IFwiZm9yXCIsXG4gIGh0dHBFcXVpdjogXCJodHRwLWVxdWl2XCJcbn07XG5jb25zdCBpc0tub3duSHRtbEF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgYGFjY2VwdCxhY2NlcHQtY2hhcnNldCxhY2Nlc3NrZXksYWN0aW9uLGFsaWduLGFsbG93LGFsdCxhc3luYyxhdXRvY2FwaXRhbGl6ZSxhdXRvY29tcGxldGUsYXV0b2ZvY3VzLGF1dG9wbGF5LGJhY2tncm91bmQsYmdjb2xvcixib3JkZXIsYnVmZmVyZWQsY2FwdHVyZSxjaGFsbGVuZ2UsY2hhcnNldCxjaGVja2VkLGNpdGUsY2xhc3MsY29kZSxjb2RlYmFzZSxjb2xvcixjb2xzLGNvbHNwYW4sY29udGVudCxjb250ZW50ZWRpdGFibGUsY29udGV4dG1lbnUsY29udHJvbHMsY29vcmRzLGNyb3Nzb3JpZ2luLGNzcCxkYXRhLGRhdGV0aW1lLGRlY29kaW5nLGRlZmF1bHQsZGVmZXIsZGlyLGRpcm5hbWUsZGlzYWJsZWQsZG93bmxvYWQsZHJhZ2dhYmxlLGRyb3B6b25lLGVuY3R5cGUsZW50ZXJrZXloaW50LGZvcixmb3JtLGZvcm1hY3Rpb24sZm9ybWVuY3R5cGUsZm9ybW1ldGhvZCxmb3Jtbm92YWxpZGF0ZSxmb3JtdGFyZ2V0LGhlYWRlcnMsaGVpZ2h0LGhpZGRlbixoaWdoLGhyZWYsaHJlZmxhbmcsaHR0cC1lcXVpdixpY29uLGlkLGltcG9ydGFuY2UsaW5lcnQsaW50ZWdyaXR5LGlzbWFwLGl0ZW1wcm9wLGtleXR5cGUsa2luZCxsYWJlbCxsYW5nLGxhbmd1YWdlLGxvYWRpbmcsbGlzdCxsb29wLGxvdyxtYW5pZmVzdCxtYXgsbWF4bGVuZ3RoLG1pbmxlbmd0aCxtZWRpYSxtaW4sbXVsdGlwbGUsbXV0ZWQsbmFtZSxub3ZhbGlkYXRlLG9wZW4sb3B0aW11bSxwYXR0ZXJuLHBpbmcscGxhY2Vob2xkZXIscG9zdGVyLHByZWxvYWQscmFkaW9ncm91cCxyZWFkb25seSxyZWZlcnJlcnBvbGljeSxyZWwscmVxdWlyZWQscmV2ZXJzZWQscm93cyxyb3dzcGFuLHNhbmRib3gsc2NvcGUsc2NvcGVkLHNlbGVjdGVkLHNoYXBlLHNpemUsc2l6ZXMsc2xvdCxzcGFuLHNwZWxsY2hlY2ssc3JjLHNyY2RvYyxzcmNsYW5nLHNyY3NldCxzdGFydCxzdGVwLHN0eWxlLHN1bW1hcnksdGFiaW5kZXgsdGFyZ2V0LHRpdGxlLHRyYW5zbGF0ZSx0eXBlLHVzZW1hcCx2YWx1ZSx3aWR0aCx3cmFwYFxuKTtcbmNvbnN0IGlzS25vd25TdmdBdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIGB4bWxucyxhY2NlbnQtaGVpZ2h0LGFjY3VtdWxhdGUsYWRkaXRpdmUsYWxpZ25tZW50LWJhc2VsaW5lLGFscGhhYmV0aWMsYW1wbGl0dWRlLGFyYWJpYy1mb3JtLGFzY2VudCxhdHRyaWJ1dGVOYW1lLGF0dHJpYnV0ZVR5cGUsYXppbXV0aCxiYXNlRnJlcXVlbmN5LGJhc2VsaW5lLXNoaWZ0LGJhc2VQcm9maWxlLGJib3gsYmVnaW4sYmlhcyxieSxjYWxjTW9kZSxjYXAtaGVpZ2h0LGNsYXNzLGNsaXAsY2xpcFBhdGhVbml0cyxjbGlwLXBhdGgsY2xpcC1ydWxlLGNvbG9yLGNvbG9yLWludGVycG9sYXRpb24sY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzLGNvbG9yLXByb2ZpbGUsY29sb3ItcmVuZGVyaW5nLGNvbnRlbnRTY3JpcHRUeXBlLGNvbnRlbnRTdHlsZVR5cGUsY3Jvc3NvcmlnaW4sY3Vyc29yLGN4LGN5LGQsZGVjZWxlcmF0ZSxkZXNjZW50LGRpZmZ1c2VDb25zdGFudCxkaXJlY3Rpb24sZGlzcGxheSxkaXZpc29yLGRvbWluYW50LWJhc2VsaW5lLGR1cixkeCxkeSxlZGdlTW9kZSxlbGV2YXRpb24sZW5hYmxlLWJhY2tncm91bmQsZW5kLGV4cG9uZW50LGZpbGwsZmlsbC1vcGFjaXR5LGZpbGwtcnVsZSxmaWx0ZXIsZmlsdGVyUmVzLGZpbHRlclVuaXRzLGZsb29kLWNvbG9yLGZsb29kLW9wYWNpdHksZm9udC1mYW1pbHksZm9udC1zaXplLGZvbnQtc2l6ZS1hZGp1c3QsZm9udC1zdHJldGNoLGZvbnQtc3R5bGUsZm9udC12YXJpYW50LGZvbnQtd2VpZ2h0LGZvcm1hdCxmcm9tLGZyLGZ4LGZ5LGcxLGcyLGdseXBoLW5hbWUsZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCxnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCxnbHlwaFJlZixncmFkaWVudFRyYW5zZm9ybSxncmFkaWVudFVuaXRzLGhhbmdpbmcsaGVpZ2h0LGhyZWYsaHJlZmxhbmcsaG9yaXotYWR2LXgsaG9yaXotb3JpZ2luLXgsaWQsaWRlb2dyYXBoaWMsaW1hZ2UtcmVuZGVyaW5nLGluLGluMixpbnRlcmNlcHQsayxrMSxrMixrMyxrNCxrZXJuZWxNYXRyaXgsa2VybmVsVW5pdExlbmd0aCxrZXJuaW5nLGtleVBvaW50cyxrZXlTcGxpbmVzLGtleVRpbWVzLGxhbmcsbGVuZ3RoQWRqdXN0LGxldHRlci1zcGFjaW5nLGxpZ2h0aW5nLWNvbG9yLGxpbWl0aW5nQ29uZUFuZ2xlLGxvY2FsLG1hcmtlci1lbmQsbWFya2VyLW1pZCxtYXJrZXItc3RhcnQsbWFya2VySGVpZ2h0LG1hcmtlclVuaXRzLG1hcmtlcldpZHRoLG1hc2ssbWFza0NvbnRlbnRVbml0cyxtYXNrVW5pdHMsbWF0aGVtYXRpY2FsLG1heCxtZWRpYSxtZXRob2QsbWluLG1vZGUsbmFtZSxudW1PY3RhdmVzLG9mZnNldCxvcGFjaXR5LG9wZXJhdG9yLG9yZGVyLG9yaWVudCxvcmllbnRhdGlvbixvcmlnaW4sb3ZlcmZsb3csb3ZlcmxpbmUtcG9zaXRpb24sb3ZlcmxpbmUtdGhpY2tuZXNzLHBhbm9zZS0xLHBhaW50LW9yZGVyLHBhdGgscGF0aExlbmd0aCxwYXR0ZXJuQ29udGVudFVuaXRzLHBhdHRlcm5UcmFuc2Zvcm0scGF0dGVyblVuaXRzLHBpbmcscG9pbnRlci1ldmVudHMscG9pbnRzLHBvaW50c0F0WCxwb2ludHNBdFkscG9pbnRzQXRaLHByZXNlcnZlQWxwaGEscHJlc2VydmVBc3BlY3RSYXRpbyxwcmltaXRpdmVVbml0cyxyLHJhZGl1cyxyZWZlcnJlclBvbGljeSxyZWZYLHJlZlkscmVsLHJlbmRlcmluZy1pbnRlbnQscmVwZWF0Q291bnQscmVwZWF0RHVyLHJlcXVpcmVkRXh0ZW5zaW9ucyxyZXF1aXJlZEZlYXR1cmVzLHJlc3RhcnQscmVzdWx0LHJvdGF0ZSxyeCxyeSxzY2FsZSxzZWVkLHNoYXBlLXJlbmRlcmluZyxzbG9wZSxzcGFjaW5nLHNwZWN1bGFyQ29uc3RhbnQsc3BlY3VsYXJFeHBvbmVudCxzcGVlZCxzcHJlYWRNZXRob2Qsc3RhcnRPZmZzZXQsc3RkRGV2aWF0aW9uLHN0ZW1oLHN0ZW12LHN0aXRjaFRpbGVzLHN0b3AtY29sb3Isc3RvcC1vcGFjaXR5LHN0cmlrZXRocm91Z2gtcG9zaXRpb24sc3RyaWtldGhyb3VnaC10aGlja25lc3Msc3RyaW5nLHN0cm9rZSxzdHJva2UtZGFzaGFycmF5LHN0cm9rZS1kYXNob2Zmc2V0LHN0cm9rZS1saW5lY2FwLHN0cm9rZS1saW5lam9pbixzdHJva2UtbWl0ZXJsaW1pdCxzdHJva2Utb3BhY2l0eSxzdHJva2Utd2lkdGgsc3R5bGUsc3VyZmFjZVNjYWxlLHN5c3RlbUxhbmd1YWdlLHRhYmluZGV4LHRhYmxlVmFsdWVzLHRhcmdldCx0YXJnZXRYLHRhcmdldFksdGV4dC1hbmNob3IsdGV4dC1kZWNvcmF0aW9uLHRleHQtcmVuZGVyaW5nLHRleHRMZW5ndGgsdG8sdHJhbnNmb3JtLHRyYW5zZm9ybS1vcmlnaW4sdHlwZSx1MSx1Mix1bmRlcmxpbmUtcG9zaXRpb24sdW5kZXJsaW5lLXRoaWNrbmVzcyx1bmljb2RlLHVuaWNvZGUtYmlkaSx1bmljb2RlLXJhbmdlLHVuaXRzLXBlci1lbSx2LWFscGhhYmV0aWMsdi1oYW5naW5nLHYtaWRlb2dyYXBoaWMsdi1tYXRoZW1hdGljYWwsdmFsdWVzLHZlY3Rvci1lZmZlY3QsdmVyc2lvbix2ZXJ0LWFkdi15LHZlcnQtb3JpZ2luLXgsdmVydC1vcmlnaW4teSx2aWV3Qm94LHZpZXdUYXJnZXQsdmlzaWJpbGl0eSx3aWR0aCx3aWR0aHMsd29yZC1zcGFjaW5nLHdyaXRpbmctbW9kZSx4LHgtaGVpZ2h0LHgxLHgyLHhDaGFubmVsU2VsZWN0b3IseGxpbms6YWN0dWF0ZSx4bGluazphcmNyb2xlLHhsaW5rOmhyZWYseGxpbms6cm9sZSx4bGluazpzaG93LHhsaW5rOnRpdGxlLHhsaW5rOnR5cGUseG1sOmJhc2UseG1sOmxhbmcseG1sOnNwYWNlLHkseTEseTIseUNoYW5uZWxTZWxlY3Rvcix6LHpvb21BbmRQYW5gXG4pO1xuXG5jb25zdCBlc2NhcGVSRSA9IC9bXCInJjw+XS87XG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICBjb25zdCBzdHIgPSBcIlwiICsgc3RyaW5nO1xuICBjb25zdCBtYXRjaCA9IGVzY2FwZVJFLmV4ZWMoc3RyKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgbGV0IGh0bWwgPSBcIlwiO1xuICBsZXQgZXNjYXBlZDtcbiAgbGV0IGluZGV4O1xuICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgZXNjYXBlZCA9IFwiJnF1b3Q7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgZXNjYXBlZCA9IFwiJmFtcDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM5OlxuICAgICAgICBlc2NhcGVkID0gXCImIzM5O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZsdDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYyOlxuICAgICAgICBlc2NhcGVkID0gXCImZ3Q7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChsYXN0SW5kZXggIT09IGluZGV4KSB7XG4gICAgICBodG1sICs9IHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgIGh0bWwgKz0gZXNjYXBlZDtcbiAgfVxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xufVxuY29uc3QgY29tbWVudFN0cmlwUkUgPSAvXi0/Pnw8IS0tfC0tPnwtLSE+fDwhLSQvZztcbmZ1bmN0aW9uIGVzY2FwZUh0bWxDb21tZW50KHNyYykge1xuICByZXR1cm4gc3JjLnJlcGxhY2UoY29tbWVudFN0cmlwUkUsIFwiXCIpO1xufVxuXG5mdW5jdGlvbiBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgbGV0IGVxdWFsID0gdHJ1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGVxdWFsICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgZXF1YWwgPSBsb29zZUVxdWFsKGFbaV0sIGJbaV0pO1xuICB9XG4gIHJldHVybiBlcXVhbDtcbn1cbmZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYilcbiAgICByZXR1cm4gdHJ1ZTtcbiAgbGV0IGFWYWxpZFR5cGUgPSBpc0RhdGUoYSk7XG4gIGxldCBiVmFsaWRUeXBlID0gaXNEYXRlKGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKSA6IGZhbHNlO1xuICB9XG4gIGFWYWxpZFR5cGUgPSBpc1N5bWJvbChhKTtcbiAgYlZhbGlkVHlwZSA9IGlzU3ltYm9sKGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cbiAgYVZhbGlkVHlwZSA9IGlzQXJyYXkoYSk7XG4gIGJWYWxpZFR5cGUgPSBpc0FycmF5KGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSA6IGZhbHNlO1xuICB9XG4gIGFWYWxpZFR5cGUgPSBpc09iamVjdChhKTtcbiAgYlZhbGlkVHlwZSA9IGlzT2JqZWN0KGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgaWYgKCFhVmFsaWRUeXBlIHx8ICFiVmFsaWRUeXBlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhhKS5sZW5ndGg7XG4gICAgY29uc3QgYktleXNDb3VudCA9IE9iamVjdC5rZXlzKGIpLmxlbmd0aDtcbiAgICBpZiAoYUtleXNDb3VudCAhPT0gYktleXNDb3VudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XG4gICAgICBjb25zdCBhSGFzS2V5ID0gYS5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgY29uc3QgYkhhc0tleSA9IGIuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgIGlmIChhSGFzS2V5ICYmICFiSGFzS2V5IHx8ICFhSGFzS2V5ICYmIGJIYXNLZXkgfHwgIWxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xufVxuZnVuY3Rpb24gbG9vc2VJbmRleE9mKGFyciwgdmFsKSB7XG4gIHJldHVybiBhcnIuZmluZEluZGV4KChpdGVtKSA9PiBsb29zZUVxdWFsKGl0ZW0sIHZhbCkpO1xufVxuXG5jb25zdCB0b0Rpc3BsYXlTdHJpbmcgPSAodmFsKSA9PiB7XG4gIHJldHVybiBpc1N0cmluZyh2YWwpID8gdmFsIDogdmFsID09IG51bGwgPyBcIlwiIDogaXNBcnJheSh2YWwpIHx8IGlzT2JqZWN0KHZhbCkgJiYgKHZhbC50b1N0cmluZyA9PT0gb2JqZWN0VG9TdHJpbmcgfHwgIWlzRnVuY3Rpb24odmFsLnRvU3RyaW5nKSkgPyBKU09OLnN0cmluZ2lmeSh2YWwsIHJlcGxhY2VyLCAyKSA6IFN0cmluZyh2YWwpO1xufTtcbmNvbnN0IHJlcGxhY2VyID0gKF9rZXksIHZhbCkgPT4ge1xuICBpZiAodmFsICYmIHZhbC5fX3ZfaXNSZWYpIHtcbiAgICByZXR1cm4gcmVwbGFjZXIoX2tleSwgdmFsLnZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc01hcCh2YWwpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtgTWFwKCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLmVudHJpZXMoKV0ucmVkdWNlKChlbnRyaWVzLCBba2V5LCB2YWwyXSkgPT4ge1xuICAgICAgICBlbnRyaWVzW2Ake2tleX0gPT5gXSA9IHZhbDI7XG4gICAgICAgIHJldHVybiBlbnRyaWVzO1xuICAgICAgfSwge30pXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpc1NldCh2YWwpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtgU2V0KCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLnZhbHVlcygpXVxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSAmJiAhaXNBcnJheSh2YWwpICYmICFpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICByZXR1cm4gU3RyaW5nKHZhbCk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbmV4cG9ydCB7IEVNUFRZX0FSUiwgRU1QVFlfT0JKLCBOTywgTk9PUCwgUGF0Y2hGbGFnTmFtZXMsIGNhbWVsaXplLCBjYXBpdGFsaXplLCBkZWYsIGVzY2FwZUh0bWwsIGVzY2FwZUh0bWxDb21tZW50LCBleHRlbmQsIGdlblByb3BzQWNjZXNzRXhwLCBnZW5lcmF0ZUNvZGVGcmFtZSwgZ2V0R2xvYmFsVGhpcywgaGFzQ2hhbmdlZCwgaGFzT3duLCBoeXBoZW5hdGUsIGluY2x1ZGVCb29sZWFuQXR0ciwgaW52b2tlQXJyYXlGbnMsIGlzQXJyYXksIGlzQm9vbGVhbkF0dHIsIGlzQnVpbHRJbkRpcmVjdGl2ZSwgaXNEYXRlLCBpc0Z1bmN0aW9uLCBpc0dsb2JhbGx5QWxsb3dlZCwgaXNHbG9iYWxseVdoaXRlbGlzdGVkLCBpc0hUTUxUYWcsIGlzSW50ZWdlcktleSwgaXNLbm93bkh0bWxBdHRyLCBpc0tub3duU3ZnQXR0ciwgaXNNYXAsIGlzTW9kZWxMaXN0ZW5lciwgaXNPYmplY3QsIGlzT24sIGlzUGxhaW5PYmplY3QsIGlzUHJvbWlzZSwgaXNSZWdFeHAsIGlzUmVzZXJ2ZWRQcm9wLCBpc1NTUlNhZmVBdHRyTmFtZSwgaXNTVkdUYWcsIGlzU2V0LCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaXNTdHJpbmcsIGlzU3ltYm9sLCBpc1ZvaWRUYWcsIGxvb3NlRXF1YWwsIGxvb3NlSW5kZXhPZiwgbG9vc2VUb051bWJlciwgbWFrZU1hcCwgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVByb3BzLCBub3JtYWxpemVTdHlsZSwgb2JqZWN0VG9TdHJpbmcsIHBhcnNlU3RyaW5nU3R5bGUsIHByb3BzVG9BdHRyTWFwLCByZW1vdmUsIHNsb3RGbGFnc1RleHQsIHN0cmluZ2lmeVN0eWxlLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSwgdG9OdW1iZXIsIHRvUmF3VHlwZSwgdG9UeXBlU3RyaW5nIH07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIHJ1bnRpbWUgaGVscGVyIGZvciBzZXR0aW5nIHByb3BlcnRpZXMgb24gY29tcG9uZW50c1xuLy8gaW4gYSB0cmVlLXNoYWthYmxlIHdheVxuZXhwb3J0cy5kZWZhdWx0ID0gKHNmYywgcHJvcHMpID0+IHtcbiAgICBjb25zdCB0YXJnZXQgPSBzZmMuX192Y2NPcHRzIHx8IHNmYztcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgcHJvcHMpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuIiwiPCEtLVxyXG4gICAgYXV0aG9yOiBwZWFreVxyXG4tLT5cclxuPHRlbXBsYXRlPlxyXG4gIDxkaXY+XHJcbiAgICA8cm91dGVyLXZpZXcvPlxyXG4gIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdCBsYW5nPVwidHNcIiBzZXR1cD5cclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGUgIGxhbmc9XCJzY3NzXCIgc2NvcGVkPlxyXG5cclxuPC9zdHlsZT5cclxuIiwiaW1wb3J0IHsgaW5pdEN1c3RvbUZvcm1hdHRlciwgd2FybiB9IGZyb20gJ0B2dWUvcnVudGltZS1kb20nO1xuZXhwb3J0ICogZnJvbSAnQHZ1ZS9ydW50aW1lLWRvbSc7XG5cbmZ1bmN0aW9uIGluaXREZXYoKSB7XG4gIHtcbiAgICBpbml0Q3VzdG9tRm9ybWF0dGVyKCk7XG4gIH1cbn1cblxuaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgaW5pdERldigpO1xufVxuY29uc3QgY29tcGlsZSA9ICgpID0+IHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuKFxuICAgICAgYFJ1bnRpbWUgY29tcGlsYXRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJ1aWxkIG9mIFZ1ZS5gICsgKGAgQ29uZmlndXJlIHlvdXIgYnVuZGxlciB0byBhbGlhcyBcInZ1ZVwiIHRvIFwidnVlL2Rpc3QvdnVlLmVzbS1idW5kbGVyLmpzXCIuYCApXG4gICAgICAvKiBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGNvbXBpbGUgfTtcbiIsImltcG9ydCB7IGNyZWF0ZUFwcCB9IGZyb20gXCJ2dWVcIlxyXG5pbXBvcnQgeyBjcmVhdGVQaW5pYSB9IGZyb20gXCJwaW5pYVwiXHJcbi8vIOWvvOWFpeaguee7hOS7tlxyXG5pbXBvcnQgQXBwIGZyb20gXCJAL0FwcC52dWVcIlxyXG4vLyDlr7zlhaXot6/nlLHlrp7kvotcclxuaW1wb3J0IHJvdXRlciBmcm9tIFwiQC9yb3V0ZXIvcm91dGVyXCJcclxuLy8g5Yib5bu6IHZ1ZSDlupTnlKjlrp7kvotcclxuY29uc3QgYXBwID0gY3JlYXRlQXBwKEFwcClcclxuLy8g5Yib5bu6IHBpbmlhIOW6lOeUqOWunuS+i1xyXG5jb25zdCBwaW5pYSA9IGNyZWF0ZVBpbmlhKClcclxuLy8g5rOo5YaM6Lev55Sx5a6e5L6L44CBcGluaWHlupTnlKjlrp7kvotcclxuYXBwLnVzZShyb3V0ZXIpLnVzZShwaW5pYSlcclxuLy8g5oyC6L29IHZ1ZSDlupTnlKjlrp7kvotcclxuYXBwLm1vdW50KFwiI2FwcFwiKVxyXG5cclxuIiwiaW1wb3J0IHsgY3JlYXRlUm91dGVyLCBjcmVhdGVXZWJIaXN0b3J5IH0gZnJvbSBcInZ1ZS1yb3V0ZXJcIlxyXG5cclxuLy8g5a6a5LmJ6Lev55Sx6YWN572uXHJcbmNvbnN0IHJvdXRlcyA9IFtcclxuICAgIHsgcGF0aDogJy8nLCBjb21wb25lbnQ6ICgpID0+IGltcG9ydChcIkAvdmlld3MvSG9tZS52dWVcIikgfVxyXG5dXHJcbi8vIOWIm+W7uui3r+eUseWunuS+i1xyXG5jb25zdCByb3V0ZXIgPSBjcmVhdGVSb3V0ZXIoe1xyXG4gICAgaGlzdG9yeTogY3JlYXRlV2ViSGlzdG9yeSgpLCAvLyDmjIflrprot6/nlLHnmoTljoblj7LnrqHnkIbmqKHlvI9cclxuICAgIHJvdXRlcyAvLyDlrprkuYnot6/nlLHphY3nva5cclxufSlcclxuLy8g5a+85Ye66Lev55Sx5a6e5L6LXHJcbmV4cG9ydCBkZWZhdWx0IHJvdXRlclxyXG4iLCJpbXBvcnQgeyByZW5kZXIgfSBmcm9tIFwiLi9BcHAudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTdiYTViZDkwXCJcbmNvbnN0IHNjcmlwdCA9IHt9XG5cbmltcG9ydCBleHBvcnRDb21wb25lbnQgZnJvbSBcIi4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzXCJcbmNvbnN0IF9fZXhwb3J0c19fID0gLyojX19QVVJFX18qL2V4cG9ydENvbXBvbmVudChzY3JpcHQsIFtbJ3JlbmRlcicscmVuZGVyXSxbJ19fZmlsZScsXCJzcmMvQXBwLnZ1ZVwiXV0pXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICBfX2V4cG9ydHNfXy5fX2htcklkID0gXCI3YmE1YmQ5MFwiXG4gIGNvbnN0IGFwaSA9IF9fVlVFX0hNUl9SVU5USU1FX19cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIWFwaS5jcmVhdGVSZWNvcmQoJzdiYTViZDkwJywgX19leHBvcnRzX18pKSB7XG4gICAgYXBpLnJlbG9hZCgnN2JhNWJkOTAnLCBfX2V4cG9ydHNfXylcbiAgfVxuICBcbiAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL0FwcC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9N2JhNWJkOTBcIiwgKCkgPT4ge1xuICAgIGFwaS5yZXJlbmRlcignN2JhNWJkOTAnLCByZW5kZXIpXG4gIH0pXG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBfX2V4cG9ydHNfXyIsImV4cG9ydCAqIGZyb20gXCItIS4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvdGVtcGxhdGVMb2FkZXIuanM/P3J1bGVTZXRbMV0ucnVsZXNbM10hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s5XS51c2VbMF0hLi9BcHAudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTdiYTViZDkwXCIiLCIvKiFcbiAqIHBpbmlhIHYyLjEuN1xuICogKGMpIDIwMjMgRWR1YXJkbyBTYW4gTWFydGluIE1vcm90ZVxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IGhhc0luamVjdGlvbkNvbnRleHQsIGluamVjdCwgdG9SYXcsIHdhdGNoLCB1bnJlZiwgbWFya1JhdywgZWZmZWN0U2NvcGUsIHJlZiwgaXNWdWUyLCBpc1JlZiwgaXNSZWFjdGl2ZSwgc2V0LCBnZXRDdXJyZW50U2NvcGUsIG9uU2NvcGVEaXNwb3NlLCBnZXRDdXJyZW50SW5zdGFuY2UsIHJlYWN0aXZlLCB0b1JlZiwgZGVsLCBuZXh0VGljaywgY29tcHV0ZWQsIHRvUmVmcyB9IGZyb20gJ3Z1ZS1kZW1pJztcbmltcG9ydCB7IHNldHVwRGV2dG9vbHNQbHVnaW4gfSBmcm9tICdAdnVlL2RldnRvb2xzLWFwaSc7XG5cbi8qKlxuICogc2V0QWN0aXZlUGluaWEgbXVzdCBiZSBjYWxsZWQgdG8gaGFuZGxlIFNTUiBhdCB0aGUgdG9wIG9mIGZ1bmN0aW9ucyBsaWtlXG4gKiBgZmV0Y2hgLCBgc2V0dXBgLCBgc2VydmVyUHJlZmV0Y2hgIGFuZCBvdGhlcnNcbiAqL1xubGV0IGFjdGl2ZVBpbmlhO1xuLyoqXG4gKiBTZXRzIG9yIHVuc2V0cyB0aGUgYWN0aXZlIHBpbmlhLiBVc2VkIGluIFNTUiBhbmQgaW50ZXJuYWxseSB3aGVuIGNhbGxpbmdcbiAqIGFjdGlvbnMgYW5kIGdldHRlcnNcbiAqXG4gKiBAcGFyYW0gcGluaWEgLSBQaW5pYSBpbnN0YW5jZVxuICovXG4vLyBAdHMtZXhwZWN0LWVycm9yOiBjYW5ub3QgY29uc3RyYWluIHRoZSB0eXBlIG9mIHRoZSByZXR1cm5cbmNvbnN0IHNldEFjdGl2ZVBpbmlhID0gKHBpbmlhKSA9PiAoYWN0aXZlUGluaWEgPSBwaW5pYSk7XG4vKipcbiAqIEdldCB0aGUgY3VycmVudGx5IGFjdGl2ZSBwaW5pYSBpZiB0aGVyZSBpcyBhbnkuXG4gKi9cbmNvbnN0IGdldEFjdGl2ZVBpbmlhID0gKCkgPT4gKGhhc0luamVjdGlvbkNvbnRleHQoKSAmJiBpbmplY3QocGluaWFTeW1ib2wpKSB8fCBhY3RpdmVQaW5pYTtcbmNvbnN0IHBpbmlhU3ltYm9sID0gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IFN5bWJvbCgncGluaWEnKSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFN5bWJvbCgpKTtcblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5vKSB7XG4gICAgcmV0dXJuIChvICYmXG4gICAgICAgIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmXG4gICAgICAgIHR5cGVvZiBvLnRvSlNPTiAhPT0gJ2Z1bmN0aW9uJyk7XG59XG4vLyB0eXBlIERlZXBSZWFkb25seTxUPiA9IHsgcmVhZG9ubHkgW1AgaW4ga2V5b2YgVF06IERlZXBSZWFkb25seTxUW1BdPiB9XG4vLyBUT0RPOiBjYW4gd2UgY2hhbmdlIHRoZXNlIHRvIG51bWJlcnM/XG4vKipcbiAqIFBvc3NpYmxlIHR5cGVzIGZvciBTdWJzY3JpcHRpb25DYWxsYmFja1xuICovXG52YXIgTXV0YXRpb25UeXBlO1xuKGZ1bmN0aW9uIChNdXRhdGlvblR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBEaXJlY3QgbXV0YXRpb24gb2YgdGhlIHN0YXRlOlxuICAgICAqXG4gICAgICogLSBgc3RvcmUubmFtZSA9ICduZXcgbmFtZSdgXG4gICAgICogLSBgc3RvcmUuJHN0YXRlLm5hbWUgPSAnbmV3IG5hbWUnYFxuICAgICAqIC0gYHN0b3JlLmxpc3QucHVzaCgnbmV3IGl0ZW0nKWBcbiAgICAgKi9cbiAgICBNdXRhdGlvblR5cGVbXCJkaXJlY3RcIl0gPSBcImRpcmVjdFwiO1xuICAgIC8qKlxuICAgICAqIE11dGF0ZWQgdGhlIHN0YXRlIHdpdGggYCRwYXRjaGAgYW5kIGFuIG9iamVjdFxuICAgICAqXG4gICAgICogLSBgc3RvcmUuJHBhdGNoKHsgbmFtZTogJ25ld05hbWUnIH0pYFxuICAgICAqL1xuICAgIE11dGF0aW9uVHlwZVtcInBhdGNoT2JqZWN0XCJdID0gXCJwYXRjaCBvYmplY3RcIjtcbiAgICAvKipcbiAgICAgKiBNdXRhdGVkIHRoZSBzdGF0ZSB3aXRoIGAkcGF0Y2hgIGFuZCBhIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiAtIGBzdG9yZS4kcGF0Y2goc3RhdGUgPT4gc3RhdGUubmFtZSA9ICduZXdOYW1lJylgXG4gICAgICovXG4gICAgTXV0YXRpb25UeXBlW1wicGF0Y2hGdW5jdGlvblwiXSA9IFwicGF0Y2ggZnVuY3Rpb25cIjtcbiAgICAvLyBtYXliZSByZXNldD8gZm9yICRzdGF0ZSA9IHt9IGFuZCAkcmVzZXRcbn0pKE11dGF0aW9uVHlwZSB8fCAoTXV0YXRpb25UeXBlID0ge30pKTtcblxuY29uc3QgSVNfQ0xJRU5UID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG4vKipcbiAqIFNob3VsZCB3ZSBhZGQgdGhlIGRldnRvb2xzIHBsdWdpbnMuXG4gKiAtIG9ubHkgaWYgZGV2IG1vZGUgb3IgZm9yY2VkIHRocm91Z2ggdGhlIHByb2QgZGV2dG9vbHMgZmxhZ1xuICogLSBub3QgaW4gdGVzdFxuICogLSBvbmx5IGlmIHdpbmRvdyBleGlzdHMgKGNvdWxkIGNoYW5nZSBpbiB0aGUgZnV0dXJlKVxuICovXG5jb25zdCBVU0VfREVWVE9PTFMgPSAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICh0eXBlb2YgX19WVUVfUFJPRF9ERVZUT09MU19fICE9PSAndW5kZWZpbmVkJyAmJiBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pKSAmJiAhKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpICYmIElTX0NMSUVOVDtcblxuLypcbiAqIEZpbGVTYXZlci5qcyBBIHNhdmVBcygpIEZpbGVTYXZlciBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBPcmlnaW5hbGx5IGJ5IEVsaSBHcmV5LCBhZGFwdGVkIGFzIGFuIEVTTSBtb2R1bGUgYnkgRWR1YXJkbyBTYW4gTWFydGluXG4gKiBNb3JvdGUuXG4gKlxuICogTGljZW5zZSA6IE1JVFxuICovXG4vLyBUaGUgb25lIGFuZCBvbmx5IHdheSBvZiBnZXR0aW5nIGdsb2JhbCBzY29wZSBpbiBhbGwgZW52aXJvbm1lbnRzXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMzI3NzE4Mi8xMDA4OTk5XG5jb25zdCBfZ2xvYmFsID0gLyojX19QVVJFX18qLyAoKCkgPT4gdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LndpbmRvdyA9PT0gd2luZG93XG4gICAgPyB3aW5kb3dcbiAgICA6IHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyAmJiBzZWxmLnNlbGYgPT09IHNlbGZcbiAgICAgICAgPyBzZWxmXG4gICAgICAgIDogdHlwZW9mIGdsb2JhbCA9PT0gJ29iamVjdCcgJiYgZ2xvYmFsLmdsb2JhbCA9PT0gZ2xvYmFsXG4gICAgICAgICAgICA/IGdsb2JhbFxuICAgICAgICAgICAgOiB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFRoaXNcbiAgICAgICAgICAgICAgICA6IHsgSFRNTEVsZW1lbnQ6IG51bGwgfSkoKTtcbmZ1bmN0aW9uIGJvbShibG9iLCB7IGF1dG9Cb20gPSBmYWxzZSB9ID0ge30pIHtcbiAgICAvLyBwcmVwZW5kIEJPTSBmb3IgVVRGLTggWE1MIGFuZCB0ZXh0LyogdHlwZXMgKGluY2x1ZGluZyBIVE1MKVxuICAgIC8vIG5vdGU6IHlvdXIgYnJvd3NlciB3aWxsIGF1dG9tYXRpY2FsbHkgY29udmVydCBVVEYtMTYgVStGRUZGIHRvIEVGIEJCIEJGXG4gICAgaWYgKGF1dG9Cb20gJiZcbiAgICAgICAgL15cXHMqKD86dGV4dFxcL1xcUyp8YXBwbGljYXRpb25cXC94bWx8XFxTKlxcL1xcUypcXCt4bWwpXFxzKjsuKmNoYXJzZXRcXHMqPVxccyp1dGYtOC9pLnRlc3QoYmxvYi50eXBlKSkge1xuICAgICAgICByZXR1cm4gbmV3IEJsb2IoW1N0cmluZy5mcm9tQ2hhckNvZGUoMHhmZWZmKSwgYmxvYl0sIHsgdHlwZTogYmxvYi50eXBlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYmxvYjtcbn1cbmZ1bmN0aW9uIGRvd25sb2FkKHVybCwgbmFtZSwgb3B0cykge1xuICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2F2ZUFzKHhoci5yZXNwb25zZSwgbmFtZSwgb3B0cyk7XG4gICAgfTtcbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignY291bGQgbm90IGRvd25sb2FkIGZpbGUnKTtcbiAgICB9O1xuICAgIHhoci5zZW5kKCk7XG59XG5mdW5jdGlvbiBjb3JzRW5hYmxlZCh1cmwpIHtcbiAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAvLyB1c2Ugc3luYyB0byBhdm9pZCBwb3B1cCBibG9ja2VyXG4gICAgeGhyLm9wZW4oJ0hFQUQnLCB1cmwsIGZhbHNlKTtcbiAgICB0cnkge1xuICAgICAgICB4aHIuc2VuZCgpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkgeyB9XG4gICAgcmV0dXJuIHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPD0gMjk5O1xufVxuLy8gYGEuY2xpY2soKWAgZG9lc24ndCB3b3JrIGZvciBhbGwgYnJvd3NlcnMgKCM0NjUpXG5mdW5jdGlvbiBjbGljayhub2RlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbm9kZS5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KCdjbGljaycpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJyk7XG4gICAgICAgIGV2dC5pbml0TW91c2VFdmVudCgnY2xpY2snLCB0cnVlLCB0cnVlLCB3aW5kb3csIDAsIDAsIDAsIDgwLCAyMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICBub2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICB9XG59XG5jb25zdCBfbmF2aWdhdG9yID0gXG4gdHlwZW9mIG5hdmlnYXRvciA9PT0gJ29iamVjdCcgPyBuYXZpZ2F0b3IgOiB7IHVzZXJBZ2VudDogJycgfTtcbi8vIERldGVjdCBXZWJWaWV3IGluc2lkZSBhIG5hdGl2ZSBtYWNPUyBhcHAgYnkgcnVsaW5nIG91dCBhbGwgYnJvd3NlcnNcbi8vIFdlIGp1c3QgbmVlZCB0byBjaGVjayBmb3IgJ1NhZmFyaScgYmVjYXVzZSBhbGwgb3RoZXIgYnJvd3NlcnMgKGJlc2lkZXMgRmlyZWZveCkgaW5jbHVkZSB0aGF0IHRvb1xuLy8gaHR0cHM6Ly93d3cud2hhdGlzbXlicm93c2VyLmNvbS9ndWlkZXMvdGhlLWxhdGVzdC11c2VyLWFnZW50L21hY29zXG5jb25zdCBpc01hY09TV2ViVmlldyA9IC8qI19fUFVSRV9fKi8gKCgpID0+IC9NYWNpbnRvc2gvLnRlc3QoX25hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgL0FwcGxlV2ViS2l0Ly50ZXN0KF9uYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgICEvU2FmYXJpLy50ZXN0KF9uYXZpZ2F0b3IudXNlckFnZW50KSkoKTtcbmNvbnN0IHNhdmVBcyA9ICFJU19DTElFTlRcbiAgICA/ICgpID0+IHsgfSAvLyBub29wXG4gICAgOiAvLyBVc2UgZG93bmxvYWQgYXR0cmlidXRlIGZpcnN0IGlmIHBvc3NpYmxlICgjMTkzIEx1bWlhIG1vYmlsZSkgdW5sZXNzIHRoaXMgaXMgYSBtYWNPUyBXZWJWaWV3IG9yIG1pbmkgcHJvZ3JhbVxuICAgICAgICB0eXBlb2YgSFRNTEFuY2hvckVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAnZG93bmxvYWQnIGluIEhUTUxBbmNob3JFbGVtZW50LnByb3RvdHlwZSAmJlxuICAgICAgICAgICAgIWlzTWFjT1NXZWJWaWV3XG4gICAgICAgICAgICA/IGRvd25sb2FkU2F2ZUFzXG4gICAgICAgICAgICA6IC8vIFVzZSBtc1NhdmVPck9wZW5CbG9iIGFzIGEgc2Vjb25kIGFwcHJvYWNoXG4gICAgICAgICAgICAgICAgJ21zU2F2ZU9yT3BlbkJsb2InIGluIF9uYXZpZ2F0b3JcbiAgICAgICAgICAgICAgICAgICAgPyBtc1NhdmVBc1xuICAgICAgICAgICAgICAgICAgICA6IC8vIEZhbGxiYWNrIHRvIHVzaW5nIEZpbGVSZWFkZXIgYW5kIGEgcG9wdXBcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVTYXZlclNhdmVBcztcbmZ1bmN0aW9uIGRvd25sb2FkU2F2ZUFzKGJsb2IsIG5hbWUgPSAnZG93bmxvYWQnLCBvcHRzKSB7XG4gICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICBhLmRvd25sb2FkID0gbmFtZTtcbiAgICBhLnJlbCA9ICdub29wZW5lcic7IC8vIHRhYm5hYmJpbmdcbiAgICAvLyBUT0RPOiBkZXRlY3QgY2hyb21lIGV4dGVuc2lvbnMgJiBwYWNrYWdlZCBhcHBzXG4gICAgLy8gYS50YXJnZXQgPSAnX2JsYW5rJ1xuICAgIGlmICh0eXBlb2YgYmxvYiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gU3VwcG9ydCByZWd1bGFyIGxpbmtzXG4gICAgICAgIGEuaHJlZiA9IGJsb2I7XG4gICAgICAgIGlmIChhLm9yaWdpbiAhPT0gbG9jYXRpb24ub3JpZ2luKSB7XG4gICAgICAgICAgICBpZiAoY29yc0VuYWJsZWQoYS5ocmVmKSkge1xuICAgICAgICAgICAgICAgIGRvd25sb2FkKGJsb2IsIG5hbWUsIG9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYS50YXJnZXQgPSAnX2JsYW5rJztcbiAgICAgICAgICAgICAgICBjbGljayhhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsaWNrKGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBTdXBwb3J0IGJsb2JzXG4gICAgICAgIGEuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChhLmhyZWYpO1xuICAgICAgICB9LCA0ZTQpOyAvLyA0MHNcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGljayhhKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxufVxuZnVuY3Rpb24gbXNTYXZlQXMoYmxvYiwgbmFtZSA9ICdkb3dubG9hZCcsIG9wdHMpIHtcbiAgICBpZiAodHlwZW9mIGJsb2IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChjb3JzRW5hYmxlZChibG9iKSkge1xuICAgICAgICAgICAgZG93bmxvYWQoYmxvYiwgbmFtZSwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgICAgYS5ocmVmID0gYmxvYjtcbiAgICAgICAgICAgIGEudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjbGljayhhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBAdHMtaWdub3JlOiB3b3JrcyBvbiB3aW5kb3dzXG4gICAgICAgIG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKGJvbShibG9iLCBvcHRzKSwgbmFtZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmlsZVNhdmVyU2F2ZUFzKGJsb2IsIG5hbWUsIG9wdHMsIHBvcHVwKSB7XG4gICAgLy8gT3BlbiBhIHBvcHVwIGltbWVkaWF0ZWx5IGRvIGdvIGFyb3VuZCBwb3B1cCBibG9ja2VyXG4gICAgLy8gTW9zdGx5IG9ubHkgYXZhaWxhYmxlIG9uIHVzZXIgaW50ZXJhY3Rpb24gYW5kIHRoZSBmaWxlUmVhZGVyIGlzIGFzeW5jIHNvLi4uXG4gICAgcG9wdXAgPSBwb3B1cCB8fCBvcGVuKCcnLCAnX2JsYW5rJyk7XG4gICAgaWYgKHBvcHVwKSB7XG4gICAgICAgIHBvcHVwLmRvY3VtZW50LnRpdGxlID0gcG9wdXAuZG9jdW1lbnQuYm9keS5pbm5lclRleHQgPSAnZG93bmxvYWRpbmcuLi4nO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGJsb2IgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gZG93bmxvYWQoYmxvYiwgbmFtZSwgb3B0cyk7XG4gICAgY29uc3QgZm9yY2UgPSBibG9iLnR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgIGNvbnN0IGlzU2FmYXJpID0gL2NvbnN0cnVjdG9yL2kudGVzdChTdHJpbmcoX2dsb2JhbC5IVE1MRWxlbWVudCkpIHx8ICdzYWZhcmknIGluIF9nbG9iYWw7XG4gICAgY29uc3QgaXNDaHJvbWVJT1MgPSAvQ3JpT1NcXC9bXFxkXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgaWYgKChpc0Nocm9tZUlPUyB8fCAoZm9yY2UgJiYgaXNTYWZhcmkpIHx8IGlzTWFjT1NXZWJWaWV3KSAmJlxuICAgICAgICB0eXBlb2YgRmlsZVJlYWRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gU2FmYXJpIGRvZXNuJ3QgYWxsb3cgZG93bmxvYWRpbmcgb2YgYmxvYiBVUkxzXG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsZXQgdXJsID0gcmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHBvcHVwID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIHJlYWRlci5yZXN1bHQgdHlwZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXJsID0gaXNDaHJvbWVJT1NcbiAgICAgICAgICAgICAgICA/IHVybFxuICAgICAgICAgICAgICAgIDogdXJsLnJlcGxhY2UoL15kYXRhOlteO10qOy8sICdkYXRhOmF0dGFjaG1lbnQvZmlsZTsnKTtcbiAgICAgICAgICAgIGlmIChwb3B1cCkge1xuICAgICAgICAgICAgICAgIHBvcHVwLmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbi5hc3NpZ24odXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcHVwID0gbnVsbDsgLy8gcmV2ZXJzZS10YWJuYWJiaW5nICM0NjBcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICBpZiAocG9wdXApXG4gICAgICAgICAgICBwb3B1cC5sb2NhdGlvbi5hc3NpZ24odXJsKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgcG9wdXAgPSBudWxsOyAvLyByZXZlcnNlLXRhYm5hYmJpbmcgIzQ2MFxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICAgICAgfSwgNGU0KTsgLy8gNDBzXG4gICAgfVxufVxuXG4vKipcbiAqIFNob3dzIGEgdG9hc3Qgb3IgY29uc29sZS5sb2dcbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgdG8gbG9nXG4gKiBAcGFyYW0gdHlwZSAtIGRpZmZlcmVudCBjb2xvciBvZiB0aGUgdG9vbHRpcFxuICovXG5mdW5jdGlvbiB0b2FzdE1lc3NhZ2UobWVzc2FnZSwgdHlwZSkge1xuICAgIGNvbnN0IHBpbmlhTWVzc2FnZSA9ICfwn42NICcgKyBtZXNzYWdlO1xuICAgIGlmICh0eXBlb2YgX19WVUVfREVWVE9PTFNfVE9BU1RfXyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBObyBsb25nZXIgYXZhaWxhYmxlIDooXG4gICAgICAgIF9fVlVFX0RFVlRPT0xTX1RPQVNUX18ocGluaWFNZXNzYWdlLCB0eXBlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKHBpbmlhTWVzc2FnZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICd3YXJuJykge1xuICAgICAgICBjb25zb2xlLndhcm4ocGluaWFNZXNzYWdlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHBpbmlhTWVzc2FnZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNQaW5pYShvKSB7XG4gICAgcmV0dXJuICdfYScgaW4gbyAmJiAnaW5zdGFsbCcgaW4gbztcbn1cblxuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbiBkZXZ0b29scyBhY3Rpb25zLCB0aGV5IGFyZSBub3QgUGluaWEgYWN0aW9ucy5cbiAqL1xuLy8gLS0tXG5mdW5jdGlvbiBjaGVja0NsaXBib2FyZEFjY2VzcygpIHtcbiAgICBpZiAoISgnY2xpcGJvYXJkJyBpbiBuYXZpZ2F0b3IpKSB7XG4gICAgICAgIHRvYXN0TWVzc2FnZShgWW91ciBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgQ2xpcGJvYXJkIEFQSWAsICdlcnJvcicpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja05vdEZvY3VzZWRFcnJvcihlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgIGVycm9yLm1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZG9jdW1lbnQgaXMgbm90IGZvY3VzZWQnKSkge1xuICAgICAgICB0b2FzdE1lc3NhZ2UoJ1lvdSBuZWVkIHRvIGFjdGl2YXRlIHRoZSBcIkVtdWxhdGUgYSBmb2N1c2VkIHBhZ2VcIiBzZXR0aW5nIGluIHRoZSBcIlJlbmRlcmluZ1wiIHBhbmVsIG9mIGRldnRvb2xzLicsICd3YXJuJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5hc3luYyBmdW5jdGlvbiBhY3Rpb25HbG9iYWxDb3B5U3RhdGUocGluaWEpIHtcbiAgICBpZiAoY2hlY2tDbGlwYm9hcmRBY2Nlc3MoKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KEpTT04uc3RyaW5naWZ5KHBpbmlhLnN0YXRlLnZhbHVlKSk7XG4gICAgICAgIHRvYXN0TWVzc2FnZSgnR2xvYmFsIHN0YXRlIGNvcGllZCB0byBjbGlwYm9hcmQuJyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoY2hlY2tOb3RGb2N1c2VkRXJyb3IoZXJyb3IpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0b2FzdE1lc3NhZ2UoYEZhaWxlZCB0byBzZXJpYWxpemUgdGhlIHN0YXRlLiBDaGVjayB0aGUgY29uc29sZSBmb3IgbW9yZSBkZXRhaWxzLmAsICdlcnJvcicpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBhY3Rpb25HbG9iYWxQYXN0ZVN0YXRlKHBpbmlhKSB7XG4gICAgaWYgKGNoZWNrQ2xpcGJvYXJkQWNjZXNzKCkpXG4gICAgICAgIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgICBsb2FkU3RvcmVzU3RhdGUocGluaWEsIEpTT04ucGFyc2UoYXdhaXQgbmF2aWdhdG9yLmNsaXBib2FyZC5yZWFkVGV4dCgpKSk7XG4gICAgICAgIHRvYXN0TWVzc2FnZSgnR2xvYmFsIHN0YXRlIHBhc3RlZCBmcm9tIGNsaXBib2FyZC4nKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChjaGVja05vdEZvY3VzZWRFcnJvcihlcnJvcikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRvYXN0TWVzc2FnZShgRmFpbGVkIHRvIGRlc2VyaWFsaXplIHRoZSBzdGF0ZSBmcm9tIGNsaXBib2FyZC4gQ2hlY2sgdGhlIGNvbnNvbGUgZm9yIG1vcmUgZGV0YWlscy5gLCAnZXJyb3InKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gYWN0aW9uR2xvYmFsU2F2ZVN0YXRlKHBpbmlhKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgc2F2ZUFzKG5ldyBCbG9iKFtKU09OLnN0cmluZ2lmeShwaW5pYS5zdGF0ZS52YWx1ZSldLCB7XG4gICAgICAgICAgICB0eXBlOiAndGV4dC9wbGFpbjtjaGFyc2V0PXV0Zi04JyxcbiAgICAgICAgfSksICdwaW5pYS1zdGF0ZS5qc29uJyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0b2FzdE1lc3NhZ2UoYEZhaWxlZCB0byBleHBvcnQgdGhlIHN0YXRlIGFzIEpTT04uIENoZWNrIHRoZSBjb25zb2xlIGZvciBtb3JlIGRldGFpbHMuYCwgJ2Vycm9yJyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cbn1cbmxldCBmaWxlSW5wdXQ7XG5mdW5jdGlvbiBnZXRGaWxlT3BlbmVyKCkge1xuICAgIGlmICghZmlsZUlucHV0KSB7XG4gICAgICAgIGZpbGVJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGZpbGVJbnB1dC50eXBlID0gJ2ZpbGUnO1xuICAgICAgICBmaWxlSW5wdXQuYWNjZXB0ID0gJy5qc29uJztcbiAgICB9XG4gICAgZnVuY3Rpb24gb3BlbkZpbGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBmaWxlSW5wdXQub25jaGFuZ2UgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZXMgPSBmaWxlSW5wdXQuZmlsZXM7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWxlcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZSA9IGZpbGVzLml0ZW0oMCk7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7IHRleHQ6IGF3YWl0IGZpbGUudGV4dCgpLCBmaWxlIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU6IFRPRE86IGNoYW5nZWQgZnJvbSA0LjMgdG8gNC40XG4gICAgICAgICAgICBmaWxlSW5wdXQub25jYW5jZWwgPSAoKSA9PiByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgZmlsZUlucHV0Lm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgICAgICBmaWxlSW5wdXQuY2xpY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcGVuRmlsZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFjdGlvbkdsb2JhbE9wZW5TdGF0ZUZpbGUocGluaWEpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBvcGVuID0gZ2V0RmlsZU9wZW5lcigpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvcGVuKCk7XG4gICAgICAgIGlmICghcmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IHRleHQsIGZpbGUgfSA9IHJlc3VsdDtcbiAgICAgICAgbG9hZFN0b3Jlc1N0YXRlKHBpbmlhLCBKU09OLnBhcnNlKHRleHQpKTtcbiAgICAgICAgdG9hc3RNZXNzYWdlKGBHbG9iYWwgc3RhdGUgaW1wb3J0ZWQgZnJvbSBcIiR7ZmlsZS5uYW1lfVwiLmApO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdG9hc3RNZXNzYWdlKGBGYWlsZWQgdG8gaW1wb3J0IHRoZSBzdGF0ZSBmcm9tIEpTT04uIENoZWNrIHRoZSBjb25zb2xlIGZvciBtb3JlIGRldGFpbHMuYCwgJ2Vycm9yJyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxvYWRTdG9yZXNTdGF0ZShwaW5pYSwgc3RhdGUpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzdGF0ZSkge1xuICAgICAgICBjb25zdCBzdG9yZVN0YXRlID0gcGluaWEuc3RhdGUudmFsdWVba2V5XTtcbiAgICAgICAgLy8gc3RvcmUgaXMgYWxyZWFkeSBpbnN0YW50aWF0ZWQsIHBhdGNoIGl0XG4gICAgICAgIGlmIChzdG9yZVN0YXRlKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHN0b3JlU3RhdGUsIHN0YXRlW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gc3RvcmUgaXMgbm90IGluc3RhbnRpYXRlZCwgc2V0IHRoZSBpbml0aWFsIHN0YXRlXG4gICAgICAgICAgICBwaW5pYS5zdGF0ZS52YWx1ZVtrZXldID0gc3RhdGVba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0RGlzcGxheShkaXNwbGF5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgX2N1c3RvbToge1xuICAgICAgICAgICAgZGlzcGxheSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuY29uc3QgUElOSUFfUk9PVF9MQUJFTCA9ICfwn42NIFBpbmlhIChyb290KSc7XG5jb25zdCBQSU5JQV9ST09UX0lEID0gJ19yb290JztcbmZ1bmN0aW9uIGZvcm1hdFN0b3JlRm9ySW5zcGVjdG9yVHJlZShzdG9yZSkge1xuICAgIHJldHVybiBpc1BpbmlhKHN0b3JlKVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGlkOiBQSU5JQV9ST09UX0lELFxuICAgICAgICAgICAgbGFiZWw6IFBJTklBX1JPT1RfTEFCRUwsXG4gICAgICAgIH1cbiAgICAgICAgOiB7XG4gICAgICAgICAgICBpZDogc3RvcmUuJGlkLFxuICAgICAgICAgICAgbGFiZWw6IHN0b3JlLiRpZCxcbiAgICAgICAgfTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFN0b3JlRm9ySW5zcGVjdG9yU3RhdGUoc3RvcmUpIHtcbiAgICBpZiAoaXNQaW5pYShzdG9yZSkpIHtcbiAgICAgICAgY29uc3Qgc3RvcmVOYW1lcyA9IEFycmF5LmZyb20oc3RvcmUuX3Mua2V5cygpKTtcbiAgICAgICAgY29uc3Qgc3RvcmVNYXAgPSBzdG9yZS5fcztcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgICAgICBzdGF0ZTogc3RvcmVOYW1lcy5tYXAoKHN0b3JlSWQpID0+ICh7XG4gICAgICAgICAgICAgICAgZWRpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAga2V5OiBzdG9yZUlkLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBzdG9yZS5zdGF0ZS52YWx1ZVtzdG9yZUlkXSxcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIGdldHRlcnM6IHN0b3JlTmFtZXNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChpZCkgPT4gc3RvcmVNYXAuZ2V0KGlkKS5fZ2V0dGVycylcbiAgICAgICAgICAgICAgICAubWFwKChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gc3RvcmVNYXAuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGtleTogaWQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdG9yZS5fZ2V0dGVycy5yZWR1Y2UoKGdldHRlcnMsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0dGVyc1trZXldID0gc3RvcmVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXR0ZXJzO1xuICAgICAgICAgICAgICAgICAgICB9LCB7fSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICBzdGF0ZTogT2JqZWN0LmtleXMoc3RvcmUuJHN0YXRlKS5tYXAoKGtleSkgPT4gKHtcbiAgICAgICAgICAgIGVkaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHN0b3JlLiRzdGF0ZVtrZXldLFxuICAgICAgICB9KSksXG4gICAgfTtcbiAgICAvLyBhdm9pZCBhZGRpbmcgZW1wdHkgZ2V0dGVyc1xuICAgIGlmIChzdG9yZS5fZ2V0dGVycyAmJiBzdG9yZS5fZ2V0dGVycy5sZW5ndGgpIHtcbiAgICAgICAgc3RhdGUuZ2V0dGVycyA9IHN0b3JlLl9nZXR0ZXJzLm1hcCgoZ2V0dGVyTmFtZSkgPT4gKHtcbiAgICAgICAgICAgIGVkaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGtleTogZ2V0dGVyTmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiBzdG9yZVtnZXR0ZXJOYW1lXSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoc3RvcmUuX2N1c3RvbVByb3BlcnRpZXMuc2l6ZSkge1xuICAgICAgICBzdGF0ZS5jdXN0b21Qcm9wZXJ0aWVzID0gQXJyYXkuZnJvbShzdG9yZS5fY3VzdG9tUHJvcGVydGllcykubWFwKChrZXkpID0+ICh7XG4gICAgICAgICAgICBlZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlOiBzdG9yZVtrZXldLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEV2ZW50RGF0YShldmVudHMpIHtcbiAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50cykpIHtcbiAgICAgICAgLy8gVE9ETzogaGFuZGxlIGFkZCBhbmQgZGVsZXRlIGZvciBhcnJheXMgYW5kIG9iamVjdHNcbiAgICAgICAgcmV0dXJuIGV2ZW50cy5yZWR1Y2UoKGRhdGEsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBkYXRhLmtleXMucHVzaChldmVudC5rZXkpO1xuICAgICAgICAgICAgZGF0YS5vcGVyYXRpb25zLnB1c2goZXZlbnQudHlwZSk7XG4gICAgICAgICAgICBkYXRhLm9sZFZhbHVlW2V2ZW50LmtleV0gPSBldmVudC5vbGRWYWx1ZTtcbiAgICAgICAgICAgIGRhdGEubmV3VmFsdWVbZXZlbnQua2V5XSA9IGV2ZW50Lm5ld1ZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9sZFZhbHVlOiB7fSxcbiAgICAgICAgICAgIGtleXM6IFtdLFxuICAgICAgICAgICAgb3BlcmF0aW9uczogW10sXG4gICAgICAgICAgICBuZXdWYWx1ZToge30sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogZm9ybWF0RGlzcGxheShldmVudHMudHlwZSksXG4gICAgICAgICAgICBrZXk6IGZvcm1hdERpc3BsYXkoZXZlbnRzLmtleSksXG4gICAgICAgICAgICBvbGRWYWx1ZTogZXZlbnRzLm9sZFZhbHVlLFxuICAgICAgICAgICAgbmV3VmFsdWU6IGV2ZW50cy5uZXdWYWx1ZSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBmb3JtYXRNdXRhdGlvblR5cGUodHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIE11dGF0aW9uVHlwZS5kaXJlY3Q6XG4gICAgICAgICAgICByZXR1cm4gJ211dGF0aW9uJztcbiAgICAgICAgY2FzZSBNdXRhdGlvblR5cGUucGF0Y2hGdW5jdGlvbjpcbiAgICAgICAgICAgIHJldHVybiAnJHBhdGNoJztcbiAgICAgICAgY2FzZSBNdXRhdGlvblR5cGUucGF0Y2hPYmplY3Q6XG4gICAgICAgICAgICByZXR1cm4gJyRwYXRjaCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJ3Vua25vd24nO1xuICAgIH1cbn1cblxuLy8gdGltZWxpbmUgY2FuIGJlIHBhdXNlZCB3aGVuIGRpcmVjdGx5IGNoYW5naW5nIHRoZSBzdGF0ZVxubGV0IGlzVGltZWxpbmVBY3RpdmUgPSB0cnVlO1xuY29uc3QgY29tcG9uZW50U3RhdGVUeXBlcyA9IFtdO1xuY29uc3QgTVVUQVRJT05TX0xBWUVSX0lEID0gJ3BpbmlhOm11dGF0aW9ucyc7XG5jb25zdCBJTlNQRUNUT1JfSUQgPSAncGluaWEnO1xuY29uc3QgeyBhc3NpZ246IGFzc2lnbiQxIH0gPSBPYmplY3Q7XG4vKipcbiAqIEdldHMgdGhlIGRpc3BsYXllZCBuYW1lIG9mIGEgc3RvcmUgaW4gZGV2dG9vbHNcbiAqXG4gKiBAcGFyYW0gaWQgLSBpZCBvZiB0aGUgc3RvcmVcbiAqIEByZXR1cm5zIGEgZm9ybWF0dGVkIHN0cmluZ1xuICovXG5jb25zdCBnZXRTdG9yZVR5cGUgPSAoaWQpID0+ICfwn42NICcgKyBpZDtcbi8qKlxuICogQWRkIHRoZSBwaW5pYSBwbHVnaW4gd2l0aG91dCBhbnkgc3RvcmUuIEFsbG93cyBkaXNwbGF5aW5nIGEgUGluaWEgcGx1Z2luIHRhYlxuICogYXMgc29vbiBhcyBpdCBpcyBhZGRlZCB0byB0aGUgYXBwbGljYXRpb24uXG4gKlxuICogQHBhcmFtIGFwcCAtIFZ1ZSBhcHBsaWNhdGlvblxuICogQHBhcmFtIHBpbmlhIC0gcGluaWEgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJQaW5pYURldnRvb2xzKGFwcCwgcGluaWEpIHtcbiAgICBzZXR1cERldnRvb2xzUGx1Z2luKHtcbiAgICAgICAgaWQ6ICdkZXYuZXNtLnBpbmlhJyxcbiAgICAgICAgbGFiZWw6ICdQaW5pYSDwn42NJyxcbiAgICAgICAgbG9nbzogJ2h0dHBzOi8vcGluaWEudnVlanMub3JnL2xvZ28uc3ZnJyxcbiAgICAgICAgcGFja2FnZU5hbWU6ICdwaW5pYScsXG4gICAgICAgIGhvbWVwYWdlOiAnaHR0cHM6Ly9waW5pYS52dWVqcy5vcmcnLFxuICAgICAgICBjb21wb25lbnRTdGF0ZVR5cGVzLFxuICAgICAgICBhcHAsXG4gICAgfSwgKGFwaSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGFwaS5ub3cgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRvYXN0TWVzc2FnZSgnWW91IHNlZW0gdG8gYmUgdXNpbmcgYW4gb3V0ZGF0ZWQgdmVyc2lvbiBvZiBWdWUgRGV2dG9vbHMuIEFyZSB5b3Ugc3RpbGwgdXNpbmcgdGhlIEJldGEgcmVsZWFzZSBpbnN0ZWFkIG9mIHRoZSBzdGFibGUgb25lPyBZb3UgY2FuIGZpbmQgdGhlIGxpbmtzIGF0IGh0dHBzOi8vZGV2dG9vbHMudnVlanMub3JnL2d1aWRlL2luc3RhbGxhdGlvbi5odG1sLicpO1xuICAgICAgICB9XG4gICAgICAgIGFwaS5hZGRUaW1lbGluZUxheWVyKHtcbiAgICAgICAgICAgIGlkOiBNVVRBVElPTlNfTEFZRVJfSUQsXG4gICAgICAgICAgICBsYWJlbDogYFBpbmlhIPCfjY1gLFxuICAgICAgICAgICAgY29sb3I6IDB4ZTVkZjg4LFxuICAgICAgICB9KTtcbiAgICAgICAgYXBpLmFkZEluc3BlY3Rvcih7XG4gICAgICAgICAgICBpZDogSU5TUEVDVE9SX0lELFxuICAgICAgICAgICAgbGFiZWw6ICdQaW5pYSDwn42NJyxcbiAgICAgICAgICAgIGljb246ICdzdG9yYWdlJyxcbiAgICAgICAgICAgIHRyZWVGaWx0ZXJQbGFjZWhvbGRlcjogJ1NlYXJjaCBzdG9yZXMnLFxuICAgICAgICAgICAgYWN0aW9uczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2NvbnRlbnRfY29weScsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uR2xvYmFsQ29weVN0YXRlKHBpbmlhKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogJ1NlcmlhbGl6ZSBhbmQgY29weSB0aGUgc3RhdGUnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpY29uOiAnY29udGVudF9wYXN0ZScsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgYWN0aW9uR2xvYmFsUGFzdGVTdGF0ZShwaW5pYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGkuc2VuZEluc3BlY3RvclRyZWUoSU5TUEVDVE9SX0lEKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yU3RhdGUoSU5TUEVDVE9SX0lEKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogJ1JlcGxhY2UgdGhlIHN0YXRlIHdpdGggdGhlIGNvbnRlbnQgb2YgeW91ciBjbGlwYm9hcmQnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpY29uOiAnc2F2ZScsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uR2xvYmFsU2F2ZVN0YXRlKHBpbmlhKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogJ1NhdmUgdGhlIHN0YXRlIGFzIGEgSlNPTiBmaWxlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2ZvbGRlcl9vcGVuJyxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBhY3Rpb25HbG9iYWxPcGVuU3RhdGVGaWxlKHBpbmlhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yVHJlZShJTlNQRUNUT1JfSUQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JTdGF0ZShJTlNQRUNUT1JfSUQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwOiAnSW1wb3J0IHRoZSBzdGF0ZSBmcm9tIGEgSlNPTiBmaWxlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG5vZGVBY3Rpb25zOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpY29uOiAncmVzdG9yZScsXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6ICdSZXNldCB0aGUgc3RhdGUgKHdpdGggXCIkcmVzZXRcIiknLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IChub2RlSWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gcGluaWEuX3MuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9hc3RNZXNzYWdlKGBDYW5ub3QgcmVzZXQgXCIke25vZGVJZH1cIiBzdG9yZSBiZWNhdXNlIGl0IHdhc24ndCBmb3VuZC5gLCAnd2FybicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHN0b3JlLiRyZXNldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvYXN0TWVzc2FnZShgQ2Fubm90IHJlc2V0IFwiJHtub2RlSWR9XCIgc3RvcmUgYmVjYXVzZSBpdCBkb2Vzbid0IGhhdmUgYSBcIiRyZXNldFwiIG1ldGhvZCBpbXBsZW1lbnRlZC5gLCAnd2FybicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUuJHJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9hc3RNZXNzYWdlKGBTdG9yZSBcIiR7bm9kZUlkfVwiIHJlc2V0LmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgYXBpLm9uLmluc3BlY3RDb21wb25lbnQoKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJveHkgPSAocGF5bG9hZC5jb21wb25lbnRJbnN0YW5jZSAmJlxuICAgICAgICAgICAgICAgIHBheWxvYWQuY29tcG9uZW50SW5zdGFuY2UucHJveHkpO1xuICAgICAgICAgICAgaWYgKHByb3h5ICYmIHByb3h5Ll9wU3RvcmVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGluaWFTdG9yZXMgPSBwYXlsb2FkLmNvbXBvbmVudEluc3RhbmNlLnByb3h5Ll9wU3RvcmVzO1xuICAgICAgICAgICAgICAgIE9iamVjdC52YWx1ZXMocGluaWFTdG9yZXMpLmZvckVhY2goKHN0b3JlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuaW5zdGFuY2VEYXRhLnN0YXRlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZ2V0U3RvcmVUeXBlKHN0b3JlLiRpZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdzdGF0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdG9yZS5faXNPcHRpb25zQVBJXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jdXN0b206IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0b1JhdyhzdG9yZS4kc3RhdGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogJ3Jlc3RvcmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwOiAnUmVzZXQgdGhlIHN0YXRlIG9mIHRoaXMgc3RvcmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICgpID0+IHN0b3JlLiRyZXNldCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IC8vIE5PVEU6IHdvcmthcm91bmQgdG8gdW53cmFwIHRyYW5zZmVycmVkIHJlZnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc3RvcmUuJHN0YXRlKS5yZWR1Y2UoKHN0YXRlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlW2tleV0gPSBzdG9yZS4kc3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge30pLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3JlLl9nZXR0ZXJzICYmIHN0b3JlLl9nZXR0ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5pbnN0YW5jZURhdGEuc3RhdGUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZ2V0U3RvcmVUeXBlKHN0b3JlLiRpZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnZ2V0dGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdG9yZS5fZ2V0dGVycy5yZWR1Y2UoKGdldHRlcnMsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0dGVyc1trZXldID0gc3RvcmVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHdlIGp1c3Qgd2FudCB0byBzaG93IGl0IGluIGRldnRvb2xzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXJzW2tleV0gPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXBpLm9uLmdldEluc3BlY3RvclRyZWUoKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmFwcCA9PT0gYXBwICYmIHBheWxvYWQuaW5zcGVjdG9ySWQgPT09IElOU1BFQ1RPUl9JRCkge1xuICAgICAgICAgICAgICAgIGxldCBzdG9yZXMgPSBbcGluaWFdO1xuICAgICAgICAgICAgICAgIHN0b3JlcyA9IHN0b3Jlcy5jb25jYXQoQXJyYXkuZnJvbShwaW5pYS5fcy52YWx1ZXMoKSkpO1xuICAgICAgICAgICAgICAgIHBheWxvYWQucm9vdE5vZGVzID0gKHBheWxvYWQuZmlsdGVyXG4gICAgICAgICAgICAgICAgICAgID8gc3RvcmVzLmZpbHRlcigoc3RvcmUpID0+ICckaWQnIGluIHN0b3JlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHN0b3JlLiRpZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmluY2x1ZGVzKHBheWxvYWQuZmlsdGVyLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFBJTklBX1JPT1RfTEFCRUwudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhwYXlsb2FkLmZpbHRlci50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgICAgICAgICAgICAgOiBzdG9yZXMpLm1hcChmb3JtYXRTdG9yZUZvckluc3BlY3RvclRyZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXBpLm9uLmdldEluc3BlY3RvclN0YXRlKChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBpZiAocGF5bG9hZC5hcHAgPT09IGFwcCAmJiBwYXlsb2FkLmluc3BlY3RvcklkID09PSBJTlNQRUNUT1JfSUQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnNwZWN0ZWRTdG9yZSA9IHBheWxvYWQubm9kZUlkID09PSBQSU5JQV9ST09UX0lEXG4gICAgICAgICAgICAgICAgICAgID8gcGluaWFcbiAgICAgICAgICAgICAgICAgICAgOiBwaW5pYS5fcy5nZXQocGF5bG9hZC5ub2RlSWQpO1xuICAgICAgICAgICAgICAgIGlmICghaW5zcGVjdGVkU3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBiZSB0aGUgc2VsZWN0ZWQgc3RvcmUgcmVzdG9yZWQgZm9yIGEgZGlmZmVyZW50IHByb2plY3RcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gaXQncyBiZXR0ZXIgbm90IHRvIHNheSBhbnl0aGluZyBoZXJlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluc3BlY3RlZFN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuc3RhdGUgPSBmb3JtYXRTdG9yZUZvckluc3BlY3RvclN0YXRlKGluc3BlY3RlZFN0b3JlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhcGkub24uZWRpdEluc3BlY3RvclN0YXRlKChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmFwcCA9PT0gYXBwICYmIHBheWxvYWQuaW5zcGVjdG9ySWQgPT09IElOU1BFQ1RPUl9JRCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluc3BlY3RlZFN0b3JlID0gcGF5bG9hZC5ub2RlSWQgPT09IFBJTklBX1JPT1RfSURcbiAgICAgICAgICAgICAgICAgICAgPyBwaW5pYVxuICAgICAgICAgICAgICAgICAgICA6IHBpbmlhLl9zLmdldChwYXlsb2FkLm5vZGVJZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnNwZWN0ZWRTdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9hc3RNZXNzYWdlKGBzdG9yZSBcIiR7cGF5bG9hZC5ub2RlSWR9XCIgbm90IGZvdW5kYCwgJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF0aCB9ID0gcGF5bG9hZDtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUGluaWEoaW5zcGVjdGVkU3RvcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFjY2VzcyBvbmx5IHRoZSBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aC5sZW5ndGggIT09IDEgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFpbnNwZWN0ZWRTdG9yZS5fY3VzdG9tUHJvcGVydGllcy5oYXMocGF0aFswXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhbMF0gaW4gaW5zcGVjdGVkU3RvcmUuJHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLnVuc2hpZnQoJyRzdGF0ZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBSb290IGFjY2Vzcywgd2UgY2FuIG9taXQgdGhlIGAudmFsdWVgIGJlY2F1c2UgdGhlIGRldnRvb2xzIEFQSSBkb2VzIGl0IGZvciB1c1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnVuc2hpZnQoJ3N0YXRlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlzVGltZWxpbmVBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnNldChpbnNwZWN0ZWRTdG9yZSwgcGF0aCwgcGF5bG9hZC5zdGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaXNUaW1lbGluZUFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhcGkub24uZWRpdENvbXBvbmVudFN0YXRlKChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBpZiAocGF5bG9hZC50eXBlLnN0YXJ0c1dpdGgoJ/CfjY0nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlSWQgPSBwYXlsb2FkLnR5cGUucmVwbGFjZSgvXvCfjY1cXHMqLywgJycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gcGluaWEuX3MuZ2V0KHN0b3JlSWQpO1xuICAgICAgICAgICAgICAgIGlmICghc3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvYXN0TWVzc2FnZShgc3RvcmUgXCIke3N0b3JlSWR9XCIgbm90IGZvdW5kYCwgJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF0aCB9ID0gcGF5bG9hZDtcbiAgICAgICAgICAgICAgICBpZiAocGF0aFswXSAhPT0gJ3N0YXRlJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9hc3RNZXNzYWdlKGBJbnZhbGlkIHBhdGggZm9yIHN0b3JlIFwiJHtzdG9yZUlkfVwiOlxcbiR7cGF0aH1cXG5Pbmx5IHN0YXRlIGNhbiBiZSBtb2RpZmllZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmV3cml0ZSB0aGUgZmlyc3QgZW50cnkgdG8gYmUgYWJsZSB0byBkaXJlY3RseSBzZXQgdGhlIHN0YXRlIGFzXG4gICAgICAgICAgICAgICAgLy8gd2VsbCBhcyBhbnkgb3RoZXIgcGF0aFxuICAgICAgICAgICAgICAgIHBhdGhbMF0gPSAnJHN0YXRlJztcbiAgICAgICAgICAgICAgICBpc1RpbWVsaW5lQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5zZXQoc3RvcmUsIHBhdGgsIHBheWxvYWQuc3RhdGUudmFsdWUpO1xuICAgICAgICAgICAgICAgIGlzVGltZWxpbmVBY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGFkZFN0b3JlVG9EZXZ0b29scyhhcHAsIHN0b3JlKSB7XG4gICAgaWYgKCFjb21wb25lbnRTdGF0ZVR5cGVzLmluY2x1ZGVzKGdldFN0b3JlVHlwZShzdG9yZS4kaWQpKSkge1xuICAgICAgICBjb21wb25lbnRTdGF0ZVR5cGVzLnB1c2goZ2V0U3RvcmVUeXBlKHN0b3JlLiRpZCkpO1xuICAgIH1cbiAgICBzZXR1cERldnRvb2xzUGx1Z2luKHtcbiAgICAgICAgaWQ6ICdkZXYuZXNtLnBpbmlhJyxcbiAgICAgICAgbGFiZWw6ICdQaW5pYSDwn42NJyxcbiAgICAgICAgbG9nbzogJ2h0dHBzOi8vcGluaWEudnVlanMub3JnL2xvZ28uc3ZnJyxcbiAgICAgICAgcGFja2FnZU5hbWU6ICdwaW5pYScsXG4gICAgICAgIGhvbWVwYWdlOiAnaHR0cHM6Ly9waW5pYS52dWVqcy5vcmcnLFxuICAgICAgICBjb21wb25lbnRTdGF0ZVR5cGVzLFxuICAgICAgICBhcHAsXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsb2dTdG9yZUNoYW5nZXM6IHtcbiAgICAgICAgICAgICAgICBsYWJlbDogJ05vdGlmeSBhYm91dCBuZXcvZGVsZXRlZCBzdG9yZXMnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gdXNlRW1vamlzOiB7XG4gICAgICAgICAgICAvLyAgIGxhYmVsOiAnVXNlIGVtb2ppcyBpbiBtZXNzYWdlcyDimqHvuI8nLFxuICAgICAgICAgICAgLy8gICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgICAvLyAgIGRlZmF1bHRWYWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgIC8vIH0sXG4gICAgICAgIH0sXG4gICAgfSwgKGFwaSkgPT4ge1xuICAgICAgICAvLyBncmFjZWZ1bGx5IGhhbmRsZSBlcnJvcnNcbiAgICAgICAgY29uc3Qgbm93ID0gdHlwZW9mIGFwaS5ub3cgPT09ICdmdW5jdGlvbicgPyBhcGkubm93LmJpbmQoYXBpKSA6IERhdGUubm93O1xuICAgICAgICBzdG9yZS4kb25BY3Rpb24oKHsgYWZ0ZXIsIG9uRXJyb3IsIG5hbWUsIGFyZ3MgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZ3JvdXBJZCA9IHJ1bm5pbmdBY3Rpb25JZCsrO1xuICAgICAgICAgICAgYXBpLmFkZFRpbWVsaW5lRXZlbnQoe1xuICAgICAgICAgICAgICAgIGxheWVySWQ6IE1VVEFUSU9OU19MQVlFUl9JRCxcbiAgICAgICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICAgICAgICB0aW1lOiBub3coKSxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICfwn5urICcgKyBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBzdWJ0aXRsZTogJ3N0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmU6IGZvcm1hdERpc3BsYXkoc3RvcmUuJGlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogZm9ybWF0RGlzcGxheShuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWZ0ZXIoKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGFjdGl2ZUFjdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBhcGkuYWRkVGltZWxpbmVFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgIGxheWVySWQ6IE1VVEFUSU9OU19MQVlFUl9JRCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IG5vdygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICfwn5usICcgKyBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VidGl0bGU6ICdlbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlOiBmb3JtYXREaXNwbGF5KHN0b3JlLiRpZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBmb3JtYXREaXNwbGF5KG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9uRXJyb3IoKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgYWN0aXZlQWN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGFwaS5hZGRUaW1lbGluZUV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJJZDogTVVUQVRJT05TX0xBWUVSX0lELFxuICAgICAgICAgICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogbm93KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dUeXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICfwn5KlICcgKyBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VidGl0bGU6ICdlbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlOiBmb3JtYXREaXNwbGF5KHN0b3JlLiRpZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBmb3JtYXREaXNwbGF5KG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgc3RvcmUuX2N1c3RvbVByb3BlcnRpZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgd2F0Y2goKCkgPT4gdW5yZWYoc3RvcmVbbmFtZV0pLCAobmV3VmFsdWUsIG9sZFZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgYXBpLm5vdGlmeUNvbXBvbmVudFVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yU3RhdGUoSU5TUEVDVE9SX0lEKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUaW1lbGluZUFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBhcGkuYWRkVGltZWxpbmVFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcklkOiBNVVRBVElPTlNfTEFZRVJfSUQsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IG5vdygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnQ2hhbmdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0aXRsZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSWQ6IGFjdGl2ZUFjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHsgZGVlcDogdHJ1ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0b3JlLiRzdWJzY3JpYmUoKHsgZXZlbnRzLCB0eXBlIH0sIHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBhcGkubm90aWZ5Q29tcG9uZW50VXBkYXRlKCk7XG4gICAgICAgICAgICBhcGkuc2VuZEluc3BlY3RvclN0YXRlKElOU1BFQ1RPUl9JRCk7XG4gICAgICAgICAgICBpZiAoIWlzVGltZWxpbmVBY3RpdmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gcm9vdFN0b3JlLnN0YXRlW3N0b3JlLmlkXSA9IHN0YXRlXG4gICAgICAgICAgICBjb25zdCBldmVudERhdGEgPSB7XG4gICAgICAgICAgICAgICAgdGltZTogbm93KCksXG4gICAgICAgICAgICAgICAgdGl0bGU6IGZvcm1hdE11dGF0aW9uVHlwZSh0eXBlKSxcbiAgICAgICAgICAgICAgICBkYXRhOiBhc3NpZ24kMSh7IHN0b3JlOiBmb3JtYXREaXNwbGF5KHN0b3JlLiRpZCkgfSwgZm9ybWF0RXZlbnREYXRhKGV2ZW50cykpLFxuICAgICAgICAgICAgICAgIGdyb3VwSWQ6IGFjdGl2ZUFjdGlvbixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gTXV0YXRpb25UeXBlLnBhdGNoRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBldmVudERhdGEuc3VidGl0bGUgPSAn4qS177iPJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IE11dGF0aW9uVHlwZS5wYXRjaE9iamVjdCkge1xuICAgICAgICAgICAgICAgIGV2ZW50RGF0YS5zdWJ0aXRsZSA9ICfwn6epJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50cyAmJiAhQXJyYXkuaXNBcnJheShldmVudHMpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnREYXRhLnN1YnRpdGxlID0gZXZlbnRzLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgZXZlbnREYXRhLmRhdGFbJ3Jhd0V2ZW50KHMpJ10gPSB7XG4gICAgICAgICAgICAgICAgICAgIF9jdXN0b206IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdEZWJ1Z2dlckV2ZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogJ3JhdyBEZWJ1Z2dlckV2ZW50W10nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXBpLmFkZFRpbWVsaW5lRXZlbnQoe1xuICAgICAgICAgICAgICAgIGxheWVySWQ6IE1VVEFUSU9OU19MQVlFUl9JRCxcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnREYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHsgZGV0YWNoZWQ6IHRydWUsIGZsdXNoOiAnc3luYycgfSk7XG4gICAgICAgIGNvbnN0IGhvdFVwZGF0ZSA9IHN0b3JlLl9ob3RVcGRhdGU7XG4gICAgICAgIHN0b3JlLl9ob3RVcGRhdGUgPSBtYXJrUmF3KChuZXdTdG9yZSkgPT4ge1xuICAgICAgICAgICAgaG90VXBkYXRlKG5ld1N0b3JlKTtcbiAgICAgICAgICAgIGFwaS5hZGRUaW1lbGluZUV2ZW50KHtcbiAgICAgICAgICAgICAgICBsYXllcklkOiBNVVRBVElPTlNfTEFZRVJfSUQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdGltZTogbm93KCksXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAn8J+UpSAnICsgc3RvcmUuJGlkLFxuICAgICAgICAgICAgICAgICAgICBzdWJ0aXRsZTogJ0hNUiB1cGRhdGUnLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZTogZm9ybWF0RGlzcGxheShzdG9yZS4kaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mbzogZm9ybWF0RGlzcGxheShgSE1SIHVwZGF0ZWApLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgZGV2dG9vbHMgdG9vXG4gICAgICAgICAgICBhcGkubm90aWZ5Q29tcG9uZW50VXBkYXRlKCk7XG4gICAgICAgICAgICBhcGkuc2VuZEluc3BlY3RvclRyZWUoSU5TUEVDVE9SX0lEKTtcbiAgICAgICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yU3RhdGUoSU5TUEVDVE9SX0lEKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgJGRpc3Bvc2UgfSA9IHN0b3JlO1xuICAgICAgICBzdG9yZS4kZGlzcG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgICRkaXNwb3NlKCk7XG4gICAgICAgICAgICBhcGkubm90aWZ5Q29tcG9uZW50VXBkYXRlKCk7XG4gICAgICAgICAgICBhcGkuc2VuZEluc3BlY3RvclRyZWUoSU5TUEVDVE9SX0lEKTtcbiAgICAgICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yU3RhdGUoSU5TUEVDVE9SX0lEKTtcbiAgICAgICAgICAgIGFwaS5nZXRTZXR0aW5ncygpLmxvZ1N0b3JlQ2hhbmdlcyAmJlxuICAgICAgICAgICAgICAgIHRvYXN0TWVzc2FnZShgRGlzcG9zZWQgXCIke3N0b3JlLiRpZH1cIiBzdG9yZSDwn5eRYCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHRyaWdnZXIgYW4gdXBkYXRlIHNvIGl0IGNhbiBkaXNwbGF5IG5ldyByZWdpc3RlcmVkIHN0b3Jlc1xuICAgICAgICBhcGkubm90aWZ5Q29tcG9uZW50VXBkYXRlKCk7XG4gICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yVHJlZShJTlNQRUNUT1JfSUQpO1xuICAgICAgICBhcGkuc2VuZEluc3BlY3RvclN0YXRlKElOU1BFQ1RPUl9JRCk7XG4gICAgICAgIGFwaS5nZXRTZXR0aW5ncygpLmxvZ1N0b3JlQ2hhbmdlcyAmJlxuICAgICAgICAgICAgdG9hc3RNZXNzYWdlKGBcIiR7c3RvcmUuJGlkfVwiIHN0b3JlIGluc3RhbGxlZCDwn4aVYCk7XG4gICAgfSk7XG59XG5sZXQgcnVubmluZ0FjdGlvbklkID0gMDtcbmxldCBhY3RpdmVBY3Rpb247XG4vKipcbiAqIFBhdGNoZXMgYSBzdG9yZSB0byBlbmFibGUgYWN0aW9uIGdyb3VwaW5nIGluIGRldnRvb2xzIGJ5IHdyYXBwaW5nIHRoZSBzdG9yZSB3aXRoIGEgUHJveHkgdGhhdCBpcyBwYXNzZWQgYXMgdGhlXG4gKiBjb250ZXh0IG9mIGFsbCBhY3Rpb25zLCBhbGxvd2luZyB1cyB0byBzZXQgYHJ1bm5pbmdBY3Rpb25gIG9uIGVhY2ggYWNjZXNzIGFuZCBlZmZlY3RpdmVseSBhc3NvY2lhdGluZyBhbnkgc3RhdGVcbiAqIG11dGF0aW9uIHRvIHRoZSBhY3Rpb24uXG4gKlxuICogQHBhcmFtIHN0b3JlIC0gc3RvcmUgdG8gcGF0Y2hcbiAqIEBwYXJhbSBhY3Rpb25OYW1lcyAtIGxpc3Qgb2YgYWN0aW9uc3QgdG8gcGF0Y2hcbiAqL1xuZnVuY3Rpb24gcGF0Y2hBY3Rpb25Gb3JHcm91cGluZyhzdG9yZSwgYWN0aW9uTmFtZXMsIHdyYXBXaXRoUHJveHkpIHtcbiAgICAvLyBvcmlnaW5hbCBhY3Rpb25zIG9mIHRoZSBzdG9yZSBhcyB0aGV5IGFyZSBnaXZlbiBieSBwaW5pYS4gV2UgYXJlIGdvaW5nIHRvIG92ZXJyaWRlIHRoZW1cbiAgICBjb25zdCBhY3Rpb25zID0gYWN0aW9uTmFtZXMucmVkdWNlKChzdG9yZUFjdGlvbnMsIGFjdGlvbk5hbWUpID0+IHtcbiAgICAgICAgLy8gdXNlIHRvUmF3IHRvIGF2b2lkIHRyYWNraW5nICM1NDFcbiAgICAgICAgc3RvcmVBY3Rpb25zW2FjdGlvbk5hbWVdID0gdG9SYXcoc3RvcmUpW2FjdGlvbk5hbWVdO1xuICAgICAgICByZXR1cm4gc3RvcmVBY3Rpb25zO1xuICAgIH0sIHt9KTtcbiAgICBmb3IgKGNvbnN0IGFjdGlvbk5hbWUgaW4gYWN0aW9ucykge1xuICAgICAgICBzdG9yZVthY3Rpb25OYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHRoZSBydW5uaW5nIGFjdGlvbiBpZCBpcyBpbmNyZW1lbnRlZCBpbiBhIGJlZm9yZSBhY3Rpb24gaG9va1xuICAgICAgICAgICAgY29uc3QgX2FjdGlvbklkID0gcnVubmluZ0FjdGlvbklkO1xuICAgICAgICAgICAgY29uc3QgdHJhY2tlZFN0b3JlID0gd3JhcFdpdGhQcm94eVxuICAgICAgICAgICAgICAgID8gbmV3IFByb3h5KHN0b3JlLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVBY3Rpb24gPSBfYWN0aW9uSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQoLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNldCguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVBY3Rpb24gPSBfYWN0aW9uSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5zZXQoLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICA6IHN0b3JlO1xuICAgICAgICAgICAgLy8gRm9yIFNldHVwIFN0b3JlcyB3ZSBuZWVkIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFzeW5jLWNvbnRleHRcbiAgICAgICAgICAgIGFjdGl2ZUFjdGlvbiA9IF9hY3Rpb25JZDtcbiAgICAgICAgICAgIGNvbnN0IHJldFZhbHVlID0gYWN0aW9uc1thY3Rpb25OYW1lXS5hcHBseSh0cmFja2VkU3RvcmUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHNhZmVyIGFzIGFzeW5jIGFjdGlvbnMgaW4gU2V0dXAgU3RvcmVzIHdvdWxkIGFzc29jaWF0ZSBtdXRhdGlvbnMgZG9uZSBvdXRzaWRlIG9mIHRoZSBhY3Rpb25cbiAgICAgICAgICAgIGFjdGl2ZUFjdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiByZXRWYWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqIHBpbmlhLnVzZShkZXZ0b29sc1BsdWdpbilcbiAqL1xuZnVuY3Rpb24gZGV2dG9vbHNQbHVnaW4oeyBhcHAsIHN0b3JlLCBvcHRpb25zIH0pIHtcbiAgICAvLyBITVIgbW9kdWxlXG4gICAgaWYgKHN0b3JlLiRpZC5zdGFydHNXaXRoKCdfX2hvdDonKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGRldGVjdCBvcHRpb24gYXBpIHZzIHNldHVwIGFwaVxuICAgIHN0b3JlLl9pc09wdGlvbnNBUEkgPSAhIW9wdGlvbnMuc3RhdGU7XG4gICAgcGF0Y2hBY3Rpb25Gb3JHcm91cGluZyhzdG9yZSwgT2JqZWN0LmtleXMob3B0aW9ucy5hY3Rpb25zKSwgc3RvcmUuX2lzT3B0aW9uc0FQSSk7XG4gICAgLy8gVXBncmFkZSB0aGUgSE1SIHRvIGFsc28gdXBkYXRlIHRoZSBuZXcgYWN0aW9uc1xuICAgIGNvbnN0IG9yaWdpbmFsSG90VXBkYXRlID0gc3RvcmUuX2hvdFVwZGF0ZTtcbiAgICB0b1JhdyhzdG9yZSkuX2hvdFVwZGF0ZSA9IGZ1bmN0aW9uIChuZXdTdG9yZSkge1xuICAgICAgICBvcmlnaW5hbEhvdFVwZGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBwYXRjaEFjdGlvbkZvckdyb3VwaW5nKHN0b3JlLCBPYmplY3Qua2V5cyhuZXdTdG9yZS5faG1yUGF5bG9hZC5hY3Rpb25zKSwgISFzdG9yZS5faXNPcHRpb25zQVBJKTtcbiAgICB9O1xuICAgIGFkZFN0b3JlVG9EZXZ0b29scyhhcHAsIFxuICAgIC8vIEZJWE1FOiBpcyB0aGVyZSBhIHdheSB0byBhbGxvdyB0aGUgYXNzaWdubWVudCBmcm9tIFN0b3JlPElkLCBTLCBHLCBBPiB0byBTdG9yZUdlbmVyaWM/XG4gICAgc3RvcmUpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBQaW5pYSBpbnN0YW5jZSB0byBiZSB1c2VkIGJ5IHRoZSBhcHBsaWNhdGlvblxuICovXG5mdW5jdGlvbiBjcmVhdGVQaW5pYSgpIHtcbiAgICBjb25zdCBzY29wZSA9IGVmZmVjdFNjb3BlKHRydWUpO1xuICAgIC8vIE5PVEU6IGhlcmUgd2UgY291bGQgY2hlY2sgdGhlIHdpbmRvdyBvYmplY3QgZm9yIGEgc3RhdGUgYW5kIGRpcmVjdGx5IHNldCBpdFxuICAgIC8vIGlmIHRoZXJlIGlzIGFueXRoaW5nIGxpa2UgaXQgd2l0aCBWdWUgMyBTU1JcbiAgICBjb25zdCBzdGF0ZSA9IHNjb3BlLnJ1bigoKSA9PiByZWYoe30pKTtcbiAgICBsZXQgX3AgPSBbXTtcbiAgICAvLyBwbHVnaW5zIGFkZGVkIGJlZm9yZSBjYWxsaW5nIGFwcC51c2UocGluaWEpXG4gICAgbGV0IHRvQmVJbnN0YWxsZWQgPSBbXTtcbiAgICBjb25zdCBwaW5pYSA9IG1hcmtSYXcoe1xuICAgICAgICBpbnN0YWxsKGFwcCkge1xuICAgICAgICAgICAgLy8gdGhpcyBhbGxvd3MgY2FsbGluZyB1c2VTdG9yZSgpIG91dHNpZGUgb2YgYSBjb21wb25lbnQgc2V0dXAgYWZ0ZXJcbiAgICAgICAgICAgIC8vIGluc3RhbGxpbmcgcGluaWEncyBwbHVnaW5cbiAgICAgICAgICAgIHNldEFjdGl2ZVBpbmlhKHBpbmlhKTtcbiAgICAgICAgICAgIGlmICghaXNWdWUyKSB7XG4gICAgICAgICAgICAgICAgcGluaWEuX2EgPSBhcHA7XG4gICAgICAgICAgICAgICAgYXBwLnByb3ZpZGUocGluaWFTeW1ib2wsIHBpbmlhKTtcbiAgICAgICAgICAgICAgICBhcHAuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMuJHBpbmlhID0gcGluaWE7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAoVVNFX0RFVlRPT0xTKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyUGluaWFEZXZ0b29scyhhcHAsIHBpbmlhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9CZUluc3RhbGxlZC5mb3JFYWNoKChwbHVnaW4pID0+IF9wLnB1c2gocGx1Z2luKSk7XG4gICAgICAgICAgICAgICAgdG9CZUluc3RhbGxlZCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1c2UocGx1Z2luKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2EgJiYgIWlzVnVlMikge1xuICAgICAgICAgICAgICAgIHRvQmVJbnN0YWxsZWQucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3AucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIF9wLFxuICAgICAgICAvLyBpdCdzIGFjdHVhbGx5IHVuZGVmaW5lZCBoZXJlXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgX2E6IG51bGwsXG4gICAgICAgIF9lOiBzY29wZSxcbiAgICAgICAgX3M6IG5ldyBNYXAoKSxcbiAgICAgICAgc3RhdGUsXG4gICAgfSk7XG4gICAgLy8gcGluaWEgZGV2dG9vbHMgcmVseSBvbiBkZXYgb25seSBmZWF0dXJlcyBzbyB0aGV5IGNhbm5vdCBiZSBmb3JjZWQgdW5sZXNzXG4gICAgLy8gdGhlIGRldiBidWlsZCBvZiBWdWUgaXMgdXNlZC4gQXZvaWQgb2xkIGJyb3dzZXJzIGxpa2UgSUUxMS5cbiAgICBpZiAoVVNFX0RFVlRPT0xTICYmIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGluaWEudXNlKGRldnRvb2xzUGx1Z2luKTtcbiAgICB9XG4gICAgcmV0dXJuIHBpbmlhO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGZ1bmN0aW9uIGlzIGEgYFN0b3JlRGVmaW5pdGlvbmAuXG4gKlxuICogQHBhcmFtIGZuIC0gb2JqZWN0IHRvIHRlc3RcbiAqIEByZXR1cm5zIHRydWUgaWYgYGZuYCBpcyBhIFN0b3JlRGVmaW5pdGlvblxuICovXG5jb25zdCBpc1VzZVN0b3JlID0gKGZuKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZm4uJGlkID09PSAnc3RyaW5nJztcbn07XG4vKipcbiAqIE11dGF0ZXMgaW4gcGxhY2UgYG5ld1N0YXRlYCB3aXRoIGBvbGRTdGF0ZWAgdG8gX2hvdCB1cGRhdGVfIGl0LiBJdCB3aWxsXG4gKiByZW1vdmUgYW55IGtleSBub3QgZXhpc3RpbmcgaW4gYG5ld1N0YXRlYCBhbmQgcmVjdXJzaXZlbHkgbWVyZ2UgcGxhaW5cbiAqIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIG5ld1N0YXRlIC0gbmV3IHN0YXRlIG9iamVjdCB0byBiZSBwYXRjaGVkXG4gKiBAcGFyYW0gb2xkU3RhdGUgLSBvbGQgc3RhdGUgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBwYXRjaCBuZXdTdGF0ZVxuICogQHJldHVybnMgLSBuZXdTdGF0ZVxuICovXG5mdW5jdGlvbiBwYXRjaE9iamVjdChuZXdTdGF0ZSwgb2xkU3RhdGUpIHtcbiAgICAvLyBubyBuZWVkIHRvIGdvIHRocm91Z2ggc3ltYm9scyBiZWNhdXNlIHRoZXkgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYW55d2F5XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2xkU3RhdGUpIHtcbiAgICAgICAgY29uc3Qgc3ViUGF0Y2ggPSBvbGRTdGF0ZVtrZXldO1xuICAgICAgICAvLyBza2lwIHRoZSB3aG9sZSBzdWIgdHJlZVxuICAgICAgICBpZiAoIShrZXkgaW4gbmV3U3RhdGUpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IG5ld1N0YXRlW2tleV07XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldFZhbHVlKSAmJlxuICAgICAgICAgICAgaXNQbGFpbk9iamVjdChzdWJQYXRjaCkgJiZcbiAgICAgICAgICAgICFpc1JlZihzdWJQYXRjaCkgJiZcbiAgICAgICAgICAgICFpc1JlYWN0aXZlKHN1YlBhdGNoKSkge1xuICAgICAgICAgICAgbmV3U3RhdGVba2V5XSA9IHBhdGNoT2JqZWN0KHRhcmdldFZhbHVlLCBzdWJQYXRjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBvYmplY3RzIGFyZSBlaXRoZXIgYSBiaXQgbW9yZSBjb21wbGV4IChlLmcuIHJlZnMpIG9yIHByaW1pdGl2ZXMsIHNvIHdlXG4gICAgICAgICAgICAvLyBqdXN0IHNldCB0aGUgd2hvbGUgdGhpbmdcbiAgICAgICAgICAgIGlmIChpc1Z1ZTIpIHtcbiAgICAgICAgICAgICAgICBzZXQobmV3U3RhdGUsIGtleSwgc3ViUGF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGVba2V5XSA9IHN1YlBhdGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdTdGF0ZTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBfYWNjZXB0XyBmdW5jdGlvbiB0byBwYXNzIHRvIGBpbXBvcnQubWV0YS5ob3RgIGluIFZpdGUgYXBwbGljYXRpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogY29uc3QgdXNlVXNlciA9IGRlZmluZVN0b3JlKC4uLilcbiAqIGlmIChpbXBvcnQubWV0YS5ob3QpIHtcbiAqICAgaW1wb3J0Lm1ldGEuaG90LmFjY2VwdChhY2NlcHRITVJVcGRhdGUodXNlVXNlciwgaW1wb3J0Lm1ldGEuaG90KSlcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBpbml0aWFsVXNlU3RvcmUgLSByZXR1cm4gb2YgdGhlIGRlZmluZVN0b3JlIHRvIGhvdCB1cGRhdGVcbiAqIEBwYXJhbSBob3QgLSBgaW1wb3J0Lm1ldGEuaG90YFxuICovXG5mdW5jdGlvbiBhY2NlcHRITVJVcGRhdGUoaW5pdGlhbFVzZVN0b3JlLCBob3QpIHtcbiAgICAvLyBzdHJpcCBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gaWlmZS5wcm9kXG4gICAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHsgfTtcbiAgICB9XG4gICAgcmV0dXJuIChuZXdNb2R1bGUpID0+IHtcbiAgICAgICAgY29uc3QgcGluaWEgPSBob3QuZGF0YS5waW5pYSB8fCBpbml0aWFsVXNlU3RvcmUuX3BpbmlhO1xuICAgICAgICBpZiAoIXBpbmlhKSB7XG4gICAgICAgICAgICAvLyB0aGlzIHN0b3JlIGlzIHN0aWxsIG5vdCB1c2VkXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJlc2VydmUgdGhlIHBpbmlhIGluc3RhbmNlIGFjcm9zcyBsb2Fkc1xuICAgICAgICBob3QuZGF0YS5waW5pYSA9IHBpbmlhO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnZ290IGRhdGEnLCBuZXdTdG9yZSlcbiAgICAgICAgZm9yIChjb25zdCBleHBvcnROYW1lIGluIG5ld01vZHVsZSkge1xuICAgICAgICAgICAgY29uc3QgdXNlU3RvcmUgPSBuZXdNb2R1bGVbZXhwb3J0TmFtZV07XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnY2hlY2tpbmcgZm9yJywgZXhwb3J0TmFtZSlcbiAgICAgICAgICAgIGlmIChpc1VzZVN0b3JlKHVzZVN0b3JlKSAmJiBwaW5pYS5fcy5oYXModXNlU3RvcmUuJGlkKSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdBY2NlcHRpbmcgdXBkYXRlIGZvcicsIHVzZVN0b3JlLiRpZClcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IHVzZVN0b3JlLiRpZDtcbiAgICAgICAgICAgICAgICBpZiAoaWQgIT09IGluaXRpYWxVc2VTdG9yZS4kaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBUaGUgaWQgb2YgdGhlIHN0b3JlIGNoYW5nZWQgZnJvbSBcIiR7aW5pdGlhbFVzZVN0b3JlLiRpZH1cIiB0byBcIiR7aWR9XCIuIFJlbG9hZGluZy5gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIGltcG9ydC5tZXRhLmhvdC5pbnZhbGlkYXRlKClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhvdC5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nU3RvcmUgPSBwaW5pYS5fcy5nZXQoaWQpO1xuICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmdTdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW1BpbmlhXTogc2tpcHBpbmcgaG1yIGJlY2F1c2Ugc3RvcmUgZG9lc24ndCBleGlzdCB5ZXRgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1c2VTdG9yZShwaW5pYSwgZXhpc3RpbmdTdG9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5jb25zdCBub29wID0gKCkgPT4geyB9O1xuZnVuY3Rpb24gYWRkU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbnMsIGNhbGxiYWNrLCBkZXRhY2hlZCwgb25DbGVhbnVwID0gbm9vcCkge1xuICAgIHN1YnNjcmlwdGlvbnMucHVzaChjYWxsYmFjayk7XG4gICAgY29uc3QgcmVtb3ZlU3Vic2NyaXB0aW9uID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBpZHggPSBzdWJzY3JpcHRpb25zLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICBpZiAoaWR4ID4gLTEpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICBvbkNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKCFkZXRhY2hlZCAmJiBnZXRDdXJyZW50U2NvcGUoKSkge1xuICAgICAgICBvblNjb3BlRGlzcG9zZShyZW1vdmVTdWJzY3JpcHRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gcmVtb3ZlU3Vic2NyaXB0aW9uO1xufVxuZnVuY3Rpb24gdHJpZ2dlclN1YnNjcmlwdGlvbnMoc3Vic2NyaXB0aW9ucywgLi4uYXJncykge1xuICAgIHN1YnNjcmlwdGlvbnMuc2xpY2UoKS5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgICBjYWxsYmFjayguLi5hcmdzKTtcbiAgICB9KTtcbn1cblxuY29uc3QgZmFsbGJhY2tSdW5XaXRoQ29udGV4dCA9IChmbikgPT4gZm4oKTtcbmZ1bmN0aW9uIG1lcmdlUmVhY3RpdmVPYmplY3RzKHRhcmdldCwgcGF0Y2hUb0FwcGx5KSB7XG4gICAgLy8gSGFuZGxlIE1hcCBpbnN0YW5jZXNcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTWFwICYmIHBhdGNoVG9BcHBseSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBwYXRjaFRvQXBwbHkuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gdGFyZ2V0LnNldChrZXksIHZhbHVlKSk7XG4gICAgfVxuICAgIC8vIEhhbmRsZSBTZXQgaW5zdGFuY2VzXG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFNldCAmJiBwYXRjaFRvQXBwbHkgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgcGF0Y2hUb0FwcGx5LmZvckVhY2godGFyZ2V0LmFkZCwgdGFyZ2V0KTtcbiAgICB9XG4gICAgLy8gbm8gbmVlZCB0byBnbyB0aHJvdWdoIHN5bWJvbHMgYmVjYXVzZSB0aGV5IGNhbm5vdCBiZSBzZXJpYWxpemVkIGFueXdheVxuICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoVG9BcHBseSkge1xuICAgICAgICBpZiAoIXBhdGNoVG9BcHBseS5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHN1YlBhdGNoID0gcGF0Y2hUb0FwcGx5W2tleV07XG4gICAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldFZhbHVlKSAmJlxuICAgICAgICAgICAgaXNQbGFpbk9iamVjdChzdWJQYXRjaCkgJiZcbiAgICAgICAgICAgIHRhcmdldC5oYXNPd25Qcm9wZXJ0eShrZXkpICYmXG4gICAgICAgICAgICAhaXNSZWYoc3ViUGF0Y2gpICYmXG4gICAgICAgICAgICAhaXNSZWFjdGl2ZShzdWJQYXRjaCkpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IGhlcmUgSSB3YW50ZWQgdG8gd2FybiBhYm91dCBpbmNvbnNpc3RlbnQgdHlwZXMgYnV0IGl0J3Mgbm90IHBvc3NpYmxlIGJlY2F1c2UgaW4gc2V0dXAgc3RvcmVzIG9uZSBtaWdodFxuICAgICAgICAgICAgLy8gc3RhcnQgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgYXMgYSBjZXJ0YWluIHR5cGUgZS5nLiBhIE1hcCwgYW5kIHRoZW4gZm9yIHNvbWUgcmVhc29uLCBkdXJpbmcgU1NSLCBjaGFuZ2UgdGhhdFxuICAgICAgICAgICAgLy8gdG8gYHVuZGVmaW5lZGAuIFdoZW4gdHJ5aW5nIHRvIGh5ZHJhdGUsIHdlIHdhbnQgdG8gb3ZlcnJpZGUgdGhlIE1hcCB3aXRoIGB1bmRlZmluZWRgLlxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBtZXJnZVJlYWN0aXZlT2JqZWN0cyh0YXJnZXRWYWx1ZSwgc3ViUGF0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogc3ViUGF0Y2ggaXMgYSB2YWxpZCB2YWx1ZVxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzdWJQYXRjaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuY29uc3Qgc2tpcEh5ZHJhdGVTeW1ib2wgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICA/IFN5bWJvbCgncGluaWE6c2tpcEh5ZHJhdGlvbicpXG4gICAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBTeW1ib2woKTtcbmNvbnN0IHNraXBIeWRyYXRlTWFwID0gLyojX19QVVJFX18qLyBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBUZWxscyBQaW5pYSB0byBza2lwIHRoZSBoeWRyYXRpb24gcHJvY2VzcyBvZiBhIGdpdmVuIG9iamVjdC4gVGhpcyBpcyB1c2VmdWwgaW4gc2V0dXAgc3RvcmVzIChvbmx5KSB3aGVuIHlvdSByZXR1cm4gYVxuICogc3RhdGVmdWwgb2JqZWN0IGluIHRoZSBzdG9yZSBidXQgaXQgaXNuJ3QgcmVhbGx5IHN0YXRlLiBlLmcuIHJldHVybmluZyBhIHJvdXRlciBpbnN0YW5jZSBpbiBhIHNldHVwIHN0b3JlLlxuICpcbiAqIEBwYXJhbSBvYmogLSB0YXJnZXQgb2JqZWN0XG4gKiBAcmV0dXJucyBvYmpcbiAqL1xuZnVuY3Rpb24gc2tpcEh5ZHJhdGUob2JqKSB7XG4gICAgcmV0dXJuIGlzVnVlMlxuICAgICAgICA/IC8vIGluIEB2dWUvY29tcG9zaXRpb24tYXBpLCB0aGUgcmVmcyBhcmUgc2VhbGVkIHNvIGRlZmluZVByb3BlcnR5IGRvZXNuJ3Qgd29yay4uLlxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gc2tpcEh5ZHJhdGVNYXAuc2V0KG9iaiwgMSkgJiYgb2JqXG4gICAgICAgIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgc2tpcEh5ZHJhdGVTeW1ib2wsIHt9KTtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGEgdmFsdWUgc2hvdWxkIGJlIGh5ZHJhdGVkXG4gKlxuICogQHBhcmFtIG9iaiAtIHRhcmdldCB2YXJpYWJsZVxuICogQHJldHVybnMgdHJ1ZSBpZiBgb2JqYCBzaG91bGQgYmUgaHlkcmF0ZWRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkSHlkcmF0ZShvYmopIHtcbiAgICByZXR1cm4gaXNWdWUyXG4gICAgICAgID8gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gIXNraXBIeWRyYXRlTWFwLmhhcyhvYmopXG4gICAgICAgIDogIWlzUGxhaW5PYmplY3Qob2JqKSB8fCAhb2JqLmhhc093blByb3BlcnR5KHNraXBIeWRyYXRlU3ltYm9sKTtcbn1cbmNvbnN0IHsgYXNzaWduIH0gPSBPYmplY3Q7XG5mdW5jdGlvbiBpc0NvbXB1dGVkKG8pIHtcbiAgICByZXR1cm4gISEoaXNSZWYobykgJiYgby5lZmZlY3QpO1xufVxuZnVuY3Rpb24gY3JlYXRlT3B0aW9uc1N0b3JlKGlkLCBvcHRpb25zLCBwaW5pYSwgaG90KSB7XG4gICAgY29uc3QgeyBzdGF0ZSwgYWN0aW9ucywgZ2V0dGVycyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBpbml0aWFsU3RhdGUgPSBwaW5pYS5zdGF0ZS52YWx1ZVtpZF07XG4gICAgbGV0IHN0b3JlO1xuICAgIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgICAgICBpZiAoIWluaXRpYWxTdGF0ZSAmJiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAhaG90KSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoaXNWdWUyKSB7XG4gICAgICAgICAgICAgICAgc2V0KHBpbmlhLnN0YXRlLnZhbHVlLCBpZCwgc3RhdGUgPyBzdGF0ZSgpIDoge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGluaWEuc3RhdGUudmFsdWVbaWRdID0gc3RhdGUgPyBzdGF0ZSgpIDoge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXZvaWQgY3JlYXRpbmcgYSBzdGF0ZSBpbiBwaW5pYS5zdGF0ZS52YWx1ZVxuICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGhvdFxuICAgICAgICAgICAgPyAvLyB1c2UgcmVmKCkgdG8gdW53cmFwIHJlZnMgaW5zaWRlIHN0YXRlIFRPRE86IGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgdG9SZWZzKHJlZihzdGF0ZSA/IHN0YXRlKCkgOiB7fSkudmFsdWUpXG4gICAgICAgICAgICA6IHRvUmVmcyhwaW5pYS5zdGF0ZS52YWx1ZVtpZF0pO1xuICAgICAgICByZXR1cm4gYXNzaWduKGxvY2FsU3RhdGUsIGFjdGlvbnMsIE9iamVjdC5rZXlzKGdldHRlcnMgfHwge30pLnJlZHVjZSgoY29tcHV0ZWRHZXR0ZXJzLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG5hbWUgaW4gbG9jYWxTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW/CfjY1dOiBBIGdldHRlciBjYW5ub3QgaGF2ZSB0aGUgc2FtZSBuYW1lIGFzIGFub3RoZXIgc3RhdGUgcHJvcGVydHkuIFJlbmFtZSBvbmUgb2YgdGhlbS4gRm91bmQgd2l0aCBcIiR7bmFtZX1cIiBpbiBzdG9yZSBcIiR7aWR9XCIuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wdXRlZEdldHRlcnNbbmFtZV0gPSBtYXJrUmF3KGNvbXB1dGVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRBY3RpdmVQaW5pYShwaW5pYSk7XG4gICAgICAgICAgICAgICAgLy8gaXQgd2FzIGNyZWF0ZWQganVzdCBiZWZvcmVcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHBpbmlhLl9zLmdldChpZCk7XG4gICAgICAgICAgICAgICAgLy8gYWxsb3cgY3Jvc3MgdXNpbmcgc3RvcmVzXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICBpZiAoaXNWdWUyICYmICFzdG9yZS5fcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gZ2V0dGVycyFbbmFtZV0uY2FsbChjb250ZXh0LCBjb250ZXh0KVxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGF2b2lkIHJlYWRpbmcgdGhlIGdldHRlciB3aGlsZSBhc3NpZ25pbmcgd2l0aCBhIGdsb2JhbCB2YXJpYWJsZVxuICAgICAgICAgICAgICAgIHJldHVybiBnZXR0ZXJzW25hbWVdLmNhbGwoc3RvcmUsIHN0b3JlKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlZEdldHRlcnM7XG4gICAgICAgIH0sIHt9KSk7XG4gICAgfVxuICAgIHN0b3JlID0gY3JlYXRlU2V0dXBTdG9yZShpZCwgc2V0dXAsIG9wdGlvbnMsIHBpbmlhLCBob3QsIHRydWUpO1xuICAgIHJldHVybiBzdG9yZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNldHVwU3RvcmUoJGlkLCBzZXR1cCwgb3B0aW9ucyA9IHt9LCBwaW5pYSwgaG90LCBpc09wdGlvbnNTdG9yZSkge1xuICAgIGxldCBzY29wZTtcbiAgICBjb25zdCBvcHRpb25zRm9yUGx1Z2luID0gYXNzaWduKHsgYWN0aW9uczoge30gfSwgb3B0aW9ucyk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhcGluaWEuX2UuYWN0aXZlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGluaWEgZGVzdHJveWVkJyk7XG4gICAgfVxuICAgIC8vIHdhdGNoZXIgb3B0aW9ucyBmb3IgJHN1YnNjcmliZVxuICAgIGNvbnN0ICRzdWJzY3JpYmVPcHRpb25zID0ge1xuICAgICAgICBkZWVwOiB0cnVlLFxuICAgICAgICAvLyBmbHVzaDogJ3Bvc3QnLFxuICAgIH07XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc1Z1ZTIpIHtcbiAgICAgICAgJHN1YnNjcmliZU9wdGlvbnMub25UcmlnZ2VyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKGlzTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICAgICAgZGVidWdnZXJFdmVudHMgPSBldmVudDtcbiAgICAgICAgICAgICAgICAvLyBhdm9pZCB0cmlnZ2VyaW5nIHRoaXMgd2hpbGUgdGhlIHN0b3JlIGlzIGJlaW5nIGJ1aWx0IGFuZCB0aGUgc3RhdGUgaXMgYmVpbmcgc2V0IGluIHBpbmlhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0xpc3RlbmluZyA9PSBmYWxzZSAmJiAhc3RvcmUuX2hvdFVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gbGV0IHBhdGNoIHNlbmQgYWxsIHRoZSBldmVudHMgdG9nZXRoZXIgbGF0ZXJcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlYnVnZ2VyRXZlbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z2dlckV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ/CfjY0gZGVidWdnZXJFdmVudHMgc2hvdWxkIGJlIGFuIGFycmF5LiBUaGlzIGlzIG1vc3QgbGlrZWx5IGFuIGludGVybmFsIFBpbmlhIGJ1Zy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGludGVybmFsIHN0YXRlXG4gICAgbGV0IGlzTGlzdGVuaW5nOyAvLyBzZXQgdG8gdHJ1ZSBhdCB0aGUgZW5kXG4gICAgbGV0IGlzU3luY0xpc3RlbmluZzsgLy8gc2V0IHRvIHRydWUgYXQgdGhlIGVuZFxuICAgIGxldCBzdWJzY3JpcHRpb25zID0gW107XG4gICAgbGV0IGFjdGlvblN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICBsZXQgZGVidWdnZXJFdmVudHM7XG4gICAgY29uc3QgaW5pdGlhbFN0YXRlID0gcGluaWEuc3RhdGUudmFsdWVbJGlkXTtcbiAgICAvLyBhdm9pZCBzZXR0aW5nIHRoZSBzdGF0ZSBmb3Igb3B0aW9uIHN0b3JlcyBpZiBpdCBpcyBzZXRcbiAgICAvLyBieSB0aGUgc2V0dXBcbiAgICBpZiAoIWlzT3B0aW9uc1N0b3JlICYmICFpbml0aWFsU3RhdGUgJiYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgIWhvdCkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc1Z1ZTIpIHtcbiAgICAgICAgICAgIHNldChwaW5pYS5zdGF0ZS52YWx1ZSwgJGlkLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwaW5pYS5zdGF0ZS52YWx1ZVskaWRdID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaG90U3RhdGUgPSByZWYoe30pO1xuICAgIC8vIGF2b2lkIHRyaWdnZXJpbmcgdG9vIG1hbnkgbGlzdGVuZXJzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3BpbmlhL2lzc3Vlcy8xMTI5XG4gICAgbGV0IGFjdGl2ZUxpc3RlbmVyO1xuICAgIGZ1bmN0aW9uICRwYXRjaChwYXJ0aWFsU3RhdGVPck11dGF0b3IpIHtcbiAgICAgICAgbGV0IHN1YnNjcmlwdGlvbk11dGF0aW9uO1xuICAgICAgICBpc0xpc3RlbmluZyA9IGlzU3luY0xpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgICAvLyByZXNldCB0aGUgZGVidWdnZXIgZXZlbnRzIHNpbmNlIHBhdGNoZXMgYXJlIHN5bmNcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgZGVidWdnZXJFdmVudHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhcnRpYWxTdGF0ZU9yTXV0YXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcGFydGlhbFN0YXRlT3JNdXRhdG9yKHBpbmlhLnN0YXRlLnZhbHVlWyRpZF0pO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uTXV0YXRpb24gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogTXV0YXRpb25UeXBlLnBhdGNoRnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgc3RvcmVJZDogJGlkLFxuICAgICAgICAgICAgICAgIGV2ZW50czogZGVidWdnZXJFdmVudHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVyZ2VSZWFjdGl2ZU9iamVjdHMocGluaWEuc3RhdGUudmFsdWVbJGlkXSwgcGFydGlhbFN0YXRlT3JNdXRhdG9yKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbk11dGF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IE11dGF0aW9uVHlwZS5wYXRjaE9iamVjdCxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBwYXJ0aWFsU3RhdGVPck11dGF0b3IsXG4gICAgICAgICAgICAgICAgc3RvcmVJZDogJGlkLFxuICAgICAgICAgICAgICAgIGV2ZW50czogZGVidWdnZXJFdmVudHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG15TGlzdGVuZXJJZCA9IChhY3RpdmVMaXN0ZW5lciA9IFN5bWJvbCgpKTtcbiAgICAgICAgbmV4dFRpY2soKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChhY3RpdmVMaXN0ZW5lciA9PT0gbXlMaXN0ZW5lcklkKSB7XG4gICAgICAgICAgICAgICAgaXNMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaXNTeW5jTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBwYXVzZWQgdGhlIHdhdGNoZXIsIHdlIG5lZWQgdG8gbWFudWFsbHkgY2FsbCB0aGUgc3Vic2NyaXB0aW9uc1xuICAgICAgICB0cmlnZ2VyU3Vic2NyaXB0aW9ucyhzdWJzY3JpcHRpb25zLCBzdWJzY3JpcHRpb25NdXRhdGlvbiwgcGluaWEuc3RhdGUudmFsdWVbJGlkXSk7XG4gICAgfVxuICAgIGNvbnN0ICRyZXNldCA9IGlzT3B0aW9uc1N0b3JlXG4gICAgICAgID8gZnVuY3Rpb24gJHJlc2V0KCkge1xuICAgICAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gc3RhdGUgPyBzdGF0ZSgpIDoge307XG4gICAgICAgICAgICAvLyB3ZSB1c2UgYSBwYXRjaCB0byBncm91cCBhbGwgY2hhbmdlcyBpbnRvIG9uZSBzaW5nbGUgc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICB0aGlzLiRwYXRjaCgoJHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzaWduKCRzdGF0ZSwgbmV3U3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXG4gICAgICAgICAgICAgICAgPyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihg8J+NjTogU3RvcmUgXCIkeyRpZH1cIiBpcyBidWlsdCB1c2luZyB0aGUgc2V0dXAgc3ludGF4IGFuZCBkb2VzIG5vdCBpbXBsZW1lbnQgJHJlc2V0KCkuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogbm9vcDtcbiAgICBmdW5jdGlvbiAkZGlzcG9zZSgpIHtcbiAgICAgICAgc2NvcGUuc3RvcCgpO1xuICAgICAgICBzdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIGFjdGlvblN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgICAgcGluaWEuX3MuZGVsZXRlKCRpZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyYXBzIGFuIGFjdGlvbiB0byBoYW5kbGUgc3Vic2NyaXB0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIC0gbmFtZSBvZiB0aGUgYWN0aW9uXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIGFjdGlvbiB0byB3cmFwXG4gICAgICogQHJldHVybnMgYSB3cmFwcGVkIGFjdGlvbiB0byBoYW5kbGUgc3Vic2NyaXB0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBBY3Rpb24obmFtZSwgYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRBY3RpdmVQaW5pYShwaW5pYSk7XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICAgICAgICAgICAgY29uc3QgYWZ0ZXJDYWxsYmFja0xpc3QgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IG9uRXJyb3JDYWxsYmFja0xpc3QgPSBbXTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFmdGVyKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXJDYWxsYmFja0xpc3QucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBvbkVycm9yKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvckNhbGxiYWNrTGlzdC5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHRyaWdnZXJTdWJzY3JpcHRpb25zKGFjdGlvblN1YnNjcmlwdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICAgICAgYWZ0ZXIsXG4gICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHJldDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gYWN0aW9uLmFwcGx5KHRoaXMgJiYgdGhpcy4kaWQgPT09ICRpZCA/IHRoaXMgOiBzdG9yZSwgYXJncyk7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIHN5bmMgZXJyb3JzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyU3Vic2NyaXB0aW9ucyhvbkVycm9yQ2FsbGJhY2tMaXN0LCBlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXRcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJTdWJzY3JpcHRpb25zKGFmdGVyQ2FsbGJhY2tMaXN0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJTdWJzY3JpcHRpb25zKG9uRXJyb3JDYWxsYmFja0xpc3QsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRyaWdnZXIgYWZ0ZXIgY2FsbGJhY2tzXG4gICAgICAgICAgICB0cmlnZ2VyU3Vic2NyaXB0aW9ucyhhZnRlckNhbGxiYWNrTGlzdCwgcmV0KTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IF9obXJQYXlsb2FkID0gLyojX19QVVJFX18qLyBtYXJrUmF3KHtcbiAgICAgICAgYWN0aW9uczoge30sXG4gICAgICAgIGdldHRlcnM6IHt9LFxuICAgICAgICBzdGF0ZTogW10sXG4gICAgICAgIGhvdFN0YXRlLFxuICAgIH0pO1xuICAgIGNvbnN0IHBhcnRpYWxTdG9yZSA9IHtcbiAgICAgICAgX3A6IHBpbmlhLFxuICAgICAgICAvLyBfczogc2NvcGUsXG4gICAgICAgICRpZCxcbiAgICAgICAgJG9uQWN0aW9uOiBhZGRTdWJzY3JpcHRpb24uYmluZChudWxsLCBhY3Rpb25TdWJzY3JpcHRpb25zKSxcbiAgICAgICAgJHBhdGNoLFxuICAgICAgICAkcmVzZXQsXG4gICAgICAgICRzdWJzY3JpYmUoY2FsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlU3Vic2NyaXB0aW9uID0gYWRkU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbnMsIGNhbGxiYWNrLCBvcHRpb25zLmRldGFjaGVkLCAoKSA9PiBzdG9wV2F0Y2hlcigpKTtcbiAgICAgICAgICAgIGNvbnN0IHN0b3BXYXRjaGVyID0gc2NvcGUucnVuKCgpID0+IHdhdGNoKCgpID0+IHBpbmlhLnN0YXRlLnZhbHVlWyRpZF0sIChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZsdXNoID09PSAnc3luYycgPyBpc1N5bmNMaXN0ZW5pbmcgOiBpc0xpc3RlbmluZykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZUlkOiAkaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBNdXRhdGlvblR5cGUuZGlyZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiBkZWJ1Z2dlckV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgfSwgc3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGFzc2lnbih7fSwgJHN1YnNjcmliZU9wdGlvbnMsIG9wdGlvbnMpKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlU3Vic2NyaXB0aW9uO1xuICAgICAgICB9LFxuICAgICAgICAkZGlzcG9zZSxcbiAgICB9O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1Z1ZTIpIHtcbiAgICAgICAgLy8gc3RhcnQgYXMgbm9uIHJlYWR5XG4gICAgICAgIHBhcnRpYWxTdG9yZS5fciA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzdG9yZSA9IHJlYWN0aXZlKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBVU0VfREVWVE9PTFNcbiAgICAgICAgPyBhc3NpZ24oe1xuICAgICAgICAgICAgX2htclBheWxvYWQsXG4gICAgICAgICAgICBfY3VzdG9tUHJvcGVydGllczogbWFya1JhdyhuZXcgU2V0KCkpLCAvLyBkZXZ0b29scyBjdXN0b20gcHJvcGVydGllc1xuICAgICAgICB9LCBwYXJ0aWFsU3RvcmVcbiAgICAgICAgLy8gbXVzdCBiZSBhZGRlZCBsYXRlclxuICAgICAgICAvLyBzZXR1cFN0b3JlXG4gICAgICAgIClcbiAgICAgICAgOiBwYXJ0aWFsU3RvcmUpO1xuICAgIC8vIHN0b3JlIHRoZSBwYXJ0aWFsIHN0b3JlIG5vdyBzbyB0aGUgc2V0dXAgb2Ygc3RvcmVzIGNhbiBpbnN0YW50aWF0ZSBlYWNoIG90aGVyIGJlZm9yZSB0aGV5IGFyZSBmaW5pc2hlZCB3aXRob3V0XG4gICAgLy8gY3JlYXRpbmcgaW5maW5pdGUgbG9vcHMuXG4gICAgcGluaWEuX3Muc2V0KCRpZCwgc3RvcmUpO1xuICAgIGNvbnN0IHJ1bldpdGhDb250ZXh0ID0gKHBpbmlhLl9hICYmIHBpbmlhLl9hLnJ1bldpdGhDb250ZXh0KSB8fCBmYWxsYmFja1J1bldpdGhDb250ZXh0O1xuICAgIC8vIFRPRE86IGlkZWEgY3JlYXRlIHNraXBTZXJpYWxpemUgdGhhdCBtYXJrcyBwcm9wZXJ0aWVzIGFzIG5vbiBzZXJpYWxpemFibGUgYW5kIHRoZXkgYXJlIHNraXBwZWRcbiAgICBjb25zdCBzZXR1cFN0b3JlID0gcnVuV2l0aENvbnRleHQoKCkgPT4gcGluaWEuX2UucnVuKCgpID0+IChzY29wZSA9IGVmZmVjdFNjb3BlKCkpLnJ1bihzZXR1cCkpKTtcbiAgICAvLyBvdmVyd3JpdGUgZXhpc3RpbmcgYWN0aW9ucyB0byBzdXBwb3J0ICRvbkFjdGlvblxuICAgIGZvciAoY29uc3Qga2V5IGluIHNldHVwU3RvcmUpIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IHNldHVwU3RvcmVba2V5XTtcbiAgICAgICAgaWYgKChpc1JlZihwcm9wKSAmJiAhaXNDb21wdXRlZChwcm9wKSkgfHwgaXNSZWFjdGl2ZShwcm9wKSkge1xuICAgICAgICAgICAgLy8gbWFyayBpdCBhcyBhIHBpZWNlIG9mIHN0YXRlIHRvIGJlIHNlcmlhbGl6ZWRcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaG90KSB7XG4gICAgICAgICAgICAgICAgc2V0KGhvdFN0YXRlLnZhbHVlLCBrZXksIHRvUmVmKHNldHVwU3RvcmUsIGtleSkpO1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZU9wdGlvblN0b3JlIGRpcmVjdGx5IHNldHMgdGhlIHN0YXRlIGluIHBpbmlhLnN0YXRlLnZhbHVlIHNvIHdlXG4gICAgICAgICAgICAgICAgLy8gY2FuIGp1c3Qgc2tpcCB0aGF0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNPcHRpb25zU3RvcmUpIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBzZXR1cCBzdG9yZXMgd2UgbXVzdCBoeWRyYXRlIHRoZSBzdGF0ZSBhbmQgc3luYyBwaW5pYSBzdGF0ZSB0cmVlIHdpdGggdGhlIHJlZnMgdGhlIHVzZXIganVzdCBjcmVhdGVkXG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxTdGF0ZSAmJiBzaG91bGRIeWRyYXRlKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1JlZihwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcC52YWx1ZSA9IGluaXRpYWxTdGF0ZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvYmFibHkgYSByZWFjdGl2ZSBvYmplY3QsIGxldHMgcmVjdXJzaXZlbHkgYXNzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwcm9wIGlzIHVua25vd25cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlUmVhY3RpdmVPYmplY3RzKHByb3AsIGluaXRpYWxTdGF0ZVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0cmFuc2ZlciB0aGUgcmVmIHRvIHRoZSBwaW5pYSBzdGF0ZSB0byBrZWVwIGV2ZXJ5dGhpbmcgaW4gc3luY1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmIChpc1Z1ZTIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0KHBpbmlhLnN0YXRlLnZhbHVlWyRpZF0sIGtleSwgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwaW5pYS5zdGF0ZS52YWx1ZVskaWRdW2tleV0gPSBwcm9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgX2htclBheWxvYWQuc3RhdGUucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWN0aW9uXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHByb3AgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHdlIGFyZSBvdmVycmlkaW5nIHRoZSBmdW5jdGlvbiB3ZSBhdm9pZCB3cmFwcGluZyBpZlxuICAgICAgICAgICAgY29uc3QgYWN0aW9uVmFsdWUgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaG90ID8gcHJvcCA6IHdyYXBBY3Rpb24oa2V5LCBwcm9wKTtcbiAgICAgICAgICAgIC8vIHRoaXMgYSBob3QgbW9kdWxlIHJlcGxhY2VtZW50IHN0b3JlIGJlY2F1c2UgdGhlIGhvdFVwZGF0ZSBtZXRob2QgbmVlZHNcbiAgICAgICAgICAgIC8vIHRvIGRvIGl0IHdpdGggdGhlIHJpZ2h0IGNvbnRleHRcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKGlzVnVlMikge1xuICAgICAgICAgICAgICAgIHNldChzZXR1cFN0b3JlLCBrZXksIGFjdGlvblZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBzZXR1cFN0b3JlW2tleV0gPSBhY3Rpb25WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgX2htclBheWxvYWQuYWN0aW9uc1trZXldID0gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxpc3QgYWN0aW9ucyBzbyB0aGV5IGNhbiBiZSB1c2VkIGluIHBsdWdpbnNcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIG9wdGlvbnNGb3JQbHVnaW4uYWN0aW9uc1trZXldID0gcHJvcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIC8vIGFkZCBnZXR0ZXJzIGZvciBkZXZ0b29sc1xuICAgICAgICAgICAgaWYgKGlzQ29tcHV0ZWQocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBfaG1yUGF5bG9hZC5nZXR0ZXJzW2tleV0gPSBpc09wdGlvbnNTdG9yZVxuICAgICAgICAgICAgICAgICAgICA/IC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZ2V0dGVyc1trZXldXG4gICAgICAgICAgICAgICAgICAgIDogcHJvcDtcbiAgICAgICAgICAgICAgICBpZiAoSVNfQ0xJRU5UKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdldHRlcnMgPSBzZXR1cFN0b3JlLl9nZXR0ZXJzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBzYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2V0dXBTdG9yZS5fZ2V0dGVycyA9IG1hcmtSYXcoW10pKTtcbiAgICAgICAgICAgICAgICAgICAgZ2V0dGVycy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCB0aGUgc3RhdGUsIGdldHRlcnMsIGFuZCBhY3Rpb24gcHJvcGVydGllc1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1Z1ZTIpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoc2V0dXBTdG9yZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBzZXQoc3RvcmUsIGtleSwgc2V0dXBTdG9yZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3NpZ24oc3RvcmUsIHNldHVwU3RvcmUpO1xuICAgICAgICAvLyBhbGxvd3MgcmV0cmlldmluZyByZWFjdGl2ZSBvYmplY3RzIHdpdGggYHN0b3JlVG9SZWZzKClgLiBNdXN0IGJlIGNhbGxlZCBhZnRlciBhc3NpZ25pbmcgdG8gdGhlIHJlYWN0aXZlIG9iamVjdC5cbiAgICAgICAgLy8gTWFrZSBgc3RvcmVUb1JlZnMoKWAgd29yayB3aXRoIGByZWFjdGl2ZSgpYCAjNzk5XG4gICAgICAgIGFzc2lnbih0b1JhdyhzdG9yZSksIHNldHVwU3RvcmUpO1xuICAgIH1cbiAgICAvLyB1c2UgdGhpcyBpbnN0ZWFkIG9mIGEgY29tcHV0ZWQgd2l0aCBzZXR0ZXIgdG8gYmUgYWJsZSB0byBjcmVhdGUgaXQgYW55d2hlcmVcbiAgICAvLyB3aXRob3V0IGxpbmtpbmcgdGhlIGNvbXB1dGVkIGxpZmVzcGFuIHRvIHdoZXJldmVyIHRoZSBzdG9yZSBpcyBmaXJzdFxuICAgIC8vIGNyZWF0ZWQuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN0b3JlLCAnJHN0YXRlJywge1xuICAgICAgICBnZXQ6ICgpID0+ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaG90ID8gaG90U3RhdGUudmFsdWUgOiBwaW5pYS5zdGF0ZS52YWx1ZVskaWRdKSxcbiAgICAgICAgc2V0OiAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBob3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzZXQgaG90U3RhdGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRwYXRjaCgoJHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzaWduKCRzdGF0ZSwgc3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgLy8gYWRkIHRoZSBob3RVcGRhdGUgYmVmb3JlIHBsdWdpbnMgdG8gYWxsb3cgdGhlbSB0byBvdmVycmlkZSBpdFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICBzdG9yZS5faG90VXBkYXRlID0gbWFya1JhdygobmV3U3RvcmUpID0+IHtcbiAgICAgICAgICAgIHN0b3JlLl9ob3RVcGRhdGluZyA9IHRydWU7XG4gICAgICAgICAgICBuZXdTdG9yZS5faG1yUGF5bG9hZC5zdGF0ZS5mb3JFYWNoKChzdGF0ZUtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZUtleSBpbiBzdG9yZS4kc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3U3RhdGVUYXJnZXQgPSBuZXdTdG9yZS4kc3RhdGVbc3RhdGVLZXldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRTdGF0ZVNvdXJjZSA9IHN0b3JlLiRzdGF0ZVtzdGF0ZUtleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3U3RhdGVUYXJnZXQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1BsYWluT2JqZWN0KG5ld1N0YXRlVGFyZ2V0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQbGFpbk9iamVjdChvbGRTdGF0ZVNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoT2JqZWN0KG5ld1N0YXRlVGFyZ2V0LCBvbGRTdGF0ZVNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmFuc2ZlciB0aGUgcmVmXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdG9yZS4kc3RhdGVbc3RhdGVLZXldID0gb2xkU3RhdGVTb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcGF0Y2ggZGlyZWN0IGFjY2VzcyBwcm9wZXJ0aWVzIHRvIGFsbG93IHN0b3JlLnN0YXRlUHJvcGVydHkgdG8gd29yayBhc1xuICAgICAgICAgICAgICAgIC8vIHN0b3JlLiRzdGF0ZS5zdGF0ZVByb3BlcnR5XG4gICAgICAgICAgICAgICAgc2V0KHN0b3JlLCBzdGF0ZUtleSwgdG9SZWYobmV3U3RvcmUuJHN0YXRlLCBzdGF0ZUtleSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyByZW1vdmUgZGVsZXRlZCBzdGF0ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzdG9yZS4kc3RhdGUpLmZvckVhY2goKHN0YXRlS2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCEoc3RhdGVLZXkgaW4gbmV3U3RvcmUuJHN0YXRlKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWwoc3RvcmUsIHN0YXRlS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGF2b2lkIGRldnRvb2xzIGxvZ2dpbmcgdGhpcyBhcyBhIG11dGF0aW9uXG4gICAgICAgICAgICBpc0xpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaXNTeW5jTGlzdGVuaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBwaW5pYS5zdGF0ZS52YWx1ZVskaWRdID0gdG9SZWYobmV3U3RvcmUuX2htclBheWxvYWQsICdob3RTdGF0ZScpO1xuICAgICAgICAgICAgaXNTeW5jTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIG5leHRUaWNrKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaXNMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbk5hbWUgaW4gbmV3U3RvcmUuX2htclBheWxvYWQuYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IG5ld1N0b3JlW2FjdGlvbk5hbWVdO1xuICAgICAgICAgICAgICAgIHNldChzdG9yZSwgYWN0aW9uTmFtZSwgd3JhcEFjdGlvbihhY3Rpb25OYW1lLCBhY3Rpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE86IGRvZXMgdGhpcyB3b3JrIGluIGJvdGggc2V0dXAgYW5kIG9wdGlvbiBzdG9yZT9cbiAgICAgICAgICAgIGZvciAoY29uc3QgZ2V0dGVyTmFtZSBpbiBuZXdTdG9yZS5faG1yUGF5bG9hZC5nZXR0ZXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2V0dGVyID0gbmV3U3RvcmUuX2htclBheWxvYWQuZ2V0dGVyc1tnZXR0ZXJOYW1lXTtcbiAgICAgICAgICAgICAgICBjb25zdCBnZXR0ZXJWYWx1ZSA9IGlzT3B0aW9uc1N0b3JlXG4gICAgICAgICAgICAgICAgICAgID8gLy8gc3BlY2lhbCBoYW5kbGluZyBvZiBvcHRpb25zIGFwaVxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEFjdGl2ZVBpbmlhKHBpbmlhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVyLmNhbGwoc3RvcmUsIHN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIDogZ2V0dGVyO1xuICAgICAgICAgICAgICAgIHNldChzdG9yZSwgZ2V0dGVyTmFtZSwgZ2V0dGVyVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVtb3ZlIGRlbGV0ZWQgZ2V0dGVyc1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc3RvcmUuX2htclBheWxvYWQuZ2V0dGVycykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIG5ld1N0b3JlLl9obXJQYXlsb2FkLmdldHRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbChzdG9yZSwga2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBvbGQgYWN0aW9uc1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc3RvcmUuX2htclBheWxvYWQuYWN0aW9ucykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIG5ld1N0b3JlLl9obXJQYXlsb2FkLmFjdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbChzdG9yZSwga2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgdmFsdWVzIHVzZWQgaW4gZGV2dG9vbHMgYW5kIHRvIGFsbG93IGRlbGV0aW5nIG5ldyBwcm9wZXJ0aWVzIGxhdGVyIG9uXG4gICAgICAgICAgICBzdG9yZS5faG1yUGF5bG9hZCA9IG5ld1N0b3JlLl9obXJQYXlsb2FkO1xuICAgICAgICAgICAgc3RvcmUuX2dldHRlcnMgPSBuZXdTdG9yZS5fZ2V0dGVycztcbiAgICAgICAgICAgIHN0b3JlLl9ob3RVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKFVTRV9ERVZUT09MUykge1xuICAgICAgICBjb25zdCBub25FbnVtZXJhYmxlID0ge1xuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAvLyBhdm9pZCB3YXJuaW5nIG9uIGRldnRvb2xzIHRyeWluZyB0byBkaXNwbGF5IHRoaXMgcHJvcGVydHlcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBbJ19wJywgJ19obXJQYXlsb2FkJywgJ19nZXR0ZXJzJywgJ19jdXN0b21Qcm9wZXJ0aWVzJ10uZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN0b3JlLCBwLCBhc3NpZ24oeyB2YWx1ZTogc3RvcmVbcF0gfSwgbm9uRW51bWVyYWJsZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzVnVlMikge1xuICAgICAgICAvLyBtYXJrIHRoZSBzdG9yZSBhcyByZWFkeSBiZWZvcmUgcGx1Z2luc1xuICAgICAgICBzdG9yZS5fciA9IHRydWU7XG4gICAgfVxuICAgIC8vIGFwcGx5IGFsbCBwbHVnaW5zXG4gICAgcGluaWEuX3AuZm9yRWFjaCgoZXh0ZW5kZXIpID0+IHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKFVTRV9ERVZUT09MUykge1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9ucyA9IHNjb3BlLnJ1bigoKSA9PiBleHRlbmRlcih7XG4gICAgICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICAgICAgYXBwOiBwaW5pYS5fYSxcbiAgICAgICAgICAgICAgICBwaW5pYSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zRm9yUGx1Z2luLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZXh0ZW5zaW9ucyB8fCB7fSkuZm9yRWFjaCgoa2V5KSA9PiBzdG9yZS5fY3VzdG9tUHJvcGVydGllcy5hZGQoa2V5KSk7XG4gICAgICAgICAgICBhc3NpZ24oc3RvcmUsIGV4dGVuc2lvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXNzaWduKHN0b3JlLCBzY29wZS5ydW4oKCkgPT4gZXh0ZW5kZXIoe1xuICAgICAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgICAgIGFwcDogcGluaWEuX2EsXG4gICAgICAgICAgICAgICAgcGluaWEsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc0ZvclBsdWdpbixcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgIHN0b3JlLiRzdGF0ZSAmJlxuICAgICAgICB0eXBlb2Ygc3RvcmUuJHN0YXRlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICB0eXBlb2Ygc3RvcmUuJHN0YXRlLmNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICFzdG9yZS4kc3RhdGUuY29uc3RydWN0b3IudG9TdHJpbmcoKS5pbmNsdWRlcygnW25hdGl2ZSBjb2RlXScpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgW/CfjY1dOiBUaGUgXCJzdGF0ZVwiIG11c3QgYmUgYSBwbGFpbiBvYmplY3QuIEl0IGNhbm5vdCBiZVxcbmAgK1xuICAgICAgICAgICAgYFxcdHN0YXRlOiAoKSA9PiBuZXcgTXlDbGFzcygpXFxuYCArXG4gICAgICAgICAgICBgRm91bmQgaW4gc3RvcmUgXCIke3N0b3JlLiRpZH1cIi5gKTtcbiAgICB9XG4gICAgLy8gb25seSBhcHBseSBoeWRyYXRlIHRvIG9wdGlvbiBzdG9yZXMgd2l0aCBhbiBpbml0aWFsIHN0YXRlIGluIHBpbmlhXG4gICAgaWYgKGluaXRpYWxTdGF0ZSAmJlxuICAgICAgICBpc09wdGlvbnNTdG9yZSAmJlxuICAgICAgICBvcHRpb25zLmh5ZHJhdGUpIHtcbiAgICAgICAgb3B0aW9ucy5oeWRyYXRlKHN0b3JlLiRzdGF0ZSwgaW5pdGlhbFN0YXRlKTtcbiAgICB9XG4gICAgaXNMaXN0ZW5pbmcgPSB0cnVlO1xuICAgIGlzU3luY0xpc3RlbmluZyA9IHRydWU7XG4gICAgcmV0dXJuIHN0b3JlO1xufVxuZnVuY3Rpb24gZGVmaW5lU3RvcmUoXG4vLyBUT0RPOiBhZGQgcHJvcGVyIHR5cGVzIGZyb20gYWJvdmVcbmlkT3JPcHRpb25zLCBzZXR1cCwgc2V0dXBPcHRpb25zKSB7XG4gICAgbGV0IGlkO1xuICAgIGxldCBvcHRpb25zO1xuICAgIGNvbnN0IGlzU2V0dXBTdG9yZSA9IHR5cGVvZiBzZXR1cCA9PT0gJ2Z1bmN0aW9uJztcbiAgICBpZiAodHlwZW9mIGlkT3JPcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZCA9IGlkT3JPcHRpb25zO1xuICAgICAgICAvLyB0aGUgb3B0aW9uIHN0b3JlIHNldHVwIHdpbGwgY29udGFpbiB0aGUgYWN0dWFsIG9wdGlvbnMgaW4gdGhpcyBjYXNlXG4gICAgICAgIG9wdGlvbnMgPSBpc1NldHVwU3RvcmUgPyBzZXR1cE9wdGlvbnMgOiBzZXR1cDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSBpZE9yT3B0aW9ucztcbiAgICAgICAgaWQgPSBpZE9yT3B0aW9ucy5pZDtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFvwn42NXTogXCJkZWZpbmVTdG9yZSgpXCIgbXVzdCBiZSBwYXNzZWQgYSBzdG9yZSBpZCBhcyBpdHMgZmlyc3QgYXJndW1lbnQuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlU3RvcmUocGluaWEsIGhvdCkge1xuICAgICAgICBjb25zdCBoYXNDb250ZXh0ID0gaGFzSW5qZWN0aW9uQ29udGV4dCgpO1xuICAgICAgICBwaW5pYSA9XG4gICAgICAgICAgICAvLyBpbiB0ZXN0IG1vZGUsIGlnbm9yZSB0aGUgYXJndW1lbnQgcHJvdmlkZWQgYXMgd2UgY2FuIGFsd2F5cyByZXRyaWV2ZSBhXG4gICAgICAgICAgICAvLyBwaW5pYSBpbnN0YW5jZSB3aXRoIGdldEFjdGl2ZVBpbmlhKClcbiAgICAgICAgICAgICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0JykgJiYgYWN0aXZlUGluaWEgJiYgYWN0aXZlUGluaWEuX3Rlc3RpbmcgPyBudWxsIDogcGluaWEpIHx8XG4gICAgICAgICAgICAgICAgKGhhc0NvbnRleHQgPyBpbmplY3QocGluaWFTeW1ib2wsIG51bGwpIDogbnVsbCk7XG4gICAgICAgIGlmIChwaW5pYSlcbiAgICAgICAgICAgIHNldEFjdGl2ZVBpbmlhKHBpbmlhKTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhYWN0aXZlUGluaWEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgW/CfjY1dOiBcImdldEFjdGl2ZVBpbmlhKClcIiB3YXMgY2FsbGVkIGJ1dCB0aGVyZSB3YXMgbm8gYWN0aXZlIFBpbmlhLiBBcmUgeW91IHRyeWluZyB0byB1c2UgYSBzdG9yZSBiZWZvcmUgY2FsbGluZyBcImFwcC51c2UocGluaWEpXCI/XFxuYCArXG4gICAgICAgICAgICAgICAgYFNlZSBodHRwczovL3BpbmlhLnZ1ZWpzLm9yZy9jb3JlLWNvbmNlcHRzL291dHNpZGUtY29tcG9uZW50LXVzYWdlLmh0bWwgZm9yIGhlbHAuXFxuYCArXG4gICAgICAgICAgICAgICAgYFRoaXMgd2lsbCBmYWlsIGluIHByb2R1Y3Rpb24uYCk7XG4gICAgICAgIH1cbiAgICAgICAgcGluaWEgPSBhY3RpdmVQaW5pYTtcbiAgICAgICAgaWYgKCFwaW5pYS5fcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGluZyB0aGUgc3RvcmUgcmVnaXN0ZXJzIGl0IGluIGBwaW5pYS5fc2BcbiAgICAgICAgICAgIGlmIChpc1NldHVwU3RvcmUpIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVTZXR1cFN0b3JlKGlkLCBzZXR1cCwgb3B0aW9ucywgcGluaWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlT3B0aW9uc1N0b3JlKGlkLCBvcHRpb25zLCBwaW5pYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IG5vdCB0aGUgcmlnaHQgaW5mZXJyZWQgdHlwZVxuICAgICAgICAgICAgICAgIHVzZVN0b3JlLl9waW5pYSA9IHBpbmlhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0b3JlID0gcGluaWEuX3MuZ2V0KGlkKTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBob3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGhvdElkID0gJ19faG90OicgKyBpZDtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0b3JlID0gaXNTZXR1cFN0b3JlXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVTZXR1cFN0b3JlKGhvdElkLCBzZXR1cCwgb3B0aW9ucywgcGluaWEsIHRydWUpXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVPcHRpb25zU3RvcmUoaG90SWQsIGFzc2lnbih7fSwgb3B0aW9ucyksIHBpbmlhLCB0cnVlKTtcbiAgICAgICAgICAgIGhvdC5faG90VXBkYXRlKG5ld1N0b3JlKTtcbiAgICAgICAgICAgIC8vIGNsZWFudXAgdGhlIHN0YXRlIHByb3BlcnRpZXMgYW5kIHRoZSBzdG9yZSBmcm9tIHRoZSBjYWNoZVxuICAgICAgICAgICAgZGVsZXRlIHBpbmlhLnN0YXRlLnZhbHVlW2hvdElkXTtcbiAgICAgICAgICAgIHBpbmlhLl9zLmRlbGV0ZShob3RJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBJU19DTElFTlQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgLy8gc2F2ZSBzdG9yZXMgaW4gaW5zdGFuY2VzIHRvIGFjY2VzcyB0aGVtIGRldnRvb2xzXG4gICAgICAgICAgICBpZiAoY3VycmVudEluc3RhbmNlICYmXG4gICAgICAgICAgICAgICAgY3VycmVudEluc3RhbmNlLnByb3h5ICYmXG4gICAgICAgICAgICAgICAgLy8gYXZvaWQgYWRkaW5nIHN0b3JlcyB0aGF0IGFyZSBqdXN0IGJ1aWx0IGZvciBob3QgbW9kdWxlIHJlcGxhY2VtZW50XG4gICAgICAgICAgICAgICAgIWhvdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZtID0gY3VycmVudEluc3RhbmNlLnByb3h5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gJ19wU3RvcmVzJyBpbiB2bSA/IHZtLl9wU3RvcmVzIDogKHZtLl9wU3RvcmVzID0ge30pO1xuICAgICAgICAgICAgICAgIGNhY2hlW2lkXSA9IHN0b3JlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3JlR2VuZXJpYyBjYW5ub3QgYmUgY2FzdGVkIHRvd2FyZHMgU3RvcmVcbiAgICAgICAgcmV0dXJuIHN0b3JlO1xuICAgIH1cbiAgICB1c2VTdG9yZS4kaWQgPSBpZDtcbiAgICByZXR1cm4gdXNlU3RvcmU7XG59XG5cbmxldCBtYXBTdG9yZVN1ZmZpeCA9ICdTdG9yZSc7XG4vKipcbiAqIENoYW5nZXMgdGhlIHN1ZmZpeCBhZGRlZCBieSBgbWFwU3RvcmVzKClgLiBDYW4gYmUgc2V0IHRvIGFuIGVtcHR5IHN0cmluZy5cbiAqIERlZmF1bHRzIHRvIGBcIlN0b3JlXCJgLiBNYWtlIHN1cmUgdG8gZXh0ZW5kIHRoZSBNYXBTdG9yZXNDdXN0b21pemF0aW9uXG4gKiBpbnRlcmZhY2UgaWYgeW91IGFyZSB1c2luZyBUeXBlU2NyaXB0LlxuICpcbiAqIEBwYXJhbSBzdWZmaXggLSBuZXcgc3VmZml4XG4gKi9cbmZ1bmN0aW9uIHNldE1hcFN0b3JlU3VmZml4KHN1ZmZpeCAvLyBjb3VsZCBiZSAnU3RvcmUnIGJ1dCB0aGF0IHdvdWxkIGJlIGFubm95aW5nIGZvciBKU1xuKSB7XG4gICAgbWFwU3RvcmVTdWZmaXggPSBzdWZmaXg7XG59XG4vKipcbiAqIEFsbG93cyB1c2luZyBzdG9yZXMgd2l0aG91dCB0aGUgY29tcG9zaXRpb24gQVBJIChgc2V0dXAoKWApIGJ5IGdlbmVyYXRpbmcgYW5cbiAqIG9iamVjdCB0byBiZSBzcHJlYWQgaW4gdGhlIGBjb21wdXRlZGAgZmllbGQgb2YgYSBjb21wb25lbnQuIEl0IGFjY2VwdHMgYSBsaXN0XG4gKiBvZiBzdG9yZSBkZWZpbml0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGV4cG9ydCBkZWZhdWx0IHtcbiAqICAgY29tcHV0ZWQ6IHtcbiAqICAgICAvLyBvdGhlciBjb21wdXRlZCBwcm9wZXJ0aWVzXG4gKiAgICAgLi4ubWFwU3RvcmVzKHVzZVVzZXJTdG9yZSwgdXNlQ2FydFN0b3JlKVxuICogICB9LFxuICpcbiAqICAgY3JlYXRlZCgpIHtcbiAqICAgICB0aGlzLnVzZXJTdG9yZSAvLyBzdG9yZSB3aXRoIGlkIFwidXNlclwiXG4gKiAgICAgdGhpcy5jYXJ0U3RvcmUgLy8gc3RvcmUgd2l0aCBpZCBcImNhcnRcIlxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc3RvcmVzIC0gbGlzdCBvZiBzdG9yZXMgdG8gbWFwIHRvIGFuIG9iamVjdFxuICovXG5mdW5jdGlvbiBtYXBTdG9yZXMoLi4uc3RvcmVzKSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBBcnJheS5pc0FycmF5KHN0b3Jlc1swXSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBb8J+NjV06IERpcmVjdGx5IHBhc3MgYWxsIHN0b3JlcyB0byBcIm1hcFN0b3JlcygpXCIgd2l0aG91dCBwdXR0aW5nIHRoZW0gaW4gYW4gYXJyYXk6XFxuYCArXG4gICAgICAgICAgICBgUmVwbGFjZVxcbmAgK1xuICAgICAgICAgICAgYFxcdG1hcFN0b3JlcyhbdXNlQXV0aFN0b3JlLCB1c2VDYXJ0U3RvcmVdKVxcbmAgK1xuICAgICAgICAgICAgYHdpdGhcXG5gICtcbiAgICAgICAgICAgIGBcXHRtYXBTdG9yZXModXNlQXV0aFN0b3JlLCB1c2VDYXJ0U3RvcmUpXFxuYCArXG4gICAgICAgICAgICBgVGhpcyB3aWxsIGZhaWwgaW4gcHJvZHVjdGlvbiBpZiBub3QgZml4ZWQuYCk7XG4gICAgICAgIHN0b3JlcyA9IHN0b3Jlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIHN0b3Jlcy5yZWR1Y2UoKHJlZHVjZWQsIHVzZVN0b3JlKSA9PiB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6ICRpZCBpcyBhZGRlZCBieSBkZWZpbmVTdG9yZVxuICAgICAgICByZWR1Y2VkW3VzZVN0b3JlLiRpZCArIG1hcFN0b3JlU3VmZml4XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VTdG9yZSh0aGlzLiRwaW5pYSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWR1Y2VkO1xuICAgIH0sIHt9KTtcbn1cbi8qKlxuICogQWxsb3dzIHVzaW5nIHN0YXRlIGFuZCBnZXR0ZXJzIGZyb20gb25lIHN0b3JlIHdpdGhvdXQgdXNpbmcgdGhlIGNvbXBvc2l0aW9uXG4gKiBBUEkgKGBzZXR1cCgpYCkgYnkgZ2VuZXJhdGluZyBhbiBvYmplY3QgdG8gYmUgc3ByZWFkIGluIHRoZSBgY29tcHV0ZWRgIGZpZWxkXG4gKiBvZiBhIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0gdXNlU3RvcmUgLSBzdG9yZSB0byBtYXAgZnJvbVxuICogQHBhcmFtIGtleXNPck1hcHBlciAtIGFycmF5IG9yIG9iamVjdFxuICovXG5mdW5jdGlvbiBtYXBTdGF0ZSh1c2VTdG9yZSwga2V5c09yTWFwcGVyKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoa2V5c09yTWFwcGVyKVxuICAgICAgICA/IGtleXNPck1hcHBlci5yZWR1Y2UoKHJlZHVjZWQsIGtleSkgPT4ge1xuICAgICAgICAgICAgcmVkdWNlZFtrZXldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1c2VTdG9yZSh0aGlzLiRwaW5pYSlba2V5XTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVkdWNlZDtcbiAgICAgICAgfSwge30pXG4gICAgICAgIDogT2JqZWN0LmtleXMoa2V5c09yTWFwcGVyKS5yZWR1Y2UoKHJlZHVjZWQsIGtleSkgPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgcmVkdWNlZFtrZXldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUodGhpcy4kcGluaWEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlS2V5ID0ga2V5c09yTWFwcGVyW2tleV07XG4gICAgICAgICAgICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIFRTIGlzIHVuYWJsZSB0byBpbmZlciB0aGUgdHlwZSBvZiBzdG9yZUtleSB0byBiZSBhXG4gICAgICAgICAgICAgICAgLy8gZnVuY3Rpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHN0b3JlS2V5ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgID8gc3RvcmVLZXkuY2FsbCh0aGlzLCBzdG9yZSlcbiAgICAgICAgICAgICAgICAgICAgOiBzdG9yZVtzdG9yZUtleV07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlZHVjZWQ7XG4gICAgICAgIH0sIHt9KTtcbn1cbi8qKlxuICogQWxpYXMgZm9yIGBtYXBTdGF0ZSgpYC4gWW91IHNob3VsZCB1c2UgYG1hcFN0YXRlKClgIGluc3RlYWQuXG4gKiBAZGVwcmVjYXRlZCB1c2UgYG1hcFN0YXRlKClgIGluc3RlYWQuXG4gKi9cbmNvbnN0IG1hcEdldHRlcnMgPSBtYXBTdGF0ZTtcbi8qKlxuICogQWxsb3dzIGRpcmVjdGx5IHVzaW5nIGFjdGlvbnMgZnJvbSB5b3VyIHN0b3JlIHdpdGhvdXQgdXNpbmcgdGhlIGNvbXBvc2l0aW9uXG4gKiBBUEkgKGBzZXR1cCgpYCkgYnkgZ2VuZXJhdGluZyBhbiBvYmplY3QgdG8gYmUgc3ByZWFkIGluIHRoZSBgbWV0aG9kc2AgZmllbGRcbiAqIG9mIGEgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB1c2VTdG9yZSAtIHN0b3JlIHRvIG1hcCBmcm9tXG4gKiBAcGFyYW0ga2V5c09yTWFwcGVyIC0gYXJyYXkgb3Igb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIG1hcEFjdGlvbnModXNlU3RvcmUsIGtleXNPck1hcHBlcikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGtleXNPck1hcHBlcilcbiAgICAgICAgPyBrZXlzT3JNYXBwZXIucmVkdWNlKChyZWR1Y2VkLCBrZXkpID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHJlZHVjZWRba2V5XSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZVN0b3JlKHRoaXMuJHBpbmlhKVtrZXldKC4uLmFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZWR1Y2VkO1xuICAgICAgICB9LCB7fSlcbiAgICAgICAgOiBPYmplY3Qua2V5cyhrZXlzT3JNYXBwZXIpLnJlZHVjZSgocmVkdWNlZCwga2V5KSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICByZWR1Y2VkW2tleV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIHJldHVybiB1c2VTdG9yZSh0aGlzLiRwaW5pYSlba2V5c09yTWFwcGVyW2tleV1dKC4uLmFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZWR1Y2VkO1xuICAgICAgICB9LCB7fSk7XG59XG4vKipcbiAqIEFsbG93cyB1c2luZyBzdGF0ZSBhbmQgZ2V0dGVycyBmcm9tIG9uZSBzdG9yZSB3aXRob3V0IHVzaW5nIHRoZSBjb21wb3NpdGlvblxuICogQVBJIChgc2V0dXAoKWApIGJ5IGdlbmVyYXRpbmcgYW4gb2JqZWN0IHRvIGJlIHNwcmVhZCBpbiB0aGUgYGNvbXB1dGVkYCBmaWVsZFxuICogb2YgYSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHVzZVN0b3JlIC0gc3RvcmUgdG8gbWFwIGZyb21cbiAqIEBwYXJhbSBrZXlzT3JNYXBwZXIgLSBhcnJheSBvciBvYmplY3RcbiAqL1xuZnVuY3Rpb24gbWFwV3JpdGFibGVTdGF0ZSh1c2VTdG9yZSwga2V5c09yTWFwcGVyKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoa2V5c09yTWFwcGVyKVxuICAgICAgICA/IGtleXNPck1hcHBlci5yZWR1Y2UoKHJlZHVjZWQsIGtleSkgPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmVkdWNlZFtrZXldID0ge1xuICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVzZVN0b3JlKHRoaXMuJHBpbmlhKVtrZXldO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgZWFzaWVyIHRvIHR5cGUgaXQgaGVyZSBhcyBhbnlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh1c2VTdG9yZSh0aGlzLiRwaW5pYSlba2V5XSA9IHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZWR1Y2VkO1xuICAgICAgICB9LCB7fSlcbiAgICAgICAgOiBPYmplY3Qua2V5cyhrZXlzT3JNYXBwZXIpLnJlZHVjZSgocmVkdWNlZCwga2V5KSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICByZWR1Y2VkW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXNlU3RvcmUodGhpcy4kcGluaWEpW2tleXNPck1hcHBlcltrZXldXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIGVhc2llciB0byB0eXBlIGl0IGhlcmUgYXMgYW55XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodXNlU3RvcmUodGhpcy4kcGluaWEpW2tleXNPck1hcHBlcltrZXldXSA9IHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZWR1Y2VkO1xuICAgICAgICB9LCB7fSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3Qgb2YgcmVmZXJlbmNlcyB3aXRoIGFsbCB0aGUgc3RhdGUsIGdldHRlcnMsIGFuZCBwbHVnaW4tYWRkZWRcbiAqIHN0YXRlIHByb3BlcnRpZXMgb2YgdGhlIHN0b3JlLiBTaW1pbGFyIHRvIGB0b1JlZnMoKWAgYnV0IHNwZWNpZmljYWxseVxuICogZGVzaWduZWQgZm9yIFBpbmlhIHN0b3JlcyBzbyBtZXRob2RzIGFuZCBub24gcmVhY3RpdmUgcHJvcGVydGllcyBhcmVcbiAqIGNvbXBsZXRlbHkgaWdub3JlZC5cbiAqXG4gKiBAcGFyYW0gc3RvcmUgLSBzdG9yZSB0byBleHRyYWN0IHRoZSByZWZzIGZyb21cbiAqL1xuZnVuY3Rpb24gc3RvcmVUb1JlZnMoc3RvcmUpIHtcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3BpbmlhL2lzc3Vlcy84NTJcbiAgICAvLyBJdCdzIGVhc2llciB0byBqdXN0IHVzZSB0b1JlZnMoKSBldmVuIGlmIGl0IGluY2x1ZGVzIG1vcmUgc3R1ZmZcbiAgICBpZiAoaXNWdWUyKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHRvUmVmcyBpbmNsdWRlIG1ldGhvZHMgYW5kIG90aGVyc1xuICAgICAgICByZXR1cm4gdG9SZWZzKHN0b3JlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0b3JlID0gdG9SYXcoc3RvcmUpO1xuICAgICAgICBjb25zdCByZWZzID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHN0b3JlKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHN0b3JlW2tleV07XG4gICAgICAgICAgICBpZiAoaXNSZWYodmFsdWUpIHx8IGlzUmVhY3RpdmUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogdGhlIGtleSBpcyBzdGF0ZSBvciBnZXR0ZXJcbiAgICAgICAgICAgICAgICByZWZzW2tleV0gPVxuICAgICAgICAgICAgICAgICAgICAvLyAtLS1cbiAgICAgICAgICAgICAgICAgICAgdG9SZWYoc3RvcmUsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZnM7XG4gICAgfVxufVxuXG4vKipcbiAqIFZ1ZSAyIFBsdWdpbiB0aGF0IG11c3QgYmUgaW5zdGFsbGVkIGZvciBwaW5pYSB0byB3b3JrLiBOb3RlICoqeW91IGRvbid0IG5lZWRcbiAqIHRoaXMgcGx1Z2luIGlmIHlvdSBhcmUgdXNpbmcgTnV4dC5qcyoqLiBVc2UgdGhlIGBidWlsZE1vZHVsZWAgaW5zdGVhZDpcbiAqIGh0dHBzOi8vcGluaWEudnVlanMub3JnL3Nzci9udXh0Lmh0bWwuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcbiAqIGltcG9ydCB7IFBpbmlhVnVlUGx1Z2luLCBjcmVhdGVQaW5pYSB9IGZyb20gJ3BpbmlhJ1xuICpcbiAqIFZ1ZS51c2UoUGluaWFWdWVQbHVnaW4pXG4gKiBjb25zdCBwaW5pYSA9IGNyZWF0ZVBpbmlhKClcbiAqXG4gKiBuZXcgVnVlKHtcbiAqICAgZWw6ICcjYXBwJyxcbiAqICAgLy8gLi4uXG4gKiAgIHBpbmlhLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBfVnVlIC0gYFZ1ZWAgaW1wb3J0ZWQgZnJvbSAndnVlJy5cbiAqL1xuY29uc3QgUGluaWFWdWVQbHVnaW4gPSBmdW5jdGlvbiAoX1Z1ZSkge1xuICAgIC8vIEVxdWl2YWxlbnQgb2ZcbiAgICAvLyBhcHAuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMuJHBpbmlhID0gcGluaWFcbiAgICBfVnVlLm1peGluKHtcbiAgICAgICAgYmVmb3JlQ3JlYXRlKCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5waW5pYSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpbmlhID0gb3B0aW9ucy5waW5pYTtcbiAgICAgICAgICAgICAgICAvLyBIQUNLOiB0YWtlbiBmcm9tIHByb3ZpZGUoKTogaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL2NvbXBvc2l0aW9uLWFwaS9ibG9iL21haW4vc3JjL2FwaXMvaW5qZWN0LnRzI0wzMVxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9wcm92aWRlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm92aWRlQ2FjaGUgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfcHJvdmlkZWQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHByb3ZpZGVDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldDogKHYpID0+IE9iamVjdC5hc3NpZ24ocHJvdmlkZUNhY2hlLCB2KSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3ZpZGVkW3BpbmlhU3ltYm9sXSA9IHBpbmlhO1xuICAgICAgICAgICAgICAgIC8vIHByb3BhZ2F0ZSB0aGUgcGluaWEgaW5zdGFuY2UgaW4gYW4gU1NSIGZyaWVuZGx5IHdheVxuICAgICAgICAgICAgICAgIC8vIGF2b2lkIGFkZGluZyBpdCB0byBudXh0IHR3aWNlXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuJHBpbmlhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHBpbmlhID0gcGluaWE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBpbmlhLl9hID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoSVNfQ0xJRU5UKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgYWxsb3dzIGNhbGxpbmcgdXNlU3RvcmUoKSBvdXRzaWRlIG9mIGEgY29tcG9uZW50IHNldHVwIGFmdGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluc3RhbGxpbmcgcGluaWEncyBwbHVnaW5cbiAgICAgICAgICAgICAgICAgICAgc2V0QWN0aXZlUGluaWEocGluaWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoVVNFX0RFVlRPT0xTKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyUGluaWFEZXZ0b29scyhwaW5pYS5fYSwgcGluaWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLiRwaW5pYSAmJiBvcHRpb25zLnBhcmVudCAmJiBvcHRpb25zLnBhcmVudC4kcGluaWEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRwaW5pYSA9IG9wdGlvbnMucGFyZW50LiRwaW5pYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveWVkKCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3BTdG9yZXM7XG4gICAgICAgIH0sXG4gICAgfSk7XG59O1xuXG5leHBvcnQgeyBNdXRhdGlvblR5cGUsIFBpbmlhVnVlUGx1Z2luLCBhY2NlcHRITVJVcGRhdGUsIGNyZWF0ZVBpbmlhLCBkZWZpbmVTdG9yZSwgZ2V0QWN0aXZlUGluaWEsIG1hcEFjdGlvbnMsIG1hcEdldHRlcnMsIG1hcFN0YXRlLCBtYXBTdG9yZXMsIG1hcFdyaXRhYmxlU3RhdGUsIHNldEFjdGl2ZVBpbmlhLCBzZXRNYXBTdG9yZVN1ZmZpeCwgc2tpcEh5ZHJhdGUsIHN0b3JlVG9SZWZzIH07XG4iLCJpbXBvcnQgKiBhcyBWdWUgZnJvbSAndnVlJ1xuXG52YXIgaXNWdWUyID0gZmFsc2VcbnZhciBpc1Z1ZTMgPSB0cnVlXG52YXIgVnVlMiA9IHVuZGVmaW5lZFxuXG5mdW5jdGlvbiBpbnN0YWxsKCkge31cblxuZXhwb3J0IGZ1bmN0aW9uIHNldCh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KVxuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpXG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIHRhcmdldFtrZXldID0gdmFsXG4gIHJldHVybiB2YWxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbCh0YXJnZXQsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpXG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldXG59XG5cbmV4cG9ydCAqIGZyb20gJ3Z1ZSdcbmV4cG9ydCB7XG4gIFZ1ZSxcbiAgVnVlMixcbiAgaXNWdWUyLFxuICBpc1Z1ZTMsXG4gIGluc3RhbGwsXG59XG4iLCIvKiFcbiAgKiB2dWUtcm91dGVyIHY0LjIuNVxuICAqIChjKSAyMDIzIEVkdWFyZG8gU2FuIE1hcnRpbiBNb3JvdGVcbiAgKiBAbGljZW5zZSBNSVRcbiAgKi9cbmltcG9ydCB7IGdldEN1cnJlbnRJbnN0YW5jZSwgaW5qZWN0LCBvblVubW91bnRlZCwgb25EZWFjdGl2YXRlZCwgb25BY3RpdmF0ZWQsIGNvbXB1dGVkLCB1bnJlZiwgd2F0Y2hFZmZlY3QsIGRlZmluZUNvbXBvbmVudCwgcmVhY3RpdmUsIGgsIHByb3ZpZGUsIHJlZiwgd2F0Y2gsIHNoYWxsb3dSZWYsIHNoYWxsb3dSZWFjdGl2ZSwgbmV4dFRpY2sgfSBmcm9tICd2dWUnO1xuaW1wb3J0IHsgc2V0dXBEZXZ0b29sc1BsdWdpbiB9IGZyb20gJ0B2dWUvZGV2dG9vbHMtYXBpJztcblxuY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbmZ1bmN0aW9uIGlzRVNNb2R1bGUob2JqKSB7XG4gICAgcmV0dXJuIG9iai5fX2VzTW9kdWxlIHx8IG9ialtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJztcbn1cbmNvbnN0IGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5mdW5jdGlvbiBhcHBseVRvUGFyYW1zKGZuLCBwYXJhbXMpIHtcbiAgICBjb25zdCBuZXdQYXJhbXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgbmV3UGFyYW1zW2tleV0gPSBpc0FycmF5KHZhbHVlKVxuICAgICAgICAgICAgPyB2YWx1ZS5tYXAoZm4pXG4gICAgICAgICAgICA6IGZuKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1BhcmFtcztcbn1cbmNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG4vKipcbiAqIFR5cGVzYWZlIGFsdGVybmF0aXZlIHRvIEFycmF5LmlzQXJyYXlcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9wdWxsLzQ4MjI4XG4gKi9cbmNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICAgIC8vIGF2b2lkIHVzaW5nIC4uLmFyZ3MgYXMgaXQgYnJlYWtzIGluIG9sZGVyIEVkZ2UgYnVpbGRzXG4gICAgY29uc3QgYXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzKS5zbGljZSgxKTtcbiAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgWydbVnVlIFJvdXRlciB3YXJuXTogJyArIG1zZ10uY29uY2F0KGFyZ3MpKTtcbn1cblxuY29uc3QgVFJBSUxJTkdfU0xBU0hfUkUgPSAvXFwvJC87XG5jb25zdCByZW1vdmVUcmFpbGluZ1NsYXNoID0gKHBhdGgpID0+IHBhdGgucmVwbGFjZShUUkFJTElOR19TTEFTSF9SRSwgJycpO1xuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgVVJJIGludG8gYSBub3JtYWxpemVkIGhpc3RvcnkgbG9jYXRpb25cbiAqXG4gKiBAcGFyYW0gcGFyc2VRdWVyeVxuICogQHBhcmFtIGxvY2F0aW9uIC0gVVJJIHRvIG5vcm1hbGl6ZVxuICogQHBhcmFtIGN1cnJlbnRMb2NhdGlvbiAtIGN1cnJlbnQgYWJzb2x1dGUgbG9jYXRpb24uIEFsbG93cyByZXNvbHZpbmcgcmVsYXRpdmVcbiAqIHBhdGhzLiBNdXN0IHN0YXJ0IHdpdGggYC9gLiBEZWZhdWx0cyB0byBgL2BcbiAqIEByZXR1cm5zIGEgbm9ybWFsaXplZCBoaXN0b3J5IGxvY2F0aW9uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVVJMKHBhcnNlUXVlcnksIGxvY2F0aW9uLCBjdXJyZW50TG9jYXRpb24gPSAnLycpIHtcbiAgICBsZXQgcGF0aCwgcXVlcnkgPSB7fSwgc2VhcmNoU3RyaW5nID0gJycsIGhhc2ggPSAnJztcbiAgICAvLyBDb3VsZCB1c2UgVVJMIGFuZCBVUkxTZWFyY2hQYXJhbXMgYnV0IElFIDExIGRvZXNuJ3Qgc3VwcG9ydCBpdFxuICAgIC8vIFRPRE86IG1vdmUgdG8gbmV3IFVSTCgpXG4gICAgY29uc3QgaGFzaFBvcyA9IGxvY2F0aW9uLmluZGV4T2YoJyMnKTtcbiAgICBsZXQgc2VhcmNoUG9zID0gbG9jYXRpb24uaW5kZXhPZignPycpO1xuICAgIC8vIHRoZSBoYXNoIGFwcGVhcnMgYmVmb3JlIHRoZSBzZWFyY2gsIHNvIGl0J3Mgbm90IHBhcnQgb2YgdGhlIHNlYXJjaCBzdHJpbmdcbiAgICBpZiAoaGFzaFBvcyA8IHNlYXJjaFBvcyAmJiBoYXNoUG9zID49IDApIHtcbiAgICAgICAgc2VhcmNoUG9zID0gLTE7XG4gICAgfVxuICAgIGlmIChzZWFyY2hQb3MgPiAtMSkge1xuICAgICAgICBwYXRoID0gbG9jYXRpb24uc2xpY2UoMCwgc2VhcmNoUG9zKTtcbiAgICAgICAgc2VhcmNoU3RyaW5nID0gbG9jYXRpb24uc2xpY2Uoc2VhcmNoUG9zICsgMSwgaGFzaFBvcyA+IC0xID8gaGFzaFBvcyA6IGxvY2F0aW9uLmxlbmd0aCk7XG4gICAgICAgIHF1ZXJ5ID0gcGFyc2VRdWVyeShzZWFyY2hTdHJpbmcpO1xuICAgIH1cbiAgICBpZiAoaGFzaFBvcyA+IC0xKSB7XG4gICAgICAgIHBhdGggPSBwYXRoIHx8IGxvY2F0aW9uLnNsaWNlKDAsIGhhc2hQb3MpO1xuICAgICAgICAvLyBrZWVwIHRoZSAjIGNoYXJhY3RlclxuICAgICAgICBoYXNoID0gbG9jYXRpb24uc2xpY2UoaGFzaFBvcywgbG9jYXRpb24ubGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gbm8gc2VhcmNoIGFuZCBubyBxdWVyeVxuICAgIHBhdGggPSByZXNvbHZlUmVsYXRpdmVQYXRoKHBhdGggIT0gbnVsbCA/IHBhdGggOiBsb2NhdGlvbiwgY3VycmVudExvY2F0aW9uKTtcbiAgICAvLyBlbXB0eSBwYXRoIG1lYW5zIGEgcmVsYXRpdmUgcXVlcnkgb3IgaGFzaCBgP2Zvbz1mYCwgYCN0aGluZ2BcbiAgICByZXR1cm4ge1xuICAgICAgICBmdWxsUGF0aDogcGF0aCArIChzZWFyY2hTdHJpbmcgJiYgJz8nKSArIHNlYXJjaFN0cmluZyArIGhhc2gsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBoYXNoLFxuICAgIH07XG59XG4vKipcbiAqIFN0cmluZ2lmaWVzIGEgVVJMIG9iamVjdFxuICpcbiAqIEBwYXJhbSBzdHJpbmdpZnlRdWVyeVxuICogQHBhcmFtIGxvY2F0aW9uXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeVVSTChzdHJpbmdpZnlRdWVyeSwgbG9jYXRpb24pIHtcbiAgICBjb25zdCBxdWVyeSA9IGxvY2F0aW9uLnF1ZXJ5ID8gc3RyaW5naWZ5UXVlcnkobG9jYXRpb24ucXVlcnkpIDogJyc7XG4gICAgcmV0dXJuIGxvY2F0aW9uLnBhdGggKyAocXVlcnkgJiYgJz8nKSArIHF1ZXJ5ICsgKGxvY2F0aW9uLmhhc2ggfHwgJycpO1xufVxuLyoqXG4gKiBTdHJpcHMgb2ZmIHRoZSBiYXNlIGZyb20gdGhlIGJlZ2lubmluZyBvZiBhIGxvY2F0aW9uLnBhdGhuYW1lIGluIGEgbm9uLWNhc2Utc2Vuc2l0aXZlIHdheS5cbiAqXG4gKiBAcGFyYW0gcGF0aG5hbWUgLSBsb2NhdGlvbi5wYXRobmFtZVxuICogQHBhcmFtIGJhc2UgLSBiYXNlIHRvIHN0cmlwIG9mZlxuICovXG5mdW5jdGlvbiBzdHJpcEJhc2UocGF0aG5hbWUsIGJhc2UpIHtcbiAgICAvLyBubyBiYXNlIG9yIGJhc2UgaXMgbm90IGZvdW5kIGF0IHRoZSBiZWdpbm5pbmdcbiAgICBpZiAoIWJhc2UgfHwgIXBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChiYXNlLnRvTG93ZXJDYXNlKCkpKVxuICAgICAgICByZXR1cm4gcGF0aG5hbWU7XG4gICAgcmV0dXJuIHBhdGhuYW1lLnNsaWNlKGJhc2UubGVuZ3RoKSB8fCAnLyc7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0d28gUm91dGVMb2NhdGlvbiBhcmUgZXF1YWwuIFRoaXMgbWVhbnMgdGhhdCBib3RoIGxvY2F0aW9ucyBhcmVcbiAqIHBvaW50aW5nIHRvd2FyZHMgdGhlIHNhbWUge0BsaW5rIFJvdXRlUmVjb3JkfSBhbmQgdGhhdCBhbGwgYHBhcmFtc2AsIGBxdWVyeWBcbiAqIHBhcmFtZXRlcnMgYW5kIGBoYXNoYCBhcmUgdGhlIHNhbWVcbiAqXG4gKiBAcGFyYW0gc3RyaW5naWZ5UXVlcnkgLSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBxdWVyeSBvYmplY3Qgb2YgdHlwZSBMb2NhdGlvblF1ZXJ5UmF3IGFuZCByZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGl0LlxuICogQHBhcmFtIGEgLSBmaXJzdCB7QGxpbmsgUm91dGVMb2NhdGlvbn1cbiAqIEBwYXJhbSBiIC0gc2Vjb25kIHtAbGluayBSb3V0ZUxvY2F0aW9ufVxuICovXG5mdW5jdGlvbiBpc1NhbWVSb3V0ZUxvY2F0aW9uKHN0cmluZ2lmeVF1ZXJ5LCBhLCBiKSB7XG4gICAgY29uc3QgYUxhc3RJbmRleCA9IGEubWF0Y2hlZC5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGJMYXN0SW5kZXggPSBiLm1hdGNoZWQubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gKGFMYXN0SW5kZXggPiAtMSAmJlxuICAgICAgICBhTGFzdEluZGV4ID09PSBiTGFzdEluZGV4ICYmXG4gICAgICAgIGlzU2FtZVJvdXRlUmVjb3JkKGEubWF0Y2hlZFthTGFzdEluZGV4XSwgYi5tYXRjaGVkW2JMYXN0SW5kZXhdKSAmJlxuICAgICAgICBpc1NhbWVSb3V0ZUxvY2F0aW9uUGFyYW1zKGEucGFyYW1zLCBiLnBhcmFtcykgJiZcbiAgICAgICAgc3RyaW5naWZ5UXVlcnkoYS5xdWVyeSkgPT09IHN0cmluZ2lmeVF1ZXJ5KGIucXVlcnkpICYmXG4gICAgICAgIGEuaGFzaCA9PT0gYi5oYXNoKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdHdvIGBSb3V0ZVJlY29yZHNgIGFyZSBlcXVhbC4gVGFrZXMgaW50byBhY2NvdW50IGFsaWFzZXM6IHRoZXkgYXJlXG4gKiBjb25zaWRlcmVkIGVxdWFsIHRvIHRoZSBgUm91dGVSZWNvcmRgIHRoZXkgYXJlIGFsaWFzaW5nLlxuICpcbiAqIEBwYXJhbSBhIC0gZmlyc3Qge0BsaW5rIFJvdXRlUmVjb3JkfVxuICogQHBhcmFtIGIgLSBzZWNvbmQge0BsaW5rIFJvdXRlUmVjb3JkfVxuICovXG5mdW5jdGlvbiBpc1NhbWVSb3V0ZVJlY29yZChhLCBiKSB7XG4gICAgLy8gc2luY2UgdGhlIG9yaWdpbmFsIHJlY29yZCBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGZvciBhbGlhc09mXG4gICAgLy8gYnV0IGFsbCBhbGlhc2VzIHBvaW50IHRvIHRoZSBvcmlnaW5hbCByZWNvcmQsIHRoaXMgd2lsbCBhbHdheXMgY29tcGFyZVxuICAgIC8vIHRoZSBvcmlnaW5hbCByZWNvcmRcbiAgICByZXR1cm4gKGEuYWxpYXNPZiB8fCBhKSA9PT0gKGIuYWxpYXNPZiB8fCBiKTtcbn1cbmZ1bmN0aW9uIGlzU2FtZVJvdXRlTG9jYXRpb25QYXJhbXMoYSwgYikge1xuICAgIGlmIChPYmplY3Qua2V5cyhhKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGEpIHtcbiAgICAgICAgaWYgKCFpc1NhbWVSb3V0ZUxvY2F0aW9uUGFyYW1zVmFsdWUoYVtrZXldLCBiW2tleV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzU2FtZVJvdXRlTG9jYXRpb25QYXJhbXNWYWx1ZShhLCBiKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkoYSlcbiAgICAgICAgPyBpc0VxdWl2YWxlbnRBcnJheShhLCBiKVxuICAgICAgICA6IGlzQXJyYXkoYilcbiAgICAgICAgICAgID8gaXNFcXVpdmFsZW50QXJyYXkoYiwgYSlcbiAgICAgICAgICAgIDogYSA9PT0gYjtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdHdvIGFycmF5cyBhcmUgdGhlIHNhbWUgb3IgaWYgYW4gYXJyYXkgd2l0aCBvbmUgc2luZ2xlIGVudHJ5IGlzIHRoZVxuICogc2FtZSBhcyBhbm90aGVyIHByaW1pdGl2ZSB2YWx1ZS4gVXNlZCB0byBjaGVjayBxdWVyeSBhbmQgcGFyYW1ldGVyc1xuICpcbiAqIEBwYXJhbSBhIC0gYXJyYXkgb2YgdmFsdWVzXG4gKiBAcGFyYW0gYiAtIGFycmF5IG9mIHZhbHVlcyBvciBhIHNpbmdsZSB2YWx1ZVxuICovXG5mdW5jdGlvbiBpc0VxdWl2YWxlbnRBcnJheShhLCBiKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkoYilcbiAgICAgICAgPyBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeSgodmFsdWUsIGkpID0+IHZhbHVlID09PSBiW2ldKVxuICAgICAgICA6IGEubGVuZ3RoID09PSAxICYmIGFbMF0gPT09IGI7XG59XG4vKipcbiAqIFJlc29sdmVzIGEgcmVsYXRpdmUgcGF0aCB0aGF0IHN0YXJ0cyB3aXRoIGAuYC5cbiAqXG4gKiBAcGFyYW0gdG8gLSBwYXRoIGxvY2F0aW9uIHdlIGFyZSByZXNvbHZpbmdcbiAqIEBwYXJhbSBmcm9tIC0gY3VycmVudExvY2F0aW9uLnBhdGgsIHNob3VsZCBzdGFydCB3aXRoIGAvYFxuICovXG5mdW5jdGlvbiByZXNvbHZlUmVsYXRpdmVQYXRoKHRvLCBmcm9tKSB7XG4gICAgaWYgKHRvLnN0YXJ0c1dpdGgoJy8nKSlcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWZyb20uc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgIHdhcm4oYENhbm5vdCByZXNvbHZlIGEgcmVsYXRpdmUgbG9jYXRpb24gd2l0aG91dCBhbiBhYnNvbHV0ZSBwYXRoLiBUcnlpbmcgdG8gcmVzb2x2ZSBcIiR7dG99XCIgZnJvbSBcIiR7ZnJvbX1cIi4gSXQgc2hvdWxkIGxvb2sgbGlrZSBcIi8ke2Zyb219XCIuYCk7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgaWYgKCF0bylcbiAgICAgICAgcmV0dXJuIGZyb207XG4gICAgY29uc3QgZnJvbVNlZ21lbnRzID0gZnJvbS5zcGxpdCgnLycpO1xuICAgIGNvbnN0IHRvU2VnbWVudHMgPSB0by5zcGxpdCgnLycpO1xuICAgIGNvbnN0IGxhc3RUb1NlZ21lbnQgPSB0b1NlZ21lbnRzW3RvU2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgLy8gbWFrZSAuIGFuZCAuLyB0aGUgc2FtZSAoLi4vID09PSAuLiwgLi4vLi4vID09PSAuLi8uLilcbiAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGJlaGF2aW9yIGFzIG5ldyBVUkwoKVxuICAgIGlmIChsYXN0VG9TZWdtZW50ID09PSAnLi4nIHx8IGxhc3RUb1NlZ21lbnQgPT09ICcuJykge1xuICAgICAgICB0b1NlZ21lbnRzLnB1c2goJycpO1xuICAgIH1cbiAgICBsZXQgcG9zaXRpb24gPSBmcm9tU2VnbWVudHMubGVuZ3RoIC0gMTtcbiAgICBsZXQgdG9Qb3NpdGlvbjtcbiAgICBsZXQgc2VnbWVudDtcbiAgICBmb3IgKHRvUG9zaXRpb24gPSAwOyB0b1Bvc2l0aW9uIDwgdG9TZWdtZW50cy5sZW5ndGg7IHRvUG9zaXRpb24rKykge1xuICAgICAgICBzZWdtZW50ID0gdG9TZWdtZW50c1t0b1Bvc2l0aW9uXTtcbiAgICAgICAgLy8gd2Ugc3RheSBvbiB0aGUgc2FtZSBwb3NpdGlvblxuICAgICAgICBpZiAoc2VnbWVudCA9PT0gJy4nKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIC8vIGdvIHVwIGluIHRoZSBmcm9tIGFycmF5XG4gICAgICAgIGlmIChzZWdtZW50ID09PSAnLi4nKSB7XG4gICAgICAgICAgICAvLyB3ZSBjYW4ndCBnbyBiZWxvdyB6ZXJvLCBidXQgd2Ugc3RpbGwgbmVlZCB0byBpbmNyZW1lbnQgdG9Qb3NpdGlvblxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID4gMSlcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi0tO1xuICAgICAgICAgICAgLy8gY29udGludWVcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSByZWFjaGVkIGEgbm9uLXJlbGF0aXZlIHBhdGgsIHdlIHN0b3AgaGVyZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIChmcm9tU2VnbWVudHMuc2xpY2UoMCwgcG9zaXRpb24pLmpvaW4oJy8nKSArXG4gICAgICAgICcvJyArXG4gICAgICAgIHRvU2VnbWVudHNcbiAgICAgICAgICAgIC8vIGVuc3VyZSB3ZSB1c2UgYXQgbGVhc3QgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgdG9TZWdtZW50c1xuICAgICAgICAgICAgLnNsaWNlKHRvUG9zaXRpb24gLSAodG9Qb3NpdGlvbiA9PT0gdG9TZWdtZW50cy5sZW5ndGggPyAxIDogMCkpXG4gICAgICAgICAgICAuam9pbignLycpKTtcbn1cblxudmFyIE5hdmlnYXRpb25UeXBlO1xuKGZ1bmN0aW9uIChOYXZpZ2F0aW9uVHlwZSkge1xuICAgIE5hdmlnYXRpb25UeXBlW1wicG9wXCJdID0gXCJwb3BcIjtcbiAgICBOYXZpZ2F0aW9uVHlwZVtcInB1c2hcIl0gPSBcInB1c2hcIjtcbn0pKE5hdmlnYXRpb25UeXBlIHx8IChOYXZpZ2F0aW9uVHlwZSA9IHt9KSk7XG52YXIgTmF2aWdhdGlvbkRpcmVjdGlvbjtcbihmdW5jdGlvbiAoTmF2aWdhdGlvbkRpcmVjdGlvbikge1xuICAgIE5hdmlnYXRpb25EaXJlY3Rpb25bXCJiYWNrXCJdID0gXCJiYWNrXCI7XG4gICAgTmF2aWdhdGlvbkRpcmVjdGlvbltcImZvcndhcmRcIl0gPSBcImZvcndhcmRcIjtcbiAgICBOYXZpZ2F0aW9uRGlyZWN0aW9uW1widW5rbm93blwiXSA9IFwiXCI7XG59KShOYXZpZ2F0aW9uRGlyZWN0aW9uIHx8IChOYXZpZ2F0aW9uRGlyZWN0aW9uID0ge30pKTtcbi8qKlxuICogU3RhcnRpbmcgbG9jYXRpb24gZm9yIEhpc3Rvcmllc1xuICovXG5jb25zdCBTVEFSVCA9ICcnO1xuLy8gR2VuZXJpYyB1dGlsc1xuLyoqXG4gKiBOb3JtYWxpemVzIGEgYmFzZSBieSByZW1vdmluZyBhbnkgdHJhaWxpbmcgc2xhc2ggYW5kIHJlYWRpbmcgdGhlIGJhc2UgdGFnIGlmXG4gKiBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSBiYXNlIC0gYmFzZSB0byBub3JtYWxpemVcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQmFzZShiYXNlKSB7XG4gICAgaWYgKCFiYXNlKSB7XG4gICAgICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIC8vIHJlc3BlY3QgPGJhc2U+IHRhZ1xuICAgICAgICAgICAgY29uc3QgYmFzZUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYmFzZScpO1xuICAgICAgICAgICAgYmFzZSA9IChiYXNlRWwgJiYgYmFzZUVsLmdldEF0dHJpYnV0ZSgnaHJlZicpKSB8fCAnLyc7XG4gICAgICAgICAgICAvLyBzdHJpcCBmdWxsIFVSTCBvcmlnaW5cbiAgICAgICAgICAgIGJhc2UgPSBiYXNlLnJlcGxhY2UoL15cXHcrOlxcL1xcL1teXFwvXSsvLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBiYXNlID0gJy8nO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVuc3VyZSBsZWFkaW5nIHNsYXNoIHdoZW4gaXQgd2FzIHJlbW92ZWQgYnkgdGhlIHJlZ2V4IGFib3ZlIGF2b2lkIGxlYWRpbmdcbiAgICAvLyBzbGFzaCB3aXRoIGhhc2ggYmVjYXVzZSB0aGUgZmlsZSBjb3VsZCBiZSByZWFkIGZyb20gdGhlIGRpc2sgbGlrZSBmaWxlOi8vXG4gICAgLy8gYW5kIHRoZSBsZWFkaW5nIHNsYXNoIHdvdWxkIGNhdXNlIHByb2JsZW1zXG4gICAgaWYgKGJhc2VbMF0gIT09ICcvJyAmJiBiYXNlWzBdICE9PSAnIycpXG4gICAgICAgIGJhc2UgPSAnLycgKyBiYXNlO1xuICAgIC8vIHJlbW92ZSB0aGUgdHJhaWxpbmcgc2xhc2ggc28gYWxsIG90aGVyIG1ldGhvZCBjYW4ganVzdCBkbyBgYmFzZSArIGZ1bGxQYXRoYFxuICAgIC8vIHRvIGJ1aWxkIGFuIGhyZWZcbiAgICByZXR1cm4gcmVtb3ZlVHJhaWxpbmdTbGFzaChiYXNlKTtcbn1cbi8vIHJlbW92ZSBhbnkgY2hhcmFjdGVyIGJlZm9yZSB0aGUgaGFzaFxuY29uc3QgQkVGT1JFX0hBU0hfUkUgPSAvXlteI10rIy87XG5mdW5jdGlvbiBjcmVhdGVIcmVmKGJhc2UsIGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGJhc2UucmVwbGFjZShCRUZPUkVfSEFTSF9SRSwgJyMnKSArIGxvY2F0aW9uO1xufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50UG9zaXRpb24oZWwsIG9mZnNldCkge1xuICAgIGNvbnN0IGRvY1JlY3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgZWxSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmVoYXZpb3I6IG9mZnNldC5iZWhhdmlvcixcbiAgICAgICAgbGVmdDogZWxSZWN0LmxlZnQgLSBkb2NSZWN0LmxlZnQgLSAob2Zmc2V0LmxlZnQgfHwgMCksXG4gICAgICAgIHRvcDogZWxSZWN0LnRvcCAtIGRvY1JlY3QudG9wIC0gKG9mZnNldC50b3AgfHwgMCksXG4gICAgfTtcbn1cbmNvbnN0IGNvbXB1dGVTY3JvbGxQb3NpdGlvbiA9ICgpID0+ICh7XG4gICAgbGVmdDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgIHRvcDogd2luZG93LnBhZ2VZT2Zmc2V0LFxufSk7XG5mdW5jdGlvbiBzY3JvbGxUb1Bvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgbGV0IHNjcm9sbFRvT3B0aW9ucztcbiAgICBpZiAoJ2VsJyBpbiBwb3NpdGlvbikge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkVsID0gcG9zaXRpb24uZWw7XG4gICAgICAgIGNvbnN0IGlzSWRTZWxlY3RvciA9IHR5cGVvZiBwb3NpdGlvbkVsID09PSAnc3RyaW5nJyAmJiBwb3NpdGlvbkVsLnN0YXJ0c1dpdGgoJyMnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGBpZGBzIGNhbiBhY2NlcHQgcHJldHR5IG11Y2ggYW55IGNoYXJhY3RlcnMsIGluY2x1ZGluZyBDU1MgY29tYmluYXRvcnNcbiAgICAgICAgICogbGlrZSBgPmAgb3IgYH5gLiBJdCdzIHN0aWxsIHBvc3NpYmxlIHRvIHJldHJpZXZlIGVsZW1lbnRzIHVzaW5nXG4gICAgICAgICAqIGBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnficpYCBidXQgaXQgbmVlZHMgdG8gYmUgZXNjYXBlZCB3aGVuIHVzaW5nXG4gICAgICAgICAqIGBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjXFxcXH4nKWAgZm9yIGl0IHRvIGJlIHZhbGlkLiBUaGUgb25seVxuICAgICAgICAgKiByZXF1aXJlbWVudHMgZm9yIGBpZGBzIGFyZSB0aGVtIHRvIGJlIHVuaXF1ZSBvbiB0aGUgcGFnZSBhbmQgdG8gbm90IGJlXG4gICAgICAgICAqIGVtcHR5IChgaWQ9XCJcImApLiBCZWNhdXNlIG9mIHRoYXQsIHdoZW4gcGFzc2luZyBhbiBpZCBzZWxlY3RvciwgaXQgc2hvdWxkXG4gICAgICAgICAqIGJlIHByb3Blcmx5IGVzY2FwZWQgZm9yIGl0IHRvIHdvcmsgd2l0aCBgcXVlcnlTZWxlY3RvcmAuIFdlIGNvdWxkIGNoZWNrXG4gICAgICAgICAqIGZvciB0aGUgaWQgc2VsZWN0b3IgdG8gYmUgc2ltcGxlIChubyBDU1MgY29tYmluYXRvcnMgYCsgPn5gKSBidXQgdGhhdFxuICAgICAgICAgKiB3b3VsZCBtYWtlIHRoaW5ncyBpbmNvbnNpc3RlbnQgc2luY2UgdGhleSBhcmUgdmFsaWQgY2hhcmFjdGVycyBmb3IgYW5cbiAgICAgICAgICogYGlkYCBidXQgd291bGQgbmVlZCB0byBiZSBlc2NhcGVkIHdoZW4gdXNpbmcgYHF1ZXJ5U2VsZWN0b3JgLCBicmVha2luZ1xuICAgICAgICAgKiB0aGVpciB1c2FnZSBhbmQgZW5kaW5nIHVwIGluIG5vIHNlbGVjdG9yIHJldHVybmVkLiBTZWxlY3RvcnMgbmVlZCB0byBiZVxuICAgICAgICAgKiBlc2NhcGVkOlxuICAgICAgICAgKlxuICAgICAgICAgKiAtIGAjMS10aGluZ2AgYmVjb21lcyBgI1xcMzEgLXRoaW5nYFxuICAgICAgICAgKiAtIGAjd2l0aH5zeW1ib2xzYCBiZWNvbWVzIGAjd2l0aFxcXFx+c3ltYm9sc2BcbiAgICAgICAgICpcbiAgICAgICAgICogLSBNb3JlIGluZm9ybWF0aW9uIGFib3V0ICB0aGUgdG9waWMgY2FuIGJlIGZvdW5kIGF0XG4gICAgICAgICAqICAgaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2h0bWw1LWlkLWNsYXNzLlxuICAgICAgICAgKiAtIFByYWN0aWNhbCBleGFtcGxlOiBodHRwczovL21hdGhpYXNieW5lbnMuYmUvZGVtby9odG1sNS1pZFxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0eXBlb2YgcG9zaXRpb24uZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoIWlzSWRTZWxlY3RvciB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocG9zaXRpb24uZWwuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm91bmRFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocG9zaXRpb24uZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJZFNlbGVjdG9yICYmIGZvdW5kRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYFRoZSBzZWxlY3RvciBcIiR7cG9zaXRpb24uZWx9XCIgc2hvdWxkIGJlIHBhc3NlZCBhcyBcImVsOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcke3Bvc2l0aW9uLmVsfScpXCIgYmVjYXVzZSBpdCBzdGFydHMgd2l0aCBcIiNcIi5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiB0byBhdm9pZCBvdGhlciB3YXJuaW5nc1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgVGhlIHNlbGVjdG9yIFwiJHtwb3NpdGlvbi5lbH1cIiBpcyBpbnZhbGlkLiBJZiB5b3UgYXJlIHVzaW5nIGFuIGlkIHNlbGVjdG9yLCBtYWtlIHN1cmUgdG8gZXNjYXBlIGl0LiBZb3UgY2FuIGZpbmQgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBlc2NhcGluZyBjaGFyYWN0ZXJzIGluIHNlbGVjdG9ycyBhdCBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvY3NzLWVzY2FwZXMgb3IgdXNlIENTUy5lc2NhcGUgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DU1MvZXNjYXBlKS5gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRvIGF2b2lkIG90aGVyIHdhcm5pbmdzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWwgPSB0eXBlb2YgcG9zaXRpb25FbCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gaXNJZFNlbGVjdG9yXG4gICAgICAgICAgICAgICAgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwb3NpdGlvbkVsLnNsaWNlKDEpKVxuICAgICAgICAgICAgICAgIDogZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihwb3NpdGlvbkVsKVxuICAgICAgICAgICAgOiBwb3NpdGlvbkVsO1xuICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICB3YXJuKGBDb3VsZG4ndCBmaW5kIGVsZW1lbnQgdXNpbmcgc2VsZWN0b3IgXCIke3Bvc2l0aW9uLmVsfVwiIHJldHVybmVkIGJ5IHNjcm9sbEJlaGF2aW9yLmApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNjcm9sbFRvT3B0aW9ucyA9IGdldEVsZW1lbnRQb3NpdGlvbihlbCwgcG9zaXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2Nyb2xsVG9PcHRpb25zID0gcG9zaXRpb247XG4gICAgfVxuICAgIGlmICgnc2Nyb2xsQmVoYXZpb3InIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSlcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKHNjcm9sbFRvT3B0aW9ucyk7XG4gICAgZWxzZSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbyhzY3JvbGxUb09wdGlvbnMubGVmdCAhPSBudWxsID8gc2Nyb2xsVG9PcHRpb25zLmxlZnQgOiB3aW5kb3cucGFnZVhPZmZzZXQsIHNjcm9sbFRvT3B0aW9ucy50b3AgIT0gbnVsbCA/IHNjcm9sbFRvT3B0aW9ucy50b3AgOiB3aW5kb3cucGFnZVlPZmZzZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNjcm9sbEtleShwYXRoLCBkZWx0YSkge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gaGlzdG9yeS5zdGF0ZSA/IGhpc3Rvcnkuc3RhdGUucG9zaXRpb24gLSBkZWx0YSA6IC0xO1xuICAgIHJldHVybiBwb3NpdGlvbiArIHBhdGg7XG59XG5jb25zdCBzY3JvbGxQb3NpdGlvbnMgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBzYXZlU2Nyb2xsUG9zaXRpb24oa2V5LCBzY3JvbGxQb3NpdGlvbikge1xuICAgIHNjcm9sbFBvc2l0aW9ucy5zZXQoa2V5LCBzY3JvbGxQb3NpdGlvbik7XG59XG5mdW5jdGlvbiBnZXRTYXZlZFNjcm9sbFBvc2l0aW9uKGtleSkge1xuICAgIGNvbnN0IHNjcm9sbCA9IHNjcm9sbFBvc2l0aW9ucy5nZXQoa2V5KTtcbiAgICAvLyBjb25zdW1lIGl0IHNvIGl0J3Mgbm90IHVzZWQgYWdhaW5cbiAgICBzY3JvbGxQb3NpdGlvbnMuZGVsZXRlKGtleSk7XG4gICAgcmV0dXJuIHNjcm9sbDtcbn1cbi8vIFRPRE86IFJGQyBhYm91dCBob3cgdG8gc2F2ZSBzY3JvbGwgcG9zaXRpb25cbi8qKlxuICogU2Nyb2xsQmVoYXZpb3IgaW5zdGFuY2UgdXNlZCBieSB0aGUgcm91dGVyIHRvIGNvbXB1dGUgYW5kIHJlc3RvcmUgdGhlIHNjcm9sbFxuICogcG9zaXRpb24gd2hlbiBuYXZpZ2F0aW5nLlxuICovXG4vLyBleHBvcnQgaW50ZXJmYWNlIFNjcm9sbEhhbmRsZXI8U2Nyb2xsUG9zaXRpb25FbnRyeSBleHRlbmRzIEhpc3RvcnlTdGF0ZVZhbHVlLCBTY3JvbGxQb3NpdGlvbiBleHRlbmRzIFNjcm9sbFBvc2l0aW9uRW50cnk+IHtcbi8vICAgLy8gcmV0dXJucyBhIHNjcm9sbCBwb3NpdGlvbiB0aGF0IGNhbiBiZSBzYXZlZCBpbiBoaXN0b3J5XG4vLyAgIGNvbXB1dGUoKTogU2Nyb2xsUG9zaXRpb25FbnRyeVxuLy8gICAvLyBjYW4gdGFrZSBhbiBleHRlbmRlZCBTY3JvbGxQb3NpdGlvbkVudHJ5XG4vLyAgIHNjcm9sbChwb3NpdGlvbjogU2Nyb2xsUG9zaXRpb24pOiB2b2lkXG4vLyB9XG4vLyBleHBvcnQgY29uc3Qgc2Nyb2xsSGFuZGxlcjogU2Nyb2xsSGFuZGxlcjxTY3JvbGxQb3NpdGlvbj4gPSB7XG4vLyAgIGNvbXB1dGU6IGNvbXB1dGVTY3JvbGwsXG4vLyAgIHNjcm9sbDogc2Nyb2xsVG9Qb3NpdGlvbixcbi8vIH1cblxubGV0IGNyZWF0ZUJhc2VMb2NhdGlvbiA9ICgpID0+IGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3Q7XG4vKipcbiAqIENyZWF0ZXMgYSBub3JtYWxpemVkIGhpc3RvcnkgbG9jYXRpb24gZnJvbSBhIHdpbmRvdy5sb2NhdGlvbiBvYmplY3RcbiAqIEBwYXJhbSBiYXNlIC0gVGhlIGJhc2UgcGF0aFxuICogQHBhcmFtIGxvY2F0aW9uIC0gVGhlIHdpbmRvdy5sb2NhdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ3VycmVudExvY2F0aW9uKGJhc2UsIGxvY2F0aW9uKSB7XG4gICAgY29uc3QgeyBwYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0gPSBsb2NhdGlvbjtcbiAgICAvLyBhbGxvd3MgaGFzaCBiYXNlcyBsaWtlICMsIC8jLCAjLywgIyEsICMhLywgLyMhLywgb3IgZXZlbiAvZm9sZGVyI2VuZFxuICAgIGNvbnN0IGhhc2hQb3MgPSBiYXNlLmluZGV4T2YoJyMnKTtcbiAgICBpZiAoaGFzaFBvcyA+IC0xKSB7XG4gICAgICAgIGxldCBzbGljZVBvcyA9IGhhc2guaW5jbHVkZXMoYmFzZS5zbGljZShoYXNoUG9zKSlcbiAgICAgICAgICAgID8gYmFzZS5zbGljZShoYXNoUG9zKS5sZW5ndGhcbiAgICAgICAgICAgIDogMTtcbiAgICAgICAgbGV0IHBhdGhGcm9tSGFzaCA9IGhhc2guc2xpY2Uoc2xpY2VQb3MpO1xuICAgICAgICAvLyBwcmVwZW5kIHRoZSBzdGFydGluZyBzbGFzaCB0byBoYXNoIHNvIHRoZSB1cmwgc3RhcnRzIHdpdGggLyNcbiAgICAgICAgaWYgKHBhdGhGcm9tSGFzaFswXSAhPT0gJy8nKVxuICAgICAgICAgICAgcGF0aEZyb21IYXNoID0gJy8nICsgcGF0aEZyb21IYXNoO1xuICAgICAgICByZXR1cm4gc3RyaXBCYXNlKHBhdGhGcm9tSGFzaCwgJycpO1xuICAgIH1cbiAgICBjb25zdCBwYXRoID0gc3RyaXBCYXNlKHBhdGhuYW1lLCBiYXNlKTtcbiAgICByZXR1cm4gcGF0aCArIHNlYXJjaCArIGhhc2g7XG59XG5mdW5jdGlvbiB1c2VIaXN0b3J5TGlzdGVuZXJzKGJhc2UsIGhpc3RvcnlTdGF0ZSwgY3VycmVudExvY2F0aW9uLCByZXBsYWNlKSB7XG4gICAgbGV0IGxpc3RlbmVycyA9IFtdO1xuICAgIGxldCB0ZWFyZG93bnMgPSBbXTtcbiAgICAvLyBUT0RPOiBzaG91bGQgaXQgYmUgYSBzdGFjaz8gYSBEaWN0LiBDaGVjayBpZiB0aGUgcG9wc3RhdGUgbGlzdGVuZXJcbiAgICAvLyBjYW4gdHJpZ2dlciB0d2ljZVxuICAgIGxldCBwYXVzZVN0YXRlID0gbnVsbDtcbiAgICBjb25zdCBwb3BTdGF0ZUhhbmRsZXIgPSAoeyBzdGF0ZSwgfSkgPT4ge1xuICAgICAgICBjb25zdCB0byA9IGNyZWF0ZUN1cnJlbnRMb2NhdGlvbihiYXNlLCBsb2NhdGlvbik7XG4gICAgICAgIGNvbnN0IGZyb20gPSBjdXJyZW50TG9jYXRpb24udmFsdWU7XG4gICAgICAgIGNvbnN0IGZyb21TdGF0ZSA9IGhpc3RvcnlTdGF0ZS52YWx1ZTtcbiAgICAgICAgbGV0IGRlbHRhID0gMDtcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICBjdXJyZW50TG9jYXRpb24udmFsdWUgPSB0bztcbiAgICAgICAgICAgIGhpc3RvcnlTdGF0ZS52YWx1ZSA9IHN0YXRlO1xuICAgICAgICAgICAgLy8gaWdub3JlIHRoZSBwb3BzdGF0ZSBhbmQgcmVzZXQgdGhlIHBhdXNlU3RhdGVcbiAgICAgICAgICAgIGlmIChwYXVzZVN0YXRlICYmIHBhdXNlU3RhdGUgPT09IGZyb20pIHtcbiAgICAgICAgICAgICAgICBwYXVzZVN0YXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWx0YSA9IGZyb21TdGF0ZSA/IHN0YXRlLnBvc2l0aW9uIC0gZnJvbVN0YXRlLnBvc2l0aW9uIDogMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcGxhY2UodG8pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhlcmUgd2UgY291bGQgYWxzbyByZXZlcnQgdGhlIG5hdmlnYXRpb24gYnkgY2FsbGluZyBoaXN0b3J5LmdvKC1kZWx0YSlcbiAgICAgICAgLy8gdGhpcyBsaXN0ZW5lciB3aWxsIGhhdmUgdG8gYmUgYWRhcHRlZCB0byBub3QgdHJpZ2dlciBhZ2FpbiBhbmQgdG8gd2FpdCBmb3IgdGhlIHVybFxuICAgICAgICAvLyB0byBiZSB1cGRhdGVkIGJlZm9yZSB0cmlnZ2VyaW5nIHRoZSBsaXN0ZW5lcnMuIFNvbWUga2luZCBvZiB2YWxpZGF0aW9uIGZ1bmN0aW9uIHdvdWxkIGFsc29cbiAgICAgICAgLy8gbmVlZCB0byBiZSBwYXNzZWQgdG8gdGhlIGxpc3RlbmVycyBzbyB0aGUgbmF2aWdhdGlvbiBjYW4gYmUgYWNjZXB0ZWRcbiAgICAgICAgLy8gY2FsbCBhbGwgbGlzdGVuZXJzXG4gICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IHtcbiAgICAgICAgICAgIGxpc3RlbmVyKGN1cnJlbnRMb2NhdGlvbi52YWx1ZSwgZnJvbSwge1xuICAgICAgICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgICAgICAgIHR5cGU6IE5hdmlnYXRpb25UeXBlLnBvcCxcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGRlbHRhXG4gICAgICAgICAgICAgICAgICAgID8gZGVsdGEgPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IE5hdmlnYXRpb25EaXJlY3Rpb24uZm9yd2FyZFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBOYXZpZ2F0aW9uRGlyZWN0aW9uLmJhY2tcbiAgICAgICAgICAgICAgICAgICAgOiBOYXZpZ2F0aW9uRGlyZWN0aW9uLnVua25vd24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwYXVzZUxpc3RlbmVycygpIHtcbiAgICAgICAgcGF1c2VTdGF0ZSA9IGN1cnJlbnRMb2NhdGlvbi52YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGlzdGVuKGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIHNldCB1cCB0aGUgbGlzdGVuZXIgYW5kIHByZXBhcmUgdGVhcmRvd24gY2FsbGJhY2tzXG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgY29uc3QgdGVhcmRvd24gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9O1xuICAgICAgICB0ZWFyZG93bnMucHVzaCh0ZWFyZG93bik7XG4gICAgICAgIHJldHVybiB0ZWFyZG93bjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmVmb3JlVW5sb2FkTGlzdGVuZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgaGlzdG9yeSB9ID0gd2luZG93O1xuICAgICAgICBpZiAoIWhpc3Rvcnkuc3RhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKGFzc2lnbih7fSwgaGlzdG9yeS5zdGF0ZSwgeyBzY3JvbGw6IGNvbXB1dGVTY3JvbGxQb3NpdGlvbigpIH0pLCAnJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGZvciAoY29uc3QgdGVhcmRvd24gb2YgdGVhcmRvd25zKVxuICAgICAgICAgICAgdGVhcmRvd24oKTtcbiAgICAgICAgdGVhcmRvd25zID0gW107XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHBvcFN0YXRlSGFuZGxlcik7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBiZWZvcmVVbmxvYWRMaXN0ZW5lcik7XG4gICAgfVxuICAgIC8vIHNldCB1cCB0aGUgbGlzdGVuZXJzIGFuZCBwcmVwYXJlIHRlYXJkb3duIGNhbGxiYWNrc1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHBvcFN0YXRlSGFuZGxlcik7XG4gICAgLy8gVE9ETzogY291bGQgd2UgdXNlICdwYWdlaGlkZScgb3IgJ3Zpc2liaWxpdHljaGFuZ2UnIGluc3RlYWQ/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9ibG9nL3BhZ2UtbGlmZWN5Y2xlLWFwaS9cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgYmVmb3JlVW5sb2FkTGlzdGVuZXIsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYXVzZUxpc3RlbmVycyxcbiAgICAgICAgbGlzdGVuLFxuICAgICAgICBkZXN0cm95LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBzdGF0ZSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gYnVpbGRTdGF0ZShiYWNrLCBjdXJyZW50LCBmb3J3YXJkLCByZXBsYWNlZCA9IGZhbHNlLCBjb21wdXRlU2Nyb2xsID0gZmFsc2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBiYWNrLFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICBmb3J3YXJkLFxuICAgICAgICByZXBsYWNlZCxcbiAgICAgICAgcG9zaXRpb246IHdpbmRvdy5oaXN0b3J5Lmxlbmd0aCxcbiAgICAgICAgc2Nyb2xsOiBjb21wdXRlU2Nyb2xsID8gY29tcHV0ZVNjcm9sbFBvc2l0aW9uKCkgOiBudWxsLFxuICAgIH07XG59XG5mdW5jdGlvbiB1c2VIaXN0b3J5U3RhdGVOYXZpZ2F0aW9uKGJhc2UpIHtcbiAgICBjb25zdCB7IGhpc3RvcnksIGxvY2F0aW9uIH0gPSB3aW5kb3c7XG4gICAgLy8gcHJpdmF0ZSB2YXJpYWJsZXNcbiAgICBjb25zdCBjdXJyZW50TG9jYXRpb24gPSB7XG4gICAgICAgIHZhbHVlOiBjcmVhdGVDdXJyZW50TG9jYXRpb24oYmFzZSwgbG9jYXRpb24pLFxuICAgIH07XG4gICAgY29uc3QgaGlzdG9yeVN0YXRlID0geyB2YWx1ZTogaGlzdG9yeS5zdGF0ZSB9O1xuICAgIC8vIGJ1aWxkIGN1cnJlbnQgaGlzdG9yeSBlbnRyeSBhcyB0aGlzIGlzIGEgZnJlc2ggbmF2aWdhdGlvblxuICAgIGlmICghaGlzdG9yeVN0YXRlLnZhbHVlKSB7XG4gICAgICAgIGNoYW5nZUxvY2F0aW9uKGN1cnJlbnRMb2NhdGlvbi52YWx1ZSwge1xuICAgICAgICAgICAgYmFjazogbnVsbCxcbiAgICAgICAgICAgIGN1cnJlbnQ6IGN1cnJlbnRMb2NhdGlvbi52YWx1ZSxcbiAgICAgICAgICAgIGZvcndhcmQ6IG51bGwsXG4gICAgICAgICAgICAvLyB0aGUgbGVuZ3RoIGlzIG9mZiBieSBvbmUsIHdlIG5lZWQgdG8gZGVjcmVhc2UgaXRcbiAgICAgICAgICAgIHBvc2l0aW9uOiBoaXN0b3J5Lmxlbmd0aCAtIDEsXG4gICAgICAgICAgICByZXBsYWNlZDogdHJ1ZSxcbiAgICAgICAgICAgIC8vIGRvbid0IGFkZCBhIHNjcm9sbCBhcyB0aGUgdXNlciBtYXkgaGF2ZSBhbiBhbmNob3IsIGFuZCB3ZSB3YW50XG4gICAgICAgICAgICAvLyBzY3JvbGxCZWhhdmlvciB0byBiZSB0cmlnZ2VyZWQgd2l0aG91dCBhIHNhdmVkIHBvc2l0aW9uXG4gICAgICAgICAgICBzY3JvbGw6IG51bGwsXG4gICAgICAgIH0sIHRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGFuZ2VMb2NhdGlvbih0bywgc3RhdGUsIHJlcGxhY2UpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGlmIGEgYmFzZSB0YWcgaXMgcHJvdmlkZWQsIGFuZCB3ZSBhcmUgb24gYSBub3JtYWwgZG9tYWluLCB3ZSBoYXZlIHRvXG4gICAgICAgICAqIHJlc3BlY3QgdGhlIHByb3ZpZGVkIGBiYXNlYCBhdHRyaWJ1dGUgYmVjYXVzZSBwdXNoU3RhdGUoKSB3aWxsIHVzZSBpdCBhbmRcbiAgICAgICAgICogcG90ZW50aWFsbHkgZXJhc2UgYW55dGhpbmcgYmVmb3JlIHRoZSBgI2AgbGlrZSBhdFxuICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvcm91dGVyL2lzc3Vlcy82ODUgd2hlcmUgYSBiYXNlIG9mXG4gICAgICAgICAqIGAvZm9sZGVyLyNgIGJ1dCBhIGJhc2Ugb2YgYC9gIHdvdWxkIGVyYXNlIHRoZSBgL2ZvbGRlci9gIHNlY3Rpb24uIElmXG4gICAgICAgICAqIHRoZXJlIGlzIG5vIGhvc3QsIHRoZSBgPGJhc2U+YCB0YWcgbWFrZXMgbm8gc2Vuc2UgYW5kIGlmIHRoZXJlIGlzbid0IGFcbiAgICAgICAgICogYmFzZSB0YWcgd2UgY2FuIGp1c3QgdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGAjYC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGhhc2hJbmRleCA9IGJhc2UuaW5kZXhPZignIycpO1xuICAgICAgICBjb25zdCB1cmwgPSBoYXNoSW5kZXggPiAtMVxuICAgICAgICAgICAgPyAobG9jYXRpb24uaG9zdCAmJiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdiYXNlJylcbiAgICAgICAgICAgICAgICA/IGJhc2VcbiAgICAgICAgICAgICAgICA6IGJhc2Uuc2xpY2UoaGFzaEluZGV4KSkgKyB0b1xuICAgICAgICAgICAgOiBjcmVhdGVCYXNlTG9jYXRpb24oKSArIGJhc2UgKyB0bztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEJST1dTRVIgUVVJUktcbiAgICAgICAgICAgIC8vIE5PVEU6IFNhZmFyaSB0aHJvd3MgYSBTZWN1cml0eUVycm9yIHdoZW4gY2FsbGluZyB0aGlzIGZ1bmN0aW9uIDEwMCB0aW1lcyBpbiAzMCBzZWNvbmRzXG4gICAgICAgICAgICBoaXN0b3J5W3JlcGxhY2UgPyAncmVwbGFjZVN0YXRlJyA6ICdwdXNoU3RhdGUnXShzdGF0ZSwgJycsIHVybCk7XG4gICAgICAgICAgICBoaXN0b3J5U3RhdGUudmFsdWUgPSBzdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgd2FybignRXJyb3Igd2l0aCBwdXNoL3JlcGxhY2UgU3RhdGUnLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm9yY2UgdGhlIG5hdmlnYXRpb24sIHRoaXMgYWxzbyByZXNldHMgdGhlIGNhbGwgY291bnRcbiAgICAgICAgICAgIGxvY2F0aW9uW3JlcGxhY2UgPyAncmVwbGFjZScgOiAnYXNzaWduJ10odXJsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXBsYWNlKHRvLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gYXNzaWduKHt9LCBoaXN0b3J5LnN0YXRlLCBidWlsZFN0YXRlKGhpc3RvcnlTdGF0ZS52YWx1ZS5iYWNrLCBcbiAgICAgICAgLy8ga2VlcCBiYWNrIGFuZCBmb3J3YXJkIGVudHJpZXMgYnV0IG92ZXJyaWRlIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgdG8sIGhpc3RvcnlTdGF0ZS52YWx1ZS5mb3J3YXJkLCB0cnVlKSwgZGF0YSwgeyBwb3NpdGlvbjogaGlzdG9yeVN0YXRlLnZhbHVlLnBvc2l0aW9uIH0pO1xuICAgICAgICBjaGFuZ2VMb2NhdGlvbih0bywgc3RhdGUsIHRydWUpO1xuICAgICAgICBjdXJyZW50TG9jYXRpb24udmFsdWUgPSB0bztcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaCh0bywgZGF0YSkge1xuICAgICAgICAvLyBBZGQgdG8gY3VycmVudCBlbnRyeSB0aGUgaW5mb3JtYXRpb24gb2Ygd2hlcmUgd2UgYXJlIGdvaW5nXG4gICAgICAgIC8vIGFzIHdlbGwgYXMgc2F2aW5nIHRoZSBjdXJyZW50IHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGFzc2lnbih7fSwgXG4gICAgICAgIC8vIHVzZSBjdXJyZW50IGhpc3Rvcnkgc3RhdGUgdG8gZ3JhY2VmdWxseSBoYW5kbGUgYSB3cm9uZyBjYWxsIHRvXG4gICAgICAgIC8vIGhpc3RvcnkucmVwbGFjZVN0YXRlXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy9yb3V0ZXIvaXNzdWVzLzM2NlxuICAgICAgICBoaXN0b3J5U3RhdGUudmFsdWUsIGhpc3Rvcnkuc3RhdGUsIHtcbiAgICAgICAgICAgIGZvcndhcmQ6IHRvLFxuICAgICAgICAgICAgc2Nyb2xsOiBjb21wdXRlU2Nyb2xsUG9zaXRpb24oKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWhpc3Rvcnkuc3RhdGUpIHtcbiAgICAgICAgICAgIHdhcm4oYGhpc3Rvcnkuc3RhdGUgc2VlbXMgdG8gaGF2ZSBiZWVuIG1hbnVhbGx5IHJlcGxhY2VkIHdpdGhvdXQgcHJlc2VydmluZyB0aGUgbmVjZXNzYXJ5IHZhbHVlcy4gTWFrZSBzdXJlIHRvIHByZXNlcnZlIGV4aXN0aW5nIGhpc3Rvcnkgc3RhdGUgaWYgeW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGhpc3RvcnkucmVwbGFjZVN0YXRlOlxcblxcbmAgK1xuICAgICAgICAgICAgICAgIGBoaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5LnN0YXRlLCAnJywgdXJsKVxcblxcbmAgK1xuICAgICAgICAgICAgICAgIGBZb3UgY2FuIGZpbmQgbW9yZSBpbmZvcm1hdGlvbiBhdCBodHRwczovL25leHQucm91dGVyLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vI3VzYWdlLW9mLWhpc3Rvcnktc3RhdGUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY2hhbmdlTG9jYXRpb24oY3VycmVudFN0YXRlLmN1cnJlbnQsIGN1cnJlbnRTdGF0ZSwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gYXNzaWduKHt9LCBidWlsZFN0YXRlKGN1cnJlbnRMb2NhdGlvbi52YWx1ZSwgdG8sIG51bGwpLCB7IHBvc2l0aW9uOiBjdXJyZW50U3RhdGUucG9zaXRpb24gKyAxIH0sIGRhdGEpO1xuICAgICAgICBjaGFuZ2VMb2NhdGlvbih0bywgc3RhdGUsIGZhbHNlKTtcbiAgICAgICAgY3VycmVudExvY2F0aW9uLnZhbHVlID0gdG87XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGxvY2F0aW9uOiBjdXJyZW50TG9jYXRpb24sXG4gICAgICAgIHN0YXRlOiBoaXN0b3J5U3RhdGUsXG4gICAgICAgIHB1c2gsXG4gICAgICAgIHJlcGxhY2UsXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBIVE1MNSBoaXN0b3J5LiBNb3N0IGNvbW1vbiBoaXN0b3J5IGZvciBzaW5nbGUgcGFnZSBhcHBsaWNhdGlvbnMuXG4gKlxuICogQHBhcmFtIGJhc2UgLVxuICovXG5mdW5jdGlvbiBjcmVhdGVXZWJIaXN0b3J5KGJhc2UpIHtcbiAgICBiYXNlID0gbm9ybWFsaXplQmFzZShiYXNlKTtcbiAgICBjb25zdCBoaXN0b3J5TmF2aWdhdGlvbiA9IHVzZUhpc3RvcnlTdGF0ZU5hdmlnYXRpb24oYmFzZSk7XG4gICAgY29uc3QgaGlzdG9yeUxpc3RlbmVycyA9IHVzZUhpc3RvcnlMaXN0ZW5lcnMoYmFzZSwgaGlzdG9yeU5hdmlnYXRpb24uc3RhdGUsIGhpc3RvcnlOYXZpZ2F0aW9uLmxvY2F0aW9uLCBoaXN0b3J5TmF2aWdhdGlvbi5yZXBsYWNlKTtcbiAgICBmdW5jdGlvbiBnbyhkZWx0YSwgdHJpZ2dlckxpc3RlbmVycyA9IHRydWUpIHtcbiAgICAgICAgaWYgKCF0cmlnZ2VyTGlzdGVuZXJzKVxuICAgICAgICAgICAgaGlzdG9yeUxpc3RlbmVycy5wYXVzZUxpc3RlbmVycygpO1xuICAgICAgICBoaXN0b3J5LmdvKGRlbHRhKTtcbiAgICB9XG4gICAgY29uc3Qgcm91dGVySGlzdG9yeSA9IGFzc2lnbih7XG4gICAgICAgIC8vIGl0J3Mgb3ZlcnJpZGRlbiByaWdodCBhZnRlclxuICAgICAgICBsb2NhdGlvbjogJycsXG4gICAgICAgIGJhc2UsXG4gICAgICAgIGdvLFxuICAgICAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLmJpbmQobnVsbCwgYmFzZSksXG4gICAgfSwgaGlzdG9yeU5hdmlnYXRpb24sIGhpc3RvcnlMaXN0ZW5lcnMpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyb3V0ZXJIaXN0b3J5LCAnbG9jYXRpb24nLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gaGlzdG9yeU5hdmlnYXRpb24ubG9jYXRpb24udmFsdWUsXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJvdXRlckhpc3RvcnksICdzdGF0ZScsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBoaXN0b3J5TmF2aWdhdGlvbi5zdGF0ZS52YWx1ZSxcbiAgICB9KTtcbiAgICByZXR1cm4gcm91dGVySGlzdG9yeTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGluLW1lbW9yeSBiYXNlZCBoaXN0b3J5LiBUaGUgbWFpbiBwdXJwb3NlIG9mIHRoaXMgaGlzdG9yeSBpcyB0byBoYW5kbGUgU1NSLiBJdCBzdGFydHMgaW4gYSBzcGVjaWFsIGxvY2F0aW9uIHRoYXQgaXMgbm93aGVyZS5cbiAqIEl0J3MgdXAgdG8gdGhlIHVzZXIgdG8gcmVwbGFjZSB0aGF0IGxvY2F0aW9uIHdpdGggdGhlIHN0YXJ0ZXIgbG9jYXRpb24gYnkgZWl0aGVyIGNhbGxpbmcgYHJvdXRlci5wdXNoYCBvciBgcm91dGVyLnJlcGxhY2VgLlxuICpcbiAqIEBwYXJhbSBiYXNlIC0gQmFzZSBhcHBsaWVkIHRvIGFsbCB1cmxzLCBkZWZhdWx0cyB0byAnLydcbiAqIEByZXR1cm5zIGEgaGlzdG9yeSBvYmplY3QgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSByb3V0ZXIgY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShiYXNlID0gJycpIHtcbiAgICBsZXQgbGlzdGVuZXJzID0gW107XG4gICAgbGV0IHF1ZXVlID0gW1NUQVJUXTtcbiAgICBsZXQgcG9zaXRpb24gPSAwO1xuICAgIGJhc2UgPSBub3JtYWxpemVCYXNlKGJhc2UpO1xuICAgIGZ1bmN0aW9uIHNldExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgIGlmIChwb3NpdGlvbiAhPT0gcXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyB3ZSBhcmUgaW4gdGhlIG1pZGRsZSwgd2UgcmVtb3ZlIGV2ZXJ5dGhpbmcgZnJvbSBoZXJlIGluIHRoZSBxdWV1ZVxuICAgICAgICAgICAgcXVldWUuc3BsaWNlKHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZS5wdXNoKGxvY2F0aW9uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJpZ2dlckxpc3RlbmVycyh0bywgZnJvbSwgeyBkaXJlY3Rpb24sIGRlbHRhIH0pIHtcbiAgICAgICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgICAgdHlwZTogTmF2aWdhdGlvblR5cGUucG9wLFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGxpc3RlbmVycykge1xuICAgICAgICAgICAgY2FsbGJhY2sodG8sIGZyb20sIGluZm8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJvdXRlckhpc3RvcnkgPSB7XG4gICAgICAgIC8vIHJld3JpdHRlbiBieSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgICAgICAgbG9jYXRpb246IFNUQVJULFxuICAgICAgICAvLyBUT0RPOiBzaG91bGQgYmUga2VwdCBpbiBxdWV1ZVxuICAgICAgICBzdGF0ZToge30sXG4gICAgICAgIGJhc2UsXG4gICAgICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYuYmluZChudWxsLCBiYXNlKSxcbiAgICAgICAgcmVwbGFjZSh0bykge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGN1cnJlbnQgZW50cnkgYW5kIGRlY3JlbWVudCBwb3NpdGlvblxuICAgICAgICAgICAgcXVldWUuc3BsaWNlKHBvc2l0aW9uLS0sIDEpO1xuICAgICAgICAgICAgc2V0TG9jYXRpb24odG8pO1xuICAgICAgICB9LFxuICAgICAgICBwdXNoKHRvLCBkYXRhKSB7XG4gICAgICAgICAgICBzZXRMb2NhdGlvbih0byk7XG4gICAgICAgIH0sXG4gICAgICAgIGxpc3RlbihjYWxsYmFjaykge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95KCkge1xuICAgICAgICAgICAgbGlzdGVuZXJzID0gW107XG4gICAgICAgICAgICBxdWV1ZSA9IFtTVEFSVF07XG4gICAgICAgICAgICBwb3NpdGlvbiA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGdvKGRlbHRhLCBzaG91bGRUcmlnZ2VyID0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IHRoaXMubG9jYXRpb247XG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBcbiAgICAgICAgICAgIC8vIHdlIGFyZSBjb25zaWRlcmluZyBkZWx0YSA9PT0gMCBnb2luZyBmb3J3YXJkLCBidXQgaW4gYWJzdHJhY3QgbW9kZVxuICAgICAgICAgICAgLy8gdXNpbmcgMCBmb3IgdGhlIGRlbHRhIGRvZXNuJ3QgbWFrZSBzZW5zZSBsaWtlIGl0IGRvZXMgaW4gaHRtbDUgd2hlcmVcbiAgICAgICAgICAgIC8vIGl0IHJlbG9hZHMgdGhlIHBhZ2VcbiAgICAgICAgICAgIGRlbHRhIDwgMCA/IE5hdmlnYXRpb25EaXJlY3Rpb24uYmFjayA6IE5hdmlnYXRpb25EaXJlY3Rpb24uZm9yd2FyZDtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocG9zaXRpb24gKyBkZWx0YSwgcXVldWUubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgaWYgKHNob3VsZFRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyTGlzdGVuZXJzKHRoaXMubG9jYXRpb24sIGZyb20sIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyb3V0ZXJIaXN0b3J5LCAnbG9jYXRpb24nLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gcXVldWVbcG9zaXRpb25dLFxuICAgIH0pO1xuICAgIHJldHVybiByb3V0ZXJIaXN0b3J5O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIGhpc3RvcnkuIFVzZWZ1bCBmb3Igd2ViIGFwcGxpY2F0aW9ucyB3aXRoIG5vIGhvc3QgKGUuZy4gYGZpbGU6Ly9gKSBvciB3aGVuIGNvbmZpZ3VyaW5nIGEgc2VydmVyIHRvXG4gKiBoYW5kbGUgYW55IFVSTCBpcyBub3QgcG9zc2libGUuXG4gKlxuICogQHBhcmFtIGJhc2UgLSBvcHRpb25hbCBiYXNlIHRvIHByb3ZpZGUuIERlZmF1bHRzIHRvIGBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaGAgSWYgdGhlcmUgaXMgYSBgPGJhc2U+YCB0YWdcbiAqIGluIHRoZSBgaGVhZGAsIGl0cyB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQgaW4gZmF2b3Igb2YgdGhpcyBwYXJhbWV0ZXIgKipidXQgbm90ZSBpdCBhZmZlY3RzIGFsbCB0aGUgaGlzdG9yeS5wdXNoU3RhdGUoKVxuICogY2FsbHMqKiwgbWVhbmluZyB0aGF0IGlmIHlvdSB1c2UgYSBgPGJhc2U+YCB0YWcsIGl0J3MgYGhyZWZgIHZhbHVlICoqaGFzIHRvIG1hdGNoIHRoaXMgcGFyYW1ldGVyKiogKGlnbm9yaW5nIGFueXRoaW5nXG4gKiBhZnRlciB0aGUgYCNgKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIC8vIGF0IGh0dHBzOi8vZXhhbXBsZS5jb20vZm9sZGVyXG4gKiBjcmVhdGVXZWJIYXNoSGlzdG9yeSgpIC8vIGdpdmVzIGEgdXJsIG9mIGBodHRwczovL2V4YW1wbGUuY29tL2ZvbGRlciNgXG4gKiBjcmVhdGVXZWJIYXNoSGlzdG9yeSgnL2ZvbGRlci8nKSAvLyBnaXZlcyBhIHVybCBvZiBgaHR0cHM6Ly9leGFtcGxlLmNvbS9mb2xkZXIvI2BcbiAqIC8vIGlmIHRoZSBgI2AgaXMgcHJvdmlkZWQgaW4gdGhlIGJhc2UsIGl0IHdvbid0IGJlIGFkZGVkIGJ5IGBjcmVhdGVXZWJIYXNoSGlzdG9yeWBcbiAqIGNyZWF0ZVdlYkhhc2hIaXN0b3J5KCcvZm9sZGVyLyMvYXBwLycpIC8vIGdpdmVzIGEgdXJsIG9mIGBodHRwczovL2V4YW1wbGUuY29tL2ZvbGRlci8jL2FwcC9gXG4gKiAvLyB5b3Ugc2hvdWxkIGF2b2lkIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCBjaGFuZ2VzIHRoZSBvcmlnaW5hbCB1cmwgYW5kIGJyZWFrcyBjb3B5aW5nIHVybHNcbiAqIGNyZWF0ZVdlYkhhc2hIaXN0b3J5KCcvb3RoZXItZm9sZGVyLycpIC8vIGdpdmVzIGEgdXJsIG9mIGBodHRwczovL2V4YW1wbGUuY29tL290aGVyLWZvbGRlci8jYFxuICpcbiAqIC8vIGF0IGZpbGU6Ly8vdXNyL2V0Yy9mb2xkZXIvaW5kZXguaHRtbFxuICogLy8gZm9yIGxvY2F0aW9ucyB3aXRoIG5vIGBob3N0YCwgdGhlIGJhc2UgaXMgaWdub3JlZFxuICogY3JlYXRlV2ViSGFzaEhpc3RvcnkoJy9pQW1JZ25vcmVkJykgLy8gZ2l2ZXMgYSB1cmwgb2YgYGZpbGU6Ly8vdXNyL2V0Yy9mb2xkZXIvaW5kZXguaHRtbCNgXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gY3JlYXRlV2ViSGFzaEhpc3RvcnkoYmFzZSkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGZpbmUgaW4gdGVybXMgb2YgZW5jb2RpbmcsIHNwZWNpYWxseSBmb3IgSUUxMVxuICAgIC8vIGZvciBgZmlsZTovL2AsIGRpcmVjdGx5IHVzZSB0aGUgcGF0aG5hbWUgYW5kIGlnbm9yZSB0aGUgYmFzZVxuICAgIC8vIGxvY2F0aW9uLnBhdGhuYW1lIGNvbnRhaW5zIGFuIGluaXRpYWwgYC9gIGV2ZW4gYXQgdGhlIHJvb3Q6IGBodHRwczovL2V4YW1wbGUuY29tYFxuICAgIGJhc2UgPSBsb2NhdGlvbi5ob3N0ID8gYmFzZSB8fCBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCA6ICcnO1xuICAgIC8vIGFsbG93IHRoZSB1c2VyIHRvIHByb3ZpZGUgYSBgI2AgaW4gdGhlIG1pZGRsZTogYC9iYXNlLyMvYXBwYFxuICAgIGlmICghYmFzZS5pbmNsdWRlcygnIycpKVxuICAgICAgICBiYXNlICs9ICcjJztcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFiYXNlLmVuZHNXaXRoKCcjLycpICYmICFiYXNlLmVuZHNXaXRoKCcjJykpIHtcbiAgICAgICAgd2FybihgQSBoYXNoIGJhc2UgbXVzdCBlbmQgd2l0aCBhIFwiI1wiOlxcblwiJHtiYXNlfVwiIHNob3VsZCBiZSBcIiR7YmFzZS5yZXBsYWNlKC8jLiokLywgJyMnKX1cIi5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVdlYkhpc3RvcnkoYmFzZSk7XG59XG5cbmZ1bmN0aW9uIGlzUm91dGVMb2NhdGlvbihyb3V0ZSkge1xuICAgIHJldHVybiB0eXBlb2Ygcm91dGUgPT09ICdzdHJpbmcnIHx8IChyb3V0ZSAmJiB0eXBlb2Ygcm91dGUgPT09ICdvYmplY3QnKTtcbn1cbmZ1bmN0aW9uIGlzUm91dGVOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuYW1lID09PSAnc3ltYm9sJztcbn1cblxuLyoqXG4gKiBJbml0aWFsIHJvdXRlIGxvY2F0aW9uIHdoZXJlIHRoZSByb3V0ZXIgaXMuIENhbiBiZSB1c2VkIGluIG5hdmlnYXRpb24gZ3VhcmRzXG4gKiB0byBkaWZmZXJlbnRpYXRlIHRoZSBpbml0aWFsIG5hdmlnYXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBTVEFSVF9MT0NBVElPTiB9IGZyb20gJ3Z1ZS1yb3V0ZXInXG4gKlxuICogcm91dGVyLmJlZm9yZUVhY2goKHRvLCBmcm9tKSA9PiB7XG4gKiAgIGlmIChmcm9tID09PSBTVEFSVF9MT0NBVElPTikge1xuICogICAgIC8vIGluaXRpYWwgbmF2aWdhdGlvblxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKi9cbmNvbnN0IFNUQVJUX0xPQ0FUSU9OX05PUk1BTElaRUQgPSB7XG4gICAgcGF0aDogJy8nLFxuICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICBwYXJhbXM6IHt9LFxuICAgIHF1ZXJ5OiB7fSxcbiAgICBoYXNoOiAnJyxcbiAgICBmdWxsUGF0aDogJy8nLFxuICAgIG1hdGNoZWQ6IFtdLFxuICAgIG1ldGE6IHt9LFxuICAgIHJlZGlyZWN0ZWRGcm9tOiB1bmRlZmluZWQsXG59O1xuXG5jb25zdCBOYXZpZ2F0aW9uRmFpbHVyZVN5bWJvbCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnbmF2aWdhdGlvbiBmYWlsdXJlJyA6ICcnKTtcbi8qKlxuICogRW51bWVyYXRpb24gd2l0aCBhbGwgcG9zc2libGUgdHlwZXMgZm9yIG5hdmlnYXRpb24gZmFpbHVyZXMuIENhbiBiZSBwYXNzZWQgdG9cbiAqIHtAbGluayBpc05hdmlnYXRpb25GYWlsdXJlfSB0byBjaGVjayBmb3Igc3BlY2lmaWMgZmFpbHVyZXMuXG4gKi9cbnZhciBOYXZpZ2F0aW9uRmFpbHVyZVR5cGU7XG4oZnVuY3Rpb24gKE5hdmlnYXRpb25GYWlsdXJlVHlwZSkge1xuICAgIC8qKlxuICAgICAqIEFuIGFib3J0ZWQgbmF2aWdhdGlvbiBpcyBhIG5hdmlnYXRpb24gdGhhdCBmYWlsZWQgYmVjYXVzZSBhIG5hdmlnYXRpb25cbiAgICAgKiBndWFyZCByZXR1cm5lZCBgZmFsc2VgIG9yIGNhbGxlZCBgbmV4dChmYWxzZSlgXG4gICAgICovXG4gICAgTmF2aWdhdGlvbkZhaWx1cmVUeXBlW05hdmlnYXRpb25GYWlsdXJlVHlwZVtcImFib3J0ZWRcIl0gPSA0XSA9IFwiYWJvcnRlZFwiO1xuICAgIC8qKlxuICAgICAqIEEgY2FuY2VsbGVkIG5hdmlnYXRpb24gaXMgYSBuYXZpZ2F0aW9uIHRoYXQgZmFpbGVkIGJlY2F1c2UgYSBtb3JlIHJlY2VudFxuICAgICAqIG5hdmlnYXRpb24gZmluaXNoZWQgc3RhcnRlZCAobm90IG5lY2Vzc2FyaWx5IGZpbmlzaGVkKS5cbiAgICAgKi9cbiAgICBOYXZpZ2F0aW9uRmFpbHVyZVR5cGVbTmF2aWdhdGlvbkZhaWx1cmVUeXBlW1wiY2FuY2VsbGVkXCJdID0gOF0gPSBcImNhbmNlbGxlZFwiO1xuICAgIC8qKlxuICAgICAqIEEgZHVwbGljYXRlZCBuYXZpZ2F0aW9uIGlzIGEgbmF2aWdhdGlvbiB0aGF0IGZhaWxlZCBiZWNhdXNlIGl0IHdhc1xuICAgICAqIGluaXRpYXRlZCB3aGlsZSBhbHJlYWR5IGJlaW5nIGF0IHRoZSBleGFjdCBzYW1lIGxvY2F0aW9uLlxuICAgICAqL1xuICAgIE5hdmlnYXRpb25GYWlsdXJlVHlwZVtOYXZpZ2F0aW9uRmFpbHVyZVR5cGVbXCJkdXBsaWNhdGVkXCJdID0gMTZdID0gXCJkdXBsaWNhdGVkXCI7XG59KShOYXZpZ2F0aW9uRmFpbHVyZVR5cGUgfHwgKE5hdmlnYXRpb25GYWlsdXJlVHlwZSA9IHt9KSk7XG4vLyBERVYgb25seSBkZWJ1ZyBtZXNzYWdlc1xuY29uc3QgRXJyb3JUeXBlTWVzc2FnZXMgPSB7XG4gICAgWzEgLyogRXJyb3JUeXBlcy5NQVRDSEVSX05PVF9GT1VORCAqL10oeyBsb2NhdGlvbiwgY3VycmVudExvY2F0aW9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGBObyBtYXRjaCBmb3JcXG4gJHtKU09OLnN0cmluZ2lmeShsb2NhdGlvbil9JHtjdXJyZW50TG9jYXRpb25cbiAgICAgICAgICAgID8gJ1xcbndoaWxlIGJlaW5nIGF0XFxuJyArIEpTT04uc3RyaW5naWZ5KGN1cnJlbnRMb2NhdGlvbilcbiAgICAgICAgICAgIDogJyd9YDtcbiAgICB9LFxuICAgIFsyIC8qIEVycm9yVHlwZXMuTkFWSUdBVElPTl9HVUFSRF9SRURJUkVDVCAqL10oeyBmcm9tLCB0bywgfSkge1xuICAgICAgICByZXR1cm4gYFJlZGlyZWN0ZWQgZnJvbSBcIiR7ZnJvbS5mdWxsUGF0aH1cIiB0byBcIiR7c3RyaW5naWZ5Um91dGUodG8pfVwiIHZpYSBhIG5hdmlnYXRpb24gZ3VhcmQuYDtcbiAgICB9LFxuICAgIFs0IC8qIEVycm9yVHlwZXMuTkFWSUdBVElPTl9BQk9SVEVEICovXSh7IGZyb20sIHRvIH0pIHtcbiAgICAgICAgcmV0dXJuIGBOYXZpZ2F0aW9uIGFib3J0ZWQgZnJvbSBcIiR7ZnJvbS5mdWxsUGF0aH1cIiB0byBcIiR7dG8uZnVsbFBhdGh9XCIgdmlhIGEgbmF2aWdhdGlvbiBndWFyZC5gO1xuICAgIH0sXG4gICAgWzggLyogRXJyb3JUeXBlcy5OQVZJR0FUSU9OX0NBTkNFTExFRCAqL10oeyBmcm9tLCB0byB9KSB7XG4gICAgICAgIHJldHVybiBgTmF2aWdhdGlvbiBjYW5jZWxsZWQgZnJvbSBcIiR7ZnJvbS5mdWxsUGF0aH1cIiB0byBcIiR7dG8uZnVsbFBhdGh9XCIgd2l0aCBhIG5ldyBuYXZpZ2F0aW9uLmA7XG4gICAgfSxcbiAgICBbMTYgLyogRXJyb3JUeXBlcy5OQVZJR0FUSU9OX0RVUExJQ0FURUQgKi9dKHsgZnJvbSwgdG8gfSkge1xuICAgICAgICByZXR1cm4gYEF2b2lkZWQgcmVkdW5kYW50IG5hdmlnYXRpb24gdG8gY3VycmVudCBsb2NhdGlvbjogXCIke2Zyb20uZnVsbFBhdGh9XCIuYDtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlckVycm9yKHR5cGUsIHBhcmFtcykge1xuICAgIC8vIGtlZXAgZnVsbCBlcnJvciBtZXNzYWdlcyBpbiBjanMgdmVyc2lvbnNcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICF0cnVlKSB7XG4gICAgICAgIHJldHVybiBhc3NpZ24obmV3IEVycm9yKEVycm9yVHlwZU1lc3NhZ2VzW3R5cGVdKHBhcmFtcykpLCB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgW05hdmlnYXRpb25GYWlsdXJlU3ltYm9sXTogdHJ1ZSxcbiAgICAgICAgfSwgcGFyYW1zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBhc3NpZ24obmV3IEVycm9yKCksIHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBbTmF2aWdhdGlvbkZhaWx1cmVTeW1ib2xdOiB0cnVlLFxuICAgICAgICB9LCBwYXJhbXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzTmF2aWdhdGlvbkZhaWx1cmUoZXJyb3IsIHR5cGUpIHtcbiAgICByZXR1cm4gKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgTmF2aWdhdGlvbkZhaWx1cmVTeW1ib2wgaW4gZXJyb3IgJiZcbiAgICAgICAgKHR5cGUgPT0gbnVsbCB8fCAhIShlcnJvci50eXBlICYgdHlwZSkpKTtcbn1cbmNvbnN0IHByb3BlcnRpZXNUb0xvZyA9IFsncGFyYW1zJywgJ3F1ZXJ5JywgJ2hhc2gnXTtcbmZ1bmN0aW9uIHN0cmluZ2lmeVJvdXRlKHRvKSB7XG4gICAgaWYgKHR5cGVvZiB0byA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiB0bztcbiAgICBpZiAoJ3BhdGgnIGluIHRvKVxuICAgICAgICByZXR1cm4gdG8ucGF0aDtcbiAgICBjb25zdCBsb2NhdGlvbiA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHByb3BlcnRpZXNUb0xvZykge1xuICAgICAgICBpZiAoa2V5IGluIHRvKVxuICAgICAgICAgICAgbG9jYXRpb25ba2V5XSA9IHRvW2tleV07XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShsb2NhdGlvbiwgbnVsbCwgMik7XG59XG5cbi8vIGRlZmF1bHQgcGF0dGVybiBmb3IgYSBwYXJhbTogbm9uLWdyZWVkeSBldmVyeXRoaW5nIGJ1dCAvXG5jb25zdCBCQVNFX1BBUkFNX1BBVFRFUk4gPSAnW14vXSs/JztcbmNvbnN0IEJBU0VfUEFUSF9QQVJTRVJfT1BUSU9OUyA9IHtcbiAgICBzZW5zaXRpdmU6IGZhbHNlLFxuICAgIHN0cmljdDogZmFsc2UsXG4gICAgc3RhcnQ6IHRydWUsXG4gICAgZW5kOiB0cnVlLFxufTtcbi8vIFNwZWNpYWwgUmVnZXggY2hhcmFjdGVycyB0aGF0IG11c3QgYmUgZXNjYXBlZCBpbiBzdGF0aWMgdG9rZW5zXG5jb25zdCBSRUdFWF9DSEFSU19SRSA9IC9bLisqP14ke30oKVtcXF0vXFxcXF0vZztcbi8qKlxuICogQ3JlYXRlcyBhIHBhdGggcGFyc2VyIGZyb20gYW4gYXJyYXkgb2YgU2VnbWVudHMgKGEgc2VnbWVudCBpcyBhbiBhcnJheSBvZiBUb2tlbnMpXG4gKlxuICogQHBhcmFtIHNlZ21lbnRzIC0gYXJyYXkgb2Ygc2VnbWVudHMgcmV0dXJuZWQgYnkgdG9rZW5pemVQYXRoXG4gKiBAcGFyYW0gZXh0cmFPcHRpb25zIC0gb3B0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHJlZ2V4cFxuICogQHJldHVybnMgYSBQYXRoUGFyc2VyXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvUGFyc2VyKHNlZ21lbnRzLCBleHRyYU9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRpb25zID0gYXNzaWduKHt9LCBCQVNFX1BBVEhfUEFSU0VSX09QVElPTlMsIGV4dHJhT3B0aW9ucyk7XG4gICAgLy8gdGhlIGFtb3VudCBvZiBzY29yZXMgaXMgdGhlIHNhbWUgYXMgdGhlIGxlbmd0aCBvZiBzZWdtZW50cyBleGNlcHQgZm9yIHRoZSByb290IHNlZ21lbnQgXCIvXCJcbiAgICBjb25zdCBzY29yZSA9IFtdO1xuICAgIC8vIHRoZSByZWdleHAgYXMgYSBzdHJpbmdcbiAgICBsZXQgcGF0dGVybiA9IG9wdGlvbnMuc3RhcnQgPyAnXicgOiAnJztcbiAgICAvLyBleHRyYWN0ZWQga2V5c1xuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICAgICAgLy8gdGhlIHJvb3Qgc2VnbWVudCBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudFxuICAgICAgICBjb25zdCBzZWdtZW50U2NvcmVzID0gc2VnbWVudC5sZW5ndGggPyBbXSA6IFs5MCAvKiBQYXRoU2NvcmUuUm9vdCAqL107XG4gICAgICAgIC8vIGFsbG93IHRyYWlsaW5nIHNsYXNoXG4gICAgICAgIGlmIChvcHRpb25zLnN0cmljdCAmJiAhc2VnbWVudC5sZW5ndGgpXG4gICAgICAgICAgICBwYXR0ZXJuICs9ICcvJztcbiAgICAgICAgZm9yIChsZXQgdG9rZW5JbmRleCA9IDA7IHRva2VuSW5kZXggPCBzZWdtZW50Lmxlbmd0aDsgdG9rZW5JbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHNlZ21lbnRbdG9rZW5JbmRleF07XG4gICAgICAgICAgICAvLyByZXNldHMgdGhlIHNjb3JlIGlmIHdlIGFyZSBpbnNpZGUgYSBzdWItc2VnbWVudCAvOmEtb3RoZXItOmJcbiAgICAgICAgICAgIGxldCBzdWJTZWdtZW50U2NvcmUgPSA0MCAvKiBQYXRoU2NvcmUuU2VnbWVudCAqLyArXG4gICAgICAgICAgICAgICAgKG9wdGlvbnMuc2Vuc2l0aXZlID8gMC4yNSAvKiBQYXRoU2NvcmUuQm9udXNDYXNlU2Vuc2l0aXZlICovIDogMCk7XG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMCAvKiBUb2tlblR5cGUuU3RhdGljICovKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJlcGVuZCB0aGUgc2xhc2ggaWYgd2UgYXJlIHN0YXJ0aW5nIGEgbmV3IHNlZ21lbnRcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gJy8nO1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gdG9rZW4udmFsdWUucmVwbGFjZShSRUdFWF9DSEFSU19SRSwgJ1xcXFwkJicpO1xuICAgICAgICAgICAgICAgIHN1YlNlZ21lbnRTY29yZSArPSA0MCAvKiBQYXRoU2NvcmUuU3RhdGljICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gMSAvKiBUb2tlblR5cGUuUGFyYW0gKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlLCByZXBlYXRhYmxlLCBvcHRpb25hbCwgcmVnZXhwIH0gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmUgPSByZWdleHAgPyByZWdleHAgOiBCQVNFX1BBUkFNX1BBVFRFUk47XG4gICAgICAgICAgICAgICAgLy8gdGhlIHVzZXIgcHJvdmlkZWQgYSBjdXN0b20gcmVnZXhwIC86aWQoXFxcXGQrKVxuICAgICAgICAgICAgICAgIGlmIChyZSAhPT0gQkFTRV9QQVJBTV9QQVRURVJOKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YlNlZ21lbnRTY29yZSArPSAxMCAvKiBQYXRoU2NvcmUuQm9udXNDdXN0b21SZWdFeHAgKi87XG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgcmVnZXhwIGlzIHZhbGlkIGJlZm9yZSB1c2luZyBpdFxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFJlZ0V4cChgKCR7cmV9KWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjdXN0b20gUmVnRXhwIGZvciBwYXJhbSBcIiR7dmFsdWV9XCIgKCR7cmV9KTogYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHdoZW4gd2UgcmVwZWF0IHdlIG11c3QgdGFrZSBjYXJlIG9mIHRoZSByZXBlYXRpbmcgbGVhZGluZyBzbGFzaFxuICAgICAgICAgICAgICAgIGxldCBzdWJQYXR0ZXJuID0gcmVwZWF0YWJsZSA/IGAoKD86JHtyZX0pKD86Lyg/OiR7cmV9KSkqKWAgOiBgKCR7cmV9KWA7XG4gICAgICAgICAgICAgICAgLy8gcHJlcGVuZCB0aGUgc2xhc2ggaWYgd2UgYXJlIHN0YXJ0aW5nIGEgbmV3IHNlZ21lbnRcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIHN1YlBhdHRlcm4gPVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXZvaWQgYW4gb3B0aW9uYWwgLyBpZiB0aGVyZSBhcmUgbW9yZSBzZWdtZW50cyBlLmcuIC86cD8tc3RhdGljXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvciAvOnA/LTpwMlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWwgJiYgc2VnbWVudC5sZW5ndGggPCAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgKD86LyR7c3ViUGF0dGVybn0pYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJy8nICsgc3ViUGF0dGVybjtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWwpXG4gICAgICAgICAgICAgICAgICAgIHN1YlBhdHRlcm4gKz0gJz8nO1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gc3ViUGF0dGVybjtcbiAgICAgICAgICAgICAgICBzdWJTZWdtZW50U2NvcmUgKz0gMjAgLyogUGF0aFNjb3JlLkR5bmFtaWMgKi87XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbmFsKVxuICAgICAgICAgICAgICAgICAgICBzdWJTZWdtZW50U2NvcmUgKz0gLTggLyogUGF0aFNjb3JlLkJvbnVzT3B0aW9uYWwgKi87XG4gICAgICAgICAgICAgICAgaWYgKHJlcGVhdGFibGUpXG4gICAgICAgICAgICAgICAgICAgIHN1YlNlZ21lbnRTY29yZSArPSAtMjAgLyogUGF0aFNjb3JlLkJvbnVzUmVwZWF0YWJsZSAqLztcbiAgICAgICAgICAgICAgICBpZiAocmUgPT09ICcuKicpXG4gICAgICAgICAgICAgICAgICAgIHN1YlNlZ21lbnRTY29yZSArPSAtNTAgLyogUGF0aFNjb3JlLkJvbnVzV2lsZGNhcmQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWdtZW50U2NvcmVzLnB1c2goc3ViU2VnbWVudFNjb3JlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbiBlbXB0eSBhcnJheSBsaWtlIC9ob21lLyAtPiBbW3tob21lfV0sIFtdXVxuICAgICAgICAvLyBpZiAoIXNlZ21lbnQubGVuZ3RoKSBwYXR0ZXJuICs9ICcvJ1xuICAgICAgICBzY29yZS5wdXNoKHNlZ21lbnRTY29yZXMpO1xuICAgIH1cbiAgICAvLyBvbmx5IGFwcGx5IHRoZSBzdHJpY3QgYm9udXMgdG8gdGhlIGxhc3Qgc2NvcmVcbiAgICBpZiAob3B0aW9ucy5zdHJpY3QgJiYgb3B0aW9ucy5lbmQpIHtcbiAgICAgICAgY29uc3QgaSA9IHNjb3JlLmxlbmd0aCAtIDE7XG4gICAgICAgIHNjb3JlW2ldW3Njb3JlW2ldLmxlbmd0aCAtIDFdICs9IDAuNzAwMDAwMDAwMDAwMDAwMSAvKiBQYXRoU2NvcmUuQm9udXNTdHJpY3QgKi87XG4gICAgfVxuICAgIC8vIFRPRE86IGRldiBvbmx5IHdhcm4gZG91YmxlIHRyYWlsaW5nIHNsYXNoXG4gICAgaWYgKCFvcHRpb25zLnN0cmljdClcbiAgICAgICAgcGF0dGVybiArPSAnLz8nO1xuICAgIGlmIChvcHRpb25zLmVuZClcbiAgICAgICAgcGF0dGVybiArPSAnJCc7XG4gICAgLy8gYWxsb3cgcGF0aHMgbGlrZSAvZHluYW1pYyB0byBvbmx5IG1hdGNoIGR5bmFtaWMgb3IgZHluYW1pYy8uLi4gYnV0IG5vdCBkeW5hbWljX3NvbWV0aGluZ19lbHNlXG4gICAgZWxzZSBpZiAob3B0aW9ucy5zdHJpY3QpXG4gICAgICAgIHBhdHRlcm4gKz0gJyg/Oi98JCknO1xuICAgIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knKTtcbiAgICBmdW5jdGlvbiBwYXJzZShwYXRoKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gcGF0aC5tYXRjaChyZSk7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbWF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbWF0Y2hbaV0gfHwgJyc7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2kgLSAxXTtcbiAgICAgICAgICAgIHBhcmFtc1trZXkubmFtZV0gPSB2YWx1ZSAmJiBrZXkucmVwZWF0YWJsZSA/IHZhbHVlLnNwbGl0KCcvJykgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHJpbmdpZnkocGFyYW1zKSB7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIC8vIGZvciBvcHRpb25hbCBwYXJhbWV0ZXJzIHRvIGFsbG93IHRvIGJlIGVtcHR5XG4gICAgICAgIGxldCBhdm9pZER1cGxpY2F0ZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICAgICAgICAgIGlmICghYXZvaWREdXBsaWNhdGVkU2xhc2ggfHwgIXBhdGguZW5kc1dpdGgoJy8nKSlcbiAgICAgICAgICAgICAgICBwYXRoICs9ICcvJztcbiAgICAgICAgICAgIGF2b2lkRHVwbGljYXRlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHNlZ21lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMCAvKiBUb2tlblR5cGUuU3RhdGljICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGggKz0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDEgLyogVG9rZW5UeXBlLlBhcmFtICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIHJlcGVhdGFibGUsIG9wdGlvbmFsIH0gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW0gPSB2YWx1ZSBpbiBwYXJhbXMgPyBwYXJhbXNbdmFsdWVdIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHBhcmFtKSAmJiAhcmVwZWF0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm92aWRlZCBwYXJhbSBcIiR7dmFsdWV9XCIgaXMgYW4gYXJyYXkgYnV0IGl0IGlzIG5vdCByZXBlYXRhYmxlICgqIG9yICsgbW9kaWZpZXJzKWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBpc0FycmF5KHBhcmFtKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBwYXJhbS5qb2luKCcvJylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcGFyYW07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBtb3JlIHRoYW4gb25lIG9wdGlvbmFsIHBhcmFtIGxpa2UgLzphPy1zdGF0aWMgd2UgZG9uJ3QgbmVlZCB0byBjYXJlIGFib3V0IHRoZSBvcHRpb25hbCBwYXJhbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBsYXN0IHNsYXNoIGFzIHdlIGNvdWxkIGJlIGF0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGguZW5kc1dpdGgoJy8nKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IGFwcGVuZCBhIHNsYXNoIG9uIHRoZSBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdm9pZER1cGxpY2F0ZWRTbGFzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyByZXF1aXJlZCBwYXJhbSBcIiR7dmFsdWV9XCJgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXRoICs9IHRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGF2b2lkIGVtcHR5IHBhdGggd2hlbiB3ZSBoYXZlIG11bHRpcGxlIG9wdGlvbmFsIHBhcmFtc1xuICAgICAgICByZXR1cm4gcGF0aCB8fCAnLyc7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlLFxuICAgICAgICBzY29yZSxcbiAgICAgICAga2V5cyxcbiAgICAgICAgcGFyc2UsXG4gICAgICAgIHN0cmluZ2lmeSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb21wYXJlcyBhbiBhcnJheSBvZiBudW1iZXJzIGFzIHVzZWQgaW4gUGF0aFBhcnNlci5zY29yZSBhbmQgcmV0dXJucyBhXG4gKiBudW1iZXIuIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gYHNvcnRgIGFuIGFycmF5XG4gKlxuICogQHBhcmFtIGEgLSBmaXJzdCBhcnJheSBvZiBudW1iZXJzXG4gKiBAcGFyYW0gYiAtIHNlY29uZCBhcnJheSBvZiBudW1iZXJzXG4gKiBAcmV0dXJucyAwIGlmIGJvdGggYXJlIGVxdWFsLCA8IDAgaWYgYSBzaG91bGQgYmUgc29ydGVkIGZpcnN0LCA+IDAgaWYgYlxuICogc2hvdWxkIGJlIHNvcnRlZCBmaXJzdFxuICovXG5mdW5jdGlvbiBjb21wYXJlU2NvcmVBcnJheShhLCBiKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYS5sZW5ndGggJiYgaSA8IGIubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBiW2ldIC0gYVtpXTtcbiAgICAgICAgLy8gb25seSBrZWVwIGdvaW5nIGlmIGRpZmYgPT09IDBcbiAgICAgICAgaWYgKGRpZmYpXG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgbGFzdCBzdWJzZWdtZW50IHdhcyBTdGF0aWMsIHRoZSBzaG9ydGVyIHNlZ21lbnRzIHNob3VsZCBiZSBzb3J0ZWQgZmlyc3RcbiAgICAvLyBvdGhlcndpc2Ugc29ydCB0aGUgbG9uZ2VzdCBzZWdtZW50IGZpcnN0XG4gICAgaWYgKGEubGVuZ3RoIDwgYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSAxICYmIGFbMF0gPT09IDQwIC8qIFBhdGhTY29yZS5TdGF0aWMgKi8gKyA0MCAvKiBQYXRoU2NvcmUuU2VnbWVudCAqL1xuICAgICAgICAgICAgPyAtMVxuICAgICAgICAgICAgOiAxO1xuICAgIH1cbiAgICBlbHNlIGlmIChhLmxlbmd0aCA+IGIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBiLmxlbmd0aCA9PT0gMSAmJiBiWzBdID09PSA0MCAvKiBQYXRoU2NvcmUuU3RhdGljICovICsgNDAgLyogUGF0aFNjb3JlLlNlZ21lbnQgKi9cbiAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgOiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG4vKipcbiAqIENvbXBhcmUgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB3aXRoIGBzb3J0YCB0byBzb3J0IGFuIGFycmF5IG9mIFBhdGhQYXJzZXJcbiAqXG4gKiBAcGFyYW0gYSAtIGZpcnN0IFBhdGhQYXJzZXJcbiAqIEBwYXJhbSBiIC0gc2Vjb25kIFBhdGhQYXJzZXJcbiAqIEByZXR1cm5zIDAgaWYgYm90aCBhcmUgZXF1YWwsIDwgMCBpZiBhIHNob3VsZCBiZSBzb3J0ZWQgZmlyc3QsID4gMCBpZiBiXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVQYXRoUGFyc2VyU2NvcmUoYSwgYikge1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBhU2NvcmUgPSBhLnNjb3JlO1xuICAgIGNvbnN0IGJTY29yZSA9IGIuc2NvcmU7XG4gICAgd2hpbGUgKGkgPCBhU2NvcmUubGVuZ3RoICYmIGkgPCBiU2NvcmUubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGNvbXAgPSBjb21wYXJlU2NvcmVBcnJheShhU2NvcmVbaV0sIGJTY29yZVtpXSk7XG4gICAgICAgIC8vIGRvIG5vdCByZXR1cm4gaWYgYm90aCBhcmUgZXF1YWxcbiAgICAgICAgaWYgKGNvbXApXG4gICAgICAgICAgICByZXR1cm4gY29tcDtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICBpZiAoTWF0aC5hYnMoYlNjb3JlLmxlbmd0aCAtIGFTY29yZS5sZW5ndGgpID09PSAxKSB7XG4gICAgICAgIGlmIChpc0xhc3RTY29yZU5lZ2F0aXZlKGFTY29yZSkpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKGlzTGFzdFNjb3JlTmVnYXRpdmUoYlNjb3JlKSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgLy8gaWYgYSBhbmQgYiBzaGFyZSB0aGUgc2FtZSBzY29yZSBlbnRyaWVzIGJ1dCBiIGhhcyBtb3JlLCBzb3J0IGIgZmlyc3RcbiAgICByZXR1cm4gYlNjb3JlLmxlbmd0aCAtIGFTY29yZS5sZW5ndGg7XG4gICAgLy8gdGhpcyBpcyB0aGUgdGVybmFyeSB2ZXJzaW9uXG4gICAgLy8gcmV0dXJuIGFTY29yZS5sZW5ndGggPCBiU2NvcmUubGVuZ3RoXG4gICAgLy8gICA/IDFcbiAgICAvLyAgIDogYVNjb3JlLmxlbmd0aCA+IGJTY29yZS5sZW5ndGhcbiAgICAvLyAgID8gLTFcbiAgICAvLyAgIDogMFxufVxuLyoqXG4gKiBUaGlzIGFsbG93cyBkZXRlY3Rpbmcgc3BsYXRzIGF0IHRoZSBlbmQgb2YgYSBwYXRoOiAvaG9tZS86aWQoLiopKlxuICpcbiAqIEBwYXJhbSBzY29yZSAtIHNjb3JlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBsYXN0IGVudHJ5IGlzIG5lZ2F0aXZlXG4gKi9cbmZ1bmN0aW9uIGlzTGFzdFNjb3JlTmVnYXRpdmUoc2NvcmUpIHtcbiAgICBjb25zdCBsYXN0ID0gc2NvcmVbc2NvcmUubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHNjb3JlLmxlbmd0aCA+IDAgJiYgbGFzdFtsYXN0Lmxlbmd0aCAtIDFdIDwgMDtcbn1cblxuY29uc3QgUk9PVF9UT0tFTiA9IHtcbiAgICB0eXBlOiAwIC8qIFRva2VuVHlwZS5TdGF0aWMgKi8sXG4gICAgdmFsdWU6ICcnLFxufTtcbmNvbnN0IFZBTElEX1BBUkFNX1JFID0gL1thLXpBLVowLTlfXS87XG4vLyBBZnRlciBzb21lIHByb2ZpbGluZywgdGhlIGNhY2hlIHNlZW1zIHRvIGJlIHVubmVjZXNzYXJ5IGJlY2F1c2UgdG9rZW5pemVQYXRoXG4vLyAodGhlIHNsb3dlc3QgcGFydCBvZiBhZGRpbmcgYSByb3V0ZSkgaXMgdmVyeSBmYXN0XG4vLyBjb25zdCB0b2tlbkNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIFRva2VuW11bXT4oKVxuZnVuY3Rpb24gdG9rZW5pemVQYXRoKHBhdGgpIHtcbiAgICBpZiAoIXBhdGgpXG4gICAgICAgIHJldHVybiBbW11dO1xuICAgIGlmIChwYXRoID09PSAnLycpXG4gICAgICAgIHJldHVybiBbW1JPT1RfVE9LRU5dXTtcbiAgICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgICAgID8gYFJvdXRlIHBhdGhzIHNob3VsZCBzdGFydCB3aXRoIGEgXCIvXCI6IFwiJHtwYXRofVwiIHNob3VsZCBiZSBcIi8ke3BhdGh9XCIuYFxuICAgICAgICAgICAgOiBgSW52YWxpZCBwYXRoIFwiJHtwYXRofVwiYCk7XG4gICAgfVxuICAgIC8vIGlmICh0b2tlbkNhY2hlLmhhcyhwYXRoKSkgcmV0dXJuIHRva2VuQ2FjaGUuZ2V0KHBhdGgpIVxuICAgIGZ1bmN0aW9uIGNyYXNoKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFUlIgKCR7c3RhdGV9KS9cIiR7YnVmZmVyfVwiOiAke21lc3NhZ2V9YCk7XG4gICAgfVxuICAgIGxldCBzdGF0ZSA9IDAgLyogVG9rZW5pemVyU3RhdGUuU3RhdGljICovO1xuICAgIGxldCBwcmV2aW91c1N0YXRlID0gc3RhdGU7XG4gICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgLy8gdGhlIHNlZ21lbnQgd2lsbCBhbHdheXMgYmUgdmFsaWQgYmVjYXVzZSB3ZSBnZXQgaW50byB0aGUgaW5pdGlhbCBzdGF0ZVxuICAgIC8vIHdpdGggdGhlIGxlYWRpbmcgL1xuICAgIGxldCBzZWdtZW50O1xuICAgIGZ1bmN0aW9uIGZpbmFsaXplU2VnbWVudCgpIHtcbiAgICAgICAgaWYgKHNlZ21lbnQpXG4gICAgICAgICAgICB0b2tlbnMucHVzaChzZWdtZW50KTtcbiAgICAgICAgc2VnbWVudCA9IFtdO1xuICAgIH1cbiAgICAvLyBpbmRleCBvbiB0aGUgcGF0aFxuICAgIGxldCBpID0gMDtcbiAgICAvLyBjaGFyIGF0IGluZGV4XG4gICAgbGV0IGNoYXI7XG4gICAgLy8gYnVmZmVyIG9mIHRoZSB2YWx1ZSByZWFkXG4gICAgbGV0IGJ1ZmZlciA9ICcnO1xuICAgIC8vIGN1c3RvbSByZWdleHAgZm9yIGEgcGFyYW1cbiAgICBsZXQgY3VzdG9tUmUgPSAnJztcbiAgICBmdW5jdGlvbiBjb25zdW1lQnVmZmVyKCkge1xuICAgICAgICBpZiAoIWJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHN0YXRlID09PSAwIC8qIFRva2VuaXplclN0YXRlLlN0YXRpYyAqLykge1xuICAgICAgICAgICAgc2VnbWVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAwIC8qIFRva2VuVHlwZS5TdGF0aWMgKi8sXG4gICAgICAgICAgICAgICAgdmFsdWU6IGJ1ZmZlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSAxIC8qIFRva2VuaXplclN0YXRlLlBhcmFtICovIHx8XG4gICAgICAgICAgICBzdGF0ZSA9PT0gMiAvKiBUb2tlbml6ZXJTdGF0ZS5QYXJhbVJlZ0V4cCAqLyB8fFxuICAgICAgICAgICAgc3RhdGUgPT09IDMgLyogVG9rZW5pemVyU3RhdGUuUGFyYW1SZWdFeHBFbmQgKi8pIHtcbiAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDEgJiYgKGNoYXIgPT09ICcqJyB8fCBjaGFyID09PSAnKycpKVxuICAgICAgICAgICAgICAgIGNyYXNoKGBBIHJlcGVhdGFibGUgcGFyYW0gKCR7YnVmZmVyfSkgbXVzdCBiZSBhbG9uZSBpbiBpdHMgc2VnbWVudC4gZWc6ICcvOmlkcysuYCk7XG4gICAgICAgICAgICBzZWdtZW50LnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IDEgLyogVG9rZW5UeXBlLlBhcmFtICovLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBidWZmZXIsXG4gICAgICAgICAgICAgICAgcmVnZXhwOiBjdXN0b21SZSxcbiAgICAgICAgICAgICAgICByZXBlYXRhYmxlOiBjaGFyID09PSAnKicgfHwgY2hhciA9PT0gJysnLFxuICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBjaGFyID09PSAnKicgfHwgY2hhciA9PT0gJz8nLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjcmFzaCgnSW52YWxpZCBzdGF0ZSB0byBjb25zdW1lIGJ1ZmZlcicpO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRDaGFyVG9CdWZmZXIoKSB7XG4gICAgICAgIGJ1ZmZlciArPSBjaGFyO1xuICAgIH1cbiAgICB3aGlsZSAoaSA8IHBhdGgubGVuZ3RoKSB7XG4gICAgICAgIGNoYXIgPSBwYXRoW2krK107XG4gICAgICAgIGlmIChjaGFyID09PSAnXFxcXCcgJiYgc3RhdGUgIT09IDIgLyogVG9rZW5pemVyU3RhdGUuUGFyYW1SZWdFeHAgKi8pIHtcbiAgICAgICAgICAgIHByZXZpb3VzU3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgIHN0YXRlID0gNCAvKiBUb2tlbml6ZXJTdGF0ZS5Fc2NhcGVOZXh0ICovO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIFRva2VuaXplclN0YXRlLlN0YXRpYyAqLzpcbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN1bWVCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGl6ZVNlZ21lbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gJzonKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN1bWVCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAxIC8qIFRva2VuaXplclN0YXRlLlBhcmFtICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2hhclRvQnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0IC8qIFRva2VuaXplclN0YXRlLkVzY2FwZU5leHQgKi86XG4gICAgICAgICAgICAgICAgYWRkQ2hhclRvQnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBwcmV2aW91c1N0YXRlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxIC8qIFRva2VuaXplclN0YXRlLlBhcmFtICovOlxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAyIC8qIFRva2VuaXplclN0YXRlLlBhcmFtUmVnRXhwICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChWQUxJRF9QQVJBTV9SRS50ZXN0KGNoYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZENoYXJUb0J1ZmZlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3VtZUJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDAgLyogVG9rZW5pemVyU3RhdGUuU3RhdGljICovO1xuICAgICAgICAgICAgICAgICAgICAvLyBnbyBiYWNrIG9uZSBjaGFyYWN0ZXIgaWYgd2Ugd2VyZSBub3QgbW9kaWZ5aW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyICE9PSAnKicgJiYgY2hhciAhPT0gJz8nICYmIGNoYXIgIT09ICcrJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIgLyogVG9rZW5pemVyU3RhdGUuUGFyYW1SZWdFeHAgKi86XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaXMgaXQgd29ydGggaGFuZGxpbmcgbmVzdGVkIHJlZ2V4cD8gbGlrZSA6cCg/OnByZWZpeF8oW14vXSspX3N1ZmZpeClcbiAgICAgICAgICAgICAgICAvLyBpdCBhbHJlYWR5IHdvcmtzIGJ5IGVzY2FwaW5nIHRoZSBjbG9zaW5nIClcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3BhdGhzLmVzbS5kZXYvP3A9QUFNZUpiaUF3UUVjREtiQW9BQWtQNjBQRzJSNlFBdmdOYUE2QUZBQ00yQUJ1UUJCI1xuICAgICAgICAgICAgICAgIC8vIGlzIHRoaXMgcmVhbGx5IHNvbWV0aGluZyBwZW9wbGUgbmVlZCBzaW5jZSB5b3UgY2FuIGFsc28gd3JpdGVcbiAgICAgICAgICAgICAgICAvLyAvcHJlZml4XzpwKClfc3VmZml4XG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09ICcpJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgdGhlIGVzY2FwZWQgKVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VzdG9tUmVbY3VzdG9tUmUubGVuZ3RoIC0gMV0gPT0gJ1xcXFwnKVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tUmUgPSBjdXN0b21SZS5zbGljZSgwLCAtMSkgKyBjaGFyO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDMgLyogVG9rZW5pemVyU3RhdGUuUGFyYW1SZWdFeHBFbmQgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21SZSArPSBjaGFyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMyAvKiBUb2tlbml6ZXJTdGF0ZS5QYXJhbVJlZ0V4cEVuZCAqLzpcbiAgICAgICAgICAgICAgICAvLyBzYW1lIGFzIGZpbmFsaXppbmcgYSBwYXJhbVxuICAgICAgICAgICAgICAgIGNvbnN1bWVCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IDAgLyogVG9rZW5pemVyU3RhdGUuU3RhdGljICovO1xuICAgICAgICAgICAgICAgIC8vIGdvIGJhY2sgb25lIGNoYXJhY3RlciBpZiB3ZSB3ZXJlIG5vdCBtb2RpZnlpbmdcbiAgICAgICAgICAgICAgICBpZiAoY2hhciAhPT0gJyonICYmIGNoYXIgIT09ICc/JyAmJiBjaGFyICE9PSAnKycpXG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICBjdXN0b21SZSA9ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjcmFzaCgnVW5rbm93biBzdGF0ZScpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0ZSA9PT0gMiAvKiBUb2tlbml6ZXJTdGF0ZS5QYXJhbVJlZ0V4cCAqLylcbiAgICAgICAgY3Jhc2goYFVuZmluaXNoZWQgY3VzdG9tIFJlZ0V4cCBmb3IgcGFyYW0gXCIke2J1ZmZlcn1cImApO1xuICAgIGNvbnN1bWVCdWZmZXIoKTtcbiAgICBmaW5hbGl6ZVNlZ21lbnQoKTtcbiAgICAvLyB0b2tlbkNhY2hlLnNldChwYXRoLCB0b2tlbnMpXG4gICAgcmV0dXJuIHRva2Vucztcbn1cblxuZnVuY3Rpb24gY3JlYXRlUm91dGVSZWNvcmRNYXRjaGVyKHJlY29yZCwgcGFyZW50LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdG9rZW5zVG9QYXJzZXIodG9rZW5pemVQYXRoKHJlY29yZC5wYXRoKSwgb3B0aW9ucyk7XG4gICAgLy8gd2FybiBhZ2FpbnN0IHBhcmFtcyB3aXRoIHRoZSBzYW1lIG5hbWVcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcGFyc2VyLmtleXMpIHtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0tleXMuaGFzKGtleS5uYW1lKSlcbiAgICAgICAgICAgICAgICB3YXJuKGBGb3VuZCBkdXBsaWNhdGVkIHBhcmFtcyB3aXRoIG5hbWUgXCIke2tleS5uYW1lfVwiIGZvciBwYXRoIFwiJHtyZWNvcmQucGF0aH1cIi4gT25seSB0aGUgbGFzdCBvbmUgd2lsbCBiZSBhdmFpbGFibGUgb24gXCIkcm91dGUucGFyYW1zXCIuYCk7XG4gICAgICAgICAgICBleGlzdGluZ0tleXMuYWRkKGtleS5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtYXRjaGVyID0gYXNzaWduKHBhcnNlciwge1xuICAgICAgICByZWNvcmQsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgLy8gdGhlc2UgbmVlZHMgdG8gYmUgcG9wdWxhdGVkIGJ5IHRoZSBwYXJlbnRcbiAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICBhbGlhczogW10sXG4gICAgfSk7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICAvLyBib3RoIGFyZSBhbGlhc2VzIG9yIGJvdGggYXJlIG5vdCBhbGlhc2VzXG4gICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gbWl4IHRoZW0gYmVjYXVzZSB0aGUgb3JkZXIgaXMgdXNlZCB3aGVuXG4gICAgICAgIC8vIHBhc3Npbmcgb3JpZ2luYWxSZWNvcmQgaW4gTWF0Y2hlci5hZGRSb3V0ZVxuICAgICAgICBpZiAoIW1hdGNoZXIucmVjb3JkLmFsaWFzT2YgPT09ICFwYXJlbnQucmVjb3JkLmFsaWFzT2YpXG4gICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChtYXRjaGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFJvdXRlciBNYXRjaGVyLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHJvdXRlcyAtIGFycmF5IG9mIGluaXRpYWwgcm91dGVzXG4gKiBAcGFyYW0gZ2xvYmFsT3B0aW9ucyAtIGdsb2JhbCByb3V0ZSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlck1hdGNoZXIocm91dGVzLCBnbG9iYWxPcHRpb25zKSB7XG4gICAgLy8gbm9ybWFsaXplZCBvcmRlcmVkIGFycmF5IG9mIG1hdGNoZXJzXG4gICAgY29uc3QgbWF0Y2hlcnMgPSBbXTtcbiAgICBjb25zdCBtYXRjaGVyTWFwID0gbmV3IE1hcCgpO1xuICAgIGdsb2JhbE9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoeyBzdHJpY3Q6IGZhbHNlLCBlbmQ6IHRydWUsIHNlbnNpdGl2ZTogZmFsc2UgfSwgZ2xvYmFsT3B0aW9ucyk7XG4gICAgZnVuY3Rpb24gZ2V0UmVjb3JkTWF0Y2hlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVyTWFwLmdldChuYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkUm91dGUocmVjb3JkLCBwYXJlbnQsIG9yaWdpbmFsUmVjb3JkKSB7XG4gICAgICAgIC8vIHVzZWQgbGF0ZXIgb24gdG8gcmVtb3ZlIGJ5IG5hbWVcbiAgICAgICAgY29uc3QgaXNSb290QWRkID0gIW9yaWdpbmFsUmVjb3JkO1xuICAgICAgICBjb25zdCBtYWluTm9ybWFsaXplZFJlY29yZCA9IG5vcm1hbGl6ZVJvdXRlUmVjb3JkKHJlY29yZCk7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIGNoZWNrQ2hpbGRNaXNzaW5nTmFtZVdpdGhFbXB0eVBhdGgobWFpbk5vcm1hbGl6ZWRSZWNvcmQsIHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgbWlnaHQgYmUgdGhlIGNoaWxkIG9mIGFuIGFsaWFzXG4gICAgICAgIG1haW5Ob3JtYWxpemVkUmVjb3JkLmFsaWFzT2YgPSBvcmlnaW5hbFJlY29yZCAmJiBvcmlnaW5hbFJlY29yZC5yZWNvcmQ7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoZ2xvYmFsT3B0aW9ucywgcmVjb3JkKTtcbiAgICAgICAgLy8gZ2VuZXJhdGUgYW4gYXJyYXkgb2YgcmVjb3JkcyB0byBjb3JyZWN0bHkgaGFuZGxlIGFsaWFzZXNcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFJlY29yZHMgPSBbXG4gICAgICAgICAgICBtYWluTm9ybWFsaXplZFJlY29yZCxcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKCdhbGlhcycgaW4gcmVjb3JkKSB7XG4gICAgICAgICAgICBjb25zdCBhbGlhc2VzID0gdHlwZW9mIHJlY29yZC5hbGlhcyA9PT0gJ3N0cmluZycgPyBbcmVjb3JkLmFsaWFzXSA6IHJlY29yZC5hbGlhcztcbiAgICAgICAgICAgIGZvciAoY29uc3QgYWxpYXMgb2YgYWxpYXNlcykge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRSZWNvcmRzLnB1c2goYXNzaWduKHt9LCBtYWluTm9ybWFsaXplZFJlY29yZCwge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGFsbG93cyB1cyB0byBob2xkIGEgY29weSBvZiB0aGUgYGNvbXBvbmVudHNgIG9wdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBzbyB0aGF0IGFzeW5jIGNvbXBvbmVudHMgY2FjaGUgaXMgaG9sZCBvbiB0aGUgb3JpZ2luYWwgcmVjb3JkXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IG9yaWdpbmFsUmVjb3JkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG9yaWdpbmFsUmVjb3JkLnJlY29yZC5jb21wb25lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG1haW5Ob3JtYWxpemVkUmVjb3JkLmNvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGFsaWFzLFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBtaWdodCBiZSB0aGUgY2hpbGQgb2YgYW4gYWxpYXNcbiAgICAgICAgICAgICAgICAgICAgYWxpYXNPZjogb3JpZ2luYWxSZWNvcmRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gb3JpZ2luYWxSZWNvcmQucmVjb3JkXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG1haW5Ob3JtYWxpemVkUmVjb3JkLFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYWxpYXNlcyBhcmUgYWx3YXlzIG9mIHRoZSBzYW1lIGtpbmQgYXMgdGhlIG9yaWdpbmFsIHNpbmNlIHRoZXlcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJlIGRlZmluZWQgb24gdGhlIHNhbWUgcmVjb3JkXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtYXRjaGVyO1xuICAgICAgICBsZXQgb3JpZ2luYWxNYXRjaGVyO1xuICAgICAgICBmb3IgKGNvbnN0IG5vcm1hbGl6ZWRSZWNvcmQgb2Ygbm9ybWFsaXplZFJlY29yZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGF0aCB9ID0gbm9ybWFsaXplZFJlY29yZDtcbiAgICAgICAgICAgIC8vIEJ1aWxkIHVwIHRoZSBwYXRoIGZvciBuZXN0ZWQgcm91dGVzIGlmIHRoZSBjaGlsZCBpc24ndCBhbiBhYnNvbHV0ZVxuICAgICAgICAgICAgLy8gcm91dGUuIE9ubHkgYWRkIHRoZSAvIGRlbGltaXRlciBpZiB0aGUgY2hpbGQgcGF0aCBpc24ndCBlbXB0eSBhbmQgaWYgdGhlXG4gICAgICAgICAgICAvLyBwYXJlbnQgcGF0aCBkb2Vzbid0IGhhdmUgYSB0cmFpbGluZyBzbGFzaFxuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXRoWzBdICE9PSAnLycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gcGFyZW50LnJlY29yZC5wYXRoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RpbmdTbGFzaCA9IHBhcmVudFBhdGhbcGFyZW50UGF0aC5sZW5ndGggLSAxXSA9PT0gJy8nID8gJycgOiAnLyc7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFJlY29yZC5wYXRoID1cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJlY29yZC5wYXRoICsgKHBhdGggJiYgY29ubmVjdGluZ1NsYXNoICsgcGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG5vcm1hbGl6ZWRSZWNvcmQucGF0aCA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYXRjaCBhbGwgcm91dGVzIChcIipcIikgbXVzdCBub3cgYmUgZGVmaW5lZCB1c2luZyBhIHBhcmFtIHdpdGggYSBjdXN0b20gcmVnZXhwLlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAnU2VlIG1vcmUgYXQgaHR0cHM6Ly9uZXh0LnJvdXRlci52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uLyNyZW1vdmVkLXN0YXItb3ItY2F0Y2gtYWxsLXJvdXRlcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgb2JqZWN0IGJlZm9yZWhhbmQsIHNvIGl0IGNhbiBiZSBwYXNzZWQgdG8gY2hpbGRyZW5cbiAgICAgICAgICAgIG1hdGNoZXIgPSBjcmVhdGVSb3V0ZVJlY29yZE1hdGNoZXIobm9ybWFsaXplZFJlY29yZCwgcGFyZW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcGFyZW50ICYmIHBhdGhbMF0gPT09ICcvJylcbiAgICAgICAgICAgICAgICBjaGVja01pc3NpbmdQYXJhbXNJbkFic29sdXRlUGF0aChtYXRjaGVyLCBwYXJlbnQpO1xuICAgICAgICAgICAgLy8gaWYgd2UgYXJlIGFuIGFsaWFzIHdlIG11c3QgdGVsbCB0aGUgb3JpZ2luYWwgcmVjb3JkIHRoYXQgd2UgZXhpc3QsXG4gICAgICAgICAgICAvLyBzbyB3ZSBjYW4gYmUgcmVtb3ZlZFxuICAgICAgICAgICAgaWYgKG9yaWdpbmFsUmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxSZWNvcmQuYWxpYXMucHVzaChtYXRjaGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrU2FtZVBhcmFtcyhvcmlnaW5hbFJlY29yZCwgbWF0Y2hlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCB0aGUgZmlyc3QgcmVjb3JkIGlzIHRoZSBvcmlnaW5hbCBhbmQgb3RoZXJzIGFyZSBhbGlhc2VzXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxNYXRjaGVyID0gb3JpZ2luYWxNYXRjaGVyIHx8IG1hdGNoZXI7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsTWF0Y2hlciAhPT0gbWF0Y2hlcilcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxNYXRjaGVyLmFsaWFzLnB1c2gobWF0Y2hlcik7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSByb3V0ZSBpZiBuYW1lZCBhbmQgb25seSBmb3IgdGhlIHRvcCByZWNvcmQgKGF2b2lkIGluIG5lc3RlZCBjYWxscylcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHdvcmtzIGJlY2F1c2UgdGhlIG9yaWdpbmFsIHJlY29yZCBpcyB0aGUgZmlyc3Qgb25lXG4gICAgICAgICAgICAgICAgaWYgKGlzUm9vdEFkZCAmJiByZWNvcmQubmFtZSAmJiAhaXNBbGlhc1JlY29yZChtYXRjaGVyKSlcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlUm91dGUocmVjb3JkLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1haW5Ob3JtYWxpemVkUmVjb3JkLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBtYWluTm9ybWFsaXplZFJlY29yZC5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFJvdXRlKGNoaWxkcmVuW2ldLCBtYXRjaGVyLCBvcmlnaW5hbFJlY29yZCAmJiBvcmlnaW5hbFJlY29yZC5jaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgd2FzIG5vIG9yaWdpbmFsIHJlY29yZCwgdGhlbiB0aGUgZmlyc3Qgb25lIHdhcyBub3QgYW4gYWxpYXMgYW5kIGFsbFxuICAgICAgICAgICAgLy8gb3RoZXIgYWxpYXNlcyAoaWYgYW55KSBuZWVkIHRvIHJlZmVyZW5jZSB0aGlzIHJlY29yZCB3aGVuIGFkZGluZyBjaGlsZHJlblxuICAgICAgICAgICAgb3JpZ2luYWxSZWNvcmQgPSBvcmlnaW5hbFJlY29yZCB8fCBtYXRjaGVyO1xuICAgICAgICAgICAgLy8gVE9ETzogYWRkIG5vcm1hbGl6ZWQgcmVjb3JkcyBmb3IgbW9yZSBmbGV4aWJpbGl0eVxuICAgICAgICAgICAgLy8gaWYgKHBhcmVudCAmJiBpc0FsaWFzUmVjb3JkKG9yaWdpbmFsUmVjb3JkKSkge1xuICAgICAgICAgICAgLy8gICBwYXJlbnQuY2hpbGRyZW4ucHVzaChvcmlnaW5hbFJlY29yZClcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIEF2b2lkIGFkZGluZyBhIHJlY29yZCB0aGF0IGRvZXNuJ3QgZGlzcGxheSBhbnl0aGluZy4gVGhpcyBhbGxvd3MgcGFzc2luZyB0aHJvdWdoIHJlY29yZHMgd2l0aG91dCBhIGNvbXBvbmVudCB0b1xuICAgICAgICAgICAgLy8gbm90IGJlIHJlYWNoZWQgYW5kIHBhc3MgdGhyb3VnaCB0aGUgY2F0Y2ggYWxsIHJvdXRlXG4gICAgICAgICAgICBpZiAoKG1hdGNoZXIucmVjb3JkLmNvbXBvbmVudHMgJiZcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhtYXRjaGVyLnJlY29yZC5jb21wb25lbnRzKS5sZW5ndGgpIHx8XG4gICAgICAgICAgICAgICAgbWF0Y2hlci5yZWNvcmQubmFtZSB8fFxuICAgICAgICAgICAgICAgIG1hdGNoZXIucmVjb3JkLnJlZGlyZWN0KSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0TWF0Y2hlcihtYXRjaGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ2luYWxNYXRjaGVyXG4gICAgICAgICAgICA/ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBvdGhlciBtYXRjaGVycyBhcmUgYWxpYXNlcywgdGhleSBzaG91bGQgYmUgcmVtb3ZlZCBieSB0aGUgb3JpZ2luYWwgbWF0Y2hlclxuICAgICAgICAgICAgICAgIHJlbW92ZVJvdXRlKG9yaWdpbmFsTWF0Y2hlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IG5vb3A7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZVJvdXRlKG1hdGNoZXJSZWYpIHtcbiAgICAgICAgaWYgKGlzUm91dGVOYW1lKG1hdGNoZXJSZWYpKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVyID0gbWF0Y2hlck1hcC5nZXQobWF0Y2hlclJlZik7XG4gICAgICAgICAgICBpZiAobWF0Y2hlcikge1xuICAgICAgICAgICAgICAgIG1hdGNoZXJNYXAuZGVsZXRlKG1hdGNoZXJSZWYpO1xuICAgICAgICAgICAgICAgIG1hdGNoZXJzLnNwbGljZShtYXRjaGVycy5pbmRleE9mKG1hdGNoZXIpLCAxKTtcbiAgICAgICAgICAgICAgICBtYXRjaGVyLmNoaWxkcmVuLmZvckVhY2gocmVtb3ZlUm91dGUpO1xuICAgICAgICAgICAgICAgIG1hdGNoZXIuYWxpYXMuZm9yRWFjaChyZW1vdmVSb3V0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IG1hdGNoZXJzLmluZGV4T2YobWF0Y2hlclJlZik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXJSZWYucmVjb3JkLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXJNYXAuZGVsZXRlKG1hdGNoZXJSZWYucmVjb3JkLm5hbWUpO1xuICAgICAgICAgICAgICAgIG1hdGNoZXJSZWYuY2hpbGRyZW4uZm9yRWFjaChyZW1vdmVSb3V0ZSk7XG4gICAgICAgICAgICAgICAgbWF0Y2hlclJlZi5hbGlhcy5mb3JFYWNoKHJlbW92ZVJvdXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSb3V0ZXMoKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVycztcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5zZXJ0TWF0Y2hlcihtYXRjaGVyKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBtYXRjaGVycy5sZW5ndGggJiZcbiAgICAgICAgICAgIGNvbXBhcmVQYXRoUGFyc2VyU2NvcmUobWF0Y2hlciwgbWF0Y2hlcnNbaV0pID49IDAgJiZcbiAgICAgICAgICAgIC8vIEFkZGluZyBjaGlsZHJlbiB3aXRoIGVtcHR5IHBhdGggc2hvdWxkIHN0aWxsIGFwcGVhciBiZWZvcmUgdGhlIHBhcmVudFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3JvdXRlci9pc3N1ZXMvMTEyNFxuICAgICAgICAgICAgKG1hdGNoZXIucmVjb3JkLnBhdGggIT09IG1hdGNoZXJzW2ldLnJlY29yZC5wYXRoIHx8XG4gICAgICAgICAgICAgICAgIWlzUmVjb3JkQ2hpbGRPZihtYXRjaGVyLCBtYXRjaGVyc1tpXSkpKVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICBtYXRjaGVycy5zcGxpY2UoaSwgMCwgbWF0Y2hlcik7XG4gICAgICAgIC8vIG9ubHkgYWRkIHRoZSBvcmlnaW5hbCByZWNvcmQgdG8gdGhlIG5hbWUgbWFwXG4gICAgICAgIGlmIChtYXRjaGVyLnJlY29yZC5uYW1lICYmICFpc0FsaWFzUmVjb3JkKG1hdGNoZXIpKVxuICAgICAgICAgICAgbWF0Y2hlck1hcC5zZXQobWF0Y2hlci5yZWNvcmQubmFtZSwgbWF0Y2hlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmUobG9jYXRpb24sIGN1cnJlbnRMb2NhdGlvbikge1xuICAgICAgICBsZXQgbWF0Y2hlcjtcbiAgICAgICAgbGV0IHBhcmFtcyA9IHt9O1xuICAgICAgICBsZXQgcGF0aDtcbiAgICAgICAgbGV0IG5hbWU7XG4gICAgICAgIGlmICgnbmFtZScgaW4gbG9jYXRpb24gJiYgbG9jYXRpb24ubmFtZSkge1xuICAgICAgICAgICAgbWF0Y2hlciA9IG1hdGNoZXJNYXAuZ2V0KGxvY2F0aW9uLm5hbWUpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVyKVxuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVJvdXRlckVycm9yKDEgLyogRXJyb3JUeXBlcy5NQVRDSEVSX05PVF9GT1VORCAqLywge1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHdhcm4gaWYgdGhlIHVzZXIgaXMgcGFzc2luZyBpbnZhbGlkIHBhcmFtcyBzbyB0aGV5IGNhbiBkZWJ1ZyBpdCBiZXR0ZXIgd2hlbiB0aGV5IGdldCByZW1vdmVkXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZFBhcmFtcyA9IE9iamVjdC5rZXlzKGxvY2F0aW9uLnBhcmFtcyB8fCB7fSkuZmlsdGVyKHBhcmFtTmFtZSA9PiAhbWF0Y2hlci5rZXlzLmZpbmQoayA9PiBrLm5hbWUgPT09IHBhcmFtTmFtZSkpO1xuICAgICAgICAgICAgICAgIGlmIChpbnZhbGlkUGFyYW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBEaXNjYXJkZWQgaW52YWxpZCBwYXJhbShzKSBcIiR7aW52YWxpZFBhcmFtcy5qb2luKCdcIiwgXCInKX1cIiB3aGVuIG5hdmlnYXRpbmcuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvcm91dGVyL2Jsb2IvbWFpbi9wYWNrYWdlcy9yb3V0ZXIvQ0hBTkdFTE9HLm1kIzQxNC0yMDIyLTA4LTIyIGZvciBtb3JlIGRldGFpbHMuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFtZSA9IG1hdGNoZXIucmVjb3JkLm5hbWU7XG4gICAgICAgICAgICBwYXJhbXMgPSBhc3NpZ24oXG4gICAgICAgICAgICAvLyBwYXJhbXNGcm9tTG9jYXRpb24gaXMgYSBuZXcgb2JqZWN0XG4gICAgICAgICAgICBwYXJhbXNGcm9tTG9jYXRpb24oY3VycmVudExvY2F0aW9uLnBhcmFtcywgXG4gICAgICAgICAgICAvLyBvbmx5IGtlZXAgcGFyYW1zIHRoYXQgZXhpc3QgaW4gdGhlIHJlc29sdmVkIGxvY2F0aW9uXG4gICAgICAgICAgICAvLyBUT0RPOiBvbmx5IGtlZXAgb3B0aW9uYWwgcGFyYW1zIGNvbWluZyBmcm9tIGEgcGFyZW50IHJlY29yZFxuICAgICAgICAgICAgbWF0Y2hlci5rZXlzLmZpbHRlcihrID0+ICFrLm9wdGlvbmFsKS5tYXAoayA9PiBrLm5hbWUpKSwgXG4gICAgICAgICAgICAvLyBkaXNjYXJkIGFueSBleGlzdGluZyBwYXJhbXMgaW4gdGhlIGN1cnJlbnQgbG9jYXRpb24gdGhhdCBkbyBub3QgZXhpc3QgaGVyZVxuICAgICAgICAgICAgLy8gIzE0OTcgdGhpcyBlbnN1cmVzIGJldHRlciBhY3RpdmUvZXhhY3QgbWF0Y2hpbmdcbiAgICAgICAgICAgIGxvY2F0aW9uLnBhcmFtcyAmJlxuICAgICAgICAgICAgICAgIHBhcmFtc0Zyb21Mb2NhdGlvbihsb2NhdGlvbi5wYXJhbXMsIG1hdGNoZXIua2V5cy5tYXAoayA9PiBrLm5hbWUpKSk7XG4gICAgICAgICAgICAvLyB0aHJvd3MgaWYgY2Fubm90IGJlIHN0cmluZ2lmaWVkXG4gICAgICAgICAgICBwYXRoID0gbWF0Y2hlci5zdHJpbmdpZnkocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgncGF0aCcgaW4gbG9jYXRpb24pIHtcbiAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gcmVzb2x2ZSB0aGUgcGF0aCB3aXRoIHRoZSBtYXRjaGVyIGFzIGl0IHdhcyBwcm92aWRlZFxuICAgICAgICAgICAgLy8gdGhpcyBhbHNvIGFsbG93cyB0aGUgdXNlciB0byBjb250cm9sIHRoZSBlbmNvZGluZ1xuICAgICAgICAgICAgcGF0aCA9IGxvY2F0aW9uLnBhdGg7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFwYXRoLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgIHdhcm4oYFRoZSBNYXRjaGVyIGNhbm5vdCByZXNvbHZlIHJlbGF0aXZlIHBhdGhzIGJ1dCByZWNlaXZlZCBcIiR7cGF0aH1cIi4gVW5sZXNzIHlvdSBkaXJlY3RseSBjYWxsZWQgXFxgbWF0Y2hlci5yZXNvbHZlKFwiJHtwYXRofVwiKVxcYCwgdGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiB2dWUtcm91dGVyLiBQbGVhc2Ugb3BlbiBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvcm91dGVyL2lzc3Vlcy9uZXcvY2hvb3NlLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0Y2hlciA9IG1hdGNoZXJzLmZpbmQobSA9PiBtLnJlLnRlc3QocGF0aCkpO1xuICAgICAgICAgICAgLy8gbWF0Y2hlciBzaG91bGQgaGF2ZSBhIHZhbHVlIGFmdGVyIHRoZSBsb29wXG4gICAgICAgICAgICBpZiAobWF0Y2hlcikge1xuICAgICAgICAgICAgICAgIC8vIHdlIGtub3cgdGhlIG1hdGNoZXIgd29ya3MgYmVjYXVzZSB3ZSB0ZXN0ZWQgdGhlIHJlZ2V4cFxuICAgICAgICAgICAgICAgIHBhcmFtcyA9IG1hdGNoZXIucGFyc2UocGF0aCk7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG1hdGNoZXIucmVjb3JkLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsb2NhdGlvbiBpcyBhIHJlbGF0aXZlIHBhdGhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG1hdGNoIGJ5IG5hbWUgb3IgcGF0aCBvZiBjdXJyZW50IHJvdXRlXG4gICAgICAgICAgICBtYXRjaGVyID0gY3VycmVudExvY2F0aW9uLm5hbWVcbiAgICAgICAgICAgICAgICA/IG1hdGNoZXJNYXAuZ2V0KGN1cnJlbnRMb2NhdGlvbi5uYW1lKVxuICAgICAgICAgICAgICAgIDogbWF0Y2hlcnMuZmluZChtID0+IG0ucmUudGVzdChjdXJyZW50TG9jYXRpb24ucGF0aCkpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVyKVxuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVJvdXRlckVycm9yKDEgLyogRXJyb3JUeXBlcy5NQVRDSEVSX05PVF9GT1VORCAqLywge1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExvY2F0aW9uLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmFtZSA9IG1hdGNoZXIucmVjb3JkLm5hbWU7XG4gICAgICAgICAgICAvLyBzaW5jZSB3ZSBhcmUgbmF2aWdhdGluZyB0byB0aGUgc2FtZSBsb2NhdGlvbiwgd2UgZG9uJ3QgbmVlZCB0byBwaWNrIHRoZVxuICAgICAgICAgICAgLy8gcGFyYW1zIGxpa2Ugd2hlbiBgbmFtZWAgaXMgcHJvdmlkZWRcbiAgICAgICAgICAgIHBhcmFtcyA9IGFzc2lnbih7fSwgY3VycmVudExvY2F0aW9uLnBhcmFtcywgbG9jYXRpb24ucGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBtYXRjaGVyLnN0cmluZ2lmeShwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hdGNoZWQgPSBbXTtcbiAgICAgICAgbGV0IHBhcmVudE1hdGNoZXIgPSBtYXRjaGVyO1xuICAgICAgICB3aGlsZSAocGFyZW50TWF0Y2hlcikge1xuICAgICAgICAgICAgLy8gcmV2ZXJzZWQgb3JkZXIgc28gcGFyZW50cyBhcmUgYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICAgICAgbWF0Y2hlZC51bnNoaWZ0KHBhcmVudE1hdGNoZXIucmVjb3JkKTtcbiAgICAgICAgICAgIHBhcmVudE1hdGNoZXIgPSBwYXJlbnRNYXRjaGVyLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICBtYXRjaGVkLFxuICAgICAgICAgICAgbWV0YTogbWVyZ2VNZXRhRmllbGRzKG1hdGNoZWQpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBhZGQgaW5pdGlhbCByb3V0ZXNcbiAgICByb3V0ZXMuZm9yRWFjaChyb3V0ZSA9PiBhZGRSb3V0ZShyb3V0ZSkpO1xuICAgIHJldHVybiB7IGFkZFJvdXRlLCByZXNvbHZlLCByZW1vdmVSb3V0ZSwgZ2V0Um91dGVzLCBnZXRSZWNvcmRNYXRjaGVyIH07XG59XG5mdW5jdGlvbiBwYXJhbXNGcm9tTG9jYXRpb24ocGFyYW1zLCBrZXlzKSB7XG4gICAgY29uc3QgbmV3UGFyYW1zID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBpZiAoa2V5IGluIHBhcmFtcylcbiAgICAgICAgICAgIG5ld1BhcmFtc1trZXldID0gcGFyYW1zW2tleV07XG4gICAgfVxuICAgIHJldHVybiBuZXdQYXJhbXM7XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgYSBSb3V0ZVJlY29yZFJhdy4gQ3JlYXRlcyBhIGNvcHlcbiAqXG4gKiBAcGFyYW0gcmVjb3JkXG4gKiBAcmV0dXJucyB0aGUgbm9ybWFsaXplZCB2ZXJzaW9uXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJvdXRlUmVjb3JkKHJlY29yZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6IHJlY29yZC5wYXRoLFxuICAgICAgICByZWRpcmVjdDogcmVjb3JkLnJlZGlyZWN0LFxuICAgICAgICBuYW1lOiByZWNvcmQubmFtZSxcbiAgICAgICAgbWV0YTogcmVjb3JkLm1ldGEgfHwge30sXG4gICAgICAgIGFsaWFzT2Y6IHVuZGVmaW5lZCxcbiAgICAgICAgYmVmb3JlRW50ZXI6IHJlY29yZC5iZWZvcmVFbnRlcixcbiAgICAgICAgcHJvcHM6IG5vcm1hbGl6ZVJlY29yZFByb3BzKHJlY29yZCksXG4gICAgICAgIGNoaWxkcmVuOiByZWNvcmQuY2hpbGRyZW4gfHwgW10sXG4gICAgICAgIGluc3RhbmNlczoge30sXG4gICAgICAgIGxlYXZlR3VhcmRzOiBuZXcgU2V0KCksXG4gICAgICAgIHVwZGF0ZUd1YXJkczogbmV3IFNldCgpLFxuICAgICAgICBlbnRlckNhbGxiYWNrczoge30sXG4gICAgICAgIGNvbXBvbmVudHM6ICdjb21wb25lbnRzJyBpbiByZWNvcmRcbiAgICAgICAgICAgID8gcmVjb3JkLmNvbXBvbmVudHMgfHwgbnVsbFxuICAgICAgICAgICAgOiByZWNvcmQuY29tcG9uZW50ICYmIHsgZGVmYXVsdDogcmVjb3JkLmNvbXBvbmVudCB9LFxuICAgIH07XG59XG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgb3B0aW9uYWwgYHByb3BzYCBpbiBhIHJlY29yZCB0byBhbHdheXMgYmUgYW4gb2JqZWN0IHNpbWlsYXIgdG9cbiAqIGNvbXBvbmVudHMuIEFsc28gYWNjZXB0IGEgYm9vbGVhbiBmb3IgY29tcG9uZW50cy5cbiAqIEBwYXJhbSByZWNvcmRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUmVjb3JkUHJvcHMocmVjb3JkKSB7XG4gICAgY29uc3QgcHJvcHNPYmplY3QgPSB7fTtcbiAgICAvLyBwcm9wcyBkb2VzIG5vdCBleGlzdCBvbiByZWRpcmVjdCByZWNvcmRzLCBidXQgd2UgY2FuIHNldCBmYWxzZSBkaXJlY3RseVxuICAgIGNvbnN0IHByb3BzID0gcmVjb3JkLnByb3BzIHx8IGZhbHNlO1xuICAgIGlmICgnY29tcG9uZW50JyBpbiByZWNvcmQpIHtcbiAgICAgICAgcHJvcHNPYmplY3QuZGVmYXVsdCA9IHByb3BzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTk9URTogd2UgY291bGQgYWxzbyBhbGxvdyBhIGZ1bmN0aW9uIHRvIGJlIGFwcGxpZWQgdG8gZXZlcnkgY29tcG9uZW50LlxuICAgICAgICAvLyBXb3VsZCBuZWVkIHVzZXIgZmVlZGJhY2sgZm9yIHVzZSBjYXNlc1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gcmVjb3JkLmNvbXBvbmVudHMpXG4gICAgICAgICAgICBwcm9wc09iamVjdFtuYW1lXSA9IHR5cGVvZiBwcm9wcyA9PT0gJ29iamVjdCcgPyBwcm9wc1tuYW1lXSA6IHByb3BzO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcHNPYmplY3Q7XG59XG4vKipcbiAqIENoZWNrcyBpZiBhIHJlY29yZCBvciBhbnkgb2YgaXRzIHBhcmVudCBpcyBhbiBhbGlhc1xuICogQHBhcmFtIHJlY29yZFxuICovXG5mdW5jdGlvbiBpc0FsaWFzUmVjb3JkKHJlY29yZCkge1xuICAgIHdoaWxlIChyZWNvcmQpIHtcbiAgICAgICAgaWYgKHJlY29yZC5yZWNvcmQuYWxpYXNPZilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZWNvcmQgPSByZWNvcmQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIE1lcmdlIG1ldGEgZmllbGRzIG9mIGFuIGFycmF5IG9mIHJlY29yZHNcbiAqXG4gKiBAcGFyYW0gbWF0Y2hlZCAtIGFycmF5IG9mIG1hdGNoZWQgcmVjb3Jkc1xuICovXG5mdW5jdGlvbiBtZXJnZU1ldGFGaWVsZHMobWF0Y2hlZCkge1xuICAgIHJldHVybiBtYXRjaGVkLnJlZHVjZSgobWV0YSwgcmVjb3JkKSA9PiBhc3NpZ24obWV0YSwgcmVjb3JkLm1ldGEpLCB7fSk7XG59XG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMoZGVmYXVsdHMsIHBhcnRpYWxPcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgICAgIG9wdGlvbnNba2V5XSA9IGtleSBpbiBwYXJ0aWFsT3B0aW9ucyA/IHBhcnRpYWxPcHRpb25zW2tleV0gOiBkZWZhdWx0c1trZXldO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGlzU2FtZVBhcmFtKGEsIGIpIHtcbiAgICByZXR1cm4gKGEubmFtZSA9PT0gYi5uYW1lICYmXG4gICAgICAgIGEub3B0aW9uYWwgPT09IGIub3B0aW9uYWwgJiZcbiAgICAgICAgYS5yZXBlYXRhYmxlID09PSBiLnJlcGVhdGFibGUpO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHBhdGggYW5kIGl0cyBhbGlhcyBoYXZlIHRoZSBzYW1lIHJlcXVpcmVkIHBhcmFtc1xuICpcbiAqIEBwYXJhbSBhIC0gb3JpZ2luYWwgcmVjb3JkXG4gKiBAcGFyYW0gYiAtIGFsaWFzIHJlY29yZFxuICovXG5mdW5jdGlvbiBjaGVja1NhbWVQYXJhbXMoYSwgYikge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGEua2V5cykge1xuICAgICAgICBpZiAoIWtleS5vcHRpb25hbCAmJiAhYi5rZXlzLmZpbmQoaXNTYW1lUGFyYW0uYmluZChudWxsLCBrZXkpKSlcbiAgICAgICAgICAgIHJldHVybiB3YXJuKGBBbGlhcyBcIiR7Yi5yZWNvcmQucGF0aH1cIiBhbmQgdGhlIG9yaWdpbmFsIHJlY29yZDogXCIke2EucmVjb3JkLnBhdGh9XCIgbXVzdCBoYXZlIHRoZSBleGFjdCBzYW1lIHBhcmFtIG5hbWVkIFwiJHtrZXkubmFtZX1cImApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBiLmtleXMpIHtcbiAgICAgICAgaWYgKCFrZXkub3B0aW9uYWwgJiYgIWEua2V5cy5maW5kKGlzU2FtZVBhcmFtLmJpbmQobnVsbCwga2V5KSkpXG4gICAgICAgICAgICByZXR1cm4gd2FybihgQWxpYXMgXCIke2IucmVjb3JkLnBhdGh9XCIgYW5kIHRoZSBvcmlnaW5hbCByZWNvcmQ6IFwiJHthLnJlY29yZC5wYXRofVwiIG11c3QgaGF2ZSB0aGUgZXhhY3Qgc2FtZSBwYXJhbSBuYW1lZCBcIiR7a2V5Lm5hbWV9XCJgKTtcbiAgICB9XG59XG4vKipcbiAqIEEgcm91dGUgd2l0aCBhIG5hbWUgYW5kIGEgY2hpbGQgd2l0aCBhbiBlbXB0eSBwYXRoIHdpdGhvdXQgYSBuYW1lIHNob3VsZCB3YXJuIHdoZW4gYWRkaW5nIHRoZSByb3V0ZVxuICpcbiAqIEBwYXJhbSBtYWluTm9ybWFsaXplZFJlY29yZCAtIFJvdXRlUmVjb3JkTm9ybWFsaXplZFxuICogQHBhcmFtIHBhcmVudCAtIFJvdXRlUmVjb3JkTWF0Y2hlclxuICovXG5mdW5jdGlvbiBjaGVja0NoaWxkTWlzc2luZ05hbWVXaXRoRW1wdHlQYXRoKG1haW5Ob3JtYWxpemVkUmVjb3JkLCBwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50ICYmXG4gICAgICAgIHBhcmVudC5yZWNvcmQubmFtZSAmJlxuICAgICAgICAhbWFpbk5vcm1hbGl6ZWRSZWNvcmQubmFtZSAmJlxuICAgICAgICAhbWFpbk5vcm1hbGl6ZWRSZWNvcmQucGF0aCkge1xuICAgICAgICB3YXJuKGBUaGUgcm91dGUgbmFtZWQgXCIke1N0cmluZyhwYXJlbnQucmVjb3JkLm5hbWUpfVwiIGhhcyBhIGNoaWxkIHdpdGhvdXQgYSBuYW1lIGFuZCBhbiBlbXB0eSBwYXRoLiBVc2luZyB0aGF0IG5hbWUgd29uJ3QgcmVuZGVyIHRoZSBlbXB0eSBwYXRoIGNoaWxkIHNvIHlvdSBwcm9iYWJseSB3YW50IHRvIG1vdmUgdGhlIG5hbWUgdG8gdGhlIGNoaWxkIGluc3RlYWQuIElmIHRoaXMgaXMgaW50ZW50aW9uYWwsIGFkZCBhIG5hbWUgdG8gdGhlIGNoaWxkIHJvdXRlIHRvIHJlbW92ZSB0aGUgd2FybmluZy5gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja01pc3NpbmdQYXJhbXNJbkFic29sdXRlUGF0aChyZWNvcmQsIHBhcmVudCkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHBhcmVudC5rZXlzKSB7XG4gICAgICAgIGlmICghcmVjb3JkLmtleXMuZmluZChpc1NhbWVQYXJhbS5iaW5kKG51bGwsIGtleSkpKVxuICAgICAgICAgICAgcmV0dXJuIHdhcm4oYEFic29sdXRlIHBhdGggXCIke3JlY29yZC5yZWNvcmQucGF0aH1cIiBtdXN0IGhhdmUgdGhlIGV4YWN0IHNhbWUgcGFyYW0gbmFtZWQgXCIke2tleS5uYW1lfVwiIGFzIGl0cyBwYXJlbnQgXCIke3BhcmVudC5yZWNvcmQucGF0aH1cIi5gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1JlY29yZENoaWxkT2YocmVjb3JkLCBwYXJlbnQpIHtcbiAgICByZXR1cm4gcGFyZW50LmNoaWxkcmVuLnNvbWUoY2hpbGQgPT4gY2hpbGQgPT09IHJlY29yZCB8fCBpc1JlY29yZENoaWxkT2YocmVjb3JkLCBjaGlsZCkpO1xufVxuXG4vKipcbiAqIEVuY29kaW5nIFJ1bGVzIOKQoyA9IFNwYWNlIFBhdGg6IOKQoyBcIiA8ID4gIyA/IHsgfSBRdWVyeTog4pCjIFwiIDwgPiAjICYgPSBIYXNoOiDikKMgXCJcbiAqIDwgPiBgXG4gKlxuICogT24gdG9wIG9mIHRoYXQsIHRoZSBSRkMzOTg2IChodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTIuMilcbiAqIGRlZmluZXMgc29tZSBleHRyYSBjaGFyYWN0ZXJzIHRvIGJlIGVuY29kZWQuIE1vc3QgYnJvd3NlcnMgZG8gbm90IGVuY29kZSB0aGVtXG4gKiBpbiBlbmNvZGVVUkkgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy91cmwvaXNzdWVzLzM2OSwgc28gaXQgbWF5IGJlIHNhZmVyIHRvXG4gKiBhbHNvIGVuY29kZSBgIScoKSpgLiBMZWF2aW5nIHVuLWVuY29kZWQgb25seSBBU0NJSSBhbHBoYW51bWVyaWMoYGEtekEtWjAtOWApXG4gKiBwbHVzIGAtLl9+YC4gVGhpcyBleHRyYSBzYWZldHkgc2hvdWxkIGJlIGFwcGxpZWQgdG8gcXVlcnkgYnkgcGF0Y2hpbmcgdGhlXG4gKiBzdHJpbmcgcmV0dXJuZWQgYnkgZW5jb2RlVVJJQ29tcG9uZW50IGVuY29kZVVSSSBhbHNvIGVuY29kZXMgYFtcXF1eYC4gYFxcYFxuICogc2hvdWxkIGJlIGVuY29kZWQgdG8gYXZvaWQgYW1iaWd1aXR5LiBCcm93c2VycyAoSUUsIEZGLCBDKSB0cmFuc2Zvcm0gYSBgXFxgXG4gKiBpbnRvIGEgYC9gIGlmIGRpcmVjdGx5IHR5cGVkIGluLiBUaGUgX2JhY2t0aWNrXyAoYGBgYGApIHNob3VsZCBhbHNvIGJlXG4gKiBlbmNvZGVkIGV2ZXJ5d2hlcmUgYmVjYXVzZSBzb21lIGJyb3dzZXJzIGxpa2UgRkYgZW5jb2RlIGl0IHdoZW4gZGlyZWN0bHlcbiAqIHdyaXR0ZW4gd2hpbGUgb3RoZXJzIGRvbid0LiBTYWZhcmkgYW5kIElFIGRvbid0IGVuY29kZSBgYFwiPD57fWBgYCBpbiBoYXNoLlxuICovXG4vLyBjb25zdCBFWFRSQV9SRVNFUlZFRF9SRSA9IC9bIScoKSpdL2dcbi8vIGNvbnN0IGVuY29kZVJlc2VydmVkUmVwbGFjZXIgPSAoYzogc3RyaW5nKSA9PiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpXG5jb25zdCBIQVNIX1JFID0gLyMvZzsgLy8gJTIzXG5jb25zdCBBTVBFUlNBTkRfUkUgPSAvJi9nOyAvLyAlMjZcbmNvbnN0IFNMQVNIX1JFID0gL1xcLy9nOyAvLyAlMkZcbmNvbnN0IEVRVUFMX1JFID0gLz0vZzsgLy8gJTNEXG5jb25zdCBJTV9SRSA9IC9cXD8vZzsgLy8gJTNGXG5jb25zdCBQTFVTX1JFID0gL1xcKy9nOyAvLyAlMkJcbi8qKlxuICogTk9URTogSXQncyBub3QgY2xlYXIgdG8gbWUgaWYgd2Ugc2hvdWxkIGVuY29kZSB0aGUgKyBzeW1ib2wgaW4gcXVlcmllcywgaXRcbiAqIHNlZW1zIHRvIGJlIGxlc3MgZmxleGlibGUgdGhhbiBub3QgZG9pbmcgc28gYW5kIEkgY2FuJ3QgZmluZCBvdXQgdGhlIGxlZ2FjeVxuICogc3lzdGVtcyByZXF1aXJpbmcgdGhpcyBmb3IgcmVndWxhciByZXF1ZXN0cyBsaWtlIHRleHQvaHRtbC4gSW4gdGhlIHN0YW5kYXJkLFxuICogdGhlIGVuY29kaW5nIG9mIHRoZSBwbHVzIGNoYXJhY3RlciBpcyBvbmx5IG1lbnRpb25lZCBmb3JcbiAqIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogKGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsZW5jb2RlZC1wYXJzaW5nKSBhbmQgbW9zdCBicm93c2VycyBzZWVtcyBsb1xuICogbGVhdmUgdGhlIHBsdXMgY2hhcmFjdGVyIGFzIGlzIGluIHF1ZXJpZXMuIFRvIGJlIG1vcmUgZmxleGlibGUsIHdlIGFsbG93IHRoZVxuICogcGx1cyBjaGFyYWN0ZXIgb24gdGhlIHF1ZXJ5LCBidXQgaXQgY2FuIGFsc28gYmUgbWFudWFsbHkgZW5jb2RlZCBieSB0aGUgdXNlci5cbiAqXG4gKiBSZXNvdXJjZXM6XG4gKiAtIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsZW5jb2RlZC1wYXJzaW5nXG4gKiAtIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE2MzQyNzEvdXJsLWVuY29kaW5nLXRoZS1zcGFjZS1jaGFyYWN0ZXItb3ItMjBcbiAqL1xuY29uc3QgRU5DX0JSQUNLRVRfT1BFTl9SRSA9IC8lNUIvZzsgLy8gW1xuY29uc3QgRU5DX0JSQUNLRVRfQ0xPU0VfUkUgPSAvJTVEL2c7IC8vIF1cbmNvbnN0IEVOQ19DQVJFVF9SRSA9IC8lNUUvZzsgLy8gXlxuY29uc3QgRU5DX0JBQ0tUSUNLX1JFID0gLyU2MC9nOyAvLyBgXG5jb25zdCBFTkNfQ1VSTFlfT1BFTl9SRSA9IC8lN0IvZzsgLy8ge1xuY29uc3QgRU5DX1BJUEVfUkUgPSAvJTdDL2c7IC8vIHxcbmNvbnN0IEVOQ19DVVJMWV9DTE9TRV9SRSA9IC8lN0QvZzsgLy8gfVxuY29uc3QgRU5DX1NQQUNFX1JFID0gLyUyMC9nOyAvLyB9XG4vKipcbiAqIEVuY29kZSBjaGFyYWN0ZXJzIHRoYXQgbmVlZCB0byBiZSBlbmNvZGVkIG9uIHRoZSBwYXRoLCBzZWFyY2ggYW5kIGhhc2hcbiAqIHNlY3Rpb25zIG9mIHRoZSBVUkwuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gdGV4dCAtIHN0cmluZyB0byBlbmNvZGVcbiAqIEByZXR1cm5zIGVuY29kZWQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGNvbW1vbkVuY29kZSh0ZXh0KSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSSgnJyArIHRleHQpXG4gICAgICAgIC5yZXBsYWNlKEVOQ19QSVBFX1JFLCAnfCcpXG4gICAgICAgIC5yZXBsYWNlKEVOQ19CUkFDS0VUX09QRU5fUkUsICdbJylcbiAgICAgICAgLnJlcGxhY2UoRU5DX0JSQUNLRVRfQ0xPU0VfUkUsICddJyk7XG59XG4vKipcbiAqIEVuY29kZSBjaGFyYWN0ZXJzIHRoYXQgbmVlZCB0byBiZSBlbmNvZGVkIG9uIHRoZSBoYXNoIHNlY3Rpb24gb2YgdGhlIFVSTC5cbiAqXG4gKiBAcGFyYW0gdGV4dCAtIHN0cmluZyB0byBlbmNvZGVcbiAqIEByZXR1cm5zIGVuY29kZWQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUhhc2godGV4dCkge1xuICAgIHJldHVybiBjb21tb25FbmNvZGUodGV4dClcbiAgICAgICAgLnJlcGxhY2UoRU5DX0NVUkxZX09QRU5fUkUsICd7JylcbiAgICAgICAgLnJlcGxhY2UoRU5DX0NVUkxZX0NMT1NFX1JFLCAnfScpXG4gICAgICAgIC5yZXBsYWNlKEVOQ19DQVJFVF9SRSwgJ14nKTtcbn1cbi8qKlxuICogRW5jb2RlIGNoYXJhY3RlcnMgdGhhdCBuZWVkIHRvIGJlIGVuY29kZWQgcXVlcnkgdmFsdWVzIG9uIHRoZSBxdWVyeVxuICogc2VjdGlvbiBvZiB0aGUgVVJMLlxuICpcbiAqIEBwYXJhbSB0ZXh0IC0gc3RyaW5nIHRvIGVuY29kZVxuICogQHJldHVybnMgZW5jb2RlZCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZW5jb2RlUXVlcnlWYWx1ZSh0ZXh0KSB7XG4gICAgcmV0dXJuIChjb21tb25FbmNvZGUodGV4dClcbiAgICAgICAgLy8gRW5jb2RlIHRoZSBzcGFjZSBhcyArLCBlbmNvZGUgdGhlICsgdG8gZGlmZmVyZW50aWF0ZSBpdCBmcm9tIHRoZSBzcGFjZVxuICAgICAgICAucmVwbGFjZShQTFVTX1JFLCAnJTJCJylcbiAgICAgICAgLnJlcGxhY2UoRU5DX1NQQUNFX1JFLCAnKycpXG4gICAgICAgIC5yZXBsYWNlKEhBU0hfUkUsICclMjMnKVxuICAgICAgICAucmVwbGFjZShBTVBFUlNBTkRfUkUsICclMjYnKVxuICAgICAgICAucmVwbGFjZShFTkNfQkFDS1RJQ0tfUkUsICdgJylcbiAgICAgICAgLnJlcGxhY2UoRU5DX0NVUkxZX09QRU5fUkUsICd7JylcbiAgICAgICAgLnJlcGxhY2UoRU5DX0NVUkxZX0NMT1NFX1JFLCAnfScpXG4gICAgICAgIC5yZXBsYWNlKEVOQ19DQVJFVF9SRSwgJ14nKSk7XG59XG4vKipcbiAqIExpa2UgYGVuY29kZVF1ZXJ5VmFsdWVgIGJ1dCBhbHNvIGVuY29kZXMgdGhlIGA9YCBjaGFyYWN0ZXIuXG4gKlxuICogQHBhcmFtIHRleHQgLSBzdHJpbmcgdG8gZW5jb2RlXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVF1ZXJ5S2V5KHRleHQpIHtcbiAgICByZXR1cm4gZW5jb2RlUXVlcnlWYWx1ZSh0ZXh0KS5yZXBsYWNlKEVRVUFMX1JFLCAnJTNEJyk7XG59XG4vKipcbiAqIEVuY29kZSBjaGFyYWN0ZXJzIHRoYXQgbmVlZCB0byBiZSBlbmNvZGVkIG9uIHRoZSBwYXRoIHNlY3Rpb24gb2YgdGhlIFVSTC5cbiAqXG4gKiBAcGFyYW0gdGV4dCAtIHN0cmluZyB0byBlbmNvZGVcbiAqIEByZXR1cm5zIGVuY29kZWQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVBhdGgodGV4dCkge1xuICAgIHJldHVybiBjb21tb25FbmNvZGUodGV4dCkucmVwbGFjZShIQVNIX1JFLCAnJTIzJykucmVwbGFjZShJTV9SRSwgJyUzRicpO1xufVxuLyoqXG4gKiBFbmNvZGUgY2hhcmFjdGVycyB0aGF0IG5lZWQgdG8gYmUgZW5jb2RlZCBvbiB0aGUgcGF0aCBzZWN0aW9uIG9mIHRoZSBVUkwgYXMgYVxuICogcGFyYW0uIFRoaXMgZnVuY3Rpb24gZW5jb2RlcyBldmVyeXRoaW5nIHtAbGluayBlbmNvZGVQYXRofSBkb2VzIHBsdXMgdGhlXG4gKiBzbGFzaCAoYC9gKSBjaGFyYWN0ZXIuIElmIGB0ZXh0YCBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAsIHJldHVybnMgYW4gZW1wdHlcbiAqIHN0cmluZyBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB0ZXh0IC0gc3RyaW5nIHRvIGVuY29kZVxuICogQHJldHVybnMgZW5jb2RlZCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZW5jb2RlUGFyYW0odGV4dCkge1xuICAgIHJldHVybiB0ZXh0ID09IG51bGwgPyAnJyA6IGVuY29kZVBhdGgodGV4dCkucmVwbGFjZShTTEFTSF9SRSwgJyUyRicpO1xufVxuLyoqXG4gKiBEZWNvZGUgdGV4dCB1c2luZyBgZGVjb2RlVVJJQ29tcG9uZW50YC4gUmV0dXJucyB0aGUgb3JpZ2luYWwgdGV4dCBpZiBpdFxuICogZmFpbHMuXG4gKlxuICogQHBhcmFtIHRleHQgLSBzdHJpbmcgdG8gZGVjb2RlXG4gKiBAcmV0dXJucyBkZWNvZGVkIHN0cmluZ1xuICovXG5mdW5jdGlvbiBkZWNvZGUodGV4dCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoJycgKyB0ZXh0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgRXJyb3IgZGVjb2RpbmcgXCIke3RleHR9XCIuIFVzaW5nIG9yaWdpbmFsIHZhbHVlYCk7XG4gICAgfVxuICAgIHJldHVybiAnJyArIHRleHQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIHF1ZXJ5U3RyaW5nIGludG8gYSB7QGxpbmsgTG9jYXRpb25RdWVyeX0gb2JqZWN0LiBBY2NlcHQgYm90aCwgYVxuICogdmVyc2lvbiB3aXRoIHRoZSBsZWFkaW5nIGA/YCBhbmQgd2l0aG91dCBTaG91bGQgd29yayBhcyBVUkxTZWFyY2hQYXJhbXNcblxuICogQGludGVybmFsXG4gKlxuICogQHBhcmFtIHNlYXJjaCAtIHNlYXJjaCBzdHJpbmcgdG8gcGFyc2VcbiAqIEByZXR1cm5zIGEgcXVlcnkgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHBhcnNlUXVlcnkoc2VhcmNoKSB7XG4gICAgY29uc3QgcXVlcnkgPSB7fTtcbiAgICAvLyBhdm9pZCBjcmVhdGluZyBhbiBvYmplY3Qgd2l0aCBhbiBlbXB0eSBrZXkgYW5kIGVtcHR5IHZhbHVlXG4gICAgLy8gYmVjYXVzZSBvZiBzcGxpdCgnJicpXG4gICAgaWYgKHNlYXJjaCA9PT0gJycgfHwgc2VhcmNoID09PSAnPycpXG4gICAgICAgIHJldHVybiBxdWVyeTtcbiAgICBjb25zdCBoYXNMZWFkaW5nSU0gPSBzZWFyY2hbMF0gPT09ICc/JztcbiAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSAoaGFzTGVhZGluZ0lNID8gc2VhcmNoLnNsaWNlKDEpIDogc2VhcmNoKS5zcGxpdCgnJicpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VhcmNoUGFyYW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIC8vIHByZSBkZWNvZGUgdGhlICsgaW50byBzcGFjZVxuICAgICAgICBjb25zdCBzZWFyY2hQYXJhbSA9IHNlYXJjaFBhcmFtc1tpXS5yZXBsYWNlKFBMVVNfUkUsICcgJyk7XG4gICAgICAgIC8vIGFsbG93IHRoZSA9IGNoYXJhY3RlclxuICAgICAgICBjb25zdCBlcVBvcyA9IHNlYXJjaFBhcmFtLmluZGV4T2YoJz0nKTtcbiAgICAgICAgY29uc3Qga2V5ID0gZGVjb2RlKGVxUG9zIDwgMCA/IHNlYXJjaFBhcmFtIDogc2VhcmNoUGFyYW0uc2xpY2UoMCwgZXFQb3MpKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBlcVBvcyA8IDAgPyBudWxsIDogZGVjb2RlKHNlYXJjaFBhcmFtLnNsaWNlKGVxUG9zICsgMSkpO1xuICAgICAgICBpZiAoa2V5IGluIHF1ZXJ5KSB7XG4gICAgICAgICAgICAvLyBhbiBleHRyYSB2YXJpYWJsZSBmb3IgdHMgdHlwZXNcbiAgICAgICAgICAgIGxldCBjdXJyZW50VmFsdWUgPSBxdWVyeVtrZXldO1xuICAgICAgICAgICAgaWYgKCFpc0FycmF5KGN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBxdWVyeVtrZXldID0gW2N1cnJlbnRWYWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50VmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxdWVyeVtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5O1xufVxuLyoqXG4gKiBTdHJpbmdpZmllcyBhIHtAbGluayBMb2NhdGlvblF1ZXJ5UmF3fSBvYmplY3QuIExpa2UgYFVSTFNlYXJjaFBhcmFtc2AsIGl0XG4gKiBkb2Vzbid0IHByZXBlbmQgYSBgP2BcbiAqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBAcGFyYW0gcXVlcnkgLSBxdWVyeSBvYmplY3QgdG8gc3RyaW5naWZ5XG4gKiBAcmV0dXJucyBzdHJpbmcgdmVyc2lvbiBvZiB0aGUgcXVlcnkgd2l0aG91dCB0aGUgbGVhZGluZyBgP2BcbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5UXVlcnkocXVlcnkpIHtcbiAgICBsZXQgc2VhcmNoID0gJyc7XG4gICAgZm9yIChsZXQga2V5IGluIHF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcXVlcnlba2V5XTtcbiAgICAgICAga2V5ID0gZW5jb2RlUXVlcnlLZXkoa2V5KTtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgbnVsbCBhZGRzIHRoZSB2YWx1ZVxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZWFyY2ggKz0gKHNlYXJjaC5sZW5ndGggPyAnJicgOiAnJykgKyBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBrZWVwIG51bGwgdmFsdWVzXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGlzQXJyYXkodmFsdWUpXG4gICAgICAgICAgICA/IHZhbHVlLm1hcCh2ID0+IHYgJiYgZW5jb2RlUXVlcnlWYWx1ZSh2KSlcbiAgICAgICAgICAgIDogW3ZhbHVlICYmIGVuY29kZVF1ZXJ5VmFsdWUodmFsdWUpXTtcbiAgICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgLy8gc2tpcCB1bmRlZmluZWQgdmFsdWVzIGluIGFycmF5cyBhcyBpZiB0aGV5IHdlcmUgbm90IHByZXNlbnRcbiAgICAgICAgICAgIC8vIHNtYWxsZXIgY29kZSB0aGFuIHVzaW5nIGZpbHRlclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGFwcGVuZCAmIHdpdGggbm9uLWVtcHR5IHNlYXJjaFxuICAgICAgICAgICAgICAgIHNlYXJjaCArPSAoc2VhcmNoLmxlbmd0aCA/ICcmJyA6ICcnKSArIGtleTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoICs9ICc9JyArIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNlYXJjaDtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyBhIHtAbGluayBMb2NhdGlvblF1ZXJ5UmF3fSBpbnRvIGEge0BsaW5rIExvY2F0aW9uUXVlcnl9IGJ5IGNhc3RpbmdcbiAqIG51bWJlcnMgaW50byBzdHJpbmdzLCByZW1vdmluZyBrZXlzIHdpdGggYW4gdW5kZWZpbmVkIHZhbHVlIGFuZCByZXBsYWNpbmdcbiAqIHVuZGVmaW5lZCB3aXRoIG51bGwgaW4gYXJyYXlzXG4gKlxuICogQHBhcmFtIHF1ZXJ5IC0gcXVlcnkgb2JqZWN0IHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMgYSBub3JtYWxpemVkIHF1ZXJ5IG9iamVjdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVRdWVyeShxdWVyeSkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRRdWVyeSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcXVlcnlba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRRdWVyeVtrZXldID0gaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICAgICAgICA/IHZhbHVlLm1hcCh2ID0+ICh2ID09IG51bGwgPyBudWxsIDogJycgKyB2KSlcbiAgICAgICAgICAgICAgICA6IHZhbHVlID09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6ICcnICsgdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRRdWVyeTtcbn1cblxuLyoqXG4gKiBSb3V0ZVJlY29yZCBiZWluZyByZW5kZXJlZCBieSB0aGUgY2xvc2VzdCBhbmNlc3RvciBSb3V0ZXIgVmlldy4gVXNlZCBmb3JcbiAqIGBvbkJlZm9yZVJvdXRlVXBkYXRlYCBhbmQgYG9uQmVmb3JlUm91dGVMZWF2ZWAuIHJ2bG0gc3RhbmRzIGZvciBSb3V0ZXIgVmlld1xuICogTG9jYXRpb24gTWF0Y2hlZFxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBtYXRjaGVkUm91dGVLZXkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ3JvdXRlciB2aWV3IGxvY2F0aW9uIG1hdGNoZWQnIDogJycpO1xuLyoqXG4gKiBBbGxvd3Mgb3ZlcnJpZGluZyB0aGUgcm91dGVyIHZpZXcgZGVwdGggdG8gY29udHJvbCB3aGljaCBjb21wb25lbnQgaW5cbiAqIGBtYXRjaGVkYCBpcyByZW5kZXJlZC4gcnZkIHN0YW5kcyBmb3IgUm91dGVyIFZpZXcgRGVwdGhcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3Qgdmlld0RlcHRoS2V5ID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdyb3V0ZXIgdmlldyBkZXB0aCcgOiAnJyk7XG4vKipcbiAqIEFsbG93cyBvdmVycmlkaW5nIHRoZSByb3V0ZXIgaW5zdGFuY2UgcmV0dXJuZWQgYnkgYHVzZVJvdXRlcmAgaW4gdGVzdHMuIHJcbiAqIHN0YW5kcyBmb3Igcm91dGVyXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IHJvdXRlcktleSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAncm91dGVyJyA6ICcnKTtcbi8qKlxuICogQWxsb3dzIG92ZXJyaWRpbmcgdGhlIGN1cnJlbnQgcm91dGUgcmV0dXJuZWQgYnkgYHVzZVJvdXRlYCBpbiB0ZXN0cy4gcmxcbiAqIHN0YW5kcyBmb3Igcm91dGUgbG9jYXRpb25cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3Qgcm91dGVMb2NhdGlvbktleSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAncm91dGUgbG9jYXRpb24nIDogJycpO1xuLyoqXG4gKiBBbGxvd3Mgb3ZlcnJpZGluZyB0aGUgY3VycmVudCByb3V0ZSB1c2VkIGJ5IHJvdXRlci12aWV3LiBJbnRlcm5hbGx5IHRoaXMgaXNcbiAqIHVzZWQgd2hlbiB0aGUgYHJvdXRlYCBwcm9wIGlzIHBhc3NlZC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3Qgcm91dGVyVmlld0xvY2F0aW9uS2V5ID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdyb3V0ZXIgdmlldyBsb2NhdGlvbicgOiAnJyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbGlzdCBvZiBjYWxsYmFja3MgdGhhdCBjYW4gYmUgcmVzZXQuIFVzZWQgdG8gY3JlYXRlIGJlZm9yZSBhbmQgYWZ0ZXIgbmF2aWdhdGlvbiBndWFyZHMgbGlzdFxuICovXG5mdW5jdGlvbiB1c2VDYWxsYmFja3MoKSB7XG4gICAgbGV0IGhhbmRsZXJzID0gW107XG4gICAgZnVuY3Rpb24gYWRkKGhhbmRsZXIpIHtcbiAgICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBoYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpO1xuICAgICAgICAgICAgaWYgKGkgPiAtMSlcbiAgICAgICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICBoYW5kbGVycyA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhZGQsXG4gICAgICAgIGxpc3Q6ICgpID0+IGhhbmRsZXJzLnNsaWNlKCksXG4gICAgICAgIHJlc2V0LFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyR3VhcmQocmVjb3JkLCBuYW1lLCBndWFyZCkge1xuICAgIGNvbnN0IHJlbW92ZUZyb21MaXN0ID0gKCkgPT4ge1xuICAgICAgICByZWNvcmRbbmFtZV0uZGVsZXRlKGd1YXJkKTtcbiAgICB9O1xuICAgIG9uVW5tb3VudGVkKHJlbW92ZUZyb21MaXN0KTtcbiAgICBvbkRlYWN0aXZhdGVkKHJlbW92ZUZyb21MaXN0KTtcbiAgICBvbkFjdGl2YXRlZCgoKSA9PiB7XG4gICAgICAgIHJlY29yZFtuYW1lXS5hZGQoZ3VhcmQpO1xuICAgIH0pO1xuICAgIHJlY29yZFtuYW1lXS5hZGQoZ3VhcmQpO1xufVxuLyoqXG4gKiBBZGQgYSBuYXZpZ2F0aW9uIGd1YXJkIHRoYXQgdHJpZ2dlcnMgd2hlbmV2ZXIgdGhlIGNvbXBvbmVudCBmb3IgdGhlIGN1cnJlbnRcbiAqIGxvY2F0aW9uIGlzIGFib3V0IHRvIGJlIGxlZnQuIFNpbWlsYXIgdG8ge0BsaW5rIGJlZm9yZVJvdXRlTGVhdmV9IGJ1dCBjYW4gYmVcbiAqIHVzZWQgaW4gYW55IGNvbXBvbmVudC4gVGhlIGd1YXJkIGlzIHJlbW92ZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAqXG4gKiBAcGFyYW0gbGVhdmVHdWFyZCAtIHtAbGluayBOYXZpZ2F0aW9uR3VhcmR9XG4gKi9cbmZ1bmN0aW9uIG9uQmVmb3JlUm91dGVMZWF2ZShsZWF2ZUd1YXJkKSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZ2V0Q3VycmVudEluc3RhbmNlKCkpIHtcbiAgICAgICAgd2FybignZ2V0Q3VycmVudEluc3RhbmNlKCkgcmV0dXJuZWQgbnVsbC4gb25CZWZvcmVSb3V0ZUxlYXZlKCkgbXVzdCBiZSBjYWxsZWQgYXQgdGhlIHRvcCBvZiBhIHNldHVwIGZ1bmN0aW9uJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYWN0aXZlUmVjb3JkID0gaW5qZWN0KG1hdGNoZWRSb3V0ZUtleSwgXG4gICAgLy8gdG8gYXZvaWQgd2FybmluZ1xuICAgIHt9KS52YWx1ZTtcbiAgICBpZiAoIWFjdGl2ZVJlY29yZCkge1xuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgIHdhcm4oJ05vIGFjdGl2ZSByb3V0ZSByZWNvcmQgd2FzIGZvdW5kIHdoZW4gY2FsbGluZyBgb25CZWZvcmVSb3V0ZUxlYXZlKClgLiBNYWtlIHN1cmUgeW91IGNhbGwgdGhpcyBmdW5jdGlvbiBpbnNpZGUgYSBjb21wb25lbnQgY2hpbGQgb2YgPHJvdXRlci12aWV3Pi4gTWF5YmUgeW91IGNhbGxlZCBpdCBpbnNpZGUgb2YgQXBwLnZ1ZT8nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdpc3Rlckd1YXJkKGFjdGl2ZVJlY29yZCwgJ2xlYXZlR3VhcmRzJywgbGVhdmVHdWFyZCk7XG59XG4vKipcbiAqIEFkZCBhIG5hdmlnYXRpb24gZ3VhcmQgdGhhdCB0cmlnZ2VycyB3aGVuZXZlciB0aGUgY3VycmVudCBsb2NhdGlvbiBpcyBhYm91dFxuICogdG8gYmUgdXBkYXRlZC4gU2ltaWxhciB0byB7QGxpbmsgYmVmb3JlUm91dGVVcGRhdGV9IGJ1dCBjYW4gYmUgdXNlZCBpbiBhbnlcbiAqIGNvbXBvbmVudC4gVGhlIGd1YXJkIGlzIHJlbW92ZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAqXG4gKiBAcGFyYW0gdXBkYXRlR3VhcmQgLSB7QGxpbmsgTmF2aWdhdGlvbkd1YXJkfVxuICovXG5mdW5jdGlvbiBvbkJlZm9yZVJvdXRlVXBkYXRlKHVwZGF0ZUd1YXJkKSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZ2V0Q3VycmVudEluc3RhbmNlKCkpIHtcbiAgICAgICAgd2FybignZ2V0Q3VycmVudEluc3RhbmNlKCkgcmV0dXJuZWQgbnVsbC4gb25CZWZvcmVSb3V0ZVVwZGF0ZSgpIG11c3QgYmUgY2FsbGVkIGF0IHRoZSB0b3Agb2YgYSBzZXR1cCBmdW5jdGlvbicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFjdGl2ZVJlY29yZCA9IGluamVjdChtYXRjaGVkUm91dGVLZXksIFxuICAgIC8vIHRvIGF2b2lkIHdhcm5pbmdcbiAgICB7fSkudmFsdWU7XG4gICAgaWYgKCFhY3RpdmVSZWNvcmQpIHtcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICB3YXJuKCdObyBhY3RpdmUgcm91dGUgcmVjb3JkIHdhcyBmb3VuZCB3aGVuIGNhbGxpbmcgYG9uQmVmb3JlUm91dGVVcGRhdGUoKWAuIE1ha2Ugc3VyZSB5b3UgY2FsbCB0aGlzIGZ1bmN0aW9uIGluc2lkZSBhIGNvbXBvbmVudCBjaGlsZCBvZiA8cm91dGVyLXZpZXc+LiBNYXliZSB5b3UgY2FsbGVkIGl0IGluc2lkZSBvZiBBcHAudnVlPycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlZ2lzdGVyR3VhcmQoYWN0aXZlUmVjb3JkLCAndXBkYXRlR3VhcmRzJywgdXBkYXRlR3VhcmQpO1xufVxuZnVuY3Rpb24gZ3VhcmRUb1Byb21pc2VGbihndWFyZCwgdG8sIGZyb20sIHJlY29yZCwgbmFtZSkge1xuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIGVudGVyQ2FsbGJhY2tBcnJheSB0byBwcmV2ZW50IHB1c2hpbmcgY2FsbGJhY2tzIGlmIGEgbmV3IG5hdmlnYXRpb24gdG9vayBwbGFjZVxuICAgIGNvbnN0IGVudGVyQ2FsbGJhY2tBcnJheSA9IHJlY29yZCAmJlxuICAgICAgICAvLyBuYW1lIGlzIGRlZmluZWQgaWYgcmVjb3JkIGlzIGJlY2F1c2Ugb2YgdGhlIGZ1bmN0aW9uIG92ZXJsb2FkXG4gICAgICAgIChyZWNvcmQuZW50ZXJDYWxsYmFja3NbbmFtZV0gPSByZWNvcmQuZW50ZXJDYWxsYmFja3NbbmFtZV0gfHwgW10pO1xuICAgIHJldHVybiAoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHQgPSAodmFsaWQpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoY3JlYXRlUm91dGVyRXJyb3IoNCAvKiBFcnJvclR5cGVzLk5BVklHQVRJT05fQUJPUlRFRCAqLywge1xuICAgICAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWxpZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHZhbGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUm91dGVMb2NhdGlvbih2YWxpZCkpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoY3JlYXRlUm91dGVyRXJyb3IoMiAvKiBFcnJvclR5cGVzLk5BVklHQVRJT05fR1VBUkRfUkVESVJFQ1QgKi8sIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogdG8sXG4gICAgICAgICAgICAgICAgICAgIHRvOiB2YWxpZCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50ZXJDYWxsYmFja0FycmF5ICYmXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIGVudGVyQ2FsbGJhY2tBcnJheSBpcyB0cnV0aHksIGJvdGggcmVjb3JkIGFuZCBuYW1lIGFsc28gYXJlXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZC5lbnRlckNhbGxiYWNrc1tuYW1lXSA9PT0gZW50ZXJDYWxsYmFja0FycmF5ICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB2YWxpZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlbnRlckNhbGxiYWNrQXJyYXkucHVzaCh2YWxpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gd3JhcHBpbmcgd2l0aCBQcm9taXNlLnJlc29sdmUgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBib3RoIGFzeW5jIGFuZCBzeW5jIGd1YXJkc1xuICAgICAgICBjb25zdCBndWFyZFJldHVybiA9IGd1YXJkLmNhbGwocmVjb3JkICYmIHJlY29yZC5pbnN0YW5jZXNbbmFtZV0sIHRvLCBmcm9tLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBjYW5Pbmx5QmVDYWxsZWRPbmNlKG5leHQsIHRvLCBmcm9tKSA6IG5leHQpO1xuICAgICAgICBsZXQgZ3VhcmRDYWxsID0gUHJvbWlzZS5yZXNvbHZlKGd1YXJkUmV0dXJuKTtcbiAgICAgICAgaWYgKGd1YXJkLmxlbmd0aCA8IDMpXG4gICAgICAgICAgICBndWFyZENhbGwgPSBndWFyZENhbGwudGhlbihuZXh0KTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBndWFyZC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYFRoZSBcIm5leHRcIiBjYWxsYmFjayB3YXMgbmV2ZXIgY2FsbGVkIGluc2lkZSBvZiAke2d1YXJkLm5hbWUgPyAnXCInICsgZ3VhcmQubmFtZSArICdcIicgOiAnJ306XFxuJHtndWFyZC50b1N0cmluZygpfVxcbi4gSWYgeW91IGFyZSByZXR1cm5pbmcgYSB2YWx1ZSBpbnN0ZWFkIG9mIGNhbGxpbmcgXCJuZXh0XCIsIG1ha2Ugc3VyZSB0byByZW1vdmUgdGhlIFwibmV4dFwiIHBhcmFtZXRlciBmcm9tIHlvdXIgZnVuY3Rpb24uYDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZ3VhcmRSZXR1cm4gPT09ICdvYmplY3QnICYmICd0aGVuJyBpbiBndWFyZFJldHVybikge1xuICAgICAgICAgICAgICAgIGd1YXJkQ2FsbCA9IGd1YXJkQ2FsbC50aGVuKHJlc29sdmVkVmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBfY2FsbGVkIGlzIGFkZGVkIGF0IGNhbk9ubHlCZUNhbGxlZE9uY2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0Ll9jYWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdJbnZhbGlkIG5hdmlnYXRpb24gZ3VhcmQnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkVmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChndWFyZFJldHVybiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogX2NhbGxlZCBpcyBhZGRlZCBhdCBjYW5Pbmx5QmVDYWxsZWRPbmNlXG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0Ll9jYWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignSW52YWxpZCBuYXZpZ2F0aW9uIGd1YXJkJykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGd1YXJkQ2FsbC5jYXRjaChlcnIgPT4gcmVqZWN0KGVycikpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY2FuT25seUJlQ2FsbGVkT25jZShuZXh0LCB0bywgZnJvbSkge1xuICAgIGxldCBjYWxsZWQgPSAwO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChjYWxsZWQrKyA9PT0gMSlcbiAgICAgICAgICAgIHdhcm4oYFRoZSBcIm5leHRcIiBjYWxsYmFjayB3YXMgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIGluIG9uZSBuYXZpZ2F0aW9uIGd1YXJkIHdoZW4gZ29pbmcgZnJvbSBcIiR7ZnJvbS5mdWxsUGF0aH1cIiB0byBcIiR7dG8uZnVsbFBhdGh9XCIuIEl0IHNob3VsZCBiZSBjYWxsZWQgZXhhY3RseSBvbmUgdGltZSBpbiBlYWNoIG5hdmlnYXRpb24gZ3VhcmQuIFRoaXMgd2lsbCBmYWlsIGluIHByb2R1Y3Rpb24uYCk7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHdlIHB1dCBpdCBpbiB0aGUgb3JpZ2luYWwgb25lIGJlY2F1c2UgaXQncyBlYXNpZXIgdG8gY2hlY2tcbiAgICAgICAgbmV4dC5fY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGNhbGxlZCA9PT0gMSlcbiAgICAgICAgICAgIG5leHQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZXh0cmFjdENvbXBvbmVudHNHdWFyZHMobWF0Y2hlZCwgZ3VhcmRUeXBlLCB0bywgZnJvbSkge1xuICAgIGNvbnN0IGd1YXJkcyA9IFtdO1xuICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIG1hdGNoZWQpIHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhcmVjb3JkLmNvbXBvbmVudHMgJiYgIXJlY29yZC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHdhcm4oYFJlY29yZCB3aXRoIHBhdGggXCIke3JlY29yZC5wYXRofVwiIGlzIGVpdGhlciBtaXNzaW5nIGEgXCJjb21wb25lbnQocylcImAgK1xuICAgICAgICAgICAgICAgIGAgb3IgXCJjaGlsZHJlblwiIHByb3BlcnR5LmApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiByZWNvcmQuY29tcG9uZW50cykge1xuICAgICAgICAgICAgbGV0IHJhd0NvbXBvbmVudCA9IHJlY29yZC5jb21wb25lbnRzW25hbWVdO1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIGlmICghcmF3Q29tcG9uZW50IHx8XG4gICAgICAgICAgICAgICAgICAgICh0eXBlb2YgcmF3Q29tcG9uZW50ICE9PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJhd0NvbXBvbmVudCAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IFwiJHtuYW1lfVwiIGluIHJlY29yZCB3aXRoIHBhdGggXCIke3JlY29yZC5wYXRofVwiIGlzIG5vdGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCBhIHZhbGlkIGNvbXBvbmVudC4gUmVjZWl2ZWQgXCIke1N0cmluZyhyYXdDb21wb25lbnQpfVwiLmApO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdyB0byBlbnN1cmUgd2Ugc3RvcCBoZXJlIGJ1dCB3YXJuIHRvIGVuc3VyZSB0aGUgbWVzc2FnZSBpc24ndFxuICAgICAgICAgICAgICAgICAgICAvLyBtaXNzZWQgYnkgdGhlIHVzZXJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJvdXRlIGNvbXBvbmVudCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgndGhlbicgaW4gcmF3Q29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdhcm4gaWYgdXNlciB3cm90ZSBpbXBvcnQoJy9jb21wb25lbnQudnVlJykgaW5zdGVhZCBvZiAoKSA9PlxuICAgICAgICAgICAgICAgICAgICAvLyBpbXBvcnQoJy4vY29tcG9uZW50LnZ1ZScpXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBcIiR7bmFtZX1cIiBpbiByZWNvcmQgd2l0aCBwYXRoIFwiJHtyZWNvcmQucGF0aH1cIiBpcyBhIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFByb21pc2UgaW5zdGVhZCBvZiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIFByb21pc2UuIERpZCB5b3UgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgd3JpdGUgXCJpbXBvcnQoJy4vTXlQYWdlLnZ1ZScpXCIgaW5zdGVhZCBvZiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcIigpID0+IGltcG9ydCgnLi9NeVBhZ2UudnVlJylcIiA/IFRoaXMgd2lsbCBicmVhayBpbiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBwcm9kdWN0aW9uIGlmIG5vdCBmaXhlZC5gKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IHJhd0NvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAgICAgcmF3Q29tcG9uZW50ID0gKCkgPT4gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmF3Q29tcG9uZW50Ll9fYXN5bmNMb2FkZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gd2FybiBvbmx5IG9uY2UgcGVyIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAhcmF3Q29tcG9uZW50Ll9fd2FybmVkRGVmaW5lQXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmF3Q29tcG9uZW50Ll9fd2FybmVkRGVmaW5lQXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgXCIke25hbWV9XCIgaW4gcmVjb3JkIHdpdGggcGF0aCBcIiR7cmVjb3JkLnBhdGh9XCIgaXMgZGVmaW5lZCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGB1c2luZyBcImRlZmluZUFzeW5jQ29tcG9uZW50KClcIi4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgV3JpdGUgXCIoKSA9PiBpbXBvcnQoJy4vTXlQYWdlLnZ1ZScpXCIgaW5zdGVhZCBvZiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcImRlZmluZUFzeW5jQ29tcG9uZW50KCgpID0+IGltcG9ydCgnLi9NeVBhZ2UudnVlJykpXCIuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2tpcCB1cGRhdGUgYW5kIGxlYXZlIGd1YXJkcyBpZiB0aGUgcm91dGUgY29tcG9uZW50IGlzIG5vdCBtb3VudGVkXG4gICAgICAgICAgICBpZiAoZ3VhcmRUeXBlICE9PSAnYmVmb3JlUm91dGVFbnRlcicgJiYgIXJlY29yZC5pbnN0YW5jZXNbbmFtZV0pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoaXNSb3V0ZUNvbXBvbmVudChyYXdDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgLy8gX192Y2NPcHRzIGlzIGFkZGVkIGJ5IHZ1ZS1jbGFzcy1jb21wb25lbnQgYW5kIGNvbnRhaW4gdGhlIHJlZ3VsYXIgb3B0aW9uc1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSByYXdDb21wb25lbnQuX192Y2NPcHRzIHx8IHJhd0NvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBndWFyZCA9IG9wdGlvbnNbZ3VhcmRUeXBlXTtcbiAgICAgICAgICAgICAgICBndWFyZCAmJiBndWFyZHMucHVzaChndWFyZFRvUHJvbWlzZUZuKGd1YXJkLCB0bywgZnJvbSwgcmVjb3JkLCBuYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCByZXF1ZXN0aW5nIHRoZSBjaHVuayBhbHJlYWR5XG4gICAgICAgICAgICAgICAgbGV0IGNvbXBvbmVudFByb21pc2UgPSByYXdDb21wb25lbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICEoJ2NhdGNoJyBpbiBjb21wb25lbnRQcm9taXNlKSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgXCIke25hbWV9XCIgaW4gcmVjb3JkIHdpdGggcGF0aCBcIiR7cmVjb3JkLnBhdGh9XCIgaXMgYSBmdW5jdGlvbiB0aGF0IGRvZXMgbm90IHJldHVybiBhIFByb21pc2UuIElmIHlvdSB3ZXJlIHBhc3NpbmcgYSBmdW5jdGlvbmFsIGNvbXBvbmVudCwgbWFrZSBzdXJlIHRvIGFkZCBhIFwiZGlzcGxheU5hbWVcIiB0byB0aGUgY29tcG9uZW50LiBUaGlzIHdpbGwgYnJlYWsgaW4gcHJvZHVjdGlvbiBpZiBub3QgZml4ZWQuYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29tcG9uZW50UHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGd1YXJkcy5wdXNoKCgpID0+IGNvbXBvbmVudFByb21pc2UudGhlbihyZXNvbHZlZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBDb3VsZG4ndCByZXNvbHZlIGNvbXBvbmVudCBcIiR7bmFtZX1cIiBhdCBcIiR7cmVjb3JkLnBhdGh9XCJgKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkQ29tcG9uZW50ID0gaXNFU01vZHVsZShyZXNvbHZlZClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzb2x2ZWQuZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZXNvbHZlZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgcmVzb2x2ZWQgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCBiZWNhdXNlIHdlIHdlbnQgaW50byB0aGUgZm9yIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkLmNvbXBvbmVudHNbbmFtZV0gPSByZXNvbHZlZENvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAgICAgLy8gX192Y2NPcHRzIGlzIGFkZGVkIGJ5IHZ1ZS1jbGFzcy1jb21wb25lbnQgYW5kIGNvbnRhaW4gdGhlIHJlZ3VsYXIgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gcmVzb2x2ZWRDb21wb25lbnQuX192Y2NPcHRzIHx8IHJlc29sdmVkQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBndWFyZCA9IG9wdGlvbnNbZ3VhcmRUeXBlXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGd1YXJkICYmIGd1YXJkVG9Qcm9taXNlRm4oZ3VhcmQsIHRvLCBmcm9tLCByZWNvcmQsIG5hbWUpKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBndWFyZHM7XG59XG4vKipcbiAqIEFsbG93cyBkaWZmZXJlbnRpYXRpbmcgbGF6eSBjb21wb25lbnRzIGZyb20gZnVuY3Rpb25hbCBjb21wb25lbnRzIGFuZCB2dWUtY2xhc3MtY29tcG9uZW50XG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBAcGFyYW0gY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIGlzUm91dGVDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuICh0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyB8fFxuICAgICAgICAnZGlzcGxheU5hbWUnIGluIGNvbXBvbmVudCB8fFxuICAgICAgICAncHJvcHMnIGluIGNvbXBvbmVudCB8fFxuICAgICAgICAnX192Y2NPcHRzJyBpbiBjb21wb25lbnQpO1xufVxuLyoqXG4gKiBFbnN1cmVzIGEgcm91dGUgaXMgbG9hZGVkLCBzbyBpdCBjYW4gYmUgcGFzc2VkIGFzIG8gcHJvcCB0byBgPFJvdXRlclZpZXc+YC5cbiAqXG4gKiBAcGFyYW0gcm91dGUgLSByZXNvbHZlZCByb3V0ZSB0byBsb2FkXG4gKi9cbmZ1bmN0aW9uIGxvYWRSb3V0ZUxvY2F0aW9uKHJvdXRlKSB7XG4gICAgcmV0dXJuIHJvdXRlLm1hdGNoZWQuZXZlcnkocmVjb3JkID0+IHJlY29yZC5yZWRpcmVjdClcbiAgICAgICAgPyBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0Nhbm5vdCBsb2FkIGEgcm91dGUgdGhhdCByZWRpcmVjdHMuJykpXG4gICAgICAgIDogUHJvbWlzZS5hbGwocm91dGUubWF0Y2hlZC5tYXAocmVjb3JkID0+IHJlY29yZC5jb21wb25lbnRzICYmXG4gICAgICAgICAgICBQcm9taXNlLmFsbChPYmplY3Qua2V5cyhyZWNvcmQuY29tcG9uZW50cykucmVkdWNlKChwcm9taXNlcywgbmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhd0NvbXBvbmVudCA9IHJlY29yZC5jb21wb25lbnRzW25hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmF3Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICAgICAgICEoJ2Rpc3BsYXlOYW1lJyBpbiByYXdDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gocmF3Q29tcG9uZW50KCkudGhlbihyZXNvbHZlZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYENvdWxkbid0IHJlc29sdmUgY29tcG9uZW50IFwiJHtuYW1lfVwiIGF0IFwiJHtyZWNvcmQucGF0aH1cIi4gRW5zdXJlIHlvdSBwYXNzZWQgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBwcm9taXNlLmApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkQ29tcG9uZW50ID0gaXNFU01vZHVsZShyZXNvbHZlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJlc29sdmVkLmRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJlc29sdmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgcmVzb2x2ZWQgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQgYmVjYXVzZSB3ZSB3ZW50IGludG8gdGhlIGZvciBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQuY29tcG9uZW50c1tuYW1lXSA9IHJlc29sdmVkQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlcztcbiAgICAgICAgICAgIH0sIFtdKSkpKS50aGVuKCgpID0+IHJvdXRlKTtcbn1cblxuLy8gVE9ETzogd2UgY291bGQgYWxsb3cgY3VycmVudFJvdXRlIGFzIGEgcHJvcCB0byBleHBvc2UgYGlzQWN0aXZlYCBhbmRcbi8vIGBpc0V4YWN0QWN0aXZlYCBiZWhhdmlvciBzaG91bGQgZ28gdGhyb3VnaCBhbiBSRkNcbmZ1bmN0aW9uIHVzZUxpbmsocHJvcHMpIHtcbiAgICBjb25zdCByb3V0ZXIgPSBpbmplY3Qocm91dGVyS2V5KTtcbiAgICBjb25zdCBjdXJyZW50Um91dGUgPSBpbmplY3Qocm91dGVMb2NhdGlvbktleSk7XG4gICAgY29uc3Qgcm91dGUgPSBjb21wdXRlZCgoKSA9PiByb3V0ZXIucmVzb2x2ZSh1bnJlZihwcm9wcy50bykpKTtcbiAgICBjb25zdCBhY3RpdmVSZWNvcmRJbmRleCA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICAgICAgY29uc3QgeyBtYXRjaGVkIH0gPSByb3V0ZS52YWx1ZTtcbiAgICAgICAgY29uc3QgeyBsZW5ndGggfSA9IG1hdGNoZWQ7XG4gICAgICAgIGNvbnN0IHJvdXRlTWF0Y2hlZCA9IG1hdGNoZWRbbGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IGN1cnJlbnRNYXRjaGVkID0gY3VycmVudFJvdXRlLm1hdGNoZWQ7XG4gICAgICAgIGlmICghcm91dGVNYXRjaGVkIHx8ICFjdXJyZW50TWF0Y2hlZC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gY3VycmVudE1hdGNoZWQuZmluZEluZGV4KGlzU2FtZVJvdXRlUmVjb3JkLmJpbmQobnVsbCwgcm91dGVNYXRjaGVkKSk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAvLyBwb3NzaWJsZSBwYXJlbnQgcmVjb3JkXG4gICAgICAgIGNvbnN0IHBhcmVudFJlY29yZFBhdGggPSBnZXRPcmlnaW5hbFBhdGgobWF0Y2hlZFtsZW5ndGggLSAyXSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgIC8vIHdlIGFyZSBkZWFsaW5nIHdpdGggbmVzdGVkIHJvdXRlc1xuICAgICAgICBsZW5ndGggPiAxICYmXG4gICAgICAgICAgICAvLyBpZiB0aGUgcGFyZW50IGFuZCBtYXRjaGVkIHJvdXRlIGhhdmUgdGhlIHNhbWUgcGF0aCwgdGhpcyBsaW5rIGlzXG4gICAgICAgICAgICAvLyByZWZlcnJpbmcgdG8gdGhlIGVtcHR5IGNoaWxkLiBPciB3ZSBjdXJyZW50bHkgYXJlIG9uIGEgZGlmZmVyZW50XG4gICAgICAgICAgICAvLyBjaGlsZCBvZiB0aGUgc2FtZSBwYXJlbnRcbiAgICAgICAgICAgIGdldE9yaWdpbmFsUGF0aChyb3V0ZU1hdGNoZWQpID09PSBwYXJlbnRSZWNvcmRQYXRoICYmXG4gICAgICAgICAgICAvLyBhdm9pZCBjb21wYXJpbmcgdGhlIGNoaWxkIHdpdGggaXRzIHBhcmVudFxuICAgICAgICAgICAgY3VycmVudE1hdGNoZWRbY3VycmVudE1hdGNoZWQubGVuZ3RoIC0gMV0ucGF0aCAhPT0gcGFyZW50UmVjb3JkUGF0aFxuICAgICAgICAgICAgPyBjdXJyZW50TWF0Y2hlZC5maW5kSW5kZXgoaXNTYW1lUm91dGVSZWNvcmQuYmluZChudWxsLCBtYXRjaGVkW2xlbmd0aCAtIDJdKSlcbiAgICAgICAgICAgIDogaW5kZXgpO1xuICAgIH0pO1xuICAgIGNvbnN0IGlzQWN0aXZlID0gY29tcHV0ZWQoKCkgPT4gYWN0aXZlUmVjb3JkSW5kZXgudmFsdWUgPiAtMSAmJlxuICAgICAgICBpbmNsdWRlc1BhcmFtcyhjdXJyZW50Um91dGUucGFyYW1zLCByb3V0ZS52YWx1ZS5wYXJhbXMpKTtcbiAgICBjb25zdCBpc0V4YWN0QWN0aXZlID0gY29tcHV0ZWQoKCkgPT4gYWN0aXZlUmVjb3JkSW5kZXgudmFsdWUgPiAtMSAmJlxuICAgICAgICBhY3RpdmVSZWNvcmRJbmRleC52YWx1ZSA9PT0gY3VycmVudFJvdXRlLm1hdGNoZWQubGVuZ3RoIC0gMSAmJlxuICAgICAgICBpc1NhbWVSb3V0ZUxvY2F0aW9uUGFyYW1zKGN1cnJlbnRSb3V0ZS5wYXJhbXMsIHJvdXRlLnZhbHVlLnBhcmFtcykpO1xuICAgIGZ1bmN0aW9uIG5hdmlnYXRlKGUgPSB7fSkge1xuICAgICAgICBpZiAoZ3VhcmRFdmVudChlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlclt1bnJlZihwcm9wcy5yZXBsYWNlKSA/ICdyZXBsYWNlJyA6ICdwdXNoJ10odW5yZWYocHJvcHMudG8pXG4gICAgICAgICAgICAvLyBhdm9pZCB1bmNhdWdodCBlcnJvcnMgYXJlIHRoZXkgYXJlIGxvZ2dlZCBhbnl3YXlcbiAgICAgICAgICAgICkuY2F0Y2gobm9vcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICAvLyBkZXZ0b29scyBvbmx5XG4gICAgaWYgKCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSAmJiBpc0Jyb3dzZXIpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rQ29udGV4dERldnRvb2xzID0ge1xuICAgICAgICAgICAgICAgIHJvdXRlOiByb3V0ZS52YWx1ZSxcbiAgICAgICAgICAgICAgICBpc0FjdGl2ZTogaXNBY3RpdmUudmFsdWUsXG4gICAgICAgICAgICAgICAgaXNFeGFjdEFjdGl2ZTogaXNFeGFjdEFjdGl2ZS52YWx1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB0aGlzIGlzIGludGVybmFsXG4gICAgICAgICAgICBpbnN0YW5jZS5fX3ZybF9kZXZ0b29scyA9IGluc3RhbmNlLl9fdnJsX2RldnRvb2xzIHx8IFtdO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogdGhpcyBpcyBpbnRlcm5hbFxuICAgICAgICAgICAgaW5zdGFuY2UuX192cmxfZGV2dG9vbHMucHVzaChsaW5rQ29udGV4dERldnRvb2xzKTtcbiAgICAgICAgICAgIHdhdGNoRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBsaW5rQ29udGV4dERldnRvb2xzLnJvdXRlID0gcm91dGUudmFsdWU7XG4gICAgICAgICAgICAgICAgbGlua0NvbnRleHREZXZ0b29scy5pc0FjdGl2ZSA9IGlzQWN0aXZlLnZhbHVlO1xuICAgICAgICAgICAgICAgIGxpbmtDb250ZXh0RGV2dG9vbHMuaXNFeGFjdEFjdGl2ZSA9IGlzRXhhY3RBY3RpdmUudmFsdWU7XG4gICAgICAgICAgICB9LCB7IGZsdXNoOiAncG9zdCcgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTk9URTogdXBkYXRlIHtAbGluayBfUm91dGVyTGlua0l9J3MgYCRzbG90c2AgdHlwZSB3aGVuIHVwZGF0aW5nIHRoaXNcbiAgICAgKi9cbiAgICByZXR1cm4ge1xuICAgICAgICByb3V0ZSxcbiAgICAgICAgaHJlZjogY29tcHV0ZWQoKCkgPT4gcm91dGUudmFsdWUuaHJlZiksXG4gICAgICAgIGlzQWN0aXZlLFxuICAgICAgICBpc0V4YWN0QWN0aXZlLFxuICAgICAgICBuYXZpZ2F0ZSxcbiAgICB9O1xufVxuY29uc3QgUm91dGVyTGlua0ltcGwgPSAvKiNfX1BVUkVfXyovIGRlZmluZUNvbXBvbmVudCh7XG4gICAgbmFtZTogJ1JvdXRlckxpbmsnLFxuICAgIGNvbXBhdENvbmZpZzogeyBNT0RFOiAzIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgdG86IHtcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIE9iamVjdF0sXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgcmVwbGFjZTogQm9vbGVhbixcbiAgICAgICAgYWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICAgICAgLy8gaW5hY3RpdmVDbGFzczogU3RyaW5nLFxuICAgICAgICBleGFjdEFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgICAgIGN1c3RvbTogQm9vbGVhbixcbiAgICAgICAgYXJpYUN1cnJlbnRWYWx1ZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3BhZ2UnLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgdXNlTGluayxcbiAgICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XG4gICAgICAgIGNvbnN0IGxpbmsgPSByZWFjdGl2ZSh1c2VMaW5rKHByb3BzKSk7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gaW5qZWN0KHJvdXRlcktleSk7XG4gICAgICAgIGNvbnN0IGVsQ2xhc3MgPSBjb21wdXRlZCgoKSA9PiAoe1xuICAgICAgICAgICAgW2dldExpbmtDbGFzcyhwcm9wcy5hY3RpdmVDbGFzcywgb3B0aW9ucy5saW5rQWN0aXZlQ2xhc3MsICdyb3V0ZXItbGluay1hY3RpdmUnKV06IGxpbmsuaXNBY3RpdmUsXG4gICAgICAgICAgICAvLyBbZ2V0TGlua0NsYXNzKFxuICAgICAgICAgICAgLy8gICBwcm9wcy5pbmFjdGl2ZUNsYXNzLFxuICAgICAgICAgICAgLy8gICBvcHRpb25zLmxpbmtJbmFjdGl2ZUNsYXNzLFxuICAgICAgICAgICAgLy8gICAncm91dGVyLWxpbmstaW5hY3RpdmUnXG4gICAgICAgICAgICAvLyApXTogIWxpbmsuaXNFeGFjdEFjdGl2ZSxcbiAgICAgICAgICAgIFtnZXRMaW5rQ2xhc3MocHJvcHMuZXhhY3RBY3RpdmVDbGFzcywgb3B0aW9ucy5saW5rRXhhY3RBY3RpdmVDbGFzcywgJ3JvdXRlci1saW5rLWV4YWN0LWFjdGl2ZScpXTogbGluay5pc0V4YWN0QWN0aXZlLFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgc2xvdHMuZGVmYXVsdChsaW5rKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9wcy5jdXN0b21cbiAgICAgICAgICAgICAgICA/IGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgOiBoKCdhJywge1xuICAgICAgICAgICAgICAgICAgICAnYXJpYS1jdXJyZW50JzogbGluay5pc0V4YWN0QWN0aXZlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHByb3BzLmFyaWFDdXJyZW50VmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogbGluay5ocmVmLFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdvdWxkIG92ZXJyaWRlIHVzZXIgYWRkZWQgYXR0cnMgYnV0IFZ1ZSB3aWxsIHN0aWxsIGFkZFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbGlzdGVuZXIsIHNvIHdlIGVuZCB1cCB0cmlnZ2VyaW5nIGJvdGhcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogbGluay5uYXZpZ2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IGVsQ2xhc3MudmFsdWUsXG4gICAgICAgICAgICAgICAgfSwgY2hpbGRyZW4pO1xuICAgICAgICB9O1xuICAgIH0sXG59KTtcbi8vIGV4cG9ydCB0aGUgcHVibGljIHR5cGUgZm9yIGgvdHN4IGluZmVyZW5jZVxuLy8gYWxzbyB0byBhdm9pZCBpbmxpbmUgaW1wb3J0KCkgaW4gZ2VuZXJhdGVkIGQudHMgZmlsZXNcbi8qKlxuICogQ29tcG9uZW50IHRvIHJlbmRlciBhIGxpbmsgdGhhdCB0cmlnZ2VycyBhIG5hdmlnYXRpb24gb24gY2xpY2suXG4gKi9cbmNvbnN0IFJvdXRlckxpbmsgPSBSb3V0ZXJMaW5rSW1wbDtcbmZ1bmN0aW9uIGd1YXJkRXZlbnQoZSkge1xuICAgIC8vIGRvbid0IHJlZGlyZWN0IHdpdGggY29udHJvbCBrZXlzXG4gICAgaWYgKGUubWV0YUtleSB8fCBlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5zaGlmdEtleSlcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIGRvbid0IHJlZGlyZWN0IHdoZW4gcHJldmVudERlZmF1bHQgY2FsbGVkXG4gICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIGRvbid0IHJlZGlyZWN0IG9uIHJpZ2h0IGNsaWNrXG4gICAgaWYgKGUuYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgZS5idXR0b24gIT09IDApXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBkb24ndCByZWRpcmVjdCBpZiBgdGFyZ2V0PVwiX2JsYW5rXCJgXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBnZXRBdHRyaWJ1dGUgZG9lcyBleGlzdFxuICAgIGlmIChlLmN1cnJlbnRUYXJnZXQgJiYgZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSkge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGdldEF0dHJpYnV0ZSBleGlzdHNcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgndGFyZ2V0Jyk7XG4gICAgICAgIGlmICgvXFxiX2JsYW5rXFxiL2kudGVzdCh0YXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB0aGlzIG1heSBiZSBhIFdlZXggZXZlbnQgd2hpY2ggZG9lc24ndCBoYXZlIHRoaXMgbWV0aG9kXG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzUGFyYW1zKG91dGVyLCBpbm5lcikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGlubmVyKSB7XG4gICAgICAgIGNvbnN0IGlubmVyVmFsdWUgPSBpbm5lcltrZXldO1xuICAgICAgICBjb25zdCBvdXRlclZhbHVlID0gb3V0ZXJba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbm5lclZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGlubmVyVmFsdWUgIT09IG91dGVyVmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFpc0FycmF5KG91dGVyVmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgb3V0ZXJWYWx1ZS5sZW5ndGggIT09IGlubmVyVmFsdWUubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgaW5uZXJWYWx1ZS5zb21lKCh2YWx1ZSwgaSkgPT4gdmFsdWUgIT09IG91dGVyVmFsdWVbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogR2V0IHRoZSBvcmlnaW5hbCBwYXRoIHZhbHVlIG9mIGEgcmVjb3JkIGJ5IGZvbGxvd2luZyBpdHMgYWxpYXNPZlxuICogQHBhcmFtIHJlY29yZFxuICovXG5mdW5jdGlvbiBnZXRPcmlnaW5hbFBhdGgocmVjb3JkKSB7XG4gICAgcmV0dXJuIHJlY29yZCA/IChyZWNvcmQuYWxpYXNPZiA/IHJlY29yZC5hbGlhc09mLnBhdGggOiByZWNvcmQucGF0aCkgOiAnJztcbn1cbi8qKlxuICogVXRpbGl0eSBjbGFzcyB0byBnZXQgdGhlIGFjdGl2ZSBjbGFzcyBiYXNlZCBvbiBkZWZhdWx0cy5cbiAqIEBwYXJhbSBwcm9wQ2xhc3NcbiAqIEBwYXJhbSBnbG9iYWxDbGFzc1xuICogQHBhcmFtIGRlZmF1bHRDbGFzc1xuICovXG5jb25zdCBnZXRMaW5rQ2xhc3MgPSAocHJvcENsYXNzLCBnbG9iYWxDbGFzcywgZGVmYXVsdENsYXNzKSA9PiBwcm9wQ2xhc3MgIT0gbnVsbFxuICAgID8gcHJvcENsYXNzXG4gICAgOiBnbG9iYWxDbGFzcyAhPSBudWxsXG4gICAgICAgID8gZ2xvYmFsQ2xhc3NcbiAgICAgICAgOiBkZWZhdWx0Q2xhc3M7XG5cbmNvbnN0IFJvdXRlclZpZXdJbXBsID0gLyojX19QVVJFX18qLyBkZWZpbmVDb21wb25lbnQoe1xuICAgIG5hbWU6ICdSb3V0ZXJWaWV3JyxcbiAgICAvLyAjNjc0IHdlIG1hbnVhbGx5IGluaGVyaXQgdGhlbVxuICAgIGluaGVyaXRBdHRyczogZmFsc2UsXG4gICAgcHJvcHM6IHtcbiAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2RlZmF1bHQnLFxuICAgICAgICB9LFxuICAgICAgICByb3V0ZTogT2JqZWN0LFxuICAgIH0sXG4gICAgLy8gQmV0dGVyIGNvbXBhdCBmb3IgQHZ1ZS9jb21wYXQgdXNlcnNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvcm91dGVyL2lzc3Vlcy8xMzE1XG4gICAgY29tcGF0Q29uZmlnOiB7IE1PREU6IDMgfSxcbiAgICBzZXR1cChwcm9wcywgeyBhdHRycywgc2xvdHMgfSkge1xuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybkRlcHJlY2F0ZWRVc2FnZSgpO1xuICAgICAgICBjb25zdCBpbmplY3RlZFJvdXRlID0gaW5qZWN0KHJvdXRlclZpZXdMb2NhdGlvbktleSk7XG4gICAgICAgIGNvbnN0IHJvdXRlVG9EaXNwbGF5ID0gY29tcHV0ZWQoKCkgPT4gcHJvcHMucm91dGUgfHwgaW5qZWN0ZWRSb3V0ZS52YWx1ZSk7XG4gICAgICAgIGNvbnN0IGluamVjdGVkRGVwdGggPSBpbmplY3Qodmlld0RlcHRoS2V5LCAwKTtcbiAgICAgICAgLy8gVGhlIGRlcHRoIGNoYW5nZXMgYmFzZWQgb24gZW1wdHkgY29tcG9uZW50cyBvcHRpb24sIHdoaWNoIGFsbG93cyBwYXNzdGhyb3VnaCByb3V0ZXMgZS5nLiByb3V0ZXMgd2l0aCBjaGlsZHJlblxuICAgICAgICAvLyB0aGF0IGFyZSB1c2VkIHRvIHJldXNlIHRoZSBgcGF0aGAgcHJvcGVydHlcbiAgICAgICAgY29uc3QgZGVwdGggPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgICAgICAgICBsZXQgaW5pdGlhbERlcHRoID0gdW5yZWYoaW5qZWN0ZWREZXB0aCk7XG4gICAgICAgICAgICBjb25zdCB7IG1hdGNoZWQgfSA9IHJvdXRlVG9EaXNwbGF5LnZhbHVlO1xuICAgICAgICAgICAgbGV0IG1hdGNoZWRSb3V0ZTtcbiAgICAgICAgICAgIHdoaWxlICgobWF0Y2hlZFJvdXRlID0gbWF0Y2hlZFtpbml0aWFsRGVwdGhdKSAmJlxuICAgICAgICAgICAgICAgICFtYXRjaGVkUm91dGUuY29tcG9uZW50cykge1xuICAgICAgICAgICAgICAgIGluaXRpYWxEZXB0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluaXRpYWxEZXB0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1hdGNoZWRSb3V0ZVJlZiA9IGNvbXB1dGVkKCgpID0+IHJvdXRlVG9EaXNwbGF5LnZhbHVlLm1hdGNoZWRbZGVwdGgudmFsdWVdKTtcbiAgICAgICAgcHJvdmlkZSh2aWV3RGVwdGhLZXksIGNvbXB1dGVkKCgpID0+IGRlcHRoLnZhbHVlICsgMSkpO1xuICAgICAgICBwcm92aWRlKG1hdGNoZWRSb3V0ZUtleSwgbWF0Y2hlZFJvdXRlUmVmKTtcbiAgICAgICAgcHJvdmlkZShyb3V0ZXJWaWV3TG9jYXRpb25LZXksIHJvdXRlVG9EaXNwbGF5KTtcbiAgICAgICAgY29uc3Qgdmlld1JlZiA9IHJlZigpO1xuICAgICAgICAvLyB3YXRjaCBhdCB0aGUgc2FtZSB0aW1lIHRoZSBjb21wb25lbnQgaW5zdGFuY2UsIHRoZSByb3V0ZSByZWNvcmQgd2UgYXJlXG4gICAgICAgIC8vIHJlbmRlcmluZywgYW5kIHRoZSBuYW1lXG4gICAgICAgIHdhdGNoKCgpID0+IFt2aWV3UmVmLnZhbHVlLCBtYXRjaGVkUm91dGVSZWYudmFsdWUsIHByb3BzLm5hbWVdLCAoW2luc3RhbmNlLCB0bywgbmFtZV0sIFtvbGRJbnN0YW5jZSwgZnJvbSwgb2xkTmFtZV0pID0+IHtcbiAgICAgICAgICAgIC8vIGNvcHkgcmV1c2VkIGluc3RhbmNlc1xuICAgICAgICAgICAgaWYgKHRvKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIHVwZGF0ZSB0aGUgaW5zdGFuY2UgZm9yIG5ldyBpbnN0YW5jZXMgYXMgd2VsbCBhcyByZXVzZWRcbiAgICAgICAgICAgICAgICAvLyBpbnN0YW5jZXMgd2hlbiBuYXZpZ2F0aW5nIHRvIGEgbmV3IHJvdXRlXG4gICAgICAgICAgICAgICAgdG8uaW5zdGFuY2VzW25hbWVdID0gaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGNvbXBvbmVudCBpbnN0YW5jZSBpcyByZXVzZWQgZm9yIGEgZGlmZmVyZW50IHJvdXRlIG9yIG5hbWUsIHNvXG4gICAgICAgICAgICAgICAgLy8gd2UgY29weSBhbnkgc2F2ZWQgdXBkYXRlIG9yIGxlYXZlIGd1YXJkcy4gV2l0aCBhc3luYyBzZXR1cCwgdGhlXG4gICAgICAgICAgICAgICAgLy8gbW91bnRpbmcgY29tcG9uZW50IHdpbGwgbW91bnQgYmVmb3JlIHRoZSBtYXRjaGVkUm91dGUgY2hhbmdlcyxcbiAgICAgICAgICAgICAgICAvLyBtYWtpbmcgaW5zdGFuY2UgPT09IG9sZEluc3RhbmNlLCBzbyB3ZSBjaGVjayBpZiBndWFyZHMgaGF2ZSBiZWVuXG4gICAgICAgICAgICAgICAgLy8gYWRkZWQgYmVmb3JlLiBUaGlzIHdvcmtzIGJlY2F1c2Ugd2UgcmVtb3ZlIGd1YXJkcyB3aGVuXG4gICAgICAgICAgICAgICAgLy8gdW5tb3VudGluZy9kZWFjdGl2YXRpbmcgY29tcG9uZW50c1xuICAgICAgICAgICAgICAgIGlmIChmcm9tICYmIGZyb20gIT09IHRvICYmIGluc3RhbmNlICYmIGluc3RhbmNlID09PSBvbGRJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRvLmxlYXZlR3VhcmRzLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvLmxlYXZlR3VhcmRzID0gZnJvbS5sZWF2ZUd1YXJkcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRvLnVwZGF0ZUd1YXJkcy5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0by51cGRhdGVHdWFyZHMgPSBmcm9tLnVwZGF0ZUd1YXJkcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRyaWdnZXIgYmVmb3JlUm91dGVFbnRlciBuZXh0IGNhbGxiYWNrc1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlICYmXG4gICAgICAgICAgICAgICAgdG8gJiZcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBpbnN0YW5jZSBidXQgdG8gYW5kIGZyb20gYXJlIHRoZSBzYW1lIHRoaXMgbWlnaHQgYmVcbiAgICAgICAgICAgICAgICAvLyB0aGUgZmlyc3QgdmlzaXRcbiAgICAgICAgICAgICAgICAoIWZyb20gfHwgIWlzU2FtZVJvdXRlUmVjb3JkKHRvLCBmcm9tKSB8fCAhb2xkSW5zdGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgKHRvLmVudGVyQ2FsbGJhY2tzW25hbWVdIHx8IFtdKS5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKGluc3RhbmNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHsgZmx1c2g6ICdwb3N0JyB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcm91dGVUb0Rpc3BsYXkudmFsdWU7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRoZSB2YWx1ZSBhdCB0aGUgdGltZSB3ZSByZW5kZXIgYmVjYXVzZSB3aGVuIHdlIHVubW91bnQsIHdlXG4gICAgICAgICAgICAvLyBuYXZpZ2F0ZWQgdG8gYSBkaWZmZXJlbnQgbG9jYXRpb24gc28gdGhlIHZhbHVlIGlzIGRpZmZlcmVudFxuICAgICAgICAgICAgY29uc3QgY3VycmVudE5hbWUgPSBwcm9wcy5uYW1lO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlZFJvdXRlID0gbWF0Y2hlZFJvdXRlUmVmLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgVmlld0NvbXBvbmVudCA9IG1hdGNoZWRSb3V0ZSAmJiBtYXRjaGVkUm91dGUuY29tcG9uZW50c1tjdXJyZW50TmFtZV07XG4gICAgICAgICAgICBpZiAoIVZpZXdDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplU2xvdChzbG90cy5kZWZhdWx0LCB7IENvbXBvbmVudDogVmlld0NvbXBvbmVudCwgcm91dGUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcm9wcyBmcm9tIHJvdXRlIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgIGNvbnN0IHJvdXRlUHJvcHNPcHRpb24gPSBtYXRjaGVkUm91dGUucHJvcHNbY3VycmVudE5hbWVdO1xuICAgICAgICAgICAgY29uc3Qgcm91dGVQcm9wcyA9IHJvdXRlUHJvcHNPcHRpb25cbiAgICAgICAgICAgICAgICA/IHJvdXRlUHJvcHNPcHRpb24gPT09IHRydWVcbiAgICAgICAgICAgICAgICAgICAgPyByb3V0ZS5wYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2Ygcm91dGVQcm9wc09wdGlvbiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyByb3V0ZVByb3BzT3B0aW9uKHJvdXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiByb3V0ZVByb3BzT3B0aW9uXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgY29uc3Qgb25Wbm9kZVVubW91bnRlZCA9IHZub2RlID0+IHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGluc3RhbmNlIHJlZmVyZW5jZSB0byBwcmV2ZW50IGxlYWtcbiAgICAgICAgICAgICAgICBpZiAodm5vZGUuY29tcG9uZW50LmlzVW5tb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWRSb3V0ZS5pbnN0YW5jZXNbY3VycmVudE5hbWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gaChWaWV3Q29tcG9uZW50LCBhc3NpZ24oe30sIHJvdXRlUHJvcHMsIGF0dHJzLCB7XG4gICAgICAgICAgICAgICAgb25Wbm9kZVVubW91bnRlZCxcbiAgICAgICAgICAgICAgICByZWY6IHZpZXdSZWYsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pICYmXG4gICAgICAgICAgICAgICAgaXNCcm93c2VyICYmXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnJlZikge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGNhbiBkaXNwbGF5IGlmIGl0J3MgYW4gYWxpYXMsIGl0cyBwcm9wc1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoOiBkZXB0aC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbWF0Y2hlZFJvdXRlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IG1hdGNoZWRSb3V0ZS5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBtZXRhOiBtYXRjaGVkUm91dGUubWV0YSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVybmFsSW5zdGFuY2VzID0gaXNBcnJheShjb21wb25lbnQucmVmKVxuICAgICAgICAgICAgICAgICAgICA/IGNvbXBvbmVudC5yZWYubWFwKHIgPT4gci5pKVxuICAgICAgICAgICAgICAgICAgICA6IFtjb21wb25lbnQucmVmLmldO1xuICAgICAgICAgICAgICAgIGludGVybmFsSW5zdGFuY2VzLmZvckVhY2goaW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLl9fdnJ2X2RldnRvb2xzID0gaW5mbztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAvLyBwYXNzIHRoZSB2bm9kZSB0byB0aGUgc2xvdCBhcyBhIHByb3AuXG4gICAgICAgICAgICAvLyBoIGFuZCA8Y29tcG9uZW50IDppcz1cIi4uLlwiPiBib3RoIGFjY2VwdCB2bm9kZXNcbiAgICAgICAgICAgIG5vcm1hbGl6ZVNsb3Qoc2xvdHMuZGVmYXVsdCwgeyBDb21wb25lbnQ6IGNvbXBvbmVudCwgcm91dGUgfSkgfHxcbiAgICAgICAgICAgICAgICBjb21wb25lbnQpO1xuICAgICAgICB9O1xuICAgIH0sXG59KTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVNsb3Qoc2xvdCwgZGF0YSkge1xuICAgIGlmICghc2xvdClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3Qgc2xvdENvbnRlbnQgPSBzbG90KGRhdGEpO1xuICAgIHJldHVybiBzbG90Q29udGVudC5sZW5ndGggPT09IDEgPyBzbG90Q29udGVudFswXSA6IHNsb3RDb250ZW50O1xufVxuLy8gZXhwb3J0IHRoZSBwdWJsaWMgdHlwZSBmb3IgaC90c3ggaW5mZXJlbmNlXG4vLyBhbHNvIHRvIGF2b2lkIGlubGluZSBpbXBvcnQoKSBpbiBnZW5lcmF0ZWQgZC50cyBmaWxlc1xuLyoqXG4gKiBDb21wb25lbnQgdG8gZGlzcGxheSB0aGUgY3VycmVudCByb3V0ZSB0aGUgdXNlciBpcyBhdC5cbiAqL1xuY29uc3QgUm91dGVyVmlldyA9IFJvdXRlclZpZXdJbXBsO1xuLy8gd2FybiBhZ2FpbnN0IGRlcHJlY2F0ZWQgdXNhZ2Ugd2l0aCA8dHJhbnNpdGlvbj4gJiA8a2VlcC1hbGl2ZT5cbi8vIGR1ZSB0byBmdW5jdGlvbmFsIGNvbXBvbmVudCBiZWluZyBubyBsb25nZXIgZWFnZXIgaW4gVnVlIDNcbmZ1bmN0aW9uIHdhcm5EZXByZWNhdGVkVXNhZ2UoKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBjb25zdCBwYXJlbnROYW1lID0gaW5zdGFuY2UucGFyZW50ICYmIGluc3RhbmNlLnBhcmVudC50eXBlLm5hbWU7XG4gICAgY29uc3QgcGFyZW50U3ViVHJlZVR5cGUgPSBpbnN0YW5jZS5wYXJlbnQgJiYgaW5zdGFuY2UucGFyZW50LnN1YlRyZWUgJiYgaW5zdGFuY2UucGFyZW50LnN1YlRyZWUudHlwZTtcbiAgICBpZiAocGFyZW50TmFtZSAmJlxuICAgICAgICAocGFyZW50TmFtZSA9PT0gJ0tlZXBBbGl2ZScgfHwgcGFyZW50TmFtZS5pbmNsdWRlcygnVHJhbnNpdGlvbicpKSAmJlxuICAgICAgICB0eXBlb2YgcGFyZW50U3ViVHJlZVR5cGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHBhcmVudFN1YlRyZWVUeXBlLm5hbWUgPT09ICdSb3V0ZXJWaWV3Jykge1xuICAgICAgICBjb25zdCBjb21wID0gcGFyZW50TmFtZSA9PT0gJ0tlZXBBbGl2ZScgPyAna2VlcC1hbGl2ZScgOiAndHJhbnNpdGlvbic7XG4gICAgICAgIHdhcm4oYDxyb3V0ZXItdmlldz4gY2FuIG5vIGxvbmdlciBiZSB1c2VkIGRpcmVjdGx5IGluc2lkZSA8dHJhbnNpdGlvbj4gb3IgPGtlZXAtYWxpdmU+LlxcbmAgK1xuICAgICAgICAgICAgYFVzZSBzbG90IHByb3BzIGluc3RlYWQ6XFxuXFxuYCArXG4gICAgICAgICAgICBgPHJvdXRlci12aWV3IHYtc2xvdD1cInsgQ29tcG9uZW50IH1cIj5cXG5gICtcbiAgICAgICAgICAgIGAgIDwke2NvbXB9PlxcbmAgK1xuICAgICAgICAgICAgYCAgICA8Y29tcG9uZW50IDppcz1cIkNvbXBvbmVudFwiIC8+XFxuYCArXG4gICAgICAgICAgICBgICA8LyR7Y29tcH0+XFxuYCArXG4gICAgICAgICAgICBgPC9yb3V0ZXItdmlldz5gKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ29waWVzIGEgcm91dGUgbG9jYXRpb24gYW5kIHJlbW92ZXMgYW55IHByb2JsZW1hdGljIHByb3BlcnRpZXMgdGhhdCBjYW5ub3QgYmUgc2hvd24gaW4gZGV2dG9vbHMgKGUuZy4gVnVlIGluc3RhbmNlcykuXG4gKlxuICogQHBhcmFtIHJvdXRlTG9jYXRpb24gLSByb3V0ZUxvY2F0aW9uIHRvIGZvcm1hdFxuICogQHBhcmFtIHRvb2x0aXAgLSBvcHRpb25hbCB0b29sdGlwXG4gKiBAcmV0dXJucyBhIGNvcHkgb2YgdGhlIHJvdXRlTG9jYXRpb25cbiAqL1xuZnVuY3Rpb24gZm9ybWF0Um91dGVMb2NhdGlvbihyb3V0ZUxvY2F0aW9uLCB0b29sdGlwKSB7XG4gICAgY29uc3QgY29weSA9IGFzc2lnbih7fSwgcm91dGVMb2NhdGlvbiwge1xuICAgICAgICAvLyByZW1vdmUgdmFyaWFibGVzIHRoYXQgY2FuIGNvbnRhaW4gdnVlIGluc3RhbmNlc1xuICAgICAgICBtYXRjaGVkOiByb3V0ZUxvY2F0aW9uLm1hdGNoZWQubWFwKG1hdGNoZWQgPT4gb21pdChtYXRjaGVkLCBbJ2luc3RhbmNlcycsICdjaGlsZHJlbicsICdhbGlhc09mJ10pKSxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBfY3VzdG9tOiB7XG4gICAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgICAgICBkaXNwbGF5OiByb3V0ZUxvY2F0aW9uLmZ1bGxQYXRoLFxuICAgICAgICAgICAgdG9vbHRpcCxcbiAgICAgICAgICAgIHZhbHVlOiBjb3B5LFxuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBmb3JtYXREaXNwbGF5KGRpc3BsYXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBfY3VzdG9tOiB7XG4gICAgICAgICAgICBkaXNwbGF5LFxuICAgICAgICB9LFxuICAgIH07XG59XG4vLyB0byBzdXBwb3J0IG11bHRpcGxlIHJvdXRlciBpbnN0YW5jZXNcbmxldCByb3V0ZXJJZCA9IDA7XG5mdW5jdGlvbiBhZGREZXZ0b29scyhhcHAsIHJvdXRlciwgbWF0Y2hlcikge1xuICAgIC8vIFRha2Ugb3ZlciByb3V0ZXIuYmVmb3JlRWFjaCBhbmQgYWZ0ZXJFYWNoXG4gICAgLy8gbWFrZSBzdXJlIHdlIGFyZSBub3QgcmVnaXN0ZXJpbmcgdGhlIGRldnRvb2wgdHdpY2VcbiAgICBpZiAocm91dGVyLl9faGFzRGV2dG9vbHMpXG4gICAgICAgIHJldHVybjtcbiAgICByb3V0ZXIuX19oYXNEZXZ0b29scyA9IHRydWU7XG4gICAgLy8gaW5jcmVtZW50IHRvIHN1cHBvcnQgbXVsdGlwbGUgcm91dGVyIGluc3RhbmNlc1xuICAgIGNvbnN0IGlkID0gcm91dGVySWQrKztcbiAgICBzZXR1cERldnRvb2xzUGx1Z2luKHtcbiAgICAgICAgaWQ6ICdvcmcudnVlanMucm91dGVyJyArIChpZCA/ICcuJyArIGlkIDogJycpLFxuICAgICAgICBsYWJlbDogJ1Z1ZSBSb3V0ZXInLFxuICAgICAgICBwYWNrYWdlTmFtZTogJ3Z1ZS1yb3V0ZXInLFxuICAgICAgICBob21lcGFnZTogJ2h0dHBzOi8vcm91dGVyLnZ1ZWpzLm9yZycsXG4gICAgICAgIGxvZ286ICdodHRwczovL3JvdXRlci52dWVqcy5vcmcvbG9nby5wbmcnLFxuICAgICAgICBjb21wb25lbnRTdGF0ZVR5cGVzOiBbJ1JvdXRpbmcnXSxcbiAgICAgICAgYXBwLFxuICAgIH0sIGFwaSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgYXBpLm5vdyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbVnVlIFJvdXRlcl06IFlvdSBzZWVtIHRvIGJlIHVzaW5nIGFuIG91dGRhdGVkIHZlcnNpb24gb2YgVnVlIERldnRvb2xzLiBBcmUgeW91IHN0aWxsIHVzaW5nIHRoZSBCZXRhIHJlbGVhc2UgaW5zdGVhZCBvZiB0aGUgc3RhYmxlIG9uZT8gWW91IGNhbiBmaW5kIHRoZSBsaW5rcyBhdCBodHRwczovL2RldnRvb2xzLnZ1ZWpzLm9yZy9ndWlkZS9pbnN0YWxsYXRpb24uaHRtbC4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkaXNwbGF5IHN0YXRlIGFkZGVkIGJ5IHRoZSByb3V0ZXJcbiAgICAgICAgYXBpLm9uLmluc3BlY3RDb21wb25lbnQoKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBheWxvYWQuaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5pbnN0YW5jZURhdGEuc3RhdGUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdSb3V0aW5nJyxcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnJHJvdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgZWRpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZm9ybWF0Um91dGVMb2NhdGlvbihyb3V0ZXIuY3VycmVudFJvdXRlLnZhbHVlLCAnQ3VycmVudCBSb3V0ZScpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gbWFyayByb3V0ZXItbGluayBhcyBhY3RpdmUgYW5kIGRpc3BsYXkgdGFncyBvbiByb3V0ZXIgdmlld3NcbiAgICAgICAgYXBpLm9uLnZpc2l0Q29tcG9uZW50VHJlZSgoeyB0cmVlTm9kZTogbm9kZSwgY29tcG9uZW50SW5zdGFuY2UgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudEluc3RhbmNlLl9fdnJ2X2RldnRvb2xzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5mbyA9IGNvbXBvbmVudEluc3RhbmNlLl9fdnJ2X2RldnRvb2xzO1xuICAgICAgICAgICAgICAgIG5vZGUudGFncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IChpbmZvLm5hbWUgPyBgJHtpbmZvLm5hbWUudG9TdHJpbmcoKX06IGAgOiAnJykgKyBpbmZvLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHRleHRDb2xvcjogMCxcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogJ1RoaXMgY29tcG9uZW50IGlzIHJlbmRlcmVkIGJ5ICZsdDtyb3V0ZXItdmlldyZndDsnLFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFBJTktfNTAwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgbXVsdGlwbGUgdXNlTGluayBhcmUgdXNlZFxuICAgICAgICAgICAgaWYgKGlzQXJyYXkoY29tcG9uZW50SW5zdGFuY2UuX192cmxfZGV2dG9vbHMpKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuX19kZXZ0b29sc0FwaSA9IGFwaTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRJbnN0YW5jZS5fX3ZybF9kZXZ0b29scy5mb3JFYWNoKGRldnRvb2xzRGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBiYWNrZ3JvdW5kQ29sb3IgPSBPUkFOR0VfNDAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG9vbHRpcCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGV2dG9vbHNEYXRhLmlzRXhhY3RBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9IExJTUVfNTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcCA9ICdUaGlzIGlzIGV4YWN0bHkgYWN0aXZlJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkZXZ0b29sc0RhdGEuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9IEJMVUVfNjAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcCA9ICdUaGlzIGxpbmsgaXMgYWN0aXZlJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlLnRhZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZGV2dG9vbHNEYXRhLnJvdXRlLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdhdGNoKHJvdXRlci5jdXJyZW50Um91dGUsICgpID0+IHtcbiAgICAgICAgICAgIC8vIHJlZnJlc2ggYWN0aXZlIHN0YXRlXG4gICAgICAgICAgICByZWZyZXNoUm91dGVzVmlldygpO1xuICAgICAgICAgICAgYXBpLm5vdGlmeUNvbXBvbmVudFVwZGF0ZSgpO1xuICAgICAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JUcmVlKHJvdXRlckluc3BlY3RvcklkKTtcbiAgICAgICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yU3RhdGUocm91dGVySW5zcGVjdG9ySWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbmF2aWdhdGlvbnNMYXllcklkID0gJ3JvdXRlcjpuYXZpZ2F0aW9uczonICsgaWQ7XG4gICAgICAgIGFwaS5hZGRUaW1lbGluZUxheWVyKHtcbiAgICAgICAgICAgIGlkOiBuYXZpZ2F0aW9uc0xheWVySWQsXG4gICAgICAgICAgICBsYWJlbDogYFJvdXRlciR7aWQgPyAnICcgKyBpZCA6ICcnfSBOYXZpZ2F0aW9uc2AsXG4gICAgICAgICAgICBjb2xvcjogMHg0MGE4YzQsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjb25zdCBlcnJvcnNMYXllcklkID0gJ3JvdXRlcjplcnJvcnMnXG4gICAgICAgIC8vIGFwaS5hZGRUaW1lbGluZUxheWVyKHtcbiAgICAgICAgLy8gICBpZDogZXJyb3JzTGF5ZXJJZCxcbiAgICAgICAgLy8gICBsYWJlbDogJ1JvdXRlciBFcnJvcnMnLFxuICAgICAgICAvLyAgIGNvbG9yOiAweGVhNTQ1NSxcbiAgICAgICAgLy8gfSlcbiAgICAgICAgcm91dGVyLm9uRXJyb3IoKGVycm9yLCB0bykgPT4ge1xuICAgICAgICAgICAgYXBpLmFkZFRpbWVsaW5lRXZlbnQoe1xuICAgICAgICAgICAgICAgIGxheWVySWQ6IG5hdmlnYXRpb25zTGF5ZXJJZCxcbiAgICAgICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ0Vycm9yIGR1cmluZyBOYXZpZ2F0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgc3VidGl0bGU6IHRvLmZ1bGxQYXRoLFxuICAgICAgICAgICAgICAgICAgICBsb2dUeXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICB0aW1lOiBhcGkubm93KCksXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgZXJyb3IgfSxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZDogdG8ubWV0YS5fX25hdmlnYXRpb25JZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBhdHRhY2hlZCB0byBgbWV0YWAgYW5kIHVzZWQgdG8gZ3JvdXAgZXZlbnRzXG4gICAgICAgIGxldCBuYXZpZ2F0aW9uSWQgPSAwO1xuICAgICAgICByb3V0ZXIuYmVmb3JlRWFjaCgodG8sIGZyb20pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgZ3VhcmQ6IGZvcm1hdERpc3BsYXkoJ2JlZm9yZUVhY2gnKSxcbiAgICAgICAgICAgICAgICBmcm9tOiBmb3JtYXRSb3V0ZUxvY2F0aW9uKGZyb20sICdDdXJyZW50IExvY2F0aW9uIGR1cmluZyB0aGlzIG5hdmlnYXRpb24nKSxcbiAgICAgICAgICAgICAgICB0bzogZm9ybWF0Um91dGVMb2NhdGlvbih0bywgJ1RhcmdldCBsb2NhdGlvbicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFVzZWQgdG8gZ3JvdXAgbmF2aWdhdGlvbnMgdG9nZXRoZXIsIGhpZGUgZnJvbSBkZXZ0b29sc1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLm1ldGEsICdfX25hdmlnYXRpb25JZCcsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmF2aWdhdGlvbklkKyssXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFwaS5hZGRUaW1lbGluZUV2ZW50KHtcbiAgICAgICAgICAgICAgICBsYXllcklkOiBuYXZpZ2F0aW9uc0xheWVySWQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdGltZTogYXBpLm5vdygpLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1N0YXJ0IG9mIG5hdmlnYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICBzdWJ0aXRsZTogdG8uZnVsbFBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwSWQ6IHRvLm1ldGEuX19uYXZpZ2F0aW9uSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcm91dGVyLmFmdGVyRWFjaCgodG8sIGZyb20sIGZhaWx1cmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgZ3VhcmQ6IGZvcm1hdERpc3BsYXkoJ2FmdGVyRWFjaCcpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5mYWlsdXJlID0ge1xuICAgICAgICAgICAgICAgICAgICBfY3VzdG9tOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmFpbHVyZSA/IGZhaWx1cmUubWVzc2FnZSA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogJ05hdmlnYXRpb24gRmFpbHVyZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZmFpbHVyZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRhdGEuc3RhdHVzID0gZm9ybWF0RGlzcGxheSgn4p2MJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhLnN0YXR1cyA9IGZvcm1hdERpc3BsYXkoJ+KchScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2Ugc2V0IGhlcmUgdG8gaGF2ZSB0aGUgcmlnaHQgb3JkZXJcbiAgICAgICAgICAgIGRhdGEuZnJvbSA9IGZvcm1hdFJvdXRlTG9jYXRpb24oZnJvbSwgJ0N1cnJlbnQgTG9jYXRpb24gZHVyaW5nIHRoaXMgbmF2aWdhdGlvbicpO1xuICAgICAgICAgICAgZGF0YS50byA9IGZvcm1hdFJvdXRlTG9jYXRpb24odG8sICdUYXJnZXQgbG9jYXRpb24nKTtcbiAgICAgICAgICAgIGFwaS5hZGRUaW1lbGluZUV2ZW50KHtcbiAgICAgICAgICAgICAgICBsYXllcklkOiBuYXZpZ2F0aW9uc0xheWVySWQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdFbmQgb2YgbmF2aWdhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlOiB0by5mdWxsUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgdGltZTogYXBpLm5vdygpLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBsb2dUeXBlOiBmYWlsdXJlID8gJ3dhcm5pbmcnIDogJ2RlZmF1bHQnLFxuICAgICAgICAgICAgICAgICAgICBncm91cElkOiB0by5tZXRhLl9fbmF2aWdhdGlvbklkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNwZWN0b3Igb2YgRXhpc3Rpbmcgcm91dGVzXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByb3V0ZXJJbnNwZWN0b3JJZCA9ICdyb3V0ZXItaW5zcGVjdG9yOicgKyBpZDtcbiAgICAgICAgYXBpLmFkZEluc3BlY3Rvcih7XG4gICAgICAgICAgICBpZDogcm91dGVySW5zcGVjdG9ySWQsXG4gICAgICAgICAgICBsYWJlbDogJ1JvdXRlcycgKyAoaWQgPyAnICcgKyBpZCA6ICcnKSxcbiAgICAgICAgICAgIGljb246ICdib29rJyxcbiAgICAgICAgICAgIHRyZWVGaWx0ZXJQbGFjZWhvbGRlcjogJ1NlYXJjaCByb3V0ZXMnLFxuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gcmVmcmVzaFJvdXRlc1ZpZXcoKSB7XG4gICAgICAgICAgICAvLyB0aGUgcm91dGVzIHZpZXcgaXNuJ3QgYWN0aXZlXG4gICAgICAgICAgICBpZiAoIWFjdGl2ZVJvdXRlc1BheWxvYWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGFjdGl2ZVJvdXRlc1BheWxvYWQ7XG4gICAgICAgICAgICAvLyBjaGlsZHJlbiByb3V0ZXMgd2lsbCBhcHBlYXIgYXMgbmVzdGVkXG4gICAgICAgICAgICBsZXQgcm91dGVzID0gbWF0Y2hlci5nZXRSb3V0ZXMoKS5maWx0ZXIocm91dGUgPT4gIXJvdXRlLnBhcmVudCB8fFxuICAgICAgICAgICAgICAgIC8vIHRoZXNlIHJvdXRlcyBoYXZlIGEgcGFyZW50IHdpdGggbm8gY29tcG9uZW50IHdoaWNoIHdpbGwgbm90IGFwcGVhciBpbiB0aGUgdmlld1xuICAgICAgICAgICAgICAgIC8vIHRoZXJlZm9yZSB3ZSBzdGlsbCBuZWVkIHRvIGluY2x1ZGUgdGhlbVxuICAgICAgICAgICAgICAgICFyb3V0ZS5wYXJlbnQucmVjb3JkLmNvbXBvbmVudHMpO1xuICAgICAgICAgICAgLy8gcmVzZXQgbWF0Y2ggc3RhdGUgdG8gZmFsc2VcbiAgICAgICAgICAgIHJvdXRlcy5mb3JFYWNoKHJlc2V0TWF0Y2hTdGF0ZU9uUm91dGVSZWNvcmQpO1xuICAgICAgICAgICAgLy8gYXBwbHkgYSBtYXRjaCBzdGF0ZSBpZiB0aGVyZSBpcyBhIHBheWxvYWRcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmZpbHRlcikge1xuICAgICAgICAgICAgICAgIHJvdXRlcyA9IHJvdXRlcy5maWx0ZXIocm91dGUgPT4gXG4gICAgICAgICAgICAgICAgLy8gc2F2ZSBtYXRjaGVzIHN0YXRlIGJhc2VkIG9uIHRoZSBwYXlsb2FkXG4gICAgICAgICAgICAgICAgaXNSb3V0ZU1hdGNoaW5nKHJvdXRlLCBwYXlsb2FkLmZpbHRlci50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYXJrIGFjdGl2ZSByb3V0ZXNcbiAgICAgICAgICAgIHJvdXRlcy5mb3JFYWNoKHJvdXRlID0+IG1hcmtSb3V0ZVJlY29yZEFjdGl2ZShyb3V0ZSwgcm91dGVyLmN1cnJlbnRSb3V0ZS52YWx1ZSkpO1xuICAgICAgICAgICAgcGF5bG9hZC5yb290Tm9kZXMgPSByb3V0ZXMubWFwKGZvcm1hdFJvdXRlUmVjb3JkRm9ySW5zcGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWN0aXZlUm91dGVzUGF5bG9hZDtcbiAgICAgICAgYXBpLm9uLmdldEluc3BlY3RvclRyZWUocGF5bG9hZCA9PiB7XG4gICAgICAgICAgICBhY3RpdmVSb3V0ZXNQYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmFwcCA9PT0gYXBwICYmIHBheWxvYWQuaW5zcGVjdG9ySWQgPT09IHJvdXRlckluc3BlY3RvcklkKSB7XG4gICAgICAgICAgICAgICAgcmVmcmVzaFJvdXRlc1ZpZXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgcm91dGUgcmVjb3JkXG4gICAgICAgICAqL1xuICAgICAgICBhcGkub24uZ2V0SW5zcGVjdG9yU3RhdGUocGF5bG9hZCA9PiB7XG4gICAgICAgICAgICBpZiAocGF5bG9hZC5hcHAgPT09IGFwcCAmJiBwYXlsb2FkLmluc3BlY3RvcklkID09PSByb3V0ZXJJbnNwZWN0b3JJZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlcyA9IG1hdGNoZXIuZ2V0Um91dGVzKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91dGUgPSByb3V0ZXMuZmluZChyb3V0ZSA9PiByb3V0ZS5yZWNvcmQuX192ZF9pZCA9PT0gcGF5bG9hZC5ub2RlSWQpO1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogZm9ybWF0Um91dGVSZWNvcmRNYXRjaGVyRm9yU3RhdGVJbnNwZWN0b3Iocm91dGUpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yVHJlZShyb3V0ZXJJbnNwZWN0b3JJZCk7XG4gICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yU3RhdGUocm91dGVySW5zcGVjdG9ySWQpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbW9kaWZpZXJGb3JLZXkoa2V5KSB7XG4gICAgaWYgKGtleS5vcHRpb25hbCkge1xuICAgICAgICByZXR1cm4ga2V5LnJlcGVhdGFibGUgPyAnKicgOiAnPyc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ga2V5LnJlcGVhdGFibGUgPyAnKycgOiAnJztcbiAgICB9XG59XG5mdW5jdGlvbiBmb3JtYXRSb3V0ZVJlY29yZE1hdGNoZXJGb3JTdGF0ZUluc3BlY3Rvcihyb3V0ZSkge1xuICAgIGNvbnN0IHsgcmVjb3JkIH0gPSByb3V0ZTtcbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIHsgZWRpdGFibGU6IGZhbHNlLCBrZXk6ICdwYXRoJywgdmFsdWU6IHJlY29yZC5wYXRoIH0sXG4gICAgXTtcbiAgICBpZiAocmVjb3JkLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICBmaWVsZHMucHVzaCh7XG4gICAgICAgICAgICBlZGl0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBrZXk6ICduYW1lJyxcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQubmFtZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZpZWxkcy5wdXNoKHsgZWRpdGFibGU6IGZhbHNlLCBrZXk6ICdyZWdleHAnLCB2YWx1ZTogcm91dGUucmUgfSk7XG4gICAgaWYgKHJvdXRlLmtleXMubGVuZ3RoKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgIGVkaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGtleTogJ2tleXMnLFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBfY3VzdG9tOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiByb3V0ZS5rZXlzXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGtleSA9PiBgJHtrZXkubmFtZX0ke21vZGlmaWVyRm9yS2V5KGtleSl9YClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcgJyksXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6ICdQYXJhbSBrZXlzJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJvdXRlLmtleXMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocmVjb3JkLnJlZGlyZWN0ICE9IG51bGwpIHtcbiAgICAgICAgZmllbGRzLnB1c2goe1xuICAgICAgICAgICAgZWRpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAga2V5OiAncmVkaXJlY3QnLFxuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5yZWRpcmVjdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChyb3V0ZS5hbGlhcy5sZW5ndGgpIHtcbiAgICAgICAgZmllbGRzLnB1c2goe1xuICAgICAgICAgICAgZWRpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAga2V5OiAnYWxpYXNlcycsXG4gICAgICAgICAgICB2YWx1ZTogcm91dGUuYWxpYXMubWFwKGFsaWFzID0+IGFsaWFzLnJlY29yZC5wYXRoKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhyb3V0ZS5yZWNvcmQubWV0YSkubGVuZ3RoKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgIGVkaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGtleTogJ21ldGEnLFxuICAgICAgICAgICAgdmFsdWU6IHJvdXRlLnJlY29yZC5tZXRhLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZmllbGRzLnB1c2goe1xuICAgICAgICBrZXk6ICdzY29yZScsXG4gICAgICAgIGVkaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIF9jdXN0b206IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6IHJvdXRlLnNjb3JlLm1hcChzY29yZSA9PiBzY29yZS5qb2luKCcsICcpKS5qb2luKCcgfCAnKSxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiAnU2NvcmUgdXNlZCB0byBzb3J0IHJvdXRlcycsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJvdXRlLnNjb3JlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gZmllbGRzO1xufVxuLyoqXG4gKiBFeHRyYWN0ZWQgZnJvbSB0YWlsd2luZCBwYWxldHRlXG4gKi9cbmNvbnN0IFBJTktfNTAwID0gMHhlYzQ4OTk7XG5jb25zdCBCTFVFXzYwMCA9IDB4MjU2M2ViO1xuY29uc3QgTElNRV81MDAgPSAweDg0Y2MxNjtcbmNvbnN0IENZQU5fNDAwID0gMHgyMmQzZWU7XG5jb25zdCBPUkFOR0VfNDAwID0gMHhmYjkyM2M7XG4vLyBjb25zdCBHUkFZXzEwMCA9IDB4ZjRmNGY1XG5jb25zdCBEQVJLID0gMHg2NjY2NjY7XG5mdW5jdGlvbiBmb3JtYXRSb3V0ZVJlY29yZEZvckluc3BlY3Rvcihyb3V0ZSkge1xuICAgIGNvbnN0IHRhZ3MgPSBbXTtcbiAgICBjb25zdCB7IHJlY29yZCB9ID0gcm91dGU7XG4gICAgaWYgKHJlY29yZC5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgdGFncy5wdXNoKHtcbiAgICAgICAgICAgIGxhYmVsOiBTdHJpbmcocmVjb3JkLm5hbWUpLFxuICAgICAgICAgICAgdGV4dENvbG9yOiAwLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBDWUFOXzQwMCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChyZWNvcmQuYWxpYXNPZikge1xuICAgICAgICB0YWdzLnB1c2goe1xuICAgICAgICAgICAgbGFiZWw6ICdhbGlhcycsXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IDAsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IE9SQU5HRV80MDAsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocm91dGUuX192ZF9tYXRjaCkge1xuICAgICAgICB0YWdzLnB1c2goe1xuICAgICAgICAgICAgbGFiZWw6ICdtYXRjaGVzJyxcbiAgICAgICAgICAgIHRleHRDb2xvcjogMCxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogUElOS181MDAsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocm91dGUuX192ZF9leGFjdEFjdGl2ZSkge1xuICAgICAgICB0YWdzLnB1c2goe1xuICAgICAgICAgICAgbGFiZWw6ICdleGFjdCcsXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IDAsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IExJTUVfNTAwLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHJvdXRlLl9fdmRfYWN0aXZlKSB7XG4gICAgICAgIHRhZ3MucHVzaCh7XG4gICAgICAgICAgICBsYWJlbDogJ2FjdGl2ZScsXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IDAsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IEJMVUVfNjAwLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHJlY29yZC5yZWRpcmVjdCkge1xuICAgICAgICB0YWdzLnB1c2goe1xuICAgICAgICAgICAgbGFiZWw6IHR5cGVvZiByZWNvcmQucmVkaXJlY3QgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBgcmVkaXJlY3Q6ICR7cmVjb3JkLnJlZGlyZWN0fWBcbiAgICAgICAgICAgICAgICA6ICdyZWRpcmVjdHMnLFxuICAgICAgICAgICAgdGV4dENvbG9yOiAweGZmZmZmZixcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogREFSSyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGFkZCBhbiBpZCB0byBiZSBhYmxlIHRvIHNlbGVjdCBpdC4gVXNpbmcgdGhlIGBwYXRoYCBpcyBub3QgcG9zc2libGUgYmVjYXVzZVxuICAgIC8vIGVtcHR5IHBhdGggY2hpbGRyZW4gd291bGQgY29sbGlkZSB3aXRoIHRoZWlyIHBhcmVudHNcbiAgICBsZXQgaWQgPSByZWNvcmQuX192ZF9pZDtcbiAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgICBpZCA9IFN0cmluZyhyb3V0ZVJlY29yZElkKyspO1xuICAgICAgICByZWNvcmQuX192ZF9pZCA9IGlkO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpZCxcbiAgICAgICAgbGFiZWw6IHJlY29yZC5wYXRoLFxuICAgICAgICB0YWdzLFxuICAgICAgICBjaGlsZHJlbjogcm91dGUuY2hpbGRyZW4ubWFwKGZvcm1hdFJvdXRlUmVjb3JkRm9ySW5zcGVjdG9yKSxcbiAgICB9O1xufVxuLy8gIGluY3JlbWVudGFsIGlkIGZvciByb3V0ZSByZWNvcmRzIGFuZCBpbnNwZWN0b3Igc3RhdGVcbmxldCByb3V0ZVJlY29yZElkID0gMDtcbmNvbnN0IEVYVFJBQ1RfUkVHRVhQX1JFID0gL15cXC8oLiopXFwvKFthLXpdKikkLztcbmZ1bmN0aW9uIG1hcmtSb3V0ZVJlY29yZEFjdGl2ZShyb3V0ZSwgY3VycmVudFJvdXRlKSB7XG4gICAgLy8gbm8gcm91dGUgd2lsbCBiZSBhY3RpdmUgaWYgbWF0Y2hlZCBpcyBlbXB0eVxuICAgIC8vIHJlc2V0IHRoZSBtYXRjaGluZyBzdGF0ZVxuICAgIGNvbnN0IGlzRXhhY3RBY3RpdmUgPSBjdXJyZW50Um91dGUubWF0Y2hlZC5sZW5ndGggJiZcbiAgICAgICAgaXNTYW1lUm91dGVSZWNvcmQoY3VycmVudFJvdXRlLm1hdGNoZWRbY3VycmVudFJvdXRlLm1hdGNoZWQubGVuZ3RoIC0gMV0sIHJvdXRlLnJlY29yZCk7XG4gICAgcm91dGUuX192ZF9leGFjdEFjdGl2ZSA9IHJvdXRlLl9fdmRfYWN0aXZlID0gaXNFeGFjdEFjdGl2ZTtcbiAgICBpZiAoIWlzRXhhY3RBY3RpdmUpIHtcbiAgICAgICAgcm91dGUuX192ZF9hY3RpdmUgPSBjdXJyZW50Um91dGUubWF0Y2hlZC5zb21lKG1hdGNoID0+IGlzU2FtZVJvdXRlUmVjb3JkKG1hdGNoLCByb3V0ZS5yZWNvcmQpKTtcbiAgICB9XG4gICAgcm91dGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZFJvdXRlID0+IG1hcmtSb3V0ZVJlY29yZEFjdGl2ZShjaGlsZFJvdXRlLCBjdXJyZW50Um91dGUpKTtcbn1cbmZ1bmN0aW9uIHJlc2V0TWF0Y2hTdGF0ZU9uUm91dGVSZWNvcmQocm91dGUpIHtcbiAgICByb3V0ZS5fX3ZkX21hdGNoID0gZmFsc2U7XG4gICAgcm91dGUuY2hpbGRyZW4uZm9yRWFjaChyZXNldE1hdGNoU3RhdGVPblJvdXRlUmVjb3JkKTtcbn1cbmZ1bmN0aW9uIGlzUm91dGVNYXRjaGluZyhyb3V0ZSwgZmlsdGVyKSB7XG4gICAgY29uc3QgZm91bmQgPSBTdHJpbmcocm91dGUucmUpLm1hdGNoKEVYVFJBQ1RfUkVHRVhQX1JFKTtcbiAgICByb3V0ZS5fX3ZkX21hdGNoID0gZmFsc2U7XG4gICAgaWYgKCFmb3VuZCB8fCBmb3VuZC5sZW5ndGggPCAzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gdXNlIGEgcmVnZXhwIHdpdGhvdXQgJCBhdCB0aGUgZW5kIHRvIG1hdGNoIG5lc3RlZCByb3V0ZXMgYmV0dGVyXG4gICAgY29uc3Qgbm9uRW5kaW5nUkUgPSBuZXcgUmVnRXhwKGZvdW5kWzFdLnJlcGxhY2UoL1xcJCQvLCAnJyksIGZvdW5kWzJdKTtcbiAgICBpZiAobm9uRW5kaW5nUkUudGVzdChmaWx0ZXIpKSB7XG4gICAgICAgIC8vIG1hcmsgY2hpbGRyZW4gYXMgbWF0Y2hlc1xuICAgICAgICByb3V0ZS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGlzUm91dGVNYXRjaGluZyhjaGlsZCwgZmlsdGVyKSk7XG4gICAgICAgIC8vIGV4Y2VwdGlvbiBjYXNlOiBgL2BcbiAgICAgICAgaWYgKHJvdXRlLnJlY29yZC5wYXRoICE9PSAnLycgfHwgZmlsdGVyID09PSAnLycpIHtcbiAgICAgICAgICAgIHJvdXRlLl9fdmRfbWF0Y2ggPSByb3V0ZS5yZS50ZXN0KGZpbHRlcik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBoaWRlIHRoZSAvIHJvdXRlXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IHJvdXRlLnJlY29yZC5wYXRoLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgZGVjb2RlZFBhdGggPSBkZWNvZGUocGF0aCk7XG4gICAgLy8gYWxzbyBhbGxvdyBwYXJ0aWFsIG1hdGNoaW5nIG9uIHRoZSBwYXRoXG4gICAgaWYgKCFmaWx0ZXIuc3RhcnRzV2l0aCgnLycpICYmXG4gICAgICAgIChkZWNvZGVkUGF0aC5pbmNsdWRlcyhmaWx0ZXIpIHx8IHBhdGguaW5jbHVkZXMoZmlsdGVyKSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChkZWNvZGVkUGF0aC5zdGFydHNXaXRoKGZpbHRlcikgfHwgcGF0aC5zdGFydHNXaXRoKGZpbHRlcikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChyb3V0ZS5yZWNvcmQubmFtZSAmJiBTdHJpbmcocm91dGUucmVjb3JkLm5hbWUpLmluY2x1ZGVzKGZpbHRlcikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiByb3V0ZS5jaGlsZHJlbi5zb21lKGNoaWxkID0+IGlzUm91dGVNYXRjaGluZyhjaGlsZCwgZmlsdGVyKSk7XG59XG5mdW5jdGlvbiBvbWl0KG9iaiwga2V5cykge1xuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoIWtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgcmV0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBSb3V0ZXIgaW5zdGFuY2UgdGhhdCBjYW4gYmUgdXNlZCBieSBhIFZ1ZSBhcHAuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSB7QGxpbmsgUm91dGVyT3B0aW9uc31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUm91dGVyKG9wdGlvbnMpIHtcbiAgICBjb25zdCBtYXRjaGVyID0gY3JlYXRlUm91dGVyTWF0Y2hlcihvcHRpb25zLnJvdXRlcywgb3B0aW9ucyk7XG4gICAgY29uc3QgcGFyc2VRdWVyeSQxID0gb3B0aW9ucy5wYXJzZVF1ZXJ5IHx8IHBhcnNlUXVlcnk7XG4gICAgY29uc3Qgc3RyaW5naWZ5UXVlcnkkMSA9IG9wdGlvbnMuc3RyaW5naWZ5UXVlcnkgfHwgc3RyaW5naWZ5UXVlcnk7XG4gICAgY29uc3Qgcm91dGVySGlzdG9yeSA9IG9wdGlvbnMuaGlzdG9yeTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFyb3V0ZXJIaXN0b3J5KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGUgdGhlIFwiaGlzdG9yeVwiIG9wdGlvbiB3aGVuIGNhbGxpbmcgXCJjcmVhdGVSb3V0ZXIoKVwiOicgK1xuICAgICAgICAgICAgJyBodHRwczovL25leHQucm91dGVyLnZ1ZWpzLm9yZy9hcGkvI2hpc3RvcnkuJyk7XG4gICAgY29uc3QgYmVmb3JlR3VhcmRzID0gdXNlQ2FsbGJhY2tzKCk7XG4gICAgY29uc3QgYmVmb3JlUmVzb2x2ZUd1YXJkcyA9IHVzZUNhbGxiYWNrcygpO1xuICAgIGNvbnN0IGFmdGVyR3VhcmRzID0gdXNlQ2FsbGJhY2tzKCk7XG4gICAgY29uc3QgY3VycmVudFJvdXRlID0gc2hhbGxvd1JlZihTVEFSVF9MT0NBVElPTl9OT1JNQUxJWkVEKTtcbiAgICBsZXQgcGVuZGluZ0xvY2F0aW9uID0gU1RBUlRfTE9DQVRJT05fTk9STUFMSVpFRDtcbiAgICAvLyBsZWF2ZSB0aGUgc2Nyb2xsUmVzdG9yYXRpb24gaWYgbm8gc2Nyb2xsQmVoYXZpb3IgaXMgcHJvdmlkZWRcbiAgICBpZiAoaXNCcm93c2VyICYmIG9wdGlvbnMuc2Nyb2xsQmVoYXZpb3IgJiYgJ3Njcm9sbFJlc3RvcmF0aW9uJyBpbiBoaXN0b3J5KSB7XG4gICAgICAgIGhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSAnbWFudWFsJztcbiAgICB9XG4gICAgY29uc3Qgbm9ybWFsaXplUGFyYW1zID0gYXBwbHlUb1BhcmFtcy5iaW5kKG51bGwsIHBhcmFtVmFsdWUgPT4gJycgKyBwYXJhbVZhbHVlKTtcbiAgICBjb25zdCBlbmNvZGVQYXJhbXMgPSBhcHBseVRvUGFyYW1zLmJpbmQobnVsbCwgZW5jb2RlUGFyYW0pO1xuICAgIGNvbnN0IGRlY29kZVBhcmFtcyA9IFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVudGlvbmFsbHkgYXZvaWQgdGhlIHR5cGUgY2hlY2tcbiAgICBhcHBseVRvUGFyYW1zLmJpbmQobnVsbCwgZGVjb2RlKTtcbiAgICBmdW5jdGlvbiBhZGRSb3V0ZShwYXJlbnRPclJvdXRlLCByb3V0ZSkge1xuICAgICAgICBsZXQgcGFyZW50O1xuICAgICAgICBsZXQgcmVjb3JkO1xuICAgICAgICBpZiAoaXNSb3V0ZU5hbWUocGFyZW50T3JSb3V0ZSkpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IG1hdGNoZXIuZ2V0UmVjb3JkTWF0Y2hlcihwYXJlbnRPclJvdXRlKTtcbiAgICAgICAgICAgIHJlY29yZCA9IHJvdXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVjb3JkID0gcGFyZW50T3JSb3V0ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0Y2hlci5hZGRSb3V0ZShyZWNvcmQsIHBhcmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZVJvdXRlKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVjb3JkTWF0Y2hlciA9IG1hdGNoZXIuZ2V0UmVjb3JkTWF0Y2hlcihuYW1lKTtcbiAgICAgICAgaWYgKHJlY29yZE1hdGNoZXIpIHtcbiAgICAgICAgICAgIG1hdGNoZXIucmVtb3ZlUm91dGUocmVjb3JkTWF0Y2hlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICB3YXJuKGBDYW5ub3QgcmVtb3ZlIG5vbi1leGlzdGVudCByb3V0ZSBcIiR7U3RyaW5nKG5hbWUpfVwiYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Um91dGVzKCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlci5nZXRSb3V0ZXMoKS5tYXAocm91dGVNYXRjaGVyID0+IHJvdXRlTWF0Y2hlci5yZWNvcmQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNSb3V0ZShuYW1lKSB7XG4gICAgICAgIHJldHVybiAhIW1hdGNoZXIuZ2V0UmVjb3JkTWF0Y2hlcihuYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZShyYXdMb2NhdGlvbiwgY3VycmVudExvY2F0aW9uKSB7XG4gICAgICAgIC8vIGNvbnN0IG9iamVjdExvY2F0aW9uID0gcm91dGVyTG9jYXRpb25Bc09iamVjdChyYXdMb2NhdGlvbilcbiAgICAgICAgLy8gd2UgY3JlYXRlIGEgY29weSB0byBtb2RpZnkgaXQgbGF0ZXJcbiAgICAgICAgY3VycmVudExvY2F0aW9uID0gYXNzaWduKHt9LCBjdXJyZW50TG9jYXRpb24gfHwgY3VycmVudFJvdXRlLnZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiByYXdMb2NhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uTm9ybWFsaXplZCA9IHBhcnNlVVJMKHBhcnNlUXVlcnkkMSwgcmF3TG9jYXRpb24sIGN1cnJlbnRMb2NhdGlvbi5wYXRoKTtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZWRSb3V0ZSA9IG1hdGNoZXIucmVzb2x2ZSh7IHBhdGg6IGxvY2F0aW9uTm9ybWFsaXplZC5wYXRoIH0sIGN1cnJlbnRMb2NhdGlvbik7XG4gICAgICAgICAgICBjb25zdCBocmVmID0gcm91dGVySGlzdG9yeS5jcmVhdGVIcmVmKGxvY2F0aW9uTm9ybWFsaXplZC5mdWxsUGF0aCk7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhyZWYuc3RhcnRzV2l0aCgnLy8nKSlcbiAgICAgICAgICAgICAgICAgICAgd2FybihgTG9jYXRpb24gXCIke3Jhd0xvY2F0aW9ufVwiIHJlc29sdmVkIHRvIFwiJHtocmVmfVwiLiBBIHJlc29sdmVkIGxvY2F0aW9uIGNhbm5vdCBzdGFydCB3aXRoIG11bHRpcGxlIHNsYXNoZXMuYCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIW1hdGNoZWRSb3V0ZS5tYXRjaGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBObyBtYXRjaCBmb3VuZCBmb3IgbG9jYXRpb24gd2l0aCBwYXRoIFwiJHtyYXdMb2NhdGlvbn1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxvY2F0aW9uTm9ybWFsaXplZCBpcyBhbHdheXMgYSBuZXcgb2JqZWN0XG4gICAgICAgICAgICByZXR1cm4gYXNzaWduKGxvY2F0aW9uTm9ybWFsaXplZCwgbWF0Y2hlZFJvdXRlLCB7XG4gICAgICAgICAgICAgICAgcGFyYW1zOiBkZWNvZGVQYXJhbXMobWF0Y2hlZFJvdXRlLnBhcmFtcyksXG4gICAgICAgICAgICAgICAgaGFzaDogZGVjb2RlKGxvY2F0aW9uTm9ybWFsaXplZC5oYXNoKSxcbiAgICAgICAgICAgICAgICByZWRpcmVjdGVkRnJvbTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWF0Y2hlckxvY2F0aW9uO1xuICAgICAgICAvLyBwYXRoIGNvdWxkIGJlIHJlbGF0aXZlIGluIG9iamVjdCBhcyB3ZWxsXG4gICAgICAgIGlmICgncGF0aCcgaW4gcmF3TG9jYXRpb24pIHtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICAncGFyYW1zJyBpbiByYXdMb2NhdGlvbiAmJlxuICAgICAgICAgICAgICAgICEoJ25hbWUnIGluIHJhd0xvY2F0aW9uKSAmJlxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHRoZSB0eXBlIGlzIG5ldmVyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocmF3TG9jYXRpb24ucGFyYW1zKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBQYXRoIFwiJHtyYXdMb2NhdGlvbi5wYXRofVwiIHdhcyBwYXNzZWQgd2l0aCBwYXJhbXMgYnV0IHRoZXkgd2lsbCBiZSBpZ25vcmVkLiBVc2UgYSBuYW1lZCByb3V0ZSBhbG9uZ3NpZGUgcGFyYW1zIGluc3RlYWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRjaGVyTG9jYXRpb24gPSBhc3NpZ24oe30sIHJhd0xvY2F0aW9uLCB7XG4gICAgICAgICAgICAgICAgcGF0aDogcGFyc2VVUkwocGFyc2VRdWVyeSQxLCByYXdMb2NhdGlvbi5wYXRoLCBjdXJyZW50TG9jYXRpb24ucGF0aCkucGF0aCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGFueSBudWxsaXNoIHBhcmFtXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRQYXJhbXMgPSBhc3NpZ24oe30sIHJhd0xvY2F0aW9uLnBhcmFtcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0YXJnZXRQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0UGFyYW1zW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0UGFyYW1zW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcGFzcyBlbmNvZGVkIHZhbHVlcyB0byB0aGUgbWF0Y2hlciwgc28gaXQgY2FuIHByb2R1Y2UgZW5jb2RlZCBwYXRoIGFuZCBmdWxsUGF0aFxuICAgICAgICAgICAgbWF0Y2hlckxvY2F0aW9uID0gYXNzaWduKHt9LCByYXdMb2NhdGlvbiwge1xuICAgICAgICAgICAgICAgIHBhcmFtczogZW5jb2RlUGFyYW1zKHRhcmdldFBhcmFtcyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgbG9jYXRpb24gcGFyYW1zIGFyZSBkZWNvZGVkLCB3ZSBuZWVkIHRvIGVuY29kZSB0aGVtIGluIGNhc2UgdGhlXG4gICAgICAgICAgICAvLyBtYXRjaGVyIG1lcmdlcyB0aGUgcGFyYW1zXG4gICAgICAgICAgICBjdXJyZW50TG9jYXRpb24ucGFyYW1zID0gZW5jb2RlUGFyYW1zKGN1cnJlbnRMb2NhdGlvbi5wYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hdGNoZWRSb3V0ZSA9IG1hdGNoZXIucmVzb2x2ZShtYXRjaGVyTG9jYXRpb24sIGN1cnJlbnRMb2NhdGlvbik7XG4gICAgICAgIGNvbnN0IGhhc2ggPSByYXdMb2NhdGlvbi5oYXNoIHx8ICcnO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGhhc2ggJiYgIWhhc2guc3RhcnRzV2l0aCgnIycpKSB7XG4gICAgICAgICAgICB3YXJuKGBBIFxcYGhhc2hcXGAgc2hvdWxkIGFsd2F5cyBzdGFydCB3aXRoIHRoZSBjaGFyYWN0ZXIgXCIjXCIuIFJlcGxhY2UgXCIke2hhc2h9XCIgd2l0aCBcIiMke2hhc2h9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIG1hdGNoZXIgbWlnaHQgaGF2ZSBtZXJnZWQgY3VycmVudCBsb2NhdGlvbiBwYXJhbXMsIHNvXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcnVuIHRoZSBkZWNvZGluZyBhZ2FpblxuICAgICAgICBtYXRjaGVkUm91dGUucGFyYW1zID0gbm9ybWFsaXplUGFyYW1zKGRlY29kZVBhcmFtcyhtYXRjaGVkUm91dGUucGFyYW1zKSk7XG4gICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gc3RyaW5naWZ5VVJMKHN0cmluZ2lmeVF1ZXJ5JDEsIGFzc2lnbih7fSwgcmF3TG9jYXRpb24sIHtcbiAgICAgICAgICAgIGhhc2g6IGVuY29kZUhhc2goaGFzaCksXG4gICAgICAgICAgICBwYXRoOiBtYXRjaGVkUm91dGUucGF0aCxcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBocmVmID0gcm91dGVySGlzdG9yeS5jcmVhdGVIcmVmKGZ1bGxQYXRoKTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgaWYgKGhyZWYuc3RhcnRzV2l0aCgnLy8nKSkge1xuICAgICAgICAgICAgICAgIHdhcm4oYExvY2F0aW9uIFwiJHtyYXdMb2NhdGlvbn1cIiByZXNvbHZlZCB0byBcIiR7aHJlZn1cIi4gQSByZXNvbHZlZCBsb2NhdGlvbiBjYW5ub3Qgc3RhcnQgd2l0aCBtdWx0aXBsZSBzbGFzaGVzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIW1hdGNoZWRSb3V0ZS5tYXRjaGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHdhcm4oYE5vIG1hdGNoIGZvdW5kIGZvciBsb2NhdGlvbiB3aXRoIHBhdGggXCIkeydwYXRoJyBpbiByYXdMb2NhdGlvbiA/IHJhd0xvY2F0aW9uLnBhdGggOiByYXdMb2NhdGlvbn1cImApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3NpZ24oe1xuICAgICAgICAgICAgZnVsbFBhdGgsXG4gICAgICAgICAgICAvLyBrZWVwIHRoZSBoYXNoIGVuY29kZWQgc28gZnVsbFBhdGggaXMgZWZmZWN0aXZlbHkgcGF0aCArIGVuY29kZWRRdWVyeSArXG4gICAgICAgICAgICAvLyBoYXNoXG4gICAgICAgICAgICBoYXNoLFxuICAgICAgICAgICAgcXVlcnk6IFxuICAgICAgICAgICAgLy8gaWYgdGhlIHVzZXIgaXMgdXNpbmcgYSBjdXN0b20gcXVlcnkgbGliIGxpa2UgcXMsIHdlIG1pZ2h0IGhhdmVcbiAgICAgICAgICAgIC8vIG5lc3RlZCBvYmplY3RzLCBzbyB3ZSBrZWVwIHRoZSBxdWVyeSBhcyBpcywgbWVhbmluZyBpdCBjYW4gY29udGFpblxuICAgICAgICAgICAgLy8gbnVtYmVycyBhdCBgJHJvdXRlLnF1ZXJ5YCwgYnV0IGF0IHRoZSBwb2ludCwgdGhlIHVzZXIgd2lsbCBoYXZlIHRvXG4gICAgICAgICAgICAvLyB1c2UgdGhlaXIgb3duIHR5cGUgYW55d2F5LlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3JvdXRlci9pc3N1ZXMvMzI4I2lzc3VlY29tbWVudC02NDk0ODE1NjdcbiAgICAgICAgICAgIHN0cmluZ2lmeVF1ZXJ5JDEgPT09IHN0cmluZ2lmeVF1ZXJ5XG4gICAgICAgICAgICAgICAgPyBub3JtYWxpemVRdWVyeShyYXdMb2NhdGlvbi5xdWVyeSlcbiAgICAgICAgICAgICAgICA6IChyYXdMb2NhdGlvbi5xdWVyeSB8fCB7fSksXG4gICAgICAgIH0sIG1hdGNoZWRSb3V0ZSwge1xuICAgICAgICAgICAgcmVkaXJlY3RlZEZyb206IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGhyZWYsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb2NhdGlvbkFzT2JqZWN0KHRvKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdG8gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IHBhcnNlVVJMKHBhcnNlUXVlcnkkMSwgdG8sIGN1cnJlbnRSb3V0ZS52YWx1ZS5wYXRoKVxuICAgICAgICAgICAgOiBhc3NpZ24oe30sIHRvKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tDYW5jZWxlZE5hdmlnYXRpb24odG8sIGZyb20pIHtcbiAgICAgICAgaWYgKHBlbmRpbmdMb2NhdGlvbiAhPT0gdG8pIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVSb3V0ZXJFcnJvcig4IC8qIEVycm9yVHlwZXMuTkFWSUdBVElPTl9DQU5DRUxMRUQgKi8sIHtcbiAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaCh0bykge1xuICAgICAgICByZXR1cm4gcHVzaFdpdGhSZWRpcmVjdCh0byk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcGxhY2UodG8pIHtcbiAgICAgICAgcmV0dXJuIHB1c2goYXNzaWduKGxvY2F0aW9uQXNPYmplY3QodG8pLCB7IHJlcGxhY2U6IHRydWUgfSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVSZWRpcmVjdFJlY29yZCh0bykge1xuICAgICAgICBjb25zdCBsYXN0TWF0Y2hlZCA9IHRvLm1hdGNoZWRbdG8ubWF0Y2hlZC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RNYXRjaGVkICYmIGxhc3RNYXRjaGVkLnJlZGlyZWN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlZGlyZWN0IH0gPSBsYXN0TWF0Y2hlZDtcbiAgICAgICAgICAgIGxldCBuZXdUYXJnZXRMb2NhdGlvbiA9IHR5cGVvZiByZWRpcmVjdCA9PT0gJ2Z1bmN0aW9uJyA/IHJlZGlyZWN0KHRvKSA6IHJlZGlyZWN0O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdUYXJnZXRMb2NhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBuZXdUYXJnZXRMb2NhdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgIG5ld1RhcmdldExvY2F0aW9uLmluY2x1ZGVzKCc/JykgfHwgbmV3VGFyZ2V0TG9jYXRpb24uaW5jbHVkZXMoJyMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAobmV3VGFyZ2V0TG9jYXRpb24gPSBsb2NhdGlvbkFzT2JqZWN0KG5ld1RhcmdldExvY2F0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogLy8gZm9yY2UgZW1wdHkgcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBwYXRoOiBuZXdUYXJnZXRMb2NhdGlvbiB9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGZvcmNlIGVtcHR5IHBhcmFtcyB3aGVuIGEgc3RyaW5nIGlzIHBhc3NlZCB0byBsZXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgcm91dGVyIHBhcnNlIHRoZW0gYWdhaW5cbiAgICAgICAgICAgICAgICBuZXdUYXJnZXRMb2NhdGlvbi5wYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICAhKCdwYXRoJyBpbiBuZXdUYXJnZXRMb2NhdGlvbikgJiZcbiAgICAgICAgICAgICAgICAhKCduYW1lJyBpbiBuZXdUYXJnZXRMb2NhdGlvbikpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBJbnZhbGlkIHJlZGlyZWN0IGZvdW5kOlxcbiR7SlNPTi5zdHJpbmdpZnkobmV3VGFyZ2V0TG9jYXRpb24sIG51bGwsIDIpfVxcbiB3aGVuIG5hdmlnYXRpbmcgdG8gXCIke3RvLmZ1bGxQYXRofVwiLiBBIHJlZGlyZWN0IG11c3QgY29udGFpbiBhIG5hbWUgb3IgcGF0aC4gVGhpcyB3aWxsIGJyZWFrIGluIHByb2R1Y3Rpb24uYCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlZGlyZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXNzaWduKHtcbiAgICAgICAgICAgICAgICBxdWVyeTogdG8ucXVlcnksXG4gICAgICAgICAgICAgICAgaGFzaDogdG8uaGFzaCxcbiAgICAgICAgICAgICAgICAvLyBhdm9pZCB0cmFuc2ZlcnJpbmcgcGFyYW1zIGlmIHRoZSByZWRpcmVjdCBoYXMgYSBwYXRoXG4gICAgICAgICAgICAgICAgcGFyYW1zOiAncGF0aCcgaW4gbmV3VGFyZ2V0TG9jYXRpb24gPyB7fSA6IHRvLnBhcmFtcyxcbiAgICAgICAgICAgIH0sIG5ld1RhcmdldExvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoV2l0aFJlZGlyZWN0KHRvLCByZWRpcmVjdGVkRnJvbSkge1xuICAgICAgICBjb25zdCB0YXJnZXRMb2NhdGlvbiA9IChwZW5kaW5nTG9jYXRpb24gPSByZXNvbHZlKHRvKSk7XG4gICAgICAgIGNvbnN0IGZyb20gPSBjdXJyZW50Um91dGUudmFsdWU7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0by5zdGF0ZTtcbiAgICAgICAgY29uc3QgZm9yY2UgPSB0by5mb3JjZTtcbiAgICAgICAgLy8gdG8gY291bGQgYmUgYSBzdHJpbmcgd2hlcmUgYHJlcGxhY2VgIGlzIGEgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgcmVwbGFjZSA9IHRvLnJlcGxhY2UgPT09IHRydWU7XG4gICAgICAgIGNvbnN0IHNob3VsZFJlZGlyZWN0ID0gaGFuZGxlUmVkaXJlY3RSZWNvcmQodGFyZ2V0TG9jYXRpb24pO1xuICAgICAgICBpZiAoc2hvdWxkUmVkaXJlY3QpXG4gICAgICAgICAgICByZXR1cm4gcHVzaFdpdGhSZWRpcmVjdChhc3NpZ24obG9jYXRpb25Bc09iamVjdChzaG91bGRSZWRpcmVjdCksIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogdHlwZW9mIHNob3VsZFJlZGlyZWN0ID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgICAgICAgICA/IGFzc2lnbih7fSwgZGF0YSwgc2hvdWxkUmVkaXJlY3Quc3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIDogZGF0YSxcbiAgICAgICAgICAgICAgICBmb3JjZSxcbiAgICAgICAgICAgICAgICByZXBsYWNlLFxuICAgICAgICAgICAgfSksIFxuICAgICAgICAgICAgLy8ga2VlcCBvcmlnaW5hbCByZWRpcmVjdGVkRnJvbSBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgIHJlZGlyZWN0ZWRGcm9tIHx8IHRhcmdldExvY2F0aW9uKTtcbiAgICAgICAgLy8gaWYgaXQgd2FzIGEgcmVkaXJlY3Qgd2UgYWxyZWFkeSBjYWxsZWQgYHB1c2hXaXRoUmVkaXJlY3RgIGFib3ZlXG4gICAgICAgIGNvbnN0IHRvTG9jYXRpb24gPSB0YXJnZXRMb2NhdGlvbjtcbiAgICAgICAgdG9Mb2NhdGlvbi5yZWRpcmVjdGVkRnJvbSA9IHJlZGlyZWN0ZWRGcm9tO1xuICAgICAgICBsZXQgZmFpbHVyZTtcbiAgICAgICAgaWYgKCFmb3JjZSAmJiBpc1NhbWVSb3V0ZUxvY2F0aW9uKHN0cmluZ2lmeVF1ZXJ5JDEsIGZyb20sIHRhcmdldExvY2F0aW9uKSkge1xuICAgICAgICAgICAgZmFpbHVyZSA9IGNyZWF0ZVJvdXRlckVycm9yKDE2IC8qIEVycm9yVHlwZXMuTkFWSUdBVElPTl9EVVBMSUNBVEVEICovLCB7IHRvOiB0b0xvY2F0aW9uLCBmcm9tIH0pO1xuICAgICAgICAgICAgLy8gdHJpZ2dlciBzY3JvbGwgdG8gYWxsb3cgc2Nyb2xsaW5nIHRvIHRoZSBzYW1lIGFuY2hvclxuICAgICAgICAgICAgaGFuZGxlU2Nyb2xsKGZyb20sIGZyb20sIFxuICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHB1c2gsIHRoZSBvbmx5IHdheSBmb3IgaXQgdG8gYmUgdHJpZ2dlcmVkIGZyb20gYVxuICAgICAgICAgICAgLy8gaGlzdG9yeS5saXN0ZW4gaXMgd2l0aCBhIHJlZGlyZWN0LCB3aGljaCBtYWtlcyBpdCBiZWNvbWUgYSBwdXNoXG4gICAgICAgICAgICB0cnVlLCBcbiAgICAgICAgICAgIC8vIFRoaXMgY2Fubm90IGJlIHRoZSBmaXJzdCBuYXZpZ2F0aW9uIGJlY2F1c2UgdGhlIGluaXRpYWwgbG9jYXRpb25cbiAgICAgICAgICAgIC8vIGNhbm5vdCBiZSBtYW51YWxseSBuYXZpZ2F0ZWQgdG9cbiAgICAgICAgICAgIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGZhaWx1cmUgPyBQcm9taXNlLnJlc29sdmUoZmFpbHVyZSkgOiBuYXZpZ2F0ZSh0b0xvY2F0aW9uLCBmcm9tKSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IGlzTmF2aWdhdGlvbkZhaWx1cmUoZXJyb3IpXG4gICAgICAgICAgICA/IC8vIG5hdmlnYXRpb24gcmVkaXJlY3RzIHN0aWxsIG1hcmsgdGhlIHJvdXRlciBhcyByZWFkeVxuICAgICAgICAgICAgICAgIGlzTmF2aWdhdGlvbkZhaWx1cmUoZXJyb3IsIDIgLyogRXJyb3JUeXBlcy5OQVZJR0FUSU9OX0dVQVJEX1JFRElSRUNUICovKVxuICAgICAgICAgICAgICAgICAgICA/IGVycm9yXG4gICAgICAgICAgICAgICAgICAgIDogbWFya0FzUmVhZHkoZXJyb3IpIC8vIGFsc28gcmV0dXJucyB0aGUgZXJyb3JcbiAgICAgICAgICAgIDogLy8gcmVqZWN0IGFueSB1bmtub3duIGVycm9yXG4gICAgICAgICAgICAgICAgdHJpZ2dlckVycm9yKGVycm9yLCB0b0xvY2F0aW9uLCBmcm9tKSlcbiAgICAgICAgICAgIC50aGVuKChmYWlsdXJlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc05hdmlnYXRpb25GYWlsdXJlKGZhaWx1cmUsIDIgLyogRXJyb3JUeXBlcy5OQVZJR0FUSU9OX0dVQVJEX1JFRElSRUNUICovKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgcmVkaXJlY3RpbmcgdG8gdGhlIHNhbWUgbG9jYXRpb24gd2Ugd2VyZSBhbHJlYWR5IGF0XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NhbWVSb3V0ZUxvY2F0aW9uKHN0cmluZ2lmeVF1ZXJ5JDEsIHJlc29sdmUoZmFpbHVyZS50byksIHRvTG9jYXRpb24pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgd2UgaGF2ZSBkb25lIGl0IGEgY291cGxlIG9mIHRpbWVzXG4gICAgICAgICAgICAgICAgICAgICAgICByZWRpcmVjdGVkRnJvbSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYWRkZWQgb25seSBpbiBkZXZcbiAgICAgICAgICAgICAgICAgICAgICAgIChyZWRpcmVjdGVkRnJvbS5fY291bnQgPSByZWRpcmVjdGVkRnJvbS5fY291bnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RlZEZyb20uX2NvdW50ICsgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogMSkgPiAzMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgRGV0ZWN0ZWQgYSBwb3NzaWJseSBpbmZpbml0ZSByZWRpcmVjdGlvbiBpbiBhIG5hdmlnYXRpb24gZ3VhcmQgd2hlbiBnb2luZyBmcm9tIFwiJHtmcm9tLmZ1bGxQYXRofVwiIHRvIFwiJHt0b0xvY2F0aW9uLmZ1bGxQYXRofVwiLiBBYm9ydGluZyB0byBhdm9pZCBhIFN0YWNrIE92ZXJmbG93LlxcbiBBcmUgeW91IGFsd2F5cyByZXR1cm5pbmcgYSBuZXcgbG9jYXRpb24gd2l0aGluIGEgbmF2aWdhdGlvbiBndWFyZD8gVGhhdCB3b3VsZCBsZWFkIHRvIHRoaXMgZXJyb3IuIE9ubHkgcmV0dXJuIHdoZW4gcmVkaXJlY3Rpbmcgb3IgYWJvcnRpbmcsIHRoYXQgc2hvdWxkIGZpeCB0aGlzLiBUaGlzIG1pZ2h0IGJyZWFrIGluIHByb2R1Y3Rpb24gaWYgbm90IGZpeGVkLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignSW5maW5pdGUgcmVkaXJlY3QgaW4gbmF2aWdhdGlvbiBndWFyZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHVzaFdpdGhSZWRpcmVjdChcbiAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmVzZXJ2ZSBhbiBleGlzdGluZyByZXBsYWNlbWVudCBidXQgYWxsb3cgdGhlIHJlZGlyZWN0IHRvIG92ZXJyaWRlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlLFxuICAgICAgICAgICAgICAgICAgICB9LCBsb2NhdGlvbkFzT2JqZWN0KGZhaWx1cmUudG8pLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogdHlwZW9mIGZhaWx1cmUudG8gPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhc3NpZ24oe30sIGRhdGEsIGZhaWx1cmUudG8uc3RhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2UsXG4gICAgICAgICAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJlc2VydmUgdGhlIG9yaWdpbmFsIHJlZGlyZWN0ZWRGcm9tIGlmIGFueVxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdGVkRnJvbSB8fCB0b0xvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBmYWlsIHdlIGRvbid0IGZpbmFsaXplIHRoZSBuYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgZmFpbHVyZSA9IGZpbmFsaXplTmF2aWdhdGlvbih0b0xvY2F0aW9uLCBmcm9tLCB0cnVlLCByZXBsYWNlLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJBZnRlckVhY2godG9Mb2NhdGlvbiwgZnJvbSwgZmFpbHVyZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFpbHVyZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciB0byByZWplY3QgYW5kIHNraXAgYWxsIG5hdmlnYXRpb24gZ3VhcmRzIGlmIGEgbmV3IG5hdmlnYXRpb24gaGFwcGVuZWRcbiAgICAgKiBAcGFyYW0gdG9cbiAgICAgKiBAcGFyYW0gZnJvbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrQ2FuY2VsZWROYXZpZ2F0aW9uQW5kUmVqZWN0KHRvLCBmcm9tKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gY2hlY2tDYW5jZWxlZE5hdmlnYXRpb24odG8sIGZyb20pO1xuICAgICAgICByZXR1cm4gZXJyb3IgPyBQcm9taXNlLnJlamVjdChlcnJvcikgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcnVuV2l0aENvbnRleHQoZm4pIHtcbiAgICAgICAgY29uc3QgYXBwID0gaW5zdGFsbGVkQXBwcy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICAgIC8vIHN1cHBvcnQgVnVlIDwgMy4zXG4gICAgICAgIHJldHVybiBhcHAgJiYgdHlwZW9mIGFwcC5ydW5XaXRoQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBhcHAucnVuV2l0aENvbnRleHQoZm4pXG4gICAgICAgICAgICA6IGZuKCk7XG4gICAgfVxuICAgIC8vIFRPRE86IHJlZmFjdG9yIHRoZSB3aG9sZSBiZWZvcmUgZ3VhcmRzIGJ5IGludGVybmFsbHkgdXNpbmcgcm91dGVyLmJlZm9yZUVhY2hcbiAgICBmdW5jdGlvbiBuYXZpZ2F0ZSh0bywgZnJvbSkge1xuICAgICAgICBsZXQgZ3VhcmRzO1xuICAgICAgICBjb25zdCBbbGVhdmluZ1JlY29yZHMsIHVwZGF0aW5nUmVjb3JkcywgZW50ZXJpbmdSZWNvcmRzXSA9IGV4dHJhY3RDaGFuZ2luZ1JlY29yZHModG8sIGZyb20pO1xuICAgICAgICAvLyBhbGwgY29tcG9uZW50cyBoZXJlIGhhdmUgYmVlbiByZXNvbHZlZCBvbmNlIGJlY2F1c2Ugd2UgYXJlIGxlYXZpbmdcbiAgICAgICAgZ3VhcmRzID0gZXh0cmFjdENvbXBvbmVudHNHdWFyZHMobGVhdmluZ1JlY29yZHMucmV2ZXJzZSgpLCAnYmVmb3JlUm91dGVMZWF2ZScsIHRvLCBmcm9tKTtcbiAgICAgICAgLy8gbGVhdmluZ1JlY29yZHMgaXMgYWxyZWFkeSByZXZlcnNlZFxuICAgICAgICBmb3IgKGNvbnN0IHJlY29yZCBvZiBsZWF2aW5nUmVjb3Jkcykge1xuICAgICAgICAgICAgcmVjb3JkLmxlYXZlR3VhcmRzLmZvckVhY2goZ3VhcmQgPT4ge1xuICAgICAgICAgICAgICAgIGd1YXJkcy5wdXNoKGd1YXJkVG9Qcm9taXNlRm4oZ3VhcmQsIHRvLCBmcm9tKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW5jZWxlZE5hdmlnYXRpb25DaGVjayA9IGNoZWNrQ2FuY2VsZWROYXZpZ2F0aW9uQW5kUmVqZWN0LmJpbmQobnVsbCwgdG8sIGZyb20pO1xuICAgICAgICBndWFyZHMucHVzaChjYW5jZWxlZE5hdmlnYXRpb25DaGVjayk7XG4gICAgICAgIC8vIHJ1biB0aGUgcXVldWUgb2YgcGVyIHJvdXRlIGJlZm9yZVJvdXRlTGVhdmUgZ3VhcmRzXG4gICAgICAgIHJldHVybiAocnVuR3VhcmRRdWV1ZShndWFyZHMpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAvLyBjaGVjayBnbG9iYWwgZ3VhcmRzIGJlZm9yZUVhY2hcbiAgICAgICAgICAgIGd1YXJkcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBndWFyZCBvZiBiZWZvcmVHdWFyZHMubGlzdCgpKSB7XG4gICAgICAgICAgICAgICAgZ3VhcmRzLnB1c2goZ3VhcmRUb1Byb21pc2VGbihndWFyZCwgdG8sIGZyb20pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGd1YXJkcy5wdXNoKGNhbmNlbGVkTmF2aWdhdGlvbkNoZWNrKTtcbiAgICAgICAgICAgIHJldHVybiBydW5HdWFyZFF1ZXVlKGd1YXJkcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAvLyBjaGVjayBpbiBjb21wb25lbnRzIGJlZm9yZVJvdXRlVXBkYXRlXG4gICAgICAgICAgICBndWFyZHMgPSBleHRyYWN0Q29tcG9uZW50c0d1YXJkcyh1cGRhdGluZ1JlY29yZHMsICdiZWZvcmVSb3V0ZVVwZGF0ZScsIHRvLCBmcm9tKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIHVwZGF0aW5nUmVjb3Jkcykge1xuICAgICAgICAgICAgICAgIHJlY29yZC51cGRhdGVHdWFyZHMuZm9yRWFjaChndWFyZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGd1YXJkcy5wdXNoKGd1YXJkVG9Qcm9taXNlRm4oZ3VhcmQsIHRvLCBmcm9tKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBndWFyZHMucHVzaChjYW5jZWxlZE5hdmlnYXRpb25DaGVjayk7XG4gICAgICAgICAgICAvLyBydW4gdGhlIHF1ZXVlIG9mIHBlciByb3V0ZSBiZWZvcmVFbnRlciBndWFyZHNcbiAgICAgICAgICAgIHJldHVybiBydW5HdWFyZFF1ZXVlKGd1YXJkcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAvLyBjaGVjayB0aGUgcm91dGUgYmVmb3JlRW50ZXJcbiAgICAgICAgICAgIGd1YXJkcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCByZWNvcmQgb2YgZW50ZXJpbmdSZWNvcmRzKSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IHRyaWdnZXIgYmVmb3JlRW50ZXIgb24gcmV1c2VkIHZpZXdzXG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC5iZWZvcmVFbnRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShyZWNvcmQuYmVmb3JlRW50ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJlZm9yZUVudGVyIG9mIHJlY29yZC5iZWZvcmVFbnRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBndWFyZHMucHVzaChndWFyZFRvUHJvbWlzZUZuKGJlZm9yZUVudGVyLCB0bywgZnJvbSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3VhcmRzLnB1c2goZ3VhcmRUb1Byb21pc2VGbihyZWNvcmQuYmVmb3JlRW50ZXIsIHRvLCBmcm9tKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBndWFyZHMucHVzaChjYW5jZWxlZE5hdmlnYXRpb25DaGVjayk7XG4gICAgICAgICAgICAvLyBydW4gdGhlIHF1ZXVlIG9mIHBlciByb3V0ZSBiZWZvcmVFbnRlciBndWFyZHNcbiAgICAgICAgICAgIHJldHVybiBydW5HdWFyZFF1ZXVlKGd1YXJkcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAvLyBOT1RFOiBhdCB0aGlzIHBvaW50IHRvLm1hdGNoZWQgaXMgbm9ybWFsaXplZCBhbmQgZG9lcyBub3QgY29udGFpbiBhbnkgKCkgPT4gUHJvbWlzZTxDb21wb25lbnQ+XG4gICAgICAgICAgICAvLyBjbGVhciBleGlzdGluZyBlbnRlckNhbGxiYWNrcywgdGhlc2UgYXJlIGFkZGVkIGJ5IGV4dHJhY3RDb21wb25lbnRzR3VhcmRzXG4gICAgICAgICAgICB0by5tYXRjaGVkLmZvckVhY2gocmVjb3JkID0+IChyZWNvcmQuZW50ZXJDYWxsYmFja3MgPSB7fSkpO1xuICAgICAgICAgICAgLy8gY2hlY2sgaW4tY29tcG9uZW50IGJlZm9yZVJvdXRlRW50ZXJcbiAgICAgICAgICAgIGd1YXJkcyA9IGV4dHJhY3RDb21wb25lbnRzR3VhcmRzKGVudGVyaW5nUmVjb3JkcywgJ2JlZm9yZVJvdXRlRW50ZXInLCB0bywgZnJvbSk7XG4gICAgICAgICAgICBndWFyZHMucHVzaChjYW5jZWxlZE5hdmlnYXRpb25DaGVjayk7XG4gICAgICAgICAgICAvLyBydW4gdGhlIHF1ZXVlIG9mIHBlciByb3V0ZSBiZWZvcmVFbnRlciBndWFyZHNcbiAgICAgICAgICAgIHJldHVybiBydW5HdWFyZFF1ZXVlKGd1YXJkcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAvLyBjaGVjayBnbG9iYWwgZ3VhcmRzIGJlZm9yZVJlc29sdmVcbiAgICAgICAgICAgIGd1YXJkcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBndWFyZCBvZiBiZWZvcmVSZXNvbHZlR3VhcmRzLmxpc3QoKSkge1xuICAgICAgICAgICAgICAgIGd1YXJkcy5wdXNoKGd1YXJkVG9Qcm9taXNlRm4oZ3VhcmQsIHRvLCBmcm9tKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBndWFyZHMucHVzaChjYW5jZWxlZE5hdmlnYXRpb25DaGVjayk7XG4gICAgICAgICAgICByZXR1cm4gcnVuR3VhcmRRdWV1ZShndWFyZHMpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLy8gY2F0Y2ggYW55IG5hdmlnYXRpb24gY2FuY2VsZWRcbiAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gaXNOYXZpZ2F0aW9uRmFpbHVyZShlcnIsIDggLyogRXJyb3JUeXBlcy5OQVZJR0FUSU9OX0NBTkNFTExFRCAqLylcbiAgICAgICAgICAgID8gZXJyXG4gICAgICAgICAgICA6IFByb21pc2UucmVqZWN0KGVycikpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJpZ2dlckFmdGVyRWFjaCh0bywgZnJvbSwgZmFpbHVyZSkge1xuICAgICAgICAvLyBuYXZpZ2F0aW9uIGlzIGNvbmZpcm1lZCwgY2FsbCBhZnRlckd1YXJkc1xuICAgICAgICAvLyBUT0RPOiB3cmFwIHdpdGggZXJyb3IgaGFuZGxlcnNcbiAgICAgICAgYWZ0ZXJHdWFyZHNcbiAgICAgICAgICAgIC5saXN0KClcbiAgICAgICAgICAgIC5mb3JFYWNoKGd1YXJkID0+IHJ1bldpdGhDb250ZXh0KCgpID0+IGd1YXJkKHRvLCBmcm9tLCBmYWlsdXJlKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAtIENsZWFucyB1cCBhbnkgbmF2aWdhdGlvbiBndWFyZHNcbiAgICAgKiAtIENoYW5nZXMgdGhlIHVybCBpZiBuZWNlc3NhcnlcbiAgICAgKiAtIENhbGxzIHRoZSBzY3JvbGxCZWhhdmlvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmFsaXplTmF2aWdhdGlvbih0b0xvY2F0aW9uLCBmcm9tLCBpc1B1c2gsIHJlcGxhY2UsIGRhdGEpIHtcbiAgICAgICAgLy8gYSBtb3JlIHJlY2VudCBuYXZpZ2F0aW9uIHRvb2sgcGxhY2VcbiAgICAgICAgY29uc3QgZXJyb3IgPSBjaGVja0NhbmNlbGVkTmF2aWdhdGlvbih0b0xvY2F0aW9uLCBmcm9tKTtcbiAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAvLyBvbmx5IGNvbnNpZGVyIGFzIHB1c2ggaWYgaXQncyBub3QgdGhlIGZpcnN0IG5hdmlnYXRpb25cbiAgICAgICAgY29uc3QgaXNGaXJzdE5hdmlnYXRpb24gPSBmcm9tID09PSBTVEFSVF9MT0NBVElPTl9OT1JNQUxJWkVEO1xuICAgICAgICBjb25zdCBzdGF0ZSA9ICFpc0Jyb3dzZXIgPyB7fSA6IGhpc3Rvcnkuc3RhdGU7XG4gICAgICAgIC8vIGNoYW5nZSBVUkwgb25seSBpZiB0aGUgdXNlciBkaWQgYSBwdXNoL3JlcGxhY2UgYW5kIGlmIGl0J3Mgbm90IHRoZSBpbml0aWFsIG5hdmlnYXRpb24gYmVjYXVzZVxuICAgICAgICAvLyBpdCdzIGp1c3QgcmVmbGVjdGluZyB0aGUgdXJsXG4gICAgICAgIGlmIChpc1B1c2gpIHtcbiAgICAgICAgICAgIC8vIG9uIHRoZSBpbml0aWFsIG5hdmlnYXRpb24sIHdlIHdhbnQgdG8gcmV1c2UgdGhlIHNjcm9sbCBwb3NpdGlvbiBmcm9tXG4gICAgICAgICAgICAvLyBoaXN0b3J5IHN0YXRlIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgaWYgKHJlcGxhY2UgfHwgaXNGaXJzdE5hdmlnYXRpb24pXG4gICAgICAgICAgICAgICAgcm91dGVySGlzdG9yeS5yZXBsYWNlKHRvTG9jYXRpb24uZnVsbFBhdGgsIGFzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbDogaXNGaXJzdE5hdmlnYXRpb24gJiYgc3RhdGUgJiYgc3RhdGUuc2Nyb2xsLFxuICAgICAgICAgICAgICAgIH0sIGRhdGEpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByb3V0ZXJIaXN0b3J5LnB1c2godG9Mb2NhdGlvbi5mdWxsUGF0aCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWNjZXB0IGN1cnJlbnQgbmF2aWdhdGlvblxuICAgICAgICBjdXJyZW50Um91dGUudmFsdWUgPSB0b0xvY2F0aW9uO1xuICAgICAgICBoYW5kbGVTY3JvbGwodG9Mb2NhdGlvbiwgZnJvbSwgaXNQdXNoLCBpc0ZpcnN0TmF2aWdhdGlvbik7XG4gICAgICAgIG1hcmtBc1JlYWR5KCk7XG4gICAgfVxuICAgIGxldCByZW1vdmVIaXN0b3J5TGlzdGVuZXI7XG4gICAgLy8gYXR0YWNoIGxpc3RlbmVyIHRvIGhpc3RvcnkgdG8gdHJpZ2dlciBuYXZpZ2F0aW9uc1xuICAgIGZ1bmN0aW9uIHNldHVwTGlzdGVuZXJzKCkge1xuICAgICAgICAvLyBhdm9pZCBzZXR0aW5nIHVwIGxpc3RlbmVycyB0d2ljZSBkdWUgdG8gYW4gaW52YWxpZCBmaXJzdCBuYXZpZ2F0aW9uXG4gICAgICAgIGlmIChyZW1vdmVIaXN0b3J5TGlzdGVuZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJlbW92ZUhpc3RvcnlMaXN0ZW5lciA9IHJvdXRlckhpc3RvcnkubGlzdGVuKCh0bywgX2Zyb20sIGluZm8pID0+IHtcbiAgICAgICAgICAgIGlmICghcm91dGVyLmxpc3RlbmluZylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBjYW5ub3QgYmUgYSByZWRpcmVjdCByb3V0ZSBiZWNhdXNlIGl0IHdhcyBpbiBoaXN0b3J5XG4gICAgICAgICAgICBjb25zdCB0b0xvY2F0aW9uID0gcmVzb2x2ZSh0byk7XG4gICAgICAgICAgICAvLyBkdWUgdG8gZHluYW1pYyByb3V0aW5nLCBhbmQgdG8gaGFzaCBoaXN0b3J5IHdpdGggbWFudWFsIG5hdmlnYXRpb25cbiAgICAgICAgICAgIC8vIChtYW51YWxseSBjaGFuZ2luZyB0aGUgdXJsIG9yIGNhbGxpbmcgaGlzdG9yeS5oYXNoID0gJyMvc29tZXdoZXJlJyksXG4gICAgICAgICAgICAvLyB0aGVyZSBjb3VsZCBiZSBhIHJlZGlyZWN0IHJlY29yZCBpbiBoaXN0b3J5XG4gICAgICAgICAgICBjb25zdCBzaG91bGRSZWRpcmVjdCA9IGhhbmRsZVJlZGlyZWN0UmVjb3JkKHRvTG9jYXRpb24pO1xuICAgICAgICAgICAgaWYgKHNob3VsZFJlZGlyZWN0KSB7XG4gICAgICAgICAgICAgICAgcHVzaFdpdGhSZWRpcmVjdChhc3NpZ24oc2hvdWxkUmVkaXJlY3QsIHsgcmVwbGFjZTogdHJ1ZSB9KSwgdG9Mb2NhdGlvbikuY2F0Y2gobm9vcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVuZGluZ0xvY2F0aW9uID0gdG9Mb2NhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBjdXJyZW50Um91dGUudmFsdWU7XG4gICAgICAgICAgICAvLyBUT0RPOiBzaG91bGQgYmUgbW92ZWQgdG8gd2ViIGhpc3Rvcnk/XG4gICAgICAgICAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgICAgICAgICAgc2F2ZVNjcm9sbFBvc2l0aW9uKGdldFNjcm9sbEtleShmcm9tLmZ1bGxQYXRoLCBpbmZvLmRlbHRhKSwgY29tcHV0ZVNjcm9sbFBvc2l0aW9uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmF2aWdhdGUodG9Mb2NhdGlvbiwgZnJvbSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmF2aWdhdGlvbkZhaWx1cmUoZXJyb3IsIDQgLyogRXJyb3JUeXBlcy5OQVZJR0FUSU9OX0FCT1JURUQgKi8gfCA4IC8qIEVycm9yVHlwZXMuTkFWSUdBVElPTl9DQU5DRUxMRUQgKi8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzTmF2aWdhdGlvbkZhaWx1cmUoZXJyb3IsIDIgLyogRXJyb3JUeXBlcy5OQVZJR0FUSU9OX0dVQVJEX1JFRElSRUNUICovKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBIZXJlIHdlIGNvdWxkIGNhbGwgaWYgKGluZm8uZGVsdGEpIHJvdXRlckhpc3RvcnkuZ28oLWluZm8uZGVsdGEsXG4gICAgICAgICAgICAgICAgICAgIC8vIGZhbHNlKSBidXQgdGhpcyBpcyBidWcgcHJvbmUgYXMgd2UgaGF2ZSBubyB3YXkgdG8gd2FpdCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gbmF2aWdhdGlvbiB0byBiZSBmaW5pc2hlZCBiZWZvcmUgY2FsbGluZyBwdXNoV2l0aFJlZGlyZWN0LiBVc2luZ1xuICAgICAgICAgICAgICAgICAgICAvLyBhIHNldFRpbWVvdXQgb2YgMTZtcyBzZWVtcyB0byB3b3JrIGJ1dCB0aGVyZSBpcyBubyBndWFyYW50ZWUgZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IHRvIHdvcmsgb24gZXZlcnkgYnJvd3Nlci4gU28gaW5zdGVhZCB3ZSBkbyBub3QgcmVzdG9yZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gaGlzdG9yeSBlbnRyeSBhbmQgdHJpZ2dlciBhIG5ldyBuYXZpZ2F0aW9uIGFzIHJlcXVlc3RlZCBieSB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gbmF2aWdhdGlvbiBndWFyZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGVycm9yIGlzIGFscmVhZHkgaGFuZGxlZCBieSByb3V0ZXIucHVzaCB3ZSBqdXN0IHdhbnQgdG8gYXZvaWRcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9nZ2luZyB0aGUgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgcHVzaFdpdGhSZWRpcmVjdChlcnJvci50bywgdG9Mb2NhdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBhdm9pZCBhbiB1bmNhdWdodCByZWplY3Rpb24sIGxldCBwdXNoIGNhbGwgdHJpZ2dlckVycm9yXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZhaWx1cmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFudWFsIGNoYW5nZSBpbiBoYXNoIGhpc3RvcnkgIzkxNiBlbmRpbmcgdXAgaW4gdGhlIFVSTCBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYW5naW5nLCBidXQgaXQgd2FzIGNoYW5nZWQgYnkgdGhlIG1hbnVhbCB1cmwgY2hhbmdlLCBzbyB3ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBtYW51YWxseSBjaGFuZ2UgaXQgb3Vyc2VsdmVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYXZpZ2F0aW9uRmFpbHVyZShmYWlsdXJlLCA0IC8qIEVycm9yVHlwZXMuTkFWSUdBVElPTl9BQk9SVEVEICovIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNiAvKiBFcnJvclR5cGVzLk5BVklHQVRJT05fRFVQTElDQVRFRCAqLykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaW5mby5kZWx0YSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8udHlwZSA9PT0gTmF2aWdhdGlvblR5cGUucG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVySGlzdG9yeS5nbygtMSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKG5vb3ApO1xuICAgICAgICAgICAgICAgICAgICAvLyBhdm9pZCB0aGUgdGhlbiBicmFuY2hcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCByZXN0b3JlIGhpc3Rvcnkgb24gdW5rbm93biBkaXJlY3Rpb25cbiAgICAgICAgICAgICAgICBpZiAoaW5mby5kZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZXJIaXN0b3J5LmdvKC1pbmZvLmRlbHRhLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHVucmVjb2duaXplZCBlcnJvciwgdHJhbnNmZXIgdG8gdGhlIGdsb2JhbCBoYW5kbGVyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyaWdnZXJFcnJvcihlcnJvciwgdG9Mb2NhdGlvbiwgZnJvbSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChmYWlsdXJlKSA9PiB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZSA9XG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsaXplTmF2aWdhdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFmdGVyIG5hdmlnYXRpb24sIGFsbCBtYXRjaGVkIGNvbXBvbmVudHMgYXJlIHJlc29sdmVkXG4gICAgICAgICAgICAgICAgICAgICAgICB0b0xvY2F0aW9uLCBmcm9tLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgLy8gcmV2ZXJ0IHRoZSBuYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8uZGVsdGEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgbmV3IG5hdmlnYXRpb24gaGFzIGJlZW4gdHJpZ2dlcmVkLCBzbyB3ZSBkbyBub3Qgd2FudCB0byByZXZlcnQsIHRoYXQgd2lsbCBjaGFuZ2UgdGhlIGN1cnJlbnQgaGlzdG9yeVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW50cnkgd2hpbGUgYSBkaWZmZXJlbnQgcm91dGUgaXMgZGlzcGxheWVkXG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNOYXZpZ2F0aW9uRmFpbHVyZShmYWlsdXJlLCA4IC8qIEVycm9yVHlwZXMuTkFWSUdBVElPTl9DQU5DRUxMRUQgKi8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXJIaXN0b3J5LmdvKC1pbmZvLmRlbHRhLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5mby50eXBlID09PSBOYXZpZ2F0aW9uVHlwZS5wb3AgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTmF2aWdhdGlvbkZhaWx1cmUoZmFpbHVyZSwgNCAvKiBFcnJvclR5cGVzLk5BVklHQVRJT05fQUJPUlRFRCAqLyB8IDE2IC8qIEVycm9yVHlwZXMuTkFWSUdBVElPTl9EVVBMSUNBVEVEICovKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFudWFsIGNoYW5nZSBpbiBoYXNoIGhpc3RvcnkgIzkxNlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBsaWtlIGEgcHVzaCBidXQgbGFja3MgdGhlIGluZm9ybWF0aW9uIG9mIHRoZSBkaXJlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlckhpc3RvcnkuZ28oLTEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmlnZ2VyQWZ0ZXJFYWNoKHRvTG9jYXRpb24sIGZyb20sIGZhaWx1cmUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAvLyBhdm9pZCB3YXJuaW5ncyBpbiB0aGUgY29uc29sZSBhYm91dCB1bmNhdWdodCByZWplY3Rpb25zLCB0aGV5IGFyZSBsb2dnZWQgYnkgdHJpZ2dlckVycm9yc1xuICAgICAgICAgICAgICAgIC5jYXRjaChub29wKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEluaXRpYWxpemF0aW9uIGFuZCBFcnJvcnNcbiAgICBsZXQgcmVhZHlIYW5kbGVycyA9IHVzZUNhbGxiYWNrcygpO1xuICAgIGxldCBlcnJvckxpc3RlbmVycyA9IHVzZUNhbGxiYWNrcygpO1xuICAgIGxldCByZWFkeTtcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIGVycm9yTGlzdGVuZXJzIGFkZGVkIHZpYSBvbkVycm9yIGFuZCB0aHJvd3MgdGhlIGVycm9yIGFzIHdlbGxcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlcnJvciAtIGVycm9yIHRvIHRocm93XG4gICAgICogQHBhcmFtIHRvIC0gbG9jYXRpb24gd2Ugd2VyZSBuYXZpZ2F0aW5nIHRvIHdoZW4gdGhlIGVycm9yIGhhcHBlbmVkXG4gICAgICogQHBhcmFtIGZyb20gLSBsb2NhdGlvbiB3ZSB3ZXJlIG5hdmlnYXRpbmcgZnJvbSB3aGVuIHRoZSBlcnJvciBoYXBwZW5lZFxuICAgICAqIEByZXR1cm5zIHRoZSBlcnJvciBhcyBhIHJlamVjdGVkIHByb21pc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmlnZ2VyRXJyb3IoZXJyb3IsIHRvLCBmcm9tKSB7XG4gICAgICAgIG1hcmtBc1JlYWR5KGVycm9yKTtcbiAgICAgICAgY29uc3QgbGlzdCA9IGVycm9yTGlzdGVuZXJzLmxpc3QoKTtcbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICBsaXN0LmZvckVhY2goaGFuZGxlciA9PiBoYW5kbGVyKGVycm9yLCB0bywgZnJvbSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIHdhcm4oJ3VuY2F1Z2h0IGVycm9yIGR1cmluZyByb3V0ZSBuYXZpZ2F0aW9uOicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVqZWN0IHRoZSBlcnJvciBubyBtYXR0ZXIgdGhlcmUgd2VyZSBlcnJvciBsaXN0ZW5lcnMgb3Igbm90XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUmVhZHkoKSB7XG4gICAgICAgIGlmIChyZWFkeSAmJiBjdXJyZW50Um91dGUudmFsdWUgIT09IFNUQVJUX0xPQ0FUSU9OX05PUk1BTElaRUQpXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZWFkeUhhbmRsZXJzLmFkZChbcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrQXNSZWFkeShlcnIpIHtcbiAgICAgICAgaWYgKCFyZWFkeSkge1xuICAgICAgICAgICAgLy8gc3RpbGwgbm90IHJlYWR5IGlmIGFuIGVycm9yIGhhcHBlbmVkXG4gICAgICAgICAgICByZWFkeSA9ICFlcnI7XG4gICAgICAgICAgICBzZXR1cExpc3RlbmVycygpO1xuICAgICAgICAgICAgcmVhZHlIYW5kbGVyc1xuICAgICAgICAgICAgICAgIC5saXN0KClcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoW3Jlc29sdmUsIHJlamVjdF0pID0+IChlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoKSkpO1xuICAgICAgICAgICAgcmVhZHlIYW5kbGVycy5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuICAgIC8vIFNjcm9sbCBiZWhhdmlvclxuICAgIGZ1bmN0aW9uIGhhbmRsZVNjcm9sbCh0bywgZnJvbSwgaXNQdXNoLCBpc0ZpcnN0TmF2aWdhdGlvbikge1xuICAgICAgICBjb25zdCB7IHNjcm9sbEJlaGF2aW9yIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAoIWlzQnJvd3NlciB8fCAhc2Nyb2xsQmVoYXZpb3IpXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIGNvbnN0IHNjcm9sbFBvc2l0aW9uID0gKCFpc1B1c2ggJiYgZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihnZXRTY3JvbGxLZXkodG8uZnVsbFBhdGgsIDApKSkgfHxcbiAgICAgICAgICAgICgoaXNGaXJzdE5hdmlnYXRpb24gfHwgIWlzUHVzaCkgJiZcbiAgICAgICAgICAgICAgICBoaXN0b3J5LnN0YXRlICYmXG4gICAgICAgICAgICAgICAgaGlzdG9yeS5zdGF0ZS5zY3JvbGwpIHx8XG4gICAgICAgICAgICBudWxsO1xuICAgICAgICByZXR1cm4gbmV4dFRpY2soKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gc2Nyb2xsQmVoYXZpb3IodG8sIGZyb20sIHNjcm9sbFBvc2l0aW9uKSlcbiAgICAgICAgICAgIC50aGVuKHBvc2l0aW9uID0+IHBvc2l0aW9uICYmIHNjcm9sbFRvUG9zaXRpb24ocG9zaXRpb24pKVxuICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB0cmlnZ2VyRXJyb3IoZXJyLCB0bywgZnJvbSkpO1xuICAgIH1cbiAgICBjb25zdCBnbyA9IChkZWx0YSkgPT4gcm91dGVySGlzdG9yeS5nbyhkZWx0YSk7XG4gICAgbGV0IHN0YXJ0ZWQ7XG4gICAgY29uc3QgaW5zdGFsbGVkQXBwcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCByb3V0ZXIgPSB7XG4gICAgICAgIGN1cnJlbnRSb3V0ZSxcbiAgICAgICAgbGlzdGVuaW5nOiB0cnVlLFxuICAgICAgICBhZGRSb3V0ZSxcbiAgICAgICAgcmVtb3ZlUm91dGUsXG4gICAgICAgIGhhc1JvdXRlLFxuICAgICAgICBnZXRSb3V0ZXMsXG4gICAgICAgIHJlc29sdmUsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIHB1c2gsXG4gICAgICAgIHJlcGxhY2UsXG4gICAgICAgIGdvLFxuICAgICAgICBiYWNrOiAoKSA9PiBnbygtMSksXG4gICAgICAgIGZvcndhcmQ6ICgpID0+IGdvKDEpLFxuICAgICAgICBiZWZvcmVFYWNoOiBiZWZvcmVHdWFyZHMuYWRkLFxuICAgICAgICBiZWZvcmVSZXNvbHZlOiBiZWZvcmVSZXNvbHZlR3VhcmRzLmFkZCxcbiAgICAgICAgYWZ0ZXJFYWNoOiBhZnRlckd1YXJkcy5hZGQsXG4gICAgICAgIG9uRXJyb3I6IGVycm9yTGlzdGVuZXJzLmFkZCxcbiAgICAgICAgaXNSZWFkeSxcbiAgICAgICAgaW5zdGFsbChhcHApIHtcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlciA9IHRoaXM7XG4gICAgICAgICAgICBhcHAuY29tcG9uZW50KCdSb3V0ZXJMaW5rJywgUm91dGVyTGluayk7XG4gICAgICAgICAgICBhcHAuY29tcG9uZW50KCdSb3V0ZXJWaWV3JywgUm91dGVyVmlldyk7XG4gICAgICAgICAgICBhcHAuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMuJHJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMsICckcm91dGUnLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHVucmVmKGN1cnJlbnRSb3V0ZSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHRoaXMgaW5pdGlhbCBuYXZpZ2F0aW9uIGlzIG9ubHkgbmVjZXNzYXJ5IG9uIGNsaWVudCwgb24gc2VydmVyIGl0IGRvZXNuJ3RcbiAgICAgICAgICAgIC8vIG1ha2Ugc2Vuc2UgYmVjYXVzZSBpdCB3aWxsIGNyZWF0ZSBhbiBleHRyYSB1bm5lY2Vzc2FyeSBuYXZpZ2F0aW9uIGFuZCBjb3VsZFxuICAgICAgICAgICAgLy8gbGVhZCB0byBwcm9ibGVtc1xuICAgICAgICAgICAgaWYgKGlzQnJvd3NlciAmJlxuICAgICAgICAgICAgICAgIC8vIHVzZWQgZm9yIHRoZSBpbml0aWFsIG5hdmlnYXRpb24gY2xpZW50IHNpZGUgdG8gYXZvaWQgcHVzaGluZ1xuICAgICAgICAgICAgICAgIC8vIG11bHRpcGxlIHRpbWVzIHdoZW4gdGhlIHJvdXRlciBpcyB1c2VkIGluIG11bHRpcGxlIGFwcHNcbiAgICAgICAgICAgICAgICAhc3RhcnRlZCAmJlxuICAgICAgICAgICAgICAgIGN1cnJlbnRSb3V0ZS52YWx1ZSA9PT0gU1RBUlRfTE9DQVRJT05fTk9STUFMSVpFRCkge1xuICAgICAgICAgICAgICAgIC8vIHNlZSBhYm92ZVxuICAgICAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHB1c2gocm91dGVySGlzdG9yeS5sb2NhdGlvbikuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oJ1VuZXhwZWN0ZWQgZXJyb3Igd2hlbiBzdGFydGluZyB0aGUgcm91dGVyOicsIGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWFjdGl2ZVJvdXRlID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBTVEFSVF9MT0NBVElPTl9OT1JNQUxJWkVEKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlYWN0aXZlUm91dGUsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGN1cnJlbnRSb3V0ZS52YWx1ZVtrZXldLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXBwLnByb3ZpZGUocm91dGVyS2V5LCByb3V0ZXIpO1xuICAgICAgICAgICAgYXBwLnByb3ZpZGUocm91dGVMb2NhdGlvbktleSwgc2hhbGxvd1JlYWN0aXZlKHJlYWN0aXZlUm91dGUpKTtcbiAgICAgICAgICAgIGFwcC5wcm92aWRlKHJvdXRlclZpZXdMb2NhdGlvbktleSwgY3VycmVudFJvdXRlKTtcbiAgICAgICAgICAgIGNvbnN0IHVubW91bnRBcHAgPSBhcHAudW5tb3VudDtcbiAgICAgICAgICAgIGluc3RhbGxlZEFwcHMuYWRkKGFwcCk7XG4gICAgICAgICAgICBhcHAudW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpbnN0YWxsZWRBcHBzLmRlbGV0ZShhcHApO1xuICAgICAgICAgICAgICAgIC8vIHRoZSByb3V0ZXIgaXMgbm90IGF0dGFjaGVkIHRvIGFuIGFwcCBhbnltb3JlXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbGxlZEFwcHMuc2l6ZSA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW52YWxpZGF0ZSB0aGUgY3VycmVudCBuYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdMb2NhdGlvbiA9IFNUQVJUX0xPQ0FUSU9OX05PUk1BTElaRUQ7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUhpc3RvcnlMaXN0ZW5lciAmJiByZW1vdmVIaXN0b3J5TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSGlzdG9yeUxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJvdXRlLnZhbHVlID0gU1RBUlRfTE9DQVRJT05fTk9STUFMSVpFRDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZWFkeSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bm1vdW50QXBwKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBwcm9iYWJseSBuZWVkcyB0byBiZSB1cGRhdGVkIHNvIGl0IGNhbiBiZSB1c2VkIGJ5IHZ1ZS10ZXJtdWlcbiAgICAgICAgICAgIGlmICgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykgJiYgaXNCcm93c2VyKSB7XG4gICAgICAgICAgICAgICAgYWRkRGV2dG9vbHMoYXBwLCByb3V0ZXIsIG1hdGNoZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG4gICAgLy8gVE9ETzogdHlwZSB0aGlzIGFzIE5hdmlnYXRpb25HdWFyZFJldHVybiBvciBzaW1pbGFyIGluc3RlYWQgb2YgYW55XG4gICAgZnVuY3Rpb24gcnVuR3VhcmRRdWV1ZShndWFyZHMpIHtcbiAgICAgICAgcmV0dXJuIGd1YXJkcy5yZWR1Y2UoKHByb21pc2UsIGd1YXJkKSA9PiBwcm9taXNlLnRoZW4oKCkgPT4gcnVuV2l0aENvbnRleHQoZ3VhcmQpKSwgUHJvbWlzZS5yZXNvbHZlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gcm91dGVyO1xufVxuZnVuY3Rpb24gZXh0cmFjdENoYW5naW5nUmVjb3Jkcyh0bywgZnJvbSkge1xuICAgIGNvbnN0IGxlYXZpbmdSZWNvcmRzID0gW107XG4gICAgY29uc3QgdXBkYXRpbmdSZWNvcmRzID0gW107XG4gICAgY29uc3QgZW50ZXJpbmdSZWNvcmRzID0gW107XG4gICAgY29uc3QgbGVuID0gTWF0aC5tYXgoZnJvbS5tYXRjaGVkLmxlbmd0aCwgdG8ubWF0Y2hlZC5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVjb3JkRnJvbSA9IGZyb20ubWF0Y2hlZFtpXTtcbiAgICAgICAgaWYgKHJlY29yZEZyb20pIHtcbiAgICAgICAgICAgIGlmICh0by5tYXRjaGVkLmZpbmQocmVjb3JkID0+IGlzU2FtZVJvdXRlUmVjb3JkKHJlY29yZCwgcmVjb3JkRnJvbSkpKVxuICAgICAgICAgICAgICAgIHVwZGF0aW5nUmVjb3Jkcy5wdXNoKHJlY29yZEZyb20pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxlYXZpbmdSZWNvcmRzLnB1c2gocmVjb3JkRnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVjb3JkVG8gPSB0by5tYXRjaGVkW2ldO1xuICAgICAgICBpZiAocmVjb3JkVG8pIHtcbiAgICAgICAgICAgIC8vIHRoZSB0eXBlIGRvZXNuJ3QgbWF0dGVyIGJlY2F1c2Ugd2UgYXJlIGNvbXBhcmluZyBwZXIgcmVmZXJlbmNlXG4gICAgICAgICAgICBpZiAoIWZyb20ubWF0Y2hlZC5maW5kKHJlY29yZCA9PiBpc1NhbWVSb3V0ZVJlY29yZChyZWNvcmQsIHJlY29yZFRvKSkpIHtcbiAgICAgICAgICAgICAgICBlbnRlcmluZ1JlY29yZHMucHVzaChyZWNvcmRUbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtsZWF2aW5nUmVjb3JkcywgdXBkYXRpbmdSZWNvcmRzLCBlbnRlcmluZ1JlY29yZHNdO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHJvdXRlciBpbnN0YW5jZS4gRXF1aXZhbGVudCB0byB1c2luZyBgJHJvdXRlcmAgaW5zaWRlXG4gKiB0ZW1wbGF0ZXMuXG4gKi9cbmZ1bmN0aW9uIHVzZVJvdXRlcigpIHtcbiAgICByZXR1cm4gaW5qZWN0KHJvdXRlcktleSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgcm91dGUgbG9jYXRpb24uIEVxdWl2YWxlbnQgdG8gdXNpbmcgYCRyb3V0ZWAgaW5zaWRlXG4gKiB0ZW1wbGF0ZXMuXG4gKi9cbmZ1bmN0aW9uIHVzZVJvdXRlKCkge1xuICAgIHJldHVybiBpbmplY3Qocm91dGVMb2NhdGlvbktleSk7XG59XG5cbmV4cG9ydCB7IE5hdmlnYXRpb25GYWlsdXJlVHlwZSwgUm91dGVyTGluaywgUm91dGVyVmlldywgU1RBUlRfTE9DQVRJT05fTk9STUFMSVpFRCBhcyBTVEFSVF9MT0NBVElPTiwgY3JlYXRlTWVtb3J5SGlzdG9yeSwgY3JlYXRlUm91dGVyLCBjcmVhdGVSb3V0ZXJNYXRjaGVyLCBjcmVhdGVXZWJIYXNoSGlzdG9yeSwgY3JlYXRlV2ViSGlzdG9yeSwgaXNOYXZpZ2F0aW9uRmFpbHVyZSwgbG9hZFJvdXRlTG9jYXRpb24sIG1hdGNoZWRSb3V0ZUtleSwgb25CZWZvcmVSb3V0ZUxlYXZlLCBvbkJlZm9yZVJvdXRlVXBkYXRlLCBwYXJzZVF1ZXJ5LCByb3V0ZUxvY2F0aW9uS2V5LCByb3V0ZXJLZXksIHJvdXRlclZpZXdMb2NhdGlvbktleSwgc3RyaW5naWZ5UXVlcnksIHVzZUxpbmssIHVzZVJvdXRlLCB1c2VSb3V0ZXIsIHZpZXdEZXB0aEtleSB9O1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChjYWNoZWRNb2R1bGUuZXJyb3IgIT09IHVuZGVmaW5lZCkgdGhyb3cgY2FjaGVkTW9kdWxlLmVycm9yO1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHR0cnkge1xuXHRcdHZhciBleGVjT3B0aW9ucyA9IHsgaWQ6IG1vZHVsZUlkLCBtb2R1bGU6IG1vZHVsZSwgZmFjdG9yeTogX193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0sIHJlcXVpcmU6IF9fd2VicGFja19yZXF1aXJlX18gfTtcblx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVyKSB7IGhhbmRsZXIoZXhlY09wdGlvbnMpOyB9KTtcblx0XHRtb2R1bGUgPSBleGVjT3B0aW9ucy5tb2R1bGU7XG5cdFx0ZXhlY09wdGlvbnMuZmFjdG9yeS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBleGVjT3B0aW9ucy5yZXF1aXJlKTtcblx0fSBjYXRjaChlKSB7XG5cdFx0bW9kdWxlLmVycm9yID0gZTtcblx0XHR0aHJvdyBlO1xuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4vLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gX193ZWJwYWNrX21vZHVsZXNfXztcblxuLy8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbl9fd2VicGFja19yZXF1aXJlX18uYyA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfXztcblxuLy8gZXhwb3NlIHRoZSBtb2R1bGUgZXhlY3V0aW9uIGludGVyY2VwdG9yXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBbXTtcblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5mID0ge307XG4vLyBUaGlzIGZpbGUgY29udGFpbnMgb25seSB0aGUgZW50cnkgY2h1bmsuXG4vLyBUaGUgY2h1bmsgbG9hZGluZyBmdW5jdGlvbiBmb3IgYWRkaXRpb25hbCBjaHVua3Ncbl9fd2VicGFja19yZXF1aXJlX18uZSA9IChjaHVua0lkKSA9PiB7XG5cdHJldHVybiBQcm9taXNlLmFsbChPYmplY3Qua2V5cyhfX3dlYnBhY2tfcmVxdWlyZV9fLmYpLnJlZHVjZSgocHJvbWlzZXMsIGtleSkgPT4ge1xuXHRcdF9fd2VicGFja19yZXF1aXJlX18uZltrZXldKGNodW5rSWQsIHByb21pc2VzKTtcblx0XHRyZXR1cm4gcHJvbWlzZXM7XG5cdH0sIFtdKSk7XG59OyIsIi8vIFRoaXMgZnVuY3Rpb24gYWxsb3cgdG8gcmVmZXJlbmNlIGFzeW5jIGNodW5rc1xuX193ZWJwYWNrX3JlcXVpcmVfXy51ID0gKGNodW5rSWQpID0+IHtcblx0Ly8gcmV0dXJuIHVybCBmb3IgZmlsZW5hbWVzIGJhc2VkIG9uIHRlbXBsYXRlXG5cdHJldHVybiBcIlwiICsgY2h1bmtJZCArIFwiLmJ1bmRsZS5qc1wiO1xufTsiLCIvLyBUaGlzIGZ1bmN0aW9uIGFsbG93IHRvIHJlZmVyZW5jZSBhbGwgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmh1ID0gKGNodW5rSWQpID0+IHtcblx0Ly8gcmV0dXJuIHVybCBmb3IgZmlsZW5hbWVzIGJhc2VkIG9uIHRlbXBsYXRlXG5cdHJldHVybiBcIlwiICsgY2h1bmtJZCArIFwiLlwiICsgX193ZWJwYWNrX3JlcXVpcmVfXy5oKCkgKyBcIi5ob3QtdXBkYXRlLmpzXCI7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uaG1yRiA9ICgpID0+IChcIm1haW4uXCIgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLmgoKSArIFwiLmhvdC11cGRhdGUuanNvblwiKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmggPSAoKSA9PiAoXCIyNjIxNmVmMTFjNmU5YmQxMzkzNVwiKSIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsInZhciBpblByb2dyZXNzID0ge307XG52YXIgZGF0YVdlYnBhY2tQcmVmaXggPSBcImVjaGFydHNfbGVhcm46XCI7XG4vLyBsb2FkU2NyaXB0IGZ1bmN0aW9uIHRvIGxvYWQgYSBzY3JpcHQgdmlhIHNjcmlwdCB0YWdcbl9fd2VicGFja19yZXF1aXJlX18ubCA9ICh1cmwsIGRvbmUsIGtleSwgY2h1bmtJZCkgPT4ge1xuXHRpZihpblByb2dyZXNzW3VybF0pIHsgaW5Qcm9ncmVzc1t1cmxdLnB1c2goZG9uZSk7IHJldHVybjsgfVxuXHR2YXIgc2NyaXB0LCBuZWVkQXR0YWNoO1xuXHRpZihrZXkgIT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHNjcmlwdHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBzID0gc2NyaXB0c1tpXTtcblx0XHRcdGlmKHMuZ2V0QXR0cmlidXRlKFwic3JjXCIpID09IHVybCB8fCBzLmdldEF0dHJpYnV0ZShcImRhdGEtd2VicGFja1wiKSA9PSBkYXRhV2VicGFja1ByZWZpeCArIGtleSkgeyBzY3JpcHQgPSBzOyBicmVhazsgfVxuXHRcdH1cblx0fVxuXHRpZighc2NyaXB0KSB7XG5cdFx0bmVlZEF0dGFjaCA9IHRydWU7XG5cdFx0c2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cblx0XHRzY3JpcHQuY2hhcnNldCA9ICd1dGYtOCc7XG5cdFx0c2NyaXB0LnRpbWVvdXQgPSAxMjA7XG5cdFx0aWYgKF9fd2VicGFja19yZXF1aXJlX18ubmMpIHtcblx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBfX3dlYnBhY2tfcmVxdWlyZV9fLm5jKTtcblx0XHR9XG5cdFx0c2NyaXB0LnNldEF0dHJpYnV0ZShcImRhdGEtd2VicGFja1wiLCBkYXRhV2VicGFja1ByZWZpeCArIGtleSk7XG5cblx0XHRzY3JpcHQuc3JjID0gdXJsO1xuXHR9XG5cdGluUHJvZ3Jlc3NbdXJsXSA9IFtkb25lXTtcblx0dmFyIG9uU2NyaXB0Q29tcGxldGUgPSAocHJldiwgZXZlbnQpID0+IHtcblx0XHQvLyBhdm9pZCBtZW0gbGVha3MgaW4gSUUuXG5cdFx0c2NyaXB0Lm9uZXJyb3IgPSBzY3JpcHQub25sb2FkID0gbnVsbDtcblx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0dmFyIGRvbmVGbnMgPSBpblByb2dyZXNzW3VybF07XG5cdFx0ZGVsZXRlIGluUHJvZ3Jlc3NbdXJsXTtcblx0XHRzY3JpcHQucGFyZW50Tm9kZSAmJiBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuXHRcdGRvbmVGbnMgJiYgZG9uZUZucy5mb3JFYWNoKChmbikgPT4gKGZuKGV2ZW50KSkpO1xuXHRcdGlmKHByZXYpIHJldHVybiBwcmV2KGV2ZW50KTtcblx0fVxuXHR2YXIgdGltZW91dCA9IHNldFRpbWVvdXQob25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHVuZGVmaW5lZCwgeyB0eXBlOiAndGltZW91dCcsIHRhcmdldDogc2NyaXB0IH0pLCAxMjAwMDApO1xuXHRzY3JpcHQub25lcnJvciA9IG9uU2NyaXB0Q29tcGxldGUuYmluZChudWxsLCBzY3JpcHQub25lcnJvcik7XG5cdHNjcmlwdC5vbmxvYWQgPSBvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgc2NyaXB0Lm9ubG9hZCk7XG5cdG5lZWRBdHRhY2ggJiYgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xufTsiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJ2YXIgY3VycmVudE1vZHVsZURhdGEgPSB7fTtcbnZhciBpbnN0YWxsZWRNb2R1bGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jO1xuXG4vLyBtb2R1bGUgYW5kIHJlcXVpcmUgY3JlYXRpb25cbnZhciBjdXJyZW50Q2hpbGRNb2R1bGU7XG52YXIgY3VycmVudFBhcmVudHMgPSBbXTtcblxuLy8gc3RhdHVzXG52YXIgcmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzID0gW107XG52YXIgY3VycmVudFN0YXR1cyA9IFwiaWRsZVwiO1xuXG4vLyB3aGlsZSBkb3dubG9hZGluZ1xudmFyIGJsb2NraW5nUHJvbWlzZXMgPSAwO1xudmFyIGJsb2NraW5nUHJvbWlzZXNXYWl0aW5nID0gW107XG5cbi8vIFRoZSB1cGRhdGUgaW5mb1xudmFyIGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzO1xudmFyIHF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmhtckQgPSBjdXJyZW50TW9kdWxlRGF0YTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXy5pLnB1c2goZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0dmFyIG1vZHVsZSA9IG9wdGlvbnMubW9kdWxlO1xuXHR2YXIgcmVxdWlyZSA9IGNyZWF0ZVJlcXVpcmUob3B0aW9ucy5yZXF1aXJlLCBvcHRpb25zLmlkKTtcblx0bW9kdWxlLmhvdCA9IGNyZWF0ZU1vZHVsZUhvdE9iamVjdChvcHRpb25zLmlkLCBtb2R1bGUpO1xuXHRtb2R1bGUucGFyZW50cyA9IGN1cnJlbnRQYXJlbnRzO1xuXHRtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0Y3VycmVudFBhcmVudHMgPSBbXTtcblx0b3B0aW9ucy5yZXF1aXJlID0gcmVxdWlyZTtcbn0pO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmhtckMgPSB7fTtcbl9fd2VicGFja19yZXF1aXJlX18uaG1ySSA9IHt9O1xuXG5mdW5jdGlvbiBjcmVhdGVSZXF1aXJlKHJlcXVpcmUsIG1vZHVsZUlkKSB7XG5cdHZhciBtZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xuXHRpZiAoIW1lKSByZXR1cm4gcmVxdWlyZTtcblx0dmFyIGZuID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcblx0XHRpZiAobWUuaG90LmFjdGl2ZSkge1xuXHRcdFx0aWYgKGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0pIHtcblx0XHRcdFx0dmFyIHBhcmVudHMgPSBpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdLnBhcmVudHM7XG5cdFx0XHRcdGlmIChwYXJlbnRzLmluZGV4T2YobW9kdWxlSWQpID09PSAtMSkge1xuXHRcdFx0XHRcdHBhcmVudHMucHVzaChtb2R1bGVJZCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN1cnJlbnRQYXJlbnRzID0gW21vZHVsZUlkXTtcblx0XHRcdFx0Y3VycmVudENoaWxkTW9kdWxlID0gcmVxdWVzdDtcblx0XHRcdH1cblx0XHRcdGlmIChtZS5jaGlsZHJlbi5pbmRleE9mKHJlcXVlc3QpID09PSAtMSkge1xuXHRcdFx0XHRtZS5jaGlsZHJlbi5wdXNoKHJlcXVlc3QpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdFwiW0hNUl0gdW5leHBlY3RlZCByZXF1aXJlKFwiICtcblx0XHRcdFx0XHRyZXF1ZXN0ICtcblx0XHRcdFx0XHRcIikgZnJvbSBkaXNwb3NlZCBtb2R1bGUgXCIgK1xuXHRcdFx0XHRcdG1vZHVsZUlkXG5cdFx0XHQpO1xuXHRcdFx0Y3VycmVudFBhcmVudHMgPSBbXTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcXVpcmUocmVxdWVzdCk7XG5cdH07XG5cdHZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiByZXF1aXJlW25hbWVdO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdHJlcXVpcmVbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9O1xuXHR9O1xuXHRmb3IgKHZhciBuYW1lIGluIHJlcXVpcmUpIHtcblx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlcXVpcmUsIG5hbWUpICYmIG5hbWUgIT09IFwiZVwiKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIG5hbWUsIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcihuYW1lKSk7XG5cdFx0fVxuXHR9XG5cdGZuLmUgPSBmdW5jdGlvbiAoY2h1bmtJZCkge1xuXHRcdHJldHVybiB0cmFja0Jsb2NraW5nUHJvbWlzZShyZXF1aXJlLmUoY2h1bmtJZCkpO1xuXHR9O1xuXHRyZXR1cm4gZm47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1vZHVsZUhvdE9iamVjdChtb2R1bGVJZCwgbWUpIHtcblx0dmFyIF9tYWluID0gY3VycmVudENoaWxkTW9kdWxlICE9PSBtb2R1bGVJZDtcblx0dmFyIGhvdCA9IHtcblx0XHQvLyBwcml2YXRlIHN0dWZmXG5cdFx0X2FjY2VwdGVkRGVwZW5kZW5jaWVzOiB7fSxcblx0XHRfYWNjZXB0ZWRFcnJvckhhbmRsZXJzOiB7fSxcblx0XHRfZGVjbGluZWREZXBlbmRlbmNpZXM6IHt9LFxuXHRcdF9zZWxmQWNjZXB0ZWQ6IGZhbHNlLFxuXHRcdF9zZWxmRGVjbGluZWQ6IGZhbHNlLFxuXHRcdF9zZWxmSW52YWxpZGF0ZWQ6IGZhbHNlLFxuXHRcdF9kaXNwb3NlSGFuZGxlcnM6IFtdLFxuXHRcdF9tYWluOiBfbWFpbixcblx0XHRfcmVxdWlyZVNlbGY6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGN1cnJlbnRQYXJlbnRzID0gbWUucGFyZW50cy5zbGljZSgpO1xuXHRcdFx0Y3VycmVudENoaWxkTW9kdWxlID0gX21haW4gPyB1bmRlZmluZWQgOiBtb2R1bGVJZDtcblx0XHRcdF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpO1xuXHRcdH0sXG5cblx0XHQvLyBNb2R1bGUgQVBJXG5cdFx0YWN0aXZlOiB0cnVlLFxuXHRcdGFjY2VwdDogZnVuY3Rpb24gKGRlcCwgY2FsbGJhY2ssIGVycm9ySGFuZGxlcikge1xuXHRcdFx0aWYgKGRlcCA9PT0gdW5kZWZpbmVkKSBob3QuX3NlbGZBY2NlcHRlZCA9IHRydWU7XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgZGVwID09PSBcImZ1bmN0aW9uXCIpIGhvdC5fc2VsZkFjY2VwdGVkID0gZGVwO1xuXHRcdFx0ZWxzZSBpZiAodHlwZW9mIGRlcCA9PT0gXCJvYmplY3RcIiAmJiBkZXAgIT09IG51bGwpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkZXAubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcFtpXV0gPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcblx0XHRcdFx0XHRob3QuX2FjY2VwdGVkRXJyb3JIYW5kbGVyc1tkZXBbaV1dID0gZXJyb3JIYW5kbGVyO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcF0gPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcblx0XHRcdFx0aG90Ll9hY2NlcHRlZEVycm9ySGFuZGxlcnNbZGVwXSA9IGVycm9ySGFuZGxlcjtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRlY2xpbmU6IGZ1bmN0aW9uIChkZXApIHtcblx0XHRcdGlmIChkZXAgPT09IHVuZGVmaW5lZCkgaG90Ll9zZWxmRGVjbGluZWQgPSB0cnVlO1xuXHRcdFx0ZWxzZSBpZiAodHlwZW9mIGRlcCA9PT0gXCJvYmplY3RcIiAmJiBkZXAgIT09IG51bGwpXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGVwLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRcdGhvdC5fZGVjbGluZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IHRydWU7XG5cdFx0XHRlbHNlIGhvdC5fZGVjbGluZWREZXBlbmRlbmNpZXNbZGVwXSA9IHRydWU7XG5cdFx0fSxcblx0XHRkaXNwb3NlOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdGhvdC5fZGlzcG9zZUhhbmRsZXJzLnB1c2goY2FsbGJhY2spO1xuXHRcdH0sXG5cdFx0YWRkRGlzcG9zZUhhbmRsZXI6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0aG90Ll9kaXNwb3NlSGFuZGxlcnMucHVzaChjYWxsYmFjayk7XG5cdFx0fSxcblx0XHRyZW1vdmVEaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgaWR4ID0gaG90Ll9kaXNwb3NlSGFuZGxlcnMuaW5kZXhPZihjYWxsYmFjayk7XG5cdFx0XHRpZiAoaWR4ID49IDApIGhvdC5fZGlzcG9zZUhhbmRsZXJzLnNwbGljZShpZHgsIDEpO1xuXHRcdH0sXG5cdFx0aW52YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fc2VsZkludmFsaWRhdGVkID0gdHJ1ZTtcblx0XHRcdHN3aXRjaCAoY3VycmVudFN0YXR1cykge1xuXHRcdFx0XHRjYXNlIFwiaWRsZVwiOlxuXHRcdFx0XHRcdGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0T2JqZWN0LmtleXMoX193ZWJwYWNrX3JlcXVpcmVfXy5obXJJKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uaG1ySVtrZXldKFxuXHRcdFx0XHRcdFx0XHRtb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnNcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0c2V0U3RhdHVzKFwicmVhZHlcIik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJyZWFkeVwiOlxuXHRcdFx0XHRcdE9iamVjdC5rZXlzKF9fd2VicGFja19yZXF1aXJlX18uaG1ySSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmhtcklba2V5XShcblx0XHRcdFx0XHRcdFx0bW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwicHJlcGFyZVwiOlxuXHRcdFx0XHRjYXNlIFwiY2hlY2tcIjpcblx0XHRcdFx0Y2FzZSBcImRpc3Bvc2VcIjpcblx0XHRcdFx0Y2FzZSBcImFwcGx5XCI6XG5cdFx0XHRcdFx0KHF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcyA9IHF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcyB8fCBbXSkucHVzaChcblx0XHRcdFx0XHRcdG1vZHVsZUlkXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHQvLyBpZ25vcmUgcmVxdWVzdHMgaW4gZXJyb3Igc3RhdGVzXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIE1hbmFnZW1lbnQgQVBJXG5cdFx0Y2hlY2s6IGhvdENoZWNrLFxuXHRcdGFwcGx5OiBob3RBcHBseSxcblx0XHRzdGF0dXM6IGZ1bmN0aW9uIChsKSB7XG5cdFx0XHRpZiAoIWwpIHJldHVybiBjdXJyZW50U3RhdHVzO1xuXHRcdFx0cmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzLnB1c2gobCk7XG5cdFx0fSxcblx0XHRhZGRTdGF0dXNIYW5kbGVyOiBmdW5jdGlvbiAobCkge1xuXHRcdFx0cmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzLnB1c2gobCk7XG5cdFx0fSxcblx0XHRyZW1vdmVTdGF0dXNIYW5kbGVyOiBmdW5jdGlvbiAobCkge1xuXHRcdFx0dmFyIGlkeCA9IHJlZ2lzdGVyZWRTdGF0dXNIYW5kbGVycy5pbmRleE9mKGwpO1xuXHRcdFx0aWYgKGlkeCA+PSAwKSByZWdpc3RlcmVkU3RhdHVzSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0fSxcblxuXHRcdC8vaW5oZXJpdCBmcm9tIHByZXZpb3VzIGRpc3Bvc2UgY2FsbFxuXHRcdGRhdGE6IGN1cnJlbnRNb2R1bGVEYXRhW21vZHVsZUlkXVxuXHR9O1xuXHRjdXJyZW50Q2hpbGRNb2R1bGUgPSB1bmRlZmluZWQ7XG5cdHJldHVybiBob3Q7XG59XG5cbmZ1bmN0aW9uIHNldFN0YXR1cyhuZXdTdGF0dXMpIHtcblx0Y3VycmVudFN0YXR1cyA9IG5ld1N0YXR1cztcblx0dmFyIHJlc3VsdHMgPSBbXTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdGVyZWRTdGF0dXNIYW5kbGVycy5sZW5ndGg7IGkrKylcblx0XHRyZXN1bHRzW2ldID0gcmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzW2ldLmNhbGwobnVsbCwgbmV3U3RhdHVzKTtcblxuXHRyZXR1cm4gUHJvbWlzZS5hbGwocmVzdWx0cyk7XG59XG5cbmZ1bmN0aW9uIHVuYmxvY2soKSB7XG5cdGlmICgtLWJsb2NraW5nUHJvbWlzZXMgPT09IDApIHtcblx0XHRzZXRTdGF0dXMoXCJyZWFkeVwiKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChibG9ja2luZ1Byb21pc2VzID09PSAwKSB7XG5cdFx0XHRcdHZhciBsaXN0ID0gYmxvY2tpbmdQcm9taXNlc1dhaXRpbmc7XG5cdFx0XHRcdGJsb2NraW5nUHJvbWlzZXNXYWl0aW5nID0gW107XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGxpc3RbaV0oKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHRyYWNrQmxvY2tpbmdQcm9taXNlKHByb21pc2UpIHtcblx0c3dpdGNoIChjdXJyZW50U3RhdHVzKSB7XG5cdFx0Y2FzZSBcInJlYWR5XCI6XG5cdFx0XHRzZXRTdGF0dXMoXCJwcmVwYXJlXCIpO1xuXHRcdC8qIGZhbGx0aHJvdWdoICovXG5cdFx0Y2FzZSBcInByZXBhcmVcIjpcblx0XHRcdGJsb2NraW5nUHJvbWlzZXMrKztcblx0XHRcdHByb21pc2UudGhlbih1bmJsb2NrLCB1bmJsb2NrKTtcblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0fVxufVxuXG5mdW5jdGlvbiB3YWl0Rm9yQmxvY2tpbmdQcm9taXNlcyhmbikge1xuXHRpZiAoYmxvY2tpbmdQcm9taXNlcyA9PT0gMCkgcmV0dXJuIGZuKCk7XG5cdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXHRcdGJsb2NraW5nUHJvbWlzZXNXYWl0aW5nLnB1c2goZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVzb2x2ZShmbigpKTtcblx0XHR9KTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGhvdENoZWNrKGFwcGx5T25VcGRhdGUpIHtcblx0aWYgKGN1cnJlbnRTdGF0dXMgIT09IFwiaWRsZVwiKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiY2hlY2soKSBpcyBvbmx5IGFsbG93ZWQgaW4gaWRsZSBzdGF0dXNcIik7XG5cdH1cblx0cmV0dXJuIHNldFN0YXR1cyhcImNoZWNrXCIpXG5cdFx0LnRoZW4oX193ZWJwYWNrX3JlcXVpcmVfXy5obXJNKVxuXHRcdC50aGVuKGZ1bmN0aW9uICh1cGRhdGUpIHtcblx0XHRcdGlmICghdXBkYXRlKSB7XG5cdFx0XHRcdHJldHVybiBzZXRTdGF0dXMoYXBwbHlJbnZhbGlkYXRlZE1vZHVsZXMoKSA/IFwicmVhZHlcIiA6IFwiaWRsZVwiKS50aGVuKFxuXHRcdFx0XHRcdGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFN0YXR1cyhcInByZXBhcmVcIikudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciB1cGRhdGVkTW9kdWxlcyA9IFtdO1xuXHRcdFx0XHRjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVycyA9IFtdO1xuXG5cdFx0XHRcdHJldHVybiBQcm9taXNlLmFsbChcblx0XHRcdFx0XHRPYmplY3Qua2V5cyhfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckMpLnJlZHVjZShmdW5jdGlvbiAoXG5cdFx0XHRcdFx0XHRwcm9taXNlcyxcblx0XHRcdFx0XHRcdGtleVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5obXJDW2tleV0oXG5cdFx0XHRcdFx0XHRcdHVwZGF0ZS5jLFxuXHRcdFx0XHRcdFx0XHR1cGRhdGUucixcblx0XHRcdFx0XHRcdFx0dXBkYXRlLm0sXG5cdFx0XHRcdFx0XHRcdHByb21pc2VzLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVycyxcblx0XHRcdFx0XHRcdFx0dXBkYXRlZE1vZHVsZXNcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZXM7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRbXSlcblx0XHRcdFx0KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gd2FpdEZvckJsb2NraW5nUHJvbWlzZXMoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0aWYgKGFwcGx5T25VcGRhdGUpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGludGVybmFsQXBwbHkoYXBwbHlPblVwZGF0ZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gc2V0U3RhdHVzKFwicmVhZHlcIikudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHVwZGF0ZWRNb2R1bGVzO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcbn1cblxuZnVuY3Rpb24gaG90QXBwbHkob3B0aW9ucykge1xuXHRpZiAoY3VycmVudFN0YXR1cyAhPT0gXCJyZWFkeVwiKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcImFwcGx5KCkgaXMgb25seSBhbGxvd2VkIGluIHJlYWR5IHN0YXR1cyAoc3RhdGU6IFwiICtcblx0XHRcdFx0XHRjdXJyZW50U3RhdHVzICtcblx0XHRcdFx0XHRcIilcIlxuXHRcdFx0KTtcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gaW50ZXJuYWxBcHBseShvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxBcHBseShvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdGFwcGx5SW52YWxpZGF0ZWRNb2R1bGVzKCk7XG5cblx0dmFyIHJlc3VsdHMgPSBjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVycy5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHtcblx0XHRyZXR1cm4gaGFuZGxlcihvcHRpb25zKTtcblx0fSk7XG5cdGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzID0gdW5kZWZpbmVkO1xuXG5cdHZhciBlcnJvcnMgPSByZXN1bHRzXG5cdFx0Lm1hcChmdW5jdGlvbiAocikge1xuXHRcdFx0cmV0dXJuIHIuZXJyb3I7XG5cdFx0fSlcblx0XHQuZmlsdGVyKEJvb2xlYW4pO1xuXG5cdGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuXHRcdHJldHVybiBzZXRTdGF0dXMoXCJhYm9ydFwiKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdHRocm93IGVycm9yc1swXTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIE5vdyBpbiBcImRpc3Bvc2VcIiBwaGFzZVxuXHR2YXIgZGlzcG9zZVByb21pc2UgPSBzZXRTdGF0dXMoXCJkaXNwb3NlXCIpO1xuXG5cdHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0aWYgKHJlc3VsdC5kaXNwb3NlKSByZXN1bHQuZGlzcG9zZSgpO1xuXHR9KTtcblxuXHQvLyBOb3cgaW4gXCJhcHBseVwiIHBoYXNlXG5cdHZhciBhcHBseVByb21pc2UgPSBzZXRTdGF0dXMoXCJhcHBseVwiKTtcblxuXHR2YXIgZXJyb3I7XG5cdHZhciByZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcblx0XHRpZiAoIWVycm9yKSBlcnJvciA9IGVycjtcblx0fTtcblxuXHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW107XG5cdHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0aWYgKHJlc3VsdC5hcHBseSkge1xuXHRcdFx0dmFyIG1vZHVsZXMgPSByZXN1bHQuYXBwbHkocmVwb3J0RXJyb3IpO1xuXHRcdFx0aWYgKG1vZHVsZXMpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzLnB1c2gobW9kdWxlc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBQcm9taXNlLmFsbChbZGlzcG9zZVByb21pc2UsIGFwcGx5UHJvbWlzZV0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdC8vIGhhbmRsZSBlcnJvcnMgaW4gYWNjZXB0IGhhbmRsZXJzIGFuZCBzZWxmIGFjY2VwdGVkIG1vZHVsZSBsb2FkXG5cdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRyZXR1cm4gc2V0U3RhdHVzKFwiZmFpbFwiKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAocXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzKSB7XG5cdFx0XHRyZXR1cm4gaW50ZXJuYWxBcHBseShvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChsaXN0KSB7XG5cdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuXHRcdFx0XHRcdGlmIChsaXN0LmluZGV4T2YobW9kdWxlSWQpIDwgMCkgbGlzdC5wdXNoKG1vZHVsZUlkKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBsaXN0O1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNldFN0YXR1cyhcImlkbGVcIikudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gb3V0ZGF0ZWRNb2R1bGVzO1xuXHRcdH0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYXBwbHlJbnZhbGlkYXRlZE1vZHVsZXMoKSB7XG5cdGlmIChxdWV1ZWRJbnZhbGlkYXRlZE1vZHVsZXMpIHtcblx0XHRpZiAoIWN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzKSBjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVycyA9IFtdO1xuXHRcdE9iamVjdC5rZXlzKF9fd2VicGFja19yZXF1aXJlX18uaG1ySSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRxdWV1ZWRJbnZhbGlkYXRlZE1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlSWQpIHtcblx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5obXJJW2tleV0oXG5cdFx0XHRcdFx0bW9kdWxlSWQsXG5cdFx0XHRcdFx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnNcblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdHF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcyA9IHVuZGVmaW5lZDtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSIsInZhciBzY3JpcHRVcmw7XG5pZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5nLmltcG9ydFNjcmlwdHMpIHNjcmlwdFVybCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5sb2NhdGlvbiArIFwiXCI7XG52YXIgZG9jdW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcuZG9jdW1lbnQ7XG5pZiAoIXNjcmlwdFVybCAmJiBkb2N1bWVudCkge1xuXHRpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdClcblx0XHRzY3JpcHRVcmwgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYztcblx0aWYgKCFzY3JpcHRVcmwpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGlmKHNjcmlwdHMubGVuZ3RoKSB7XG5cdFx0XHR2YXIgaSA9IHNjcmlwdHMubGVuZ3RoIC0gMTtcblx0XHRcdHdoaWxlIChpID4gLTEgJiYgIXNjcmlwdFVybCkgc2NyaXB0VXJsID0gc2NyaXB0c1tpLS1dLnNyYztcblx0XHR9XG5cdH1cbn1cbi8vIFdoZW4gc3VwcG9ydGluZyBicm93c2VycyB3aGVyZSBhbiBhdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIHlvdSBtdXN0IHNwZWNpZnkgYW4gb3V0cHV0LnB1YmxpY1BhdGggbWFudWFsbHkgdmlhIGNvbmZpZ3VyYXRpb25cbi8vIG9yIHBhc3MgYW4gZW1wdHkgc3RyaW5nIChcIlwiKSBhbmQgc2V0IHRoZSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyB2YXJpYWJsZSBmcm9tIHlvdXIgY29kZSB0byB1c2UgeW91ciBvd24gbG9naWMuXG5pZiAoIXNjcmlwdFVybCkgdGhyb3cgbmV3IEVycm9yKFwiQXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7XG5zY3JpcHRVcmwgPSBzY3JpcHRVcmwucmVwbGFjZSgvIy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcPy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcL1teXFwvXSskLywgXCIvXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gc2NyaXB0VXJsOyIsIi8vIG5vIGJhc2VVUklcblxuLy8gb2JqZWN0IHRvIHN0b3JlIGxvYWRlZCBhbmQgbG9hZGluZyBjaHVua3Ncbi8vIHVuZGVmaW5lZCA9IGNodW5rIG5vdCBsb2FkZWQsIG51bGwgPSBjaHVuayBwcmVsb2FkZWQvcHJlZmV0Y2hlZFxuLy8gW3Jlc29sdmUsIHJlamVjdCwgUHJvbWlzZV0gPSBjaHVuayBsb2FkaW5nLCAwID0gY2h1bmsgbG9hZGVkXG52YXIgaW5zdGFsbGVkQ2h1bmtzID0gX193ZWJwYWNrX3JlcXVpcmVfXy5obXJTX2pzb25wID0gX193ZWJwYWNrX3JlcXVpcmVfXy5obXJTX2pzb25wIHx8IHtcblx0XCJtYWluXCI6IDBcbn07XG5cbl9fd2VicGFja19yZXF1aXJlX18uZi5qID0gKGNodW5rSWQsIHByb21pc2VzKSA9PiB7XG5cdFx0Ly8gSlNPTlAgY2h1bmsgbG9hZGluZyBmb3IgamF2YXNjcmlwdFxuXHRcdHZhciBpbnN0YWxsZWRDaHVua0RhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm8oaW5zdGFsbGVkQ2h1bmtzLCBjaHVua0lkKSA/IGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA6IHVuZGVmaW5lZDtcblx0XHRpZihpbnN0YWxsZWRDaHVua0RhdGEgIT09IDApIHsgLy8gMCBtZWFucyBcImFscmVhZHkgaW5zdGFsbGVkXCIuXG5cblx0XHRcdC8vIGEgUHJvbWlzZSBtZWFucyBcImN1cnJlbnRseSBsb2FkaW5nXCIuXG5cdFx0XHRpZihpbnN0YWxsZWRDaHVua0RhdGEpIHtcblx0XHRcdFx0cHJvbWlzZXMucHVzaChpbnN0YWxsZWRDaHVua0RhdGFbMl0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYodHJ1ZSkgeyAvLyBhbGwgY2h1bmtzIGhhdmUgSlNcblx0XHRcdFx0XHQvLyBzZXR1cCBQcm9taXNlIGluIGNodW5rIGNhY2hlXG5cdFx0XHRcdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiAoaW5zdGFsbGVkQ2h1bmtEYXRhID0gaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gW3Jlc29sdmUsIHJlamVjdF0pKTtcblx0XHRcdFx0XHRwcm9taXNlcy5wdXNoKGluc3RhbGxlZENodW5rRGF0YVsyXSA9IHByb21pc2UpO1xuXG5cdFx0XHRcdFx0Ly8gc3RhcnQgY2h1bmsgbG9hZGluZ1xuXHRcdFx0XHRcdHZhciB1cmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLnUoY2h1bmtJZCk7XG5cdFx0XHRcdFx0Ly8gY3JlYXRlIGVycm9yIGJlZm9yZSBzdGFjayB1bndvdW5kIHRvIGdldCB1c2VmdWwgc3RhY2t0cmFjZSBsYXRlclxuXHRcdFx0XHRcdHZhciBlcnJvciA9IG5ldyBFcnJvcigpO1xuXHRcdFx0XHRcdHZhciBsb2FkaW5nRW5kZWQgPSAoZXZlbnQpID0+IHtcblx0XHRcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhpbnN0YWxsZWRDaHVua3MsIGNodW5rSWQpKSB7XG5cdFx0XHRcdFx0XHRcdGluc3RhbGxlZENodW5rRGF0YSA9IGluc3RhbGxlZENodW5rc1tjaHVua0lkXTtcblx0XHRcdFx0XHRcdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhICE9PSAwKSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBlcnJvclR5cGUgPSBldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ2xvYWQnID8gJ21pc3NpbmcnIDogZXZlbnQudHlwZSk7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJlYWxTcmMgPSBldmVudCAmJiBldmVudC50YXJnZXQgJiYgZXZlbnQudGFyZ2V0LnNyYztcblx0XHRcdFx0XHRcdFx0XHRlcnJvci5tZXNzYWdlID0gJ0xvYWRpbmcgY2h1bmsgJyArIGNodW5rSWQgKyAnIGZhaWxlZC5cXG4oJyArIGVycm9yVHlwZSArICc6ICcgKyByZWFsU3JjICsgJyknO1xuXHRcdFx0XHRcdFx0XHRcdGVycm9yLm5hbWUgPSAnQ2h1bmtMb2FkRXJyb3InO1xuXHRcdFx0XHRcdFx0XHRcdGVycm9yLnR5cGUgPSBlcnJvclR5cGU7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3IucmVxdWVzdCA9IHJlYWxTcmM7XG5cdFx0XHRcdFx0XHRcdFx0aW5zdGFsbGVkQ2h1bmtEYXRhWzFdKGVycm9yKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5sKHVybCwgbG9hZGluZ0VuZGVkLCBcImNodW5rLVwiICsgY2h1bmtJZCwgY2h1bmtJZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG59O1xuXG4vLyBubyBwcmVmZXRjaGluZ1xuXG4vLyBubyBwcmVsb2FkZWRcblxudmFyIGN1cnJlbnRVcGRhdGVkTW9kdWxlc0xpc3Q7XG52YXIgd2FpdGluZ1VwZGF0ZVJlc29sdmVzID0ge307XG5mdW5jdGlvbiBsb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCwgdXBkYXRlZE1vZHVsZXNMaXN0KSB7XG5cdGN1cnJlbnRVcGRhdGVkTW9kdWxlc0xpc3QgPSB1cGRhdGVkTW9kdWxlc0xpc3Q7XG5cdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0d2FpdGluZ1VwZGF0ZVJlc29sdmVzW2NodW5rSWRdID0gcmVzb2x2ZTtcblx0XHQvLyBzdGFydCB1cGRhdGUgY2h1bmsgbG9hZGluZ1xuXHRcdHZhciB1cmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLmh1KGNodW5rSWQpO1xuXHRcdC8vIGNyZWF0ZSBlcnJvciBiZWZvcmUgc3RhY2sgdW53b3VuZCB0byBnZXQgdXNlZnVsIHN0YWNrdHJhY2UgbGF0ZXJcblx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoKTtcblx0XHR2YXIgbG9hZGluZ0VuZGVkID0gKGV2ZW50KSA9PiB7XG5cdFx0XHRpZih3YWl0aW5nVXBkYXRlUmVzb2x2ZXNbY2h1bmtJZF0pIHtcblx0XHRcdFx0d2FpdGluZ1VwZGF0ZVJlc29sdmVzW2NodW5rSWRdID0gdW5kZWZpbmVkXG5cdFx0XHRcdHZhciBlcnJvclR5cGUgPSBldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ2xvYWQnID8gJ21pc3NpbmcnIDogZXZlbnQudHlwZSk7XG5cdFx0XHRcdHZhciByZWFsU3JjID0gZXZlbnQgJiYgZXZlbnQudGFyZ2V0ICYmIGV2ZW50LnRhcmdldC5zcmM7XG5cdFx0XHRcdGVycm9yLm1lc3NhZ2UgPSAnTG9hZGluZyBob3QgdXBkYXRlIGNodW5rICcgKyBjaHVua0lkICsgJyBmYWlsZWQuXFxuKCcgKyBlcnJvclR5cGUgKyAnOiAnICsgcmVhbFNyYyArICcpJztcblx0XHRcdFx0ZXJyb3IubmFtZSA9ICdDaHVua0xvYWRFcnJvcic7XG5cdFx0XHRcdGVycm9yLnR5cGUgPSBlcnJvclR5cGU7XG5cdFx0XHRcdGVycm9yLnJlcXVlc3QgPSByZWFsU3JjO1xuXHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5sKHVybCwgbG9hZGluZ0VuZGVkKTtcblx0fSk7XG59XG5cbnNlbGZbXCJ3ZWJwYWNrSG90VXBkYXRlZWNoYXJ0c19sZWFyblwiXSA9IChjaHVua0lkLCBtb3JlTW9kdWxlcywgcnVudGltZSkgPT4ge1xuXHRmb3IodmFyIG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1vcmVNb2R1bGVzLCBtb2R1bGVJZCkpIHtcblx0XHRcdGN1cnJlbnRVcGRhdGVbbW9kdWxlSWRdID0gbW9yZU1vZHVsZXNbbW9kdWxlSWRdO1xuXHRcdFx0aWYoY3VycmVudFVwZGF0ZWRNb2R1bGVzTGlzdCkgY3VycmVudFVwZGF0ZWRNb2R1bGVzTGlzdC5wdXNoKG1vZHVsZUlkKTtcblx0XHR9XG5cdH1cblx0aWYocnVudGltZSkgY3VycmVudFVwZGF0ZVJ1bnRpbWUucHVzaChydW50aW1lKTtcblx0aWYod2FpdGluZ1VwZGF0ZVJlc29sdmVzW2NodW5rSWRdKSB7XG5cdFx0d2FpdGluZ1VwZGF0ZVJlc29sdmVzW2NodW5rSWRdKCk7XG5cdFx0d2FpdGluZ1VwZGF0ZVJlc29sdmVzW2NodW5rSWRdID0gdW5kZWZpbmVkO1xuXHR9XG59O1xuXG52YXIgY3VycmVudFVwZGF0ZUNodW5rcztcbnZhciBjdXJyZW50VXBkYXRlO1xudmFyIGN1cnJlbnRVcGRhdGVSZW1vdmVkQ2h1bmtzO1xudmFyIGN1cnJlbnRVcGRhdGVSdW50aW1lO1xuZnVuY3Rpb24gYXBwbHlIYW5kbGVyKG9wdGlvbnMpIHtcblx0aWYgKF9fd2VicGFja19yZXF1aXJlX18uZikgZGVsZXRlIF9fd2VicGFja19yZXF1aXJlX18uZi5qc29ucEhtcjtcblx0Y3VycmVudFVwZGF0ZUNodW5rcyA9IHVuZGVmaW5lZDtcblx0ZnVuY3Rpb24gZ2V0QWZmZWN0ZWRNb2R1bGVFZmZlY3RzKHVwZGF0ZU1vZHVsZUlkKSB7XG5cdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFt1cGRhdGVNb2R1bGVJZF07XG5cdFx0dmFyIG91dGRhdGVkRGVwZW5kZW5jaWVzID0ge307XG5cblx0XHR2YXIgcXVldWUgPSBvdXRkYXRlZE1vZHVsZXMubWFwKGZ1bmN0aW9uIChpZCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y2hhaW46IFtpZF0sXG5cdFx0XHRcdGlkOiBpZFxuXHRcdFx0fTtcblx0XHR9KTtcblx0XHR3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuXHRcdFx0dmFyIHF1ZXVlSXRlbSA9IHF1ZXVlLnBvcCgpO1xuXHRcdFx0dmFyIG1vZHVsZUlkID0gcXVldWVJdGVtLmlkO1xuXHRcdFx0dmFyIGNoYWluID0gcXVldWVJdGVtLmNoYWluO1xuXHRcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18uY1ttb2R1bGVJZF07XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCFtb2R1bGUgfHxcblx0XHRcdFx0KG1vZHVsZS5ob3QuX3NlbGZBY2NlcHRlZCAmJiAhbW9kdWxlLmhvdC5fc2VsZkludmFsaWRhdGVkKVxuXHRcdFx0KVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdGlmIChtb2R1bGUuaG90Ll9zZWxmRGVjbGluZWQpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0eXBlOiBcInNlbGYtZGVjbGluZWRcIixcblx0XHRcdFx0XHRjaGFpbjogY2hhaW4sXG5cdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAobW9kdWxlLmhvdC5fbWFpbikge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHR5cGU6IFwidW5hY2NlcHRlZFwiLFxuXHRcdFx0XHRcdGNoYWluOiBjaGFpbixcblx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbW9kdWxlLnBhcmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIHBhcmVudElkID0gbW9kdWxlLnBhcmVudHNbaV07XG5cdFx0XHRcdHZhciBwYXJlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbcGFyZW50SWRdO1xuXHRcdFx0XHRpZiAoIXBhcmVudCkgY29udGludWU7XG5cdFx0XHRcdGlmIChwYXJlbnQuaG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0dHlwZTogXCJkZWNsaW5lZFwiLFxuXHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLmNvbmNhdChbcGFyZW50SWRdKSxcblx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcblx0XHRcdFx0XHRcdHBhcmVudElkOiBwYXJlbnRJZFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG91dGRhdGVkTW9kdWxlcy5pbmRleE9mKHBhcmVudElkKSAhPT0gLTEpIGNvbnRpbnVlO1xuXHRcdFx0XHRpZiAocGFyZW50LmhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKSB7XG5cdFx0XHRcdFx0aWYgKCFvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0pXG5cdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0gPSBbXTtcblx0XHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0sIFttb2R1bGVJZF0pO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlbGV0ZSBvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF07XG5cdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5wdXNoKHBhcmVudElkKTtcblx0XHRcdFx0cXVldWUucHVzaCh7XG5cdFx0XHRcdFx0Y2hhaW46IGNoYWluLmNvbmNhdChbcGFyZW50SWRdKSxcblx0XHRcdFx0XHRpZDogcGFyZW50SWRcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IFwiYWNjZXB0ZWRcIixcblx0XHRcdG1vZHVsZUlkOiB1cGRhdGVNb2R1bGVJZCxcblx0XHRcdG91dGRhdGVkTW9kdWxlczogb3V0ZGF0ZWRNb2R1bGVzLFxuXHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXM6IG91dGRhdGVkRGVwZW5kZW5jaWVzXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFkZEFsbFRvU2V0KGEsIGIpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gYltpXTtcblx0XHRcdGlmIChhLmluZGV4T2YoaXRlbSkgPT09IC0xKSBhLnB1c2goaXRlbSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gYXQgYmVnaW4gYWxsIHVwZGF0ZXMgbW9kdWxlcyBhcmUgb3V0ZGF0ZWRcblx0Ly8gdGhlIFwib3V0ZGF0ZWRcIiBzdGF0dXMgY2FuIHByb3BhZ2F0ZSB0byBwYXJlbnRzIGlmIHRoZXkgZG9uJ3QgYWNjZXB0IHRoZSBjaGlsZHJlblxuXHR2YXIgb3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSB7fTtcblx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xuXHR2YXIgYXBwbGllZFVwZGF0ZSA9IHt9O1xuXG5cdHZhciB3YXJuVW5leHBlY3RlZFJlcXVpcmUgPSBmdW5jdGlvbiB3YXJuVW5leHBlY3RlZFJlcXVpcmUobW9kdWxlKSB7XG5cdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XCJbSE1SXSB1bmV4cGVjdGVkIHJlcXVpcmUoXCIgKyBtb2R1bGUuaWQgKyBcIikgdG8gZGlzcG9zZWQgbW9kdWxlXCJcblx0XHQpO1xuXHR9O1xuXG5cdGZvciAodmFyIG1vZHVsZUlkIGluIGN1cnJlbnRVcGRhdGUpIHtcblx0XHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGN1cnJlbnRVcGRhdGUsIG1vZHVsZUlkKSkge1xuXHRcdFx0dmFyIG5ld01vZHVsZUZhY3RvcnkgPSBjdXJyZW50VXBkYXRlW21vZHVsZUlkXTtcblx0XHRcdC8qKiBAdHlwZSB7VE9ET30gKi9cblx0XHRcdHZhciByZXN1bHQ7XG5cdFx0XHRpZiAobmV3TW9kdWxlRmFjdG9yeSkge1xuXHRcdFx0XHRyZXN1bHQgPSBnZXRBZmZlY3RlZE1vZHVsZUVmZmVjdHMobW9kdWxlSWQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0ID0ge1xuXHRcdFx0XHRcdHR5cGU6IFwiZGlzcG9zZWRcIixcblx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdC8qKiBAdHlwZSB7RXJyb3J8ZmFsc2V9ICovXG5cdFx0XHR2YXIgYWJvcnRFcnJvciA9IGZhbHNlO1xuXHRcdFx0dmFyIGRvQXBwbHkgPSBmYWxzZTtcblx0XHRcdHZhciBkb0Rpc3Bvc2UgPSBmYWxzZTtcblx0XHRcdHZhciBjaGFpbkluZm8gPSBcIlwiO1xuXHRcdFx0aWYgKHJlc3VsdC5jaGFpbikge1xuXHRcdFx0XHRjaGFpbkluZm8gPSBcIlxcblVwZGF0ZSBwcm9wYWdhdGlvbjogXCIgKyByZXN1bHQuY2hhaW4uam9pbihcIiAtPiBcIik7XG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2ggKHJlc3VsdC50eXBlKSB7XG5cdFx0XHRcdGNhc2UgXCJzZWxmLWRlY2xpbmVkXCI6XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMub25EZWNsaW5lZCkgb3B0aW9ucy5vbkRlY2xpbmVkKHJlc3VsdCk7XG5cdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZURlY2xpbmVkKVxuXHRcdFx0XHRcdFx0YWJvcnRFcnJvciA9IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0XCJBYm9ydGVkIGJlY2F1c2Ugb2Ygc2VsZiBkZWNsaW5lOiBcIiArXG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0Lm1vZHVsZUlkICtcblx0XHRcdFx0XHRcdFx0XHRjaGFpbkluZm9cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJkZWNsaW5lZFwiOlxuXHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRGVjbGluZWQpIG9wdGlvbnMub25EZWNsaW5lZChyZXN1bHQpO1xuXHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVEZWNsaW5lZClcblx0XHRcdFx0XHRcdGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRcdFwiQWJvcnRlZCBiZWNhdXNlIG9mIGRlY2xpbmVkIGRlcGVuZGVuY3k6IFwiICtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHQubW9kdWxlSWQgK1xuXHRcdFx0XHRcdFx0XHRcdFwiIGluIFwiICtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHQucGFyZW50SWQgK1xuXHRcdFx0XHRcdFx0XHRcdGNoYWluSW5mb1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInVuYWNjZXB0ZWRcIjpcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5vblVuYWNjZXB0ZWQpIG9wdGlvbnMub25VbmFjY2VwdGVkKHJlc3VsdCk7XG5cdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZVVuYWNjZXB0ZWQpXG5cdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0XHRcIkFib3J0ZWQgYmVjYXVzZSBcIiArIG1vZHVsZUlkICsgXCIgaXMgbm90IGFjY2VwdGVkXCIgKyBjaGFpbkluZm9cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJhY2NlcHRlZFwiOlxuXHRcdFx0XHRcdGlmIChvcHRpb25zLm9uQWNjZXB0ZWQpIG9wdGlvbnMub25BY2NlcHRlZChyZXN1bHQpO1xuXHRcdFx0XHRcdGRvQXBwbHkgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZGlzcG9zZWRcIjpcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkRpc3Bvc2VkKSBvcHRpb25zLm9uRGlzcG9zZWQocmVzdWx0KTtcblx0XHRcdFx0XHRkb0Rpc3Bvc2UgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlVuZXhjZXB0aW9uIHR5cGUgXCIgKyByZXN1bHQudHlwZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYWJvcnRFcnJvcikge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGVycm9yOiBhYm9ydEVycm9yXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAoZG9BcHBseSkge1xuXHRcdFx0XHRhcHBsaWVkVXBkYXRlW21vZHVsZUlkXSA9IG5ld01vZHVsZUZhY3Rvcnk7XG5cdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkTW9kdWxlcywgcmVzdWx0Lm91dGRhdGVkTW9kdWxlcyk7XG5cdFx0XHRcdGZvciAobW9kdWxlSWQgaW4gcmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XG5cdFx0XHRcdFx0aWYgKF9fd2VicGFja19yZXF1aXJlX18ubyhyZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXMsIG1vZHVsZUlkKSkge1xuXHRcdFx0XHRcdFx0aWYgKCFvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pXG5cdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSA9IFtdO1xuXHRcdFx0XHRcdFx0YWRkQWxsVG9TZXQoXG5cdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSxcblx0XHRcdFx0XHRcdFx0cmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChkb0Rpc3Bvc2UpIHtcblx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWRNb2R1bGVzLCBbcmVzdWx0Lm1vZHVsZUlkXSk7XG5cdFx0XHRcdGFwcGxpZWRVcGRhdGVbbW9kdWxlSWRdID0gd2FyblVuZXhwZWN0ZWRSZXF1aXJlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRjdXJyZW50VXBkYXRlID0gdW5kZWZpbmVkO1xuXG5cdC8vIFN0b3JlIHNlbGYgYWNjZXB0ZWQgb3V0ZGF0ZWQgbW9kdWxlcyB0byByZXF1aXJlIHRoZW0gbGF0ZXIgYnkgdGhlIG1vZHVsZSBzeXN0ZW1cblx0dmFyIG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcyA9IFtdO1xuXHRmb3IgKHZhciBqID0gMDsgaiA8IG91dGRhdGVkTW9kdWxlcy5sZW5ndGg7IGorKykge1xuXHRcdHZhciBvdXRkYXRlZE1vZHVsZUlkID0gb3V0ZGF0ZWRNb2R1bGVzW2pdO1xuXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbb3V0ZGF0ZWRNb2R1bGVJZF07XG5cdFx0aWYgKFxuXHRcdFx0bW9kdWxlICYmXG5cdFx0XHQobW9kdWxlLmhvdC5fc2VsZkFjY2VwdGVkIHx8IG1vZHVsZS5ob3QuX21haW4pICYmXG5cdFx0XHQvLyByZW1vdmVkIHNlbGYtYWNjZXB0ZWQgbW9kdWxlcyBzaG91bGQgbm90IGJlIHJlcXVpcmVkXG5cdFx0XHRhcHBsaWVkVXBkYXRlW291dGRhdGVkTW9kdWxlSWRdICE9PSB3YXJuVW5leHBlY3RlZFJlcXVpcmUgJiZcblx0XHRcdC8vIHdoZW4gY2FsbGVkIGludmFsaWRhdGUgc2VsZi1hY2NlcHRpbmcgaXMgbm90IHBvc3NpYmxlXG5cdFx0XHQhbW9kdWxlLmhvdC5fc2VsZkludmFsaWRhdGVkXG5cdFx0KSB7XG5cdFx0XHRvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMucHVzaCh7XG5cdFx0XHRcdG1vZHVsZTogb3V0ZGF0ZWRNb2R1bGVJZCxcblx0XHRcdFx0cmVxdWlyZTogbW9kdWxlLmhvdC5fcmVxdWlyZVNlbGYsXG5cdFx0XHRcdGVycm9ySGFuZGxlcjogbW9kdWxlLmhvdC5fc2VsZkFjY2VwdGVkXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHR2YXIgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXM7XG5cblx0cmV0dXJuIHtcblx0XHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjdXJyZW50VXBkYXRlUmVtb3ZlZENodW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChjaHVua0lkKSB7XG5cdFx0XHRcdGRlbGV0ZSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF07XG5cdFx0XHR9KTtcblx0XHRcdGN1cnJlbnRVcGRhdGVSZW1vdmVkQ2h1bmtzID0gdW5kZWZpbmVkO1xuXG5cdFx0XHR2YXIgaWR4O1xuXHRcdFx0dmFyIHF1ZXVlID0gb3V0ZGF0ZWRNb2R1bGVzLnNsaWNlKCk7XG5cdFx0XHR3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuXHRcdFx0XHR2YXIgbW9kdWxlSWQgPSBxdWV1ZS5wb3AoKTtcblx0XHRcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18uY1ttb2R1bGVJZF07XG5cdFx0XHRcdGlmICghbW9kdWxlKSBjb250aW51ZTtcblxuXHRcdFx0XHR2YXIgZGF0YSA9IHt9O1xuXG5cdFx0XHRcdC8vIENhbGwgZGlzcG9zZSBoYW5kbGVyc1xuXHRcdFx0XHR2YXIgZGlzcG9zZUhhbmRsZXJzID0gbW9kdWxlLmhvdC5fZGlzcG9zZUhhbmRsZXJzO1xuXHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgZGlzcG9zZUhhbmRsZXJzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0ZGlzcG9zZUhhbmRsZXJzW2pdLmNhbGwobnVsbCwgZGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5obXJEW21vZHVsZUlkXSA9IGRhdGE7XG5cblx0XHRcdFx0Ly8gZGlzYWJsZSBtb2R1bGUgKHRoaXMgZGlzYWJsZXMgcmVxdWlyZXMgZnJvbSB0aGlzIG1vZHVsZSlcblx0XHRcdFx0bW9kdWxlLmhvdC5hY3RpdmUgPSBmYWxzZTtcblxuXHRcdFx0XHQvLyByZW1vdmUgbW9kdWxlIGZyb20gY2FjaGVcblx0XHRcdFx0ZGVsZXRlIF9fd2VicGFja19yZXF1aXJlX18uY1ttb2R1bGVJZF07XG5cblx0XHRcdFx0Ly8gd2hlbiBkaXNwb3NpbmcgdGhlcmUgaXMgbm8gbmVlZCB0byBjYWxsIGRpc3Bvc2UgaGFuZGxlclxuXHRcdFx0XHRkZWxldGUgb3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdO1xuXG5cdFx0XHRcdC8vIHJlbW92ZSBcInBhcmVudHNcIiByZWZlcmVuY2VzIGZyb20gYWxsIGNoaWxkcmVuXG5cdFx0XHRcdGZvciAoaiA9IDA7IGogPCBtb2R1bGUuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHR2YXIgY2hpbGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbbW9kdWxlLmNoaWxkcmVuW2pdXTtcblx0XHRcdFx0XHRpZiAoIWNoaWxkKSBjb250aW51ZTtcblx0XHRcdFx0XHRpZHggPSBjaGlsZC5wYXJlbnRzLmluZGV4T2YobW9kdWxlSWQpO1xuXHRcdFx0XHRcdGlmIChpZHggPj0gMCkge1xuXHRcdFx0XHRcdFx0Y2hpbGQucGFyZW50cy5zcGxpY2UoaWR4LCAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVtb3ZlIG91dGRhdGVkIGRlcGVuZGVuY3kgZnJvbSBtb2R1bGUgY2hpbGRyZW5cblx0XHRcdHZhciBkZXBlbmRlbmN5O1xuXHRcdFx0Zm9yICh2YXIgb3V0ZGF0ZWRNb2R1bGVJZCBpbiBvdXRkYXRlZERlcGVuZGVuY2llcykge1xuXHRcdFx0XHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5vKG91dGRhdGVkRGVwZW5kZW5jaWVzLCBvdXRkYXRlZE1vZHVsZUlkKSkge1xuXHRcdFx0XHRcdG1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18uY1tvdXRkYXRlZE1vZHVsZUlkXTtcblx0XHRcdFx0XHRpZiAobW9kdWxlKSB7XG5cdFx0XHRcdFx0XHRtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyA9XG5cdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW291dGRhdGVkTW9kdWxlSWRdO1xuXHRcdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0XHRcdGRlcGVuZGVuY3kgPSBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llc1tqXTtcblx0XHRcdFx0XHRcdFx0aWR4ID0gbW9kdWxlLmNoaWxkcmVuLmluZGV4T2YoZGVwZW5kZW5jeSk7XG5cdFx0XHRcdFx0XHRcdGlmIChpZHggPj0gMCkgbW9kdWxlLmNoaWxkcmVuLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YXBwbHk6IGZ1bmN0aW9uIChyZXBvcnRFcnJvcikge1xuXHRcdFx0Ly8gaW5zZXJ0IG5ldyBjb2RlXG5cdFx0XHRmb3IgKHZhciB1cGRhdGVNb2R1bGVJZCBpbiBhcHBsaWVkVXBkYXRlKSB7XG5cdFx0XHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm8oYXBwbGllZFVwZGF0ZSwgdXBkYXRlTW9kdWxlSWQpKSB7XG5cdFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tW3VwZGF0ZU1vZHVsZUlkXSA9IGFwcGxpZWRVcGRhdGVbdXBkYXRlTW9kdWxlSWRdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJ1biBuZXcgcnVudGltZSBtb2R1bGVzXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGN1cnJlbnRVcGRhdGVSdW50aW1lLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGN1cnJlbnRVcGRhdGVSdW50aW1lW2ldKF9fd2VicGFja19yZXF1aXJlX18pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjYWxsIGFjY2VwdCBoYW5kbGVyc1xuXHRcdFx0Zm9yICh2YXIgb3V0ZGF0ZWRNb2R1bGVJZCBpbiBvdXRkYXRlZERlcGVuZGVuY2llcykge1xuXHRcdFx0XHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5vKG91dGRhdGVkRGVwZW5kZW5jaWVzLCBvdXRkYXRlZE1vZHVsZUlkKSkge1xuXHRcdFx0XHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbb3V0ZGF0ZWRNb2R1bGVJZF07XG5cdFx0XHRcdFx0aWYgKG1vZHVsZSkge1xuXHRcdFx0XHRcdFx0bW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMgPVxuXHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1tvdXRkYXRlZE1vZHVsZUlkXTtcblx0XHRcdFx0XHRcdHZhciBjYWxsYmFja3MgPSBbXTtcblx0XHRcdFx0XHRcdHZhciBlcnJvckhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0XHR2YXIgZGVwZW5kZW5jaWVzRm9yQ2FsbGJhY2tzID0gW107XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBkZXBlbmRlbmN5ID0gbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbal07XG5cdFx0XHRcdFx0XHRcdHZhciBhY2NlcHRDYWxsYmFjayA9XG5cdFx0XHRcdFx0XHRcdFx0bW9kdWxlLmhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwZW5kZW5jeV07XG5cdFx0XHRcdFx0XHRcdHZhciBlcnJvckhhbmRsZXIgPVxuXHRcdFx0XHRcdFx0XHRcdG1vZHVsZS5ob3QuX2FjY2VwdGVkRXJyb3JIYW5kbGVyc1tkZXBlbmRlbmN5XTtcblx0XHRcdFx0XHRcdFx0aWYgKGFjY2VwdENhbGxiYWNrKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGNhbGxiYWNrcy5pbmRleE9mKGFjY2VwdENhbGxiYWNrKSAhPT0gLTEpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XHRcdGNhbGxiYWNrcy5wdXNoKGFjY2VwdENhbGxiYWNrKTtcblx0XHRcdFx0XHRcdFx0XHRlcnJvckhhbmRsZXJzLnB1c2goZXJyb3JIYW5kbGVyKTtcblx0XHRcdFx0XHRcdFx0XHRkZXBlbmRlbmNpZXNGb3JDYWxsYmFja3MucHVzaChkZXBlbmRlbmN5KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBjYWxsYmFja3MubGVuZ3RoOyBrKyspIHtcblx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRjYWxsYmFja3Nba10uY2FsbChudWxsLCBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyk7XG5cdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdFx0XHRcdGlmICh0eXBlb2YgZXJyb3JIYW5kbGVyc1trXSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRlcnJvckhhbmRsZXJzW2tdKGVyciwge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBvdXRkYXRlZE1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY3lJZDogZGVwZW5kZW5jaWVzRm9yQ2FsbGJhY2tzW2tdXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyMikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkVycm9yZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRXJyb3JlZCh7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImFjY2VwdC1lcnJvci1oYW5kbGVyLWVycm9yZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBvdXRkYXRlZE1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeUlkOiBkZXBlbmRlbmNpZXNGb3JDYWxsYmFja3Nba10sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyMixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9yaWdpbmFsRXJyb3I6IGVyclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVFcnJvcmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVwb3J0RXJyb3IoZXJyMik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVwb3J0RXJyb3IoZXJyKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkVycm9yZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYWNjZXB0LWVycm9yZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogb3V0ZGF0ZWRNb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZXBlbmRlbmN5SWQ6IGRlcGVuZGVuY2llc0ZvckNhbGxiYWNrc1trXSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVwb3J0RXJyb3IoZXJyKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9hZCBzZWxmIGFjY2VwdGVkIG1vZHVsZXNcblx0XHRcdGZvciAodmFyIG8gPSAwOyBvIDwgb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzLmxlbmd0aDsgbysrKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzW29dO1xuXHRcdFx0XHR2YXIgbW9kdWxlSWQgPSBpdGVtLm1vZHVsZTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpdGVtLnJlcXVpcmUobW9kdWxlSWQpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRpZiAodHlwZW9mIGl0ZW0uZXJyb3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdGl0ZW0uZXJyb3JIYW5kbGVyKGVyciwge1xuXHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0XHRtb2R1bGU6IF9fd2VicGFja19yZXF1aXJlX18uY1ttb2R1bGVJZF1cblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoIChlcnIyKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic2VsZi1hY2NlcHQtZXJyb3ItaGFuZGxlci1lcnJvcmVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyMixcblx0XHRcdFx0XHRcdFx0XHRcdG9yaWdpbmFsRXJyb3I6IGVyclxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVFcnJvcmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVwb3J0RXJyb3IoZXJyMik7XG5cdFx0XHRcdFx0XHRcdFx0cmVwb3J0RXJyb3IoZXJyKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkVycm9yZWQpIHtcblx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic2VsZi1hY2NlcHQtZXJyb3JlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcblx0XHRcdFx0XHRcdFx0cmVwb3J0RXJyb3IoZXJyKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG91dGRhdGVkTW9kdWxlcztcblx0XHR9XG5cdH07XG59XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmhtckkuanNvbnAgPSBmdW5jdGlvbiAobW9kdWxlSWQsIGFwcGx5SGFuZGxlcnMpIHtcblx0aWYgKCFjdXJyZW50VXBkYXRlKSB7XG5cdFx0Y3VycmVudFVwZGF0ZSA9IHt9O1xuXHRcdGN1cnJlbnRVcGRhdGVSdW50aW1lID0gW107XG5cdFx0Y3VycmVudFVwZGF0ZVJlbW92ZWRDaHVua3MgPSBbXTtcblx0XHRhcHBseUhhbmRsZXJzLnB1c2goYXBwbHlIYW5kbGVyKTtcblx0fVxuXHRpZiAoIV9fd2VicGFja19yZXF1aXJlX18ubyhjdXJyZW50VXBkYXRlLCBtb2R1bGVJZCkpIHtcblx0XHRjdXJyZW50VXBkYXRlW21vZHVsZUlkXSA9IF9fd2VicGFja19yZXF1aXJlX18ubVttb2R1bGVJZF07XG5cdH1cbn07XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmhtckMuanNvbnAgPSBmdW5jdGlvbiAoXG5cdGNodW5rSWRzLFxuXHRyZW1vdmVkQ2h1bmtzLFxuXHRyZW1vdmVkTW9kdWxlcyxcblx0cHJvbWlzZXMsXG5cdGFwcGx5SGFuZGxlcnMsXG5cdHVwZGF0ZWRNb2R1bGVzTGlzdFxuKSB7XG5cdGFwcGx5SGFuZGxlcnMucHVzaChhcHBseUhhbmRsZXIpO1xuXHRjdXJyZW50VXBkYXRlQ2h1bmtzID0ge307XG5cdGN1cnJlbnRVcGRhdGVSZW1vdmVkQ2h1bmtzID0gcmVtb3ZlZENodW5rcztcblx0Y3VycmVudFVwZGF0ZSA9IHJlbW92ZWRNb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAob2JqLCBrZXkpIHtcblx0XHRvYmpba2V5XSA9IGZhbHNlO1xuXHRcdHJldHVybiBvYmo7XG5cdH0sIHt9KTtcblx0Y3VycmVudFVwZGF0ZVJ1bnRpbWUgPSBbXTtcblx0Y2h1bmtJZHMuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmtJZCkge1xuXHRcdGlmIChcblx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubyhpbnN0YWxsZWRDaHVua3MsIGNodW5rSWQpICYmXG5cdFx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gIT09IHVuZGVmaW5lZFxuXHRcdCkge1xuXHRcdFx0cHJvbWlzZXMucHVzaChsb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCwgdXBkYXRlZE1vZHVsZXNMaXN0KSk7XG5cdFx0XHRjdXJyZW50VXBkYXRlQ2h1bmtzW2NodW5rSWRdID0gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VycmVudFVwZGF0ZUNodW5rc1tjaHVua0lkXSA9IGZhbHNlO1xuXHRcdH1cblx0fSk7XG5cdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLmYpIHtcblx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmYuanNvbnBIbXIgPSBmdW5jdGlvbiAoY2h1bmtJZCwgcHJvbWlzZXMpIHtcblx0XHRcdGlmIChcblx0XHRcdFx0Y3VycmVudFVwZGF0ZUNodW5rcyAmJlxuXHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8oY3VycmVudFVwZGF0ZUNodW5rcywgY2h1bmtJZCkgJiZcblx0XHRcdFx0IWN1cnJlbnRVcGRhdGVDaHVua3NbY2h1bmtJZF1cblx0XHRcdCkge1xuXHRcdFx0XHRwcm9taXNlcy5wdXNoKGxvYWRVcGRhdGVDaHVuayhjaHVua0lkKSk7XG5cdFx0XHRcdGN1cnJlbnRVcGRhdGVDaHVua3NbY2h1bmtJZF0gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn07XG5cbl9fd2VicGFja19yZXF1aXJlX18uaG1yTSA9ICgpID0+IHtcblx0aWYgKHR5cGVvZiBmZXRjaCA9PT0gXCJ1bmRlZmluZWRcIikgdGhyb3cgbmV3IEVycm9yKFwiTm8gYnJvd3NlciBzdXBwb3J0OiBuZWVkIGZldGNoIEFQSVwiKTtcblx0cmV0dXJuIGZldGNoKF9fd2VicGFja19yZXF1aXJlX18ucCArIF9fd2VicGFja19yZXF1aXJlX18uaG1yRigpKS50aGVuKChyZXNwb25zZSkgPT4ge1xuXHRcdGlmKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSByZXR1cm47IC8vIG5vIHVwZGF0ZSBhdmFpbGFibGVcblx0XHRpZighcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBmZXRjaCB1cGRhdGUgbWFuaWZlc3QgXCIgKyByZXNwb25zZS5zdGF0dXNUZXh0KTtcblx0XHRyZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuXHR9KTtcbn07XG5cbi8vIG5vIG9uIGNodW5rcyBsb2FkZWRcblxuLy8gaW5zdGFsbCBhIEpTT05QIGNhbGxiYWNrIGZvciBjaHVuayBsb2FkaW5nXG52YXIgd2VicGFja0pzb25wQ2FsbGJhY2sgPSAocGFyZW50Q2h1bmtMb2FkaW5nRnVuY3Rpb24sIGRhdGEpID0+IHtcblx0dmFyIFtjaHVua0lkcywgbW9yZU1vZHVsZXMsIHJ1bnRpbWVdID0gZGF0YTtcblx0Ly8gYWRkIFwibW9yZU1vZHVsZXNcIiB0byB0aGUgbW9kdWxlcyBvYmplY3QsXG5cdC8vIHRoZW4gZmxhZyBhbGwgXCJjaHVua0lkc1wiIGFzIGxvYWRlZCBhbmQgZmlyZSBjYWxsYmFja1xuXHR2YXIgbW9kdWxlSWQsIGNodW5rSWQsIGkgPSAwO1xuXHRpZihjaHVua0lkcy5zb21lKChpZCkgPT4gKGluc3RhbGxlZENodW5rc1tpZF0gIT09IDApKSkge1xuXHRcdGZvcihtb2R1bGVJZCBpbiBtb3JlTW9kdWxlcykge1xuXHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1vcmVNb2R1bGVzLCBtb2R1bGVJZCkpIHtcblx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYocnVudGltZSkgdmFyIHJlc3VsdCA9IHJ1bnRpbWUoX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdH1cblx0aWYocGFyZW50Q2h1bmtMb2FkaW5nRnVuY3Rpb24pIHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uKGRhdGEpO1xuXHRmb3IoO2kgPCBjaHVua0lkcy5sZW5ndGg7IGkrKykge1xuXHRcdGNodW5rSWQgPSBjaHVua0lkc1tpXTtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oaW5zdGFsbGVkQ2h1bmtzLCBjaHVua0lkKSAmJiBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0pIHtcblx0XHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXVswXSgpO1xuXHRcdH1cblx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSAwO1xuXHR9XG5cbn1cblxudmFyIGNodW5rTG9hZGluZ0dsb2JhbCA9IHNlbGZbXCJ3ZWJwYWNrQ2h1bmtlY2hhcnRzX2xlYXJuXCJdID0gc2VsZltcIndlYnBhY2tDaHVua2VjaGFydHNfbGVhcm5cIl0gfHwgW107XG5jaHVua0xvYWRpbmdHbG9iYWwuZm9yRWFjaCh3ZWJwYWNrSnNvbnBDYWxsYmFjay5iaW5kKG51bGwsIDApKTtcbmNodW5rTG9hZGluZ0dsb2JhbC5wdXNoID0gd2VicGFja0pzb25wQ2FsbGJhY2suYmluZChudWxsLCBjaHVua0xvYWRpbmdHbG9iYWwucHVzaC5iaW5kKGNodW5rTG9hZGluZ0dsb2JhbCkpOyIsIiIsIi8vIG1vZHVsZSBjYWNoZSBhcmUgdXNlZCBzbyBlbnRyeSBpbmxpbmluZyBpcyBkaXNhYmxlZFxuLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9tYWluLnRzXCIpO1xuIiwiIl0sIm5hbWVzIjpbIkhPT0tfU0VUVVAiLCJIT09LX1BMVUdJTl9TRVRUSU5HU19TRVQiLCJnZXREZXZ0b29sc0dsb2JhbEhvb2siLCJnZXRUYXJnZXQiLCJfX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwibmF2aWdhdG9yIiwid2luZG93IiwiZ2xvYmFsIiwiaXNQcm94eUF2YWlsYWJsZSIsIlByb3h5IiwiQXBpUHJveHkiLCJzZXR1cERldnRvb2xzUGx1Z2luIiwicGx1Z2luRGVzY3JpcHRvciIsInNldHVwRm4iLCJkZXNjcmlwdG9yIiwidGFyZ2V0IiwiaG9vayIsImVuYWJsZVByb3h5IiwiZW5hYmxlRWFybHlQcm94eSIsIl9fVlVFX0RFVlRPT0xTX1BMVUdJTl9BUElfQVZBSUxBQkxFX18iLCJlbWl0IiwicHJveHkiLCJsaXN0IiwiX19WVUVfREVWVE9PTFNfUExVR0lOU19fIiwicHVzaCIsInByb3hpZWRUYXJnZXQiLCJub3ciLCJjb25zdHJ1Y3RvciIsInBsdWdpbiIsInRhcmdldFF1ZXVlIiwib25RdWV1ZSIsImRlZmF1bHRTZXR0aW5ncyIsInNldHRpbmdzIiwiaWQiLCJpdGVtIiwiZGVmYXVsdFZhbHVlIiwibG9jYWxTZXR0aW5nc1NhdmVJZCIsImN1cnJlbnRTZXR0aW5ncyIsIk9iamVjdCIsImFzc2lnbiIsInJhdyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwiZSIsImZhbGxiYWNrcyIsImdldFNldHRpbmdzIiwic2V0U2V0dGluZ3MiLCJ2YWx1ZSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJvbiIsInBsdWdpbklkIiwicHJveGllZE9uIiwiZ2V0IiwiX3RhcmdldCIsInByb3AiLCJhcmdzIiwibWV0aG9kIiwia2V5cyIsImluY2x1ZGVzIiwicmVzb2x2ZSIsIlByb21pc2UiLCJzZXRSZWFsVGFyZ2V0Iiwic3VwcG9ydGVkIiwicGVyZiIsImlzUGVyZm9ybWFuY2VTdXBwb3J0ZWQiLCJfYSIsInVuZGVmaW5lZCIsInBlcmZvcm1hbmNlIiwicGVyZl9ob29rcyIsIkRhdGUiLCJleHRlbmQiLCJpc0FycmF5IiwiaXNTeW1ib2wiLCJpc01hcCIsImlzSW50ZWdlcktleSIsImhhc093biIsImhhc0NoYW5nZWQiLCJpc09iamVjdCIsIm1ha2VNYXAiLCJjYXBpdGFsaXplIiwidG9SYXdUeXBlIiwiZGVmIiwiaXNGdW5jdGlvbiIsIk5PT1AiLCJ3YXJuIiwibXNnIiwiY29uc29sZSIsImFjdGl2ZUVmZmVjdFNjb3BlIiwiRWZmZWN0U2NvcGUiLCJkZXRhY2hlZCIsIl9hY3RpdmUiLCJlZmZlY3RzIiwiY2xlYW51cHMiLCJwYXJlbnQiLCJpbmRleCIsInNjb3BlcyIsImFjdGl2ZSIsInJ1biIsImZuIiwiY3VycmVudEVmZmVjdFNjb3BlIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwib2ZmIiwic3RvcCIsImZyb21QYXJlbnQiLCJpIiwibCIsImxlbmd0aCIsImxhc3QiLCJwb3AiLCJlZmZlY3RTY29wZSIsInJlY29yZEVmZmVjdFNjb3BlIiwiZWZmZWN0Iiwic2NvcGUiLCJnZXRDdXJyZW50U2NvcGUiLCJvblNjb3BlRGlzcG9zZSIsImNyZWF0ZURlcCIsImRlcCIsIlNldCIsInciLCJuIiwid2FzVHJhY2tlZCIsInRyYWNrT3BCaXQiLCJuZXdUcmFja2VkIiwiaW5pdERlcE1hcmtlcnMiLCJkZXBzIiwiZmluYWxpemVEZXBNYXJrZXJzIiwicHRyIiwiZGVsZXRlIiwidGFyZ2V0TWFwIiwiV2Vha01hcCIsImVmZmVjdFRyYWNrRGVwdGgiLCJtYXhNYXJrZXJCaXRzIiwiYWN0aXZlRWZmZWN0IiwiSVRFUkFURV9LRVkiLCJTeW1ib2wiLCJNQVBfS0VZX0lURVJBVEVfS0VZIiwiUmVhY3RpdmVFZmZlY3QiLCJzY2hlZHVsZXIiLCJsYXN0U2hvdWxkVHJhY2siLCJzaG91bGRUcmFjayIsImNsZWFudXBFZmZlY3QiLCJkZWZlclN0b3AiLCJvblN0b3AiLCJlZmZlY3QyIiwib3B0aW9ucyIsIl9lZmZlY3QiLCJsYXp5IiwicnVubmVyIiwiYmluZCIsInRyYWNrU3RhY2siLCJwYXVzZVRyYWNraW5nIiwiZW5hYmxlVHJhY2tpbmciLCJyZXNldFRyYWNraW5nIiwidHJhY2siLCJ0eXBlIiwia2V5IiwiZGVwc01hcCIsInNldCIsIk1hcCIsImV2ZW50SW5mbyIsInRyYWNrRWZmZWN0cyIsImRlYnVnZ2VyRXZlbnRFeHRyYUluZm8iLCJzaG91bGRUcmFjazIiLCJoYXMiLCJhZGQiLCJvblRyYWNrIiwidHJpZ2dlciIsIm5ld1ZhbHVlIiwib2xkVmFsdWUiLCJvbGRUYXJnZXQiLCJ2YWx1ZXMiLCJuZXdMZW5ndGgiLCJOdW1iZXIiLCJmb3JFYWNoIiwia2V5MiIsInRyaWdnZXJFZmZlY3RzIiwiY29tcHV0ZWQiLCJ0cmlnZ2VyRWZmZWN0IiwiYWxsb3dSZWN1cnNlIiwib25UcmlnZ2VyIiwiZ2V0RGVwRnJvbVJlYWN0aXZlIiwib2JqZWN0IiwiaXNOb25UcmFja2FibGVLZXlzIiwiYnVpbHRJblN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZmlsdGVyIiwibWFwIiwiYXJyYXlJbnN0cnVtZW50YXRpb25zIiwiY3JlYXRlQXJyYXlJbnN0cnVtZW50YXRpb25zIiwiaW5zdHJ1bWVudGF0aW9ucyIsImFyciIsInRvUmF3IiwicmVzIiwiYXBwbHkiLCJoYXNPd25Qcm9wZXJ0eSIsIm9iaiIsIkJhc2VSZWFjdGl2ZUhhbmRsZXIiLCJfaXNSZWFkb25seSIsIl9zaGFsbG93IiwicmVjZWl2ZXIiLCJpc1JlYWRvbmx5MiIsInNoYWxsb3ciLCJzaGFsbG93UmVhZG9ubHlNYXAiLCJyZWFkb25seU1hcCIsInNoYWxsb3dSZWFjdGl2ZU1hcCIsInJlYWN0aXZlTWFwIiwidGFyZ2V0SXNBcnJheSIsIlJlZmxlY3QiLCJpc1JlZiIsInJlYWRvbmx5IiwicmVhY3RpdmUiLCJNdXRhYmxlUmVhY3RpdmVIYW5kbGVyIiwiaXNSZWFkb25seSIsImlzU2hhbGxvdyIsImhhZEtleSIsInJlc3VsdCIsImRlbGV0ZVByb3BlcnR5Iiwib3duS2V5cyIsIlJlYWRvbmx5UmVhY3RpdmVIYW5kbGVyIiwiU3RyaW5nIiwibXV0YWJsZUhhbmRsZXJzIiwicmVhZG9ubHlIYW5kbGVycyIsInNoYWxsb3dSZWFjdGl2ZUhhbmRsZXJzIiwic2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMiLCJ0b1NoYWxsb3ciLCJnZXRQcm90byIsInYiLCJnZXRQcm90b3R5cGVPZiIsInJhd1RhcmdldCIsInJhd0tleSIsImhhczIiLCJ3cmFwIiwidG9SZWFkb25seSIsInRvUmVhY3RpdmUiLCJjYWxsIiwic2l6ZSIsInByb3RvIiwiZ2V0MiIsImNoZWNrSWRlbnRpdHlLZXlzIiwiZGVsZXRlRW50cnkiLCJjbGVhciIsImhhZEl0ZW1zIiwiY3JlYXRlRm9yRWFjaCIsImNhbGxiYWNrIiwidGhpc0FyZyIsIm9ic2VydmVkIiwiY3JlYXRlSXRlcmFibGVNZXRob2QiLCJ0YXJnZXRJc01hcCIsImlzUGFpciIsIml0ZXJhdG9yIiwiaXNLZXlPbmx5IiwiaW5uZXJJdGVyYXRvciIsIm5leHQiLCJkb25lIiwiY3JlYXRlUmVhZG9ubHlNZXRob2QiLCJjcmVhdGVJbnN0cnVtZW50YXRpb25zIiwibXV0YWJsZUluc3RydW1lbnRhdGlvbnMyIiwic2hhbGxvd0luc3RydW1lbnRhdGlvbnMyIiwicmVhZG9ubHlJbnN0cnVtZW50YXRpb25zMiIsInNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnMyIiwiaXRlcmF0b3JNZXRob2RzIiwibXV0YWJsZUluc3RydW1lbnRhdGlvbnMiLCJyZWFkb25seUluc3RydW1lbnRhdGlvbnMiLCJzaGFsbG93SW5zdHJ1bWVudGF0aW9ucyIsInNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnMiLCJjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIiLCJtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzIiwic2hhbGxvd0NvbGxlY3Rpb25IYW5kbGVycyIsInJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzIiwic2hhbGxvd1JlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzIiwidGFyZ2V0VHlwZU1hcCIsInJhd1R5cGUiLCJnZXRUYXJnZXRUeXBlIiwiaXNFeHRlbnNpYmxlIiwiY3JlYXRlUmVhY3RpdmVPYmplY3QiLCJzaGFsbG93UmVhY3RpdmUiLCJzaGFsbG93UmVhZG9ubHkiLCJiYXNlSGFuZGxlcnMiLCJjb2xsZWN0aW9uSGFuZGxlcnMiLCJwcm94eU1hcCIsImV4aXN0aW5nUHJveHkiLCJ0YXJnZXRUeXBlIiwiaXNSZWFjdGl2ZSIsImlzUHJveHkiLCJtYXJrUmF3IiwidHJhY2tSZWZWYWx1ZSIsInJlZjIiLCJ0cmlnZ2VyUmVmVmFsdWUiLCJuZXdWYWwiLCJyIiwiX192X2lzUmVmIiwicmVmIiwiY3JlYXRlUmVmIiwic2hhbGxvd1JlZiIsInJhd1ZhbHVlIiwiUmVmSW1wbCIsIl9fdl9pc1NoYWxsb3ciLCJfcmF3VmFsdWUiLCJfdmFsdWUiLCJ1c2VEaXJlY3RWYWx1ZSIsInRyaWdnZXJSZWYiLCJ1bnJlZiIsInRvVmFsdWUiLCJzb3VyY2UiLCJzaGFsbG93VW53cmFwSGFuZGxlcnMiLCJwcm94eVJlZnMiLCJvYmplY3RXaXRoUmVmcyIsIkN1c3RvbVJlZkltcGwiLCJmYWN0b3J5IiwiX2dldCIsIl9zZXQiLCJjdXN0b21SZWYiLCJ0b1JlZnMiLCJyZXQiLCJBcnJheSIsInByb3BlcnR5VG9SZWYiLCJPYmplY3RSZWZJbXBsIiwiX29iamVjdCIsIl9rZXkiLCJfZGVmYXVsdFZhbHVlIiwidmFsIiwiR2V0dGVyUmVmSW1wbCIsIl9nZXR0ZXIiLCJfX3ZfaXNSZWFkb25seSIsInRvUmVmIiwiYXJndW1lbnRzIiwiQ29tcHV0ZWRSZWZJbXBsIiwiZ2V0dGVyIiwiX3NldHRlciIsImlzU1NSIiwiX2RpcnR5IiwiX2NhY2hlYWJsZSIsInNlbGYiLCJnZXR0ZXJPck9wdGlvbnMiLCJkZWJ1Z09wdGlvbnMiLCJzZXR0ZXIiLCJvbmx5R2V0dGVyIiwiY1JlZiIsInRpY2siLCJxdWV1ZSIsInF1ZXVlZCIsInRoZW4iLCJmbHVzaCIsIkRlZmVycmVkQ29tcHV0ZWRSZWZJbXBsIiwiY29tcGFyZVRhcmdldCIsImhhc0NvbXBhcmVUYXJnZXQiLCJzY2hlZHVsZWQiLCJjb21wdXRlZFRyaWdnZXIiLCJ2YWx1ZVRvQ29tcGFyZSIsImRlZmVycmVkQ29tcHV0ZWQiLCJpc1NoYWxsb3ckMSIsImNvbXB1dGVkJDEiLCJpc1N0cmluZyIsImlzUHJvbWlzZSIsImdldEdsb2JhbFRoaXMiLCJFTVBUWV9PQkoiLCJ0b0hhbmRsZXJLZXkiLCJsb29zZVRvTnVtYmVyIiwiaHlwaGVuYXRlIiwiY2FtZWxpemUiLCJpc09uIiwiaXNNb2RlbExpc3RlbmVyIiwidG9OdW1iZXIiLCJyZW1vdmUiLCJpc1NldCIsImlzUGxhaW5PYmplY3QiLCJpc0J1aWx0SW5EaXJlY3RpdmUiLCJpbnZva2VBcnJheUZucyIsImlzUmVnRXhwIiwiaXNHbG9iYWxseUFsbG93ZWQiLCJOTyIsImlzUmVzZXJ2ZWRQcm9wIiwiRU1QVFlfQVJSIiwibm9ybWFsaXplQ2xhc3MiLCJub3JtYWxpemVTdHlsZSIsIm5vcm1hbGl6ZVByb3BzIiwidG9EaXNwbGF5U3RyaW5nIiwic3RhY2siLCJwdXNoV2FybmluZ0NvbnRleHQiLCJ2bm9kZSIsInBvcFdhcm5pbmdDb250ZXh0IiwiaW5zdGFuY2UiLCJjb21wb25lbnQiLCJhcHBXYXJuSGFuZGxlciIsImFwcENvbnRleHQiLCJjb25maWciLCJ3YXJuSGFuZGxlciIsInRyYWNlIiwiZ2V0Q29tcG9uZW50VHJhY2UiLCJjYWxsV2l0aEVycm9ySGFuZGxpbmciLCJqb2luIiwiZm9ybWF0Q29tcG9uZW50TmFtZSIsIndhcm5BcmdzIiwiZm9ybWF0VHJhY2UiLCJjdXJyZW50Vk5vZGUiLCJub3JtYWxpemVkU3RhY2siLCJyZWN1cnNlQ291bnQiLCJwYXJlbnRJbnN0YW5jZSIsImxvZ3MiLCJlbnRyeSIsImZvcm1hdFRyYWNlRW50cnkiLCJwb3N0Zml4IiwiaXNSb290Iiwib3BlbiIsImNsb3NlIiwicHJvcHMiLCJmb3JtYXRQcm9wcyIsInNsaWNlIiwiZm9ybWF0UHJvcCIsIm5hbWUiLCJhc3NlcnROdW1iZXIiLCJpc05hTiIsIkVycm9yVHlwZVN0cmluZ3MiLCJlcnIiLCJoYW5kbGVFcnJvciIsImNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nIiwiY2F0Y2giLCJ0aHJvd0luRGV2IiwiY29udGV4dFZOb2RlIiwiY3VyIiwiZXhwb3NlZEluc3RhbmNlIiwiZXJyb3JJbmZvIiwiZXJyb3JDYXB0dXJlZEhvb2tzIiwiZWMiLCJhcHBFcnJvckhhbmRsZXIiLCJlcnJvckhhbmRsZXIiLCJsb2dFcnJvciIsImluZm8iLCJlcnJvciIsImlzRmx1c2hpbmciLCJpc0ZsdXNoUGVuZGluZyIsImZsdXNoSW5kZXgiLCJwZW5kaW5nUG9zdEZsdXNoQ2JzIiwiYWN0aXZlUG9zdEZsdXNoQ2JzIiwicG9zdEZsdXNoSW5kZXgiLCJyZXNvbHZlZFByb21pc2UiLCJjdXJyZW50Rmx1c2hQcm9taXNlIiwiUkVDVVJTSU9OX0xJTUlUIiwibmV4dFRpY2siLCJwIiwiZmluZEluc2VydGlvbkluZGV4Iiwic3RhcnQiLCJlbmQiLCJtaWRkbGUiLCJtaWRkbGVKb2IiLCJtaWRkbGVKb2JJZCIsImdldElkIiwicHJlIiwicXVldWVKb2IiLCJqb2IiLCJzcGxpY2UiLCJxdWV1ZUZsdXNoIiwiZmx1c2hKb2JzIiwiaW52YWxpZGF0ZUpvYiIsImluZGV4T2YiLCJxdWV1ZVBvc3RGbHVzaENiIiwiY2IiLCJmbHVzaFByZUZsdXNoQ2JzIiwic2VlbiIsImNoZWNrUmVjdXJzaXZlVXBkYXRlcyIsImZsdXNoUG9zdEZsdXNoQ2JzIiwiZGVkdXBlZCIsInNvcnQiLCJhIiwiYiIsIkluZmluaXR5IiwiY29tcGFyYXRvciIsImRpZmYiLCJjaGVjayIsImNvdW50Iiwib3duZXJJbnN0YW5jZSIsImNvbXBvbmVudE5hbWUiLCJnZXRDb21wb25lbnROYW1lIiwiaXNIbXJVcGRhdGluZyIsImhtckRpcnR5Q29tcG9uZW50cyIsIl9fVlVFX0hNUl9SVU5USU1FX18iLCJjcmVhdGVSZWNvcmQiLCJ0cnlXcmFwIiwicmVyZW5kZXIiLCJyZWxvYWQiLCJyZWdpc3RlckhNUiIsIl9faG1ySWQiLCJyZWNvcmQiLCJpbnN0YW5jZXMiLCJ1bnJlZ2lzdGVySE1SIiwiaW5pdGlhbERlZiIsIm5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50IiwiaXNDbGFzc0NvbXBvbmVudCIsIl9fdmNjT3B0cyIsIm5ld1JlbmRlciIsInJlbmRlciIsInJlbmRlckNhY2hlIiwidXBkYXRlIiwibmV3Q29tcCIsInVwZGF0ZUNvbXBvbmVudERlZiIsIm9sZENvbXAiLCJwcm9wc0NhY2hlIiwiZW1pdHNDYWNoZSIsIm9wdGlvbnNDYWNoZSIsImNlUmVsb2FkIiwic3R5bGVzIiwibG9jYXRpb24iLCJhcmciLCJkZXZ0b29scyIsImJ1ZmZlciIsImRldnRvb2xzTm90SW5zdGFsbGVkIiwiZW1pdCQxIiwiZXZlbnQiLCJzZXREZXZ0b29sc0hvb2siLCJfYiIsImVuYWJsZWQiLCJIVE1MRWxlbWVudCIsInVzZXJBZ2VudCIsInJlcGxheSIsIl9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18iLCJuZXdIb29rIiwic2V0VGltZW91dCIsImRldnRvb2xzSW5pdEFwcCIsImFwcCIsInZlcnNpb24iLCJGcmFnbWVudCIsIlRleHQiLCJDb21tZW50IiwiU3RhdGljIiwiZGV2dG9vbHNVbm1vdW50QXBwIiwiZGV2dG9vbHNDb21wb25lbnRBZGRlZCIsImNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayIsImRldnRvb2xzQ29tcG9uZW50VXBkYXRlZCIsIl9kZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQiLCJkZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQiLCJjbGVhbnVwQnVmZmVyIiwidWlkIiwiZGV2dG9vbHNQZXJmU3RhcnQiLCJjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayIsImRldnRvb2xzUGVyZkVuZCIsInRpbWUiLCJkZXZ0b29sc0NvbXBvbmVudEVtaXQiLCJwYXJhbXMiLCJyYXdBcmdzIiwiaXNVbm1vdW50ZWQiLCJlbWl0c09wdGlvbnMiLCJwcm9wc09wdGlvbnMiLCJ2YWxpZGF0b3IiLCJpc1ZhbGlkIiwic3RhcnRzV2l0aCIsIm1vZGVsQXJnIiwibW9kaWZpZXJzS2V5IiwibnVtYmVyIiwidHJpbSIsIl9fVlVFX1BST0RfREVWVE9PTFNfXyIsImxvd2VyQ2FzZUV2ZW50IiwidG9Mb3dlckNhc2UiLCJoYW5kbGVyTmFtZSIsImhhbmRsZXIiLCJvbmNlSGFuZGxlciIsImVtaXR0ZWQiLCJub3JtYWxpemVFbWl0c09wdGlvbnMiLCJjb21wIiwiYXNNaXhpbiIsImNhY2hlIiwiY2FjaGVkIiwiZW1pdHMiLCJub3JtYWxpemVkIiwiaGFzRXh0ZW5kcyIsIl9fVlVFX09QVElPTlNfQVBJX18iLCJleHRlbmRFbWl0cyIsInJhdzIiLCJub3JtYWxpemVkRnJvbUV4dGVuZCIsIm1peGlucyIsImV4dGVuZHMiLCJpc0VtaXRMaXN0ZW5lciIsInJlcGxhY2UiLCJjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UiLCJjdXJyZW50U2NvcGVJZCIsInNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSIsInByZXYiLCJfX3Njb3BlSWQiLCJwdXNoU2NvcGVJZCIsInBvcFNjb3BlSWQiLCJ3aXRoU2NvcGVJZCIsIl9pZCIsIndpdGhDdHgiLCJjdHgiLCJpc05vblNjb3BlZFNsb3QiLCJfbiIsInJlbmRlckZuV2l0aENvbnRleHQiLCJfZCIsInNldEJsb2NrVHJhY2tpbmciLCJwcmV2SW5zdGFuY2UiLCJfYyIsImFjY2Vzc2VkQXR0cnMiLCJtYXJrQXR0cnNBY2Nlc3NlZCIsInJlbmRlckNvbXBvbmVudFJvb3QiLCJDb21wb25lbnQiLCJ3aXRoUHJveHkiLCJzbG90cyIsImF0dHJzIiwic2V0dXBTdGF0ZSIsImluaGVyaXRBdHRycyIsImZhbGx0aHJvdWdoQXR0cnMiLCJzaGFwZUZsYWciLCJwcm94eVRvVXNlIiwibm9ybWFsaXplVk5vZGUiLCJyZW5kZXIyIiwiZ2V0RnVuY3Rpb25hbEZhbGx0aHJvdWdoIiwiYmxvY2tTdGFjayIsImNyZWF0ZVZOb2RlIiwicm9vdCIsInNldFJvb3QiLCJwYXRjaEZsYWciLCJnZXRDaGlsZFJvb3QiLCJzb21lIiwiZmlsdGVyTW9kZWxMaXN0ZW5lcnMiLCJjbG9uZVZOb2RlIiwiYWxsQXR0cnMiLCJldmVudEF0dHJzIiwiZXh0cmFBdHRycyIsImRpcnMiLCJpc0VsZW1lbnRSb290IiwiY29uY2F0IiwidHJhbnNpdGlvbiIsInJhd0NoaWxkcmVuIiwiY2hpbGRyZW4iLCJkeW5hbWljQ2hpbGRyZW4iLCJjaGlsZFJvb3QiLCJmaWx0ZXJTaW5nbGVSb290IiwiZHluYW1pY0luZGV4IiwidXBkYXRlZFJvb3QiLCJzaW5nbGVSb290IiwiY2hpbGQiLCJpc1ZOb2RlIiwic2hvdWxkVXBkYXRlQ29tcG9uZW50IiwicHJldlZOb2RlIiwibmV4dFZOb2RlIiwib3B0aW1pemVkIiwicHJldlByb3BzIiwicHJldkNoaWxkcmVuIiwibmV4dFByb3BzIiwibmV4dENoaWxkcmVuIiwiaGFzUHJvcHNDaGFuZ2VkIiwiZHluYW1pY1Byb3BzIiwiJHN0YWJsZSIsIm5leHRLZXlzIiwidXBkYXRlSE9DSG9zdEVsIiwiZWwiLCJzdWJUcmVlIiwiaXNTdXNwZW5zZSIsIl9faXNTdXNwZW5zZSIsIlN1c3BlbnNlSW1wbCIsIm4xIiwibjIiLCJjb250YWluZXIiLCJhbmNob3IiLCJwYXJlbnRDb21wb25lbnQiLCJwYXJlbnRTdXNwZW5zZSIsImlzU1ZHIiwic2xvdFNjb3BlSWRzIiwicmVuZGVyZXJJbnRlcm5hbHMiLCJtb3VudFN1c3BlbnNlIiwicGF0Y2hTdXNwZW5zZSIsImh5ZHJhdGUiLCJoeWRyYXRlU3VzcGVuc2UiLCJjcmVhdGUiLCJjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5Iiwibm9ybWFsaXplIiwibm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlbiIsIlN1c3BlbnNlIiwidHJpZ2dlckV2ZW50IiwiZXZlbnRMaXN0ZW5lciIsInBhdGNoIiwibyIsImNyZWF0ZUVsZW1lbnQiLCJoaWRkZW5Db250YWluZXIiLCJzdXNwZW5zZSIsInBlbmRpbmdCcmFuY2giLCJzc0NvbnRlbnQiLCJzc0ZhbGxiYWNrIiwic2V0QWN0aXZlQnJhbmNoIiwidW0iLCJ1bm1vdW50IiwibmV3QnJhbmNoIiwibmV3RmFsbGJhY2siLCJhY3RpdmVCcmFuY2giLCJpc0luRmFsbGJhY2siLCJpc0h5ZHJhdGluZyIsImlzU2FtZVZOb2RlVHlwZSIsInBlbmRpbmdJZCIsInRpbWVvdXQiLCJmYWxsYmFjayIsImhhc1dhcm5lZCIsIm0iLCJtb3ZlIiwicGFyZW50Tm9kZSIsInBhcmVudFN1c3BlbnNlSWQiLCJpc1N1c3BlbnNpYmxlIiwiaXNWTm9kZVN1c3BlbnNpYmxlIiwicmVzdW1lIiwic3luYyIsIkVycm9yIiwidm5vZGUyIiwicGFyZW50Q29tcG9uZW50MiIsImNvbnRhaW5lcjIiLCJkZWxheUVudGVyIiwibW9kZSIsImFmdGVyTGVhdmUiLCJhbmNob3IyIiwiaGFzVW5yZXNvbHZlZEFuY2VzdG9yIiwiZmFsbGJhY2tWTm9kZSIsImlzU1ZHMiIsIm1vdW50RmFsbGJhY2siLCJyZWdpc3RlckRlcCIsInNldHVwUmVuZGVyRWZmZWN0IiwiaXNJblBlbmRpbmdTdXNwZW5zZSIsImh5ZHJhdGVkRWwiLCJhc3luY0RlcCIsImFzeW5jU2V0dXBSZXN1bHQiLCJzdXNwZW5zZUlkIiwiYXN5bmNSZXNvbHZlZCIsImhhbmRsZVNldHVwUmVzdWx0IiwicGxhY2Vob2xkZXIiLCJwYXJlbnRTdXNwZW5zZTIiLCJkb1JlbW92ZSIsIm5vZGUiLCJoeWRyYXRlTm9kZSIsImRvY3VtZW50IiwiaXNTbG90Q2hpbGRyZW4iLCJub3JtYWxpemVTdXNwZW5zZVNsb3QiLCJkZWZhdWx0IiwicyIsImJsb2NrIiwidHJhY2tCbG9jayIsImlzQmxvY2tUcmVlRW5hYmxlZCIsIm9wZW5CbG9jayIsImN1cnJlbnRCbG9jayIsImNsb3NlQmxvY2siLCJzaW5nbGVDaGlsZCIsImMiLCJxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZSIsImJyYW5jaCIsInN1c3BlbnNpYmxlIiwid2F0Y2hFZmZlY3QiLCJkb1dhdGNoIiwid2F0Y2hQb3N0RWZmZWN0Iiwid2F0Y2hTeW5jRWZmZWN0IiwiSU5JVElBTF9XQVRDSEVSX1ZBTFVFIiwid2F0Y2giLCJpbW1lZGlhdGUiLCJkZWVwIiwid2FybkludmFsaWRTb3VyY2UiLCJjdXJyZW50SW5zdGFuY2UiLCJmb3JjZVRyaWdnZXIiLCJpc011bHRpU291cmNlIiwidHJhdmVyc2UiLCJjbGVhbnVwIiwib25DbGVhbnVwIiwiYmFzZUdldHRlciIsInNzckNsZWFudXAiLCJpc0luU1NSQ29tcG9uZW50U2V0dXAiLCJ1c2VTU1JDb250ZXh0IiwiX193YXRjaGVySGFuZGxlcyIsImZpbGwiLCJxdWV1ZVBvc3RSZW5kZXJFZmZlY3QiLCJ1bndhdGNoIiwiaW5zdGFuY2VXYXRjaCIsInB1YmxpY1RoaXMiLCJjcmVhdGVQYXRoR2V0dGVyIiwic2V0Q3VycmVudEluc3RhbmNlIiwidW5zZXRDdXJyZW50SW5zdGFuY2UiLCJwYXRoIiwic2VnbWVudHMiLCJzcGxpdCIsInZhbGlkYXRlRGlyZWN0aXZlTmFtZSIsIndpdGhEaXJlY3RpdmVzIiwiZGlyZWN0aXZlcyIsImludGVybmFsSW5zdGFuY2UiLCJnZXRFeHBvc2VQcm94eSIsImJpbmRpbmdzIiwiZGlyIiwibW9kaWZpZXJzIiwibW91bnRlZCIsInVwZGF0ZWQiLCJpbnZva2VEaXJlY3RpdmVIb29rIiwib2xkQmluZGluZ3MiLCJiaW5kaW5nIiwibGVhdmVDYktleSIsImVudGVyQ2JLZXkiLCJ1c2VUcmFuc2l0aW9uU3RhdGUiLCJzdGF0ZSIsImlzTW91bnRlZCIsImlzTGVhdmluZyIsImlzVW5tb3VudGluZyIsImxlYXZpbmdWTm9kZXMiLCJvbk1vdW50ZWQiLCJvbkJlZm9yZVVubW91bnQiLCJUcmFuc2l0aW9uSG9va1ZhbGlkYXRvciIsIkZ1bmN0aW9uIiwiQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMiLCJhcHBlYXIiLCJCb29sZWFuIiwicGVyc2lzdGVkIiwib25CZWZvcmVFbnRlciIsIm9uRW50ZXIiLCJvbkFmdGVyRW50ZXIiLCJvbkVudGVyQ2FuY2VsbGVkIiwib25CZWZvcmVMZWF2ZSIsIm9uTGVhdmUiLCJvbkFmdGVyTGVhdmUiLCJvbkxlYXZlQ2FuY2VsbGVkIiwib25CZWZvcmVBcHBlYXIiLCJvbkFwcGVhciIsIm9uQWZ0ZXJBcHBlYXIiLCJvbkFwcGVhckNhbmNlbGxlZCIsIkJhc2VUcmFuc2l0aW9uSW1wbCIsInNldHVwIiwiZ2V0Q3VycmVudEluc3RhbmNlIiwicHJldlRyYW5zaXRpb25LZXkiLCJnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4iLCJoYXNGb3VuZCIsInJhd1Byb3BzIiwiZW1wdHlQbGFjZWhvbGRlciIsImlubmVyQ2hpbGQiLCJnZXRLZWVwQWxpdmVDaGlsZCIsImVudGVySG9va3MiLCJyZXNvbHZlVHJhbnNpdGlvbkhvb2tzIiwic2V0VHJhbnNpdGlvbkhvb2tzIiwib2xkQ2hpbGQiLCJvbGRJbm5lckNoaWxkIiwidHJhbnNpdGlvbktleUNoYW5nZWQiLCJnZXRUcmFuc2l0aW9uS2V5IiwibGVhdmluZ0hvb2tzIiwiZGVsYXlMZWF2ZSIsImVhcmx5UmVtb3ZlIiwiZGVsYXllZExlYXZlIiwibGVhdmluZ1ZOb2Rlc0NhY2hlIiwiZ2V0TGVhdmluZ05vZGVzRm9yVHlwZSIsIkJhc2VUcmFuc2l0aW9uIiwiY2FsbEhvb2siLCJjYWxsQXN5bmNIb29rIiwiZXZlcnkiLCJob29rMiIsImhvb2tzIiwiYmVmb3JlRW50ZXIiLCJsZWF2aW5nVk5vZGUiLCJlbnRlciIsImFmdGVySG9vayIsImNhbmNlbEhvb2siLCJjYWxsZWQiLCJjYW5jZWxsZWQiLCJsZWF2ZSIsImNsb25lIiwiaXNLZWVwQWxpdmUiLCJrZWVwQ29tbWVudCIsInBhcmVudEtleSIsImtleWVkRnJhZ21lbnRDb3VudCIsImRlZmluZUNvbXBvbmVudCIsImV4dHJhT3B0aW9ucyIsImlzQXN5bmNXcmFwcGVyIiwiX19hc3luY0xvYWRlciIsImRlZmluZUFzeW5jQ29tcG9uZW50IiwibG9hZGVyIiwibG9hZGluZ0NvbXBvbmVudCIsImVycm9yQ29tcG9uZW50IiwiZGVsYXkiLCJvbkVycm9yIiwidXNlck9uRXJyb3IiLCJwZW5kaW5nUmVxdWVzdCIsInJlc29sdmVkQ29tcCIsInJldHJpZXMiLCJyZXRyeSIsImxvYWQiLCJ0aGlzUmVxdWVzdCIsInJlamVjdCIsInVzZXJSZXRyeSIsInVzZXJGYWlsIiwiX19lc01vZHVsZSIsInRvU3RyaW5nVGFnIiwiX19hc3luY1Jlc29sdmVkIiwiY3JlYXRlSW5uZXJDb21wIiwibG9hZGVkIiwiZGVsYXllZCIsImNlIiwiX19pc0tlZXBBbGl2ZSIsIktlZXBBbGl2ZUltcGwiLCJpbmNsdWRlIiwiUmVnRXhwIiwiZXhjbHVkZSIsIm1heCIsInNoYXJlZENvbnRleHQiLCJyZW5kZXJlciIsImN1cnJlbnQiLCJfX3ZfY2FjaGUiLCJfdW5tb3VudCIsInN0b3JhZ2VDb250YWluZXIiLCJhY3RpdmF0ZSIsImluc3RhbmNlMiIsImlzRGVhY3RpdmF0ZWQiLCJ2bm9kZUhvb2siLCJvblZub2RlTW91bnRlZCIsImludm9rZVZOb2RlSG9vayIsImRlYWN0aXZhdGUiLCJkYSIsIm9uVm5vZGVVbm1vdW50ZWQiLCJyZXNldFNoYXBlRmxhZyIsInBydW5lQ2FjaGUiLCJwcnVuZUNhY2hlRW50cnkiLCJtYXRjaGVzIiwicGVuZGluZ0NhY2hlS2V5IiwiY2FjaGVTdWJ0cmVlIiwiZ2V0SW5uZXJDaGlsZCIsIm9uVXBkYXRlZCIsInJhd1ZOb2RlIiwiY2FjaGVkVk5vZGUiLCJwYXJzZUludCIsIktlZXBBbGl2ZSIsInBhdHRlcm4iLCJ0ZXN0Iiwib25BY3RpdmF0ZWQiLCJyZWdpc3RlcktlZXBBbGl2ZUhvb2siLCJvbkRlYWN0aXZhdGVkIiwid3JhcHBlZEhvb2siLCJfX3dkYyIsImluamVjdEhvb2siLCJpbmplY3RUb0tlZXBBbGl2ZVJvb3QiLCJrZWVwQWxpdmVSb290IiwiaW5qZWN0ZWQiLCJvblVubW91bnRlZCIsInByZXBlbmQiLCJfX3dlaCIsInVuc2hpZnQiLCJhcGlOYW1lIiwiY3JlYXRlSG9vayIsImxpZmVjeWNsZSIsIm9uQmVmb3JlTW91bnQiLCJvbkJlZm9yZVVwZGF0ZSIsIm9uU2VydmVyUHJlZmV0Y2giLCJvblJlbmRlclRyaWdnZXJlZCIsIm9uUmVuZGVyVHJhY2tlZCIsIm9uRXJyb3JDYXB0dXJlZCIsIkNPTVBPTkVOVFMiLCJESVJFQ1RJVkVTIiwicmVzb2x2ZUNvbXBvbmVudCIsIm1heWJlU2VsZlJlZmVyZW5jZSIsInJlc29sdmVBc3NldCIsIk5VTExfRFlOQU1JQ19DT01QT05FTlQiLCJmb3IiLCJyZXNvbHZlRHluYW1pY0NvbXBvbmVudCIsInJlc29sdmVEaXJlY3RpdmUiLCJ3YXJuTWlzc2luZyIsInNlbGZOYW1lIiwiZXh0cmEiLCJyZWdpc3RyeSIsInJlbmRlckxpc3QiLCJyZW5kZXJJdGVtIiwiaXNJbnRlZ2VyIiwiZnJvbSIsImNyZWF0ZVNsb3RzIiwiZHluYW1pY1Nsb3RzIiwic2xvdCIsImoiLCJyZW5kZXJTbG90Iiwibm9TbG90dGVkIiwiaXNDRSIsInZhbGlkU2xvdENvbnRlbnQiLCJlbnN1cmVWYWxpZFZOb2RlIiwicmVuZGVyZWQiLCJjcmVhdGVCbG9jayIsIl8iLCJzY29wZUlkIiwidm5vZGVzIiwidG9IYW5kbGVycyIsInByZXNlcnZlQ2FzZUlmTmVjZXNzYXJ5IiwiZ2V0UHVibGljSW5zdGFuY2UiLCJpc1N0YXRlZnVsQ29tcG9uZW50IiwicHVibGljUHJvcGVydGllc01hcCIsIiQiLCIkZWwiLCIkZGF0YSIsIiRwcm9wcyIsIiRhdHRycyIsIiRzbG90cyIsIiRyZWZzIiwicmVmcyIsIiRwYXJlbnQiLCIkcm9vdCIsIiRlbWl0IiwiJG9wdGlvbnMiLCJyZXNvbHZlTWVyZ2VkT3B0aW9ucyIsIiRmb3JjZVVwZGF0ZSIsImYiLCIkbmV4dFRpY2siLCIkd2F0Y2giLCJpc1Jlc2VydmVkUHJlZml4IiwiaGFzU2V0dXBCaW5kaW5nIiwiX19pc1NjcmlwdFNldHVwIiwiUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzIiwiYWNjZXNzQ2FjaGUiLCJub3JtYWxpemVkUHJvcHMiLCJzaG91bGRDYWNoZUFjY2VzcyIsInB1YmxpY0dldHRlciIsImNzc01vZHVsZSIsImdsb2JhbFByb3BlcnRpZXMiLCJfX2Nzc01vZHVsZXMiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJSdW50aW1lQ29tcGlsZWRQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMiLCJ1bnNjb3BhYmxlcyIsImNyZWF0ZURldlJlbmRlckNvbnRleHQiLCJleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dCIsImV4cG9zZVNldHVwU3RhdGVPblJlbmRlckNvbnRleHQiLCJ3YXJuUnVudGltZVVzYWdlIiwiZGVmaW5lUHJvcHMiLCJkZWZpbmVFbWl0cyIsImRlZmluZUV4cG9zZSIsImV4cG9zZWQiLCJkZWZpbmVPcHRpb25zIiwiZGVmaW5lU2xvdHMiLCJkZWZpbmVNb2RlbCIsIndpdGhEZWZhdWx0cyIsImRlZmF1bHRzIiwidXNlU2xvdHMiLCJnZXRDb250ZXh0IiwidXNlQXR0cnMiLCJ1c2VNb2RlbCIsImxvY2FsIiwic2V0dXBDb250ZXh0IiwiY3JlYXRlU2V0dXBDb250ZXh0Iiwibm9ybWFsaXplUHJvcHNPckVtaXRzIiwicmVkdWNlIiwibWVyZ2VEZWZhdWx0cyIsIm9wdCIsInNraXBGYWN0b3J5IiwibWVyZ2VNb2RlbHMiLCJjcmVhdGVQcm9wc1Jlc3RQcm94eSIsImV4Y2x1ZGVkS2V5cyIsIndpdGhBc3luY0NvbnRleHQiLCJnZXRBd2FpdGFibGUiLCJhd2FpdGFibGUiLCJjcmVhdGVEdXBsaWNhdGVDaGVja2VyIiwiYXBwbHlPcHRpb25zIiwiYmVmb3JlQ3JlYXRlIiwiZGF0YU9wdGlvbnMiLCJjb21wdXRlZE9wdGlvbnMiLCJtZXRob2RzIiwid2F0Y2hPcHRpb25zIiwicHJvdmlkZSIsInByb3ZpZGVPcHRpb25zIiwiaW5qZWN0IiwiaW5qZWN0T3B0aW9ucyIsImNyZWF0ZWQiLCJiZWZvcmVNb3VudCIsImJlZm9yZVVwZGF0ZSIsImFjdGl2YXRlZCIsImRlYWN0aXZhdGVkIiwiYmVmb3JlRGVzdHJveSIsImJlZm9yZVVubW91bnQiLCJkZXN0cm95ZWQiLCJ1bm1vdW50ZWQiLCJyZW5kZXJUcmFja2VkIiwicmVuZGVyVHJpZ2dlcmVkIiwiZXJyb3JDYXB0dXJlZCIsInNlcnZlclByZWZldGNoIiwiZXhwb3NlIiwiY29tcG9uZW50cyIsImZpbHRlcnMiLCJjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMiLCJyZXNvbHZlSW5qZWN0aW9ucyIsIm1ldGhvZEhhbmRsZXIiLCJ3cml0YWJsZSIsImNyZWF0ZVdhdGNoZXIiLCJwcm92aWRlcyIsInJlZ2lzdGVyTGlmZWN5Y2xlSG9vayIsInJlZ2lzdGVyIiwiX2hvb2siLCJub3JtYWxpemVJbmplY3QiLCJoIiwiYmFzZSIsImV4dGVuZHNPcHRpb25zIiwiZ2xvYmFsTWl4aW5zIiwib3B0aW9uTWVyZ2VTdHJhdGVnaWVzIiwicmVzb2x2ZWQiLCJtZXJnZU9wdGlvbnMiLCJ0byIsInN0cmF0cyIsInN0cmF0IiwiaW50ZXJuYWxPcHRpb25NZXJnZVN0cmF0cyIsIm1lcmdlRGF0YUZuIiwibWVyZ2VFbWl0c09yUHJvcHNPcHRpb25zIiwibWVyZ2VPYmplY3RPcHRpb25zIiwibWVyZ2VBc0FycmF5IiwibWVyZ2VXYXRjaE9wdGlvbnMiLCJtZXJnZUluamVjdCIsIm1lcmdlZERhdGFGbiIsIm1lcmdlZCIsImNyZWF0ZUFwcENvbnRleHQiLCJpc05hdGl2ZVRhZyIsImNvbXBpbGVyT3B0aW9ucyIsInVpZCQxIiwiY3JlYXRlQXBwQVBJIiwiY3JlYXRlQXBwIiwicm9vdENvbXBvbmVudCIsInJvb3RQcm9wcyIsImNvbnRleHQiLCJpbnN0YWxsZWRQbHVnaW5zIiwiV2Vha1NldCIsIl91aWQiLCJfY29tcG9uZW50IiwiX3Byb3BzIiwiX2NvbnRhaW5lciIsIl9jb250ZXh0IiwiX2luc3RhbmNlIiwidXNlIiwiaW5zdGFsbCIsIm1peGluIiwidmFsaWRhdGVDb21wb25lbnROYW1lIiwiZGlyZWN0aXZlIiwibW91bnQiLCJyb290Q29udGFpbmVyIiwiaXNIeWRyYXRlIiwiX192dWVfYXBwX18iLCJydW5XaXRoQ29udGV4dCIsImN1cnJlbnRBcHAiLCJwYXJlbnRQcm92aWRlcyIsInRyZWF0RGVmYXVsdEFzRmFjdG9yeSIsImhhc0luamVjdGlvbkNvbnRleHQiLCJpbml0UHJvcHMiLCJpc1N0YXRlZnVsIiwiSW50ZXJuYWxPYmplY3RLZXkiLCJwcm9wc0RlZmF1bHRzIiwic2V0RnVsbFByb3BzIiwidmFsaWRhdGVQcm9wcyIsImlzSW5IbXJDb250ZXh0IiwidXBkYXRlUHJvcHMiLCJyYXdQcmV2UHJvcHMiLCJyYXdDdXJyZW50UHJvcHMiLCJoYXNBdHRyc0NoYW5nZWQiLCJwcm9wc1RvVXBkYXRlIiwiY2FtZWxpemVkS2V5IiwicmVzb2x2ZVByb3BWYWx1ZSIsImtlYmFiS2V5IiwibmVlZENhc3RLZXlzIiwicmF3Q2FzdFZhbHVlcyIsImNhbWVsS2V5IiwiY2FzdFZhbHVlcyIsImlzQWJzZW50IiwiaGFzRGVmYXVsdCIsIm5vcm1hbGl6ZVByb3BzT3B0aW9ucyIsImV4dGVuZFByb3BzIiwibm9ybWFsaXplZEtleSIsInZhbGlkYXRlUHJvcE5hbWUiLCJib29sZWFuSW5kZXgiLCJnZXRUeXBlSW5kZXgiLCJzdHJpbmdJbmRleCIsImdldFR5cGUiLCJjdG9yIiwibWF0Y2giLCJ0b1N0cmluZyIsImlzU2FtZVR5cGUiLCJleHBlY3RlZFR5cGVzIiwiZmluZEluZGV4IiwidCIsInJlc29sdmVkVmFsdWVzIiwidmFsaWRhdGVQcm9wIiwicmVxdWlyZWQiLCJza2lwQ2hlY2siLCJ0eXBlcyIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlIiwiYXNzZXJ0VHlwZSIsImdldEludmFsaWRUeXBlTWVzc2FnZSIsImlzU2ltcGxlVHlwZSIsIm1lc3NhZ2UiLCJyZWNlaXZlZFR5cGUiLCJleHBlY3RlZFZhbHVlIiwic3R5bGVWYWx1ZSIsInJlY2VpdmVkVmFsdWUiLCJpc0V4cGxpY2FibGUiLCJpc0Jvb2xlYW4iLCJleHBsaWNpdFR5cGVzIiwiZWxlbSIsImlzSW50ZXJuYWxLZXkiLCJub3JtYWxpemVTbG90VmFsdWUiLCJub3JtYWxpemVTbG90IiwicmF3U2xvdCIsIm5vcm1hbGl6ZU9iamVjdFNsb3RzIiwicmF3U2xvdHMiLCJfY3R4Iiwibm9ybWFsaXplVk5vZGVTbG90cyIsImluaXRTbG90cyIsInVwZGF0ZVNsb3RzIiwibmVlZERlbGV0aW9uQ2hlY2siLCJkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQiLCJzZXRSZWYiLCJyYXdSZWYiLCJvbGRSYXdSZWYiLCJpc1VubW91bnQiLCJyZWZWYWx1ZSIsIm93bmVyIiwib2xkUmVmIiwiX2lzU3RyaW5nIiwiX2lzUmVmIiwiZG9TZXQiLCJleGlzdGluZyIsImsiLCJoYXNNaXNtYXRjaCIsImlzU1ZHQ29udGFpbmVyIiwibmFtZXNwYWNlVVJJIiwidGFnTmFtZSIsImlzQ29tbWVudCIsIm5vZGVUeXBlIiwiY3JlYXRlSHlkcmF0aW9uRnVuY3Rpb25zIiwibXQiLCJtb3VudENvbXBvbmVudCIsInBhdGNoUHJvcCIsImNyZWF0ZVRleHQiLCJuZXh0U2libGluZyIsImluc2VydCIsImNyZWF0ZUNvbW1lbnQiLCJoYXNDaGlsZE5vZGVzIiwiX3Zub2RlIiwiZmlyc3RDaGlsZCIsImlzRnJhZ21lbnRTdGFydCIsIm9uTWlzbWF0Y2giLCJoYW5kbGVNaXNtYXRjaCIsImRvbVR5cGUiLCJuZXh0Tm9kZSIsImNvbnRlbnQiLCJyZXBsYWNlTm9kZSIsIm5lZWRUb0Fkb3B0Q29udGVudCIsInN0YXRpY0NvdW50Iiwib3V0ZXJIVE1MIiwiaHlkcmF0ZUZyYWdtZW50IiwiaXNUZW1wbGF0ZU5vZGUiLCJoeWRyYXRlRWxlbWVudCIsImxvY2F0ZUNsb3NpbmdBbmNob3IiLCJwcmV2aW91c1NpYmxpbmciLCJsYXN0Q2hpbGQiLCJjcmVhdGVUZXh0Vk5vZGUiLCJoeWRyYXRlQ2hpbGRyZW4iLCJmb3JjZVBhdGNoVmFsdWUiLCJlbmRzV2l0aCIsIm9uQ2xpY2siLCJ2bm9kZUhvb2tzIiwib25Wbm9kZUJlZm9yZU1vdW50IiwibmVlZENhbGxUcmFuc2l0aW9uSG9va3MiLCJuZWVkVHJhbnNpdGlvbiIsImlubmVySFRNTCIsInRleHRDb250ZW50IiwicGFyZW50Vk5vZGUiLCJmcmFnbWVudFNsb3RTY29wZUlkcyIsImlzRnJhZ21lbnQiLCJuZXh0MiIsIm5ld05vZGUiLCJvbGROb2RlIiwicGFyZW50Tm9kZTIiLCJyZXBsYWNlQ2hpbGQiLCJzdGFydE1lYXN1cmUiLCJpc1N1cHBvcnRlZCIsIm1hcmsiLCJlbmRNZWFzdXJlIiwic3RhcnRUYWciLCJlbmRUYWciLCJtZWFzdXJlIiwiY2xlYXJNYXJrcyIsImluaXRGZWF0dXJlRmxhZ3MiLCJuZWVkV2FybiIsIm11bHRpIiwiY3JlYXRlUmVuZGVyZXIiLCJiYXNlQ3JlYXRlUmVuZGVyZXIiLCJjcmVhdGVIeWRyYXRpb25SZW5kZXJlciIsImNyZWF0ZUh5ZHJhdGlvbkZucyIsIl9fVlVFX18iLCJob3N0SW5zZXJ0IiwiaG9zdFJlbW92ZSIsImhvc3RQYXRjaFByb3AiLCJob3N0Q3JlYXRlRWxlbWVudCIsImhvc3RDcmVhdGVUZXh0IiwiaG9zdENyZWF0ZUNvbW1lbnQiLCJzZXRUZXh0IiwiaG9zdFNldFRleHQiLCJzZXRFbGVtZW50VGV4dCIsImhvc3RTZXRFbGVtZW50VGV4dCIsImhvc3RQYXJlbnROb2RlIiwiaG9zdE5leHRTaWJsaW5nIiwic2V0U2NvcGVJZCIsImhvc3RTZXRTY29wZUlkIiwiaW5zZXJ0U3RhdGljQ29udGVudCIsImhvc3RJbnNlcnRTdGF0aWNDb250ZW50IiwiZ2V0TmV4dEhvc3ROb2RlIiwicHJvY2Vzc1RleHQiLCJwcm9jZXNzQ29tbWVudE5vZGUiLCJtb3VudFN0YXRpY05vZGUiLCJwYXRjaFN0YXRpY05vZGUiLCJwcm9jZXNzRnJhZ21lbnQiLCJwcm9jZXNzRWxlbWVudCIsInByb2Nlc3NDb21wb25lbnQiLCJpbnRlcm5hbHMiLCJyZW1vdmVTdGF0aWNOb2RlIiwibW92ZVN0YXRpY05vZGUiLCJtb3VudEVsZW1lbnQiLCJwYXRjaEVsZW1lbnQiLCJpcyIsIm1vdW50Q2hpbGRyZW4iLCJ1bm1vdW50Q2hpbGRyZW4iLCJjbG9uZUlmTW91bnRlZCIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJ0b2dnbGVSZWN1cnNlIiwib25Wbm9kZUJlZm9yZVVwZGF0ZSIsImFyZUNoaWxkcmVuU1ZHIiwicGF0Y2hCbG9ja0NoaWxkcmVuIiwidHJhdmVyc2VTdGF0aWNDaGlsZHJlbiIsInBhdGNoQ2hpbGRyZW4iLCJwYXRjaFByb3BzIiwiY2xhc3MiLCJzdHlsZSIsIm9uVm5vZGVVcGRhdGVkIiwib2xkQ2hpbGRyZW4iLCJuZXdDaGlsZHJlbiIsImZhbGxiYWNrQ29udGFpbmVyIiwib2xkVk5vZGUiLCJuZXdWTm9kZSIsImZyYWdtZW50U3RhcnRBbmNob3IiLCJmcmFnbWVudEVuZEFuY2hvciIsInVwZGF0ZUNvbXBvbmVudCIsImluaXRpYWxWTm9kZSIsImNyZWF0ZUNvbXBvbmVudEluc3RhbmNlIiwic2V0dXBDb21wb25lbnQiLCJ1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIiLCJjb21wb25lbnRVcGRhdGVGbiIsImJtIiwiaXNBc3luY1dyYXBwZXJWTm9kZSIsImh5ZHJhdGVTdWJUcmVlIiwic2NvcGVkSW5pdGlhbFZOb2RlIiwiYnUiLCJ1Iiwib3JpZ2luTmV4dCIsIm5leHRUcmVlIiwicHJldlRyZWUiLCJydGMiLCJydGciLCJjMSIsInByZXZTaGFwZUZsYWciLCJjMiIsInBhdGNoS2V5ZWRDaGlsZHJlbiIsInBhdGNoVW5rZXllZENoaWxkcmVuIiwib2xkTGVuZ3RoIiwiY29tbW9uTGVuZ3RoIiwiTWF0aCIsIm1pbiIsIm5leHRDaGlsZCIsInBhcmVudEFuY2hvciIsImwyIiwiZTEiLCJlMiIsIm5leHRQb3MiLCJzMSIsInMyIiwia2V5VG9OZXdJbmRleE1hcCIsInBhdGNoZWQiLCJ0b0JlUGF0Y2hlZCIsIm1vdmVkIiwibWF4TmV3SW5kZXhTb0ZhciIsIm5ld0luZGV4VG9PbGRJbmRleE1hcCIsInByZXZDaGlsZCIsIm5ld0luZGV4IiwiaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UiLCJnZXRTZXF1ZW5jZSIsIm5leHRJbmRleCIsIm1vdmVUeXBlIiwibmVlZFRyYW5zaXRpb24yIiwicmVtb3ZlMiIsInBlcmZvcm1MZWF2ZSIsInNob3VsZEludm9rZURpcnMiLCJzaG91bGRJbnZva2VWbm9kZUhvb2siLCJvblZub2RlQmVmb3JlVW5tb3VudCIsInVubW91bnRDb21wb25lbnQiLCJyZW1vdmVGcmFnbWVudCIsInBlcmZvcm1SZW1vdmUiLCJidW0iLCJtYyIsInBjIiwicGJjIiwiYWxsb3dlZCIsImNoMSIsImNoMiIsImxlbiIsImFyckkiLCJpc1RlbGVwb3J0IiwiX19pc1RlbGVwb3J0IiwiaXNUZWxlcG9ydERpc2FibGVkIiwiZGlzYWJsZWQiLCJpc1RhcmdldFNWRyIsIlNWR0VsZW1lbnQiLCJyZXNvbHZlVGFyZ2V0Iiwic2VsZWN0IiwidGFyZ2V0U2VsZWN0b3IiLCJUZWxlcG9ydEltcGwiLCJxdWVyeVNlbGVjdG9yIiwibWFpbkFuY2hvciIsInRhcmdldEFuY2hvciIsIndhc0Rpc2FibGVkIiwiY3VycmVudENvbnRhaW5lciIsImN1cnJlbnRBbmNob3IiLCJtb3ZlVGVsZXBvcnQiLCJuZXh0VGFyZ2V0IiwidXBkYXRlQ3NzVmFycyIsInNob3VsZFJlbW92ZSIsImh5ZHJhdGVUZWxlcG9ydCIsImlzUmVvcmRlciIsInRhcmdldE5vZGUiLCJfbHBhIiwiVGVsZXBvcnQiLCJ1dCIsInNldEF0dHJpYnV0ZSIsImRpc2FibGVUcmFja2luZyIsInNldHVwQmxvY2siLCJjcmVhdGVFbGVtZW50QmxvY2siLCJjcmVhdGVCYXNlVk5vZGUiLCJfX3ZfaXNWTm9kZSIsInZub2RlQXJnc1RyYW5zZm9ybWVyIiwidHJhbnNmb3JtVk5vZGVBcmdzIiwidHJhbnNmb3JtZXIiLCJjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtIiwiX2NyZWF0ZVZOb2RlIiwibm9ybWFsaXplS2V5Iiwibm9ybWFsaXplUmVmIiwicmVmX2tleSIsInJlZl9mb3IiLCJpc0Jsb2NrTm9kZSIsIm5lZWRGdWxsQ2hpbGRyZW5Ob3JtYWxpemF0aW9uIiwiX192X3NraXAiLCJub3JtYWxpemVDaGlsZHJlbiIsImNsb25lZCIsImd1YXJkUmVhY3RpdmVQcm9wcyIsImtsYXNzIiwiZXh0cmFQcm9wcyIsIm1lcmdlUmVmIiwibWVyZ2VkUHJvcHMiLCJtZXJnZVByb3BzIiwiZGVlcENsb25lVk5vZGUiLCJ0ZXh0IiwiZmxhZyIsImNyZWF0ZVN0YXRpY1ZOb2RlIiwibnVtYmVyT2ZOb2RlcyIsImNyZWF0ZUNvbW1lbnRWTm9kZSIsImFzQmxvY2siLCJtZW1vIiwic2xvdEZsYWciLCJ0b01lcmdlIiwiaW5jb21pbmciLCJlbXB0eUFwcENvbnRleHQiLCJleHBvc2VQcm94eSIsImF0dHJzUHJveHkiLCJzbG90c1Byb3h5IiwiYmMiLCJzcCIsImludGVybmFsU2V0Q3VycmVudEluc3RhbmNlIiwiZ2xvYmFsQ3VycmVudEluc3RhbmNlU2V0dGVycyIsInNldHRlcnNLZXkiLCJpc0J1aWx0SW5UYWciLCJhcHBJc05hdGl2ZVRhZyIsInNldHVwUmVzdWx0Iiwic2V0dXBTdGF0ZWZ1bENvbXBvbmVudCIsIm5hbWVzIiwiaXNSdW50aW1lT25seSIsInJlc29sdmVkUmVzdWx0IiwiZmluaXNoQ29tcG9uZW50U2V0dXAiLCJfX3NzcklubGluZVJlbmRlciIsInNzclJlbmRlciIsImRldnRvb2xzUmF3U2V0dXBTdGF0ZSIsImNvbXBpbGUiLCJpbnN0YWxsV2l0aFByb3h5IiwicmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIiLCJfY29tcGlsZSIsIl9yYyIsInNraXBPcHRpb25zIiwidGVtcGxhdGUiLCJpc0N1c3RvbUVsZW1lbnQiLCJkZWxpbWl0ZXJzIiwiY29tcG9uZW50Q29tcGlsZXJPcHRpb25zIiwiZmluYWxDb21waWxlck9wdGlvbnMiLCJnZXRBdHRyc1Byb3h5IiwiZ2V0U2xvdHNQcm94eSIsImV4cG9zZWRUeXBlIiwiZnJlZXplIiwiY2xhc3NpZnlSRSIsImNsYXNzaWZ5Iiwic3RyIiwidG9VcHBlckNhc2UiLCJpbmNsdWRlSW5mZXJyZWQiLCJkaXNwbGF5TmFtZSIsIl9fbmFtZSIsIl9fZmlsZSIsImluZmVyRnJvbVJlZ2lzdHJ5IiwicHJvcHNPckNoaWxkcmVuIiwicHJvdG90eXBlIiwic3NyQ29udGV4dEtleSIsImluaXRDdXN0b21Gb3JtYXR0ZXIiLCJ2dWVTdHlsZSIsIm51bWJlclN0eWxlIiwic3RyaW5nU3R5bGUiLCJrZXl3b3JkU3R5bGUiLCJmb3JtYXR0ZXIiLCJoZWFkZXIiLCJfX2lzVnVlIiwiZ2VuUmVmRmxhZyIsImZvcm1hdFZhbHVlIiwiaGFzQm9keSIsImJvZHkiLCJmb3JtYXRJbnN0YW5jZSIsImJsb2NrcyIsImNyZWF0ZUluc3RhbmNlQmxvY2siLCJleHRyYWN0S2V5cyIsImFzUmF3IiwiQ29tcCIsImV4dHJhY3RlZCIsImlzS2V5T2ZUeXBlIiwib3B0cyIsImRldnRvb2xzRm9ybWF0dGVycyIsIndpdGhNZW1vIiwiaXNNZW1vU2FtZSIsIl9zc3JVdGlscyIsInNzclV0aWxzIiwicmVzb2x2ZUZpbHRlciIsImNvbXBhdFV0aWxzIiwiY3JlYXRlRWxlbWVudFZOb2RlIiwiaXNTcGVjaWFsQm9vbGVhbkF0dHIiLCJpbmNsdWRlQm9vbGVhbkF0dHIiLCJjYW1lbGl6ZSQxIiwibG9vc2VJbmRleE9mIiwibG9vc2VFcXVhbCIsImlzSFRNTFRhZyIsImlzU1ZHVGFnIiwic3ZnTlMiLCJkb2MiLCJ0ZW1wbGF0ZUNvbnRhaW5lciIsIm5vZGVPcHMiLCJpbnNlcnRCZWZvcmUiLCJyZW1vdmVDaGlsZCIsInRhZyIsImNyZWF0ZUVsZW1lbnROUyIsIm11bHRpcGxlIiwiY3JlYXRlVGV4dE5vZGUiLCJub2RlVmFsdWUiLCJzZWxlY3RvciIsImJlZm9yZSIsImNsb25lTm9kZSIsIndyYXBwZXIiLCJhcHBlbmRDaGlsZCIsIlRSQU5TSVRJT04iLCJBTklNQVRJT04iLCJ2dGNLZXkiLCJUcmFuc2l0aW9uIiwicmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyIsIkRPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMiLCJjc3MiLCJkdXJhdGlvbiIsImVudGVyRnJvbUNsYXNzIiwiZW50ZXJBY3RpdmVDbGFzcyIsImVudGVyVG9DbGFzcyIsImFwcGVhckZyb21DbGFzcyIsImFwcGVhckFjdGl2ZUNsYXNzIiwiYXBwZWFyVG9DbGFzcyIsImxlYXZlRnJvbUNsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsImxlYXZlVG9DbGFzcyIsIlRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMiLCJoMiIsImhhc0V4cGxpY2l0Q2FsbGJhY2siLCJiYXNlUHJvcHMiLCJkdXJhdGlvbnMiLCJub3JtYWxpemVEdXJhdGlvbiIsImVudGVyRHVyYXRpb24iLCJsZWF2ZUR1cmF0aW9uIiwiZmluaXNoRW50ZXIiLCJpc0FwcGVhciIsInJlbW92ZVRyYW5zaXRpb25DbGFzcyIsImZpbmlzaExlYXZlIiwiX2lzTGVhdmluZyIsIm1ha2VFbnRlckhvb2siLCJuZXh0RnJhbWUiLCJhZGRUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJmb3JjZVJlZmxvdyIsIk51bWJlck9mIiwiY2xzIiwiY2xhc3NMaXN0IiwiX3Z0YyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImVuZElkIiwiZXhwbGljaXRUaW1lb3V0IiwiX2VuZElkIiwicmVzb2x2ZUlmTm90U3RhbGUiLCJwcm9wQ291bnQiLCJnZXRUcmFuc2l0aW9uSW5mbyIsImVuZEV2ZW50IiwiZW5kZWQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib25FbmQiLCJhZGRFdmVudExpc3RlbmVyIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFN0eWxlUHJvcGVydGllcyIsInRyYW5zaXRpb25EZWxheXMiLCJ0cmFuc2l0aW9uRHVyYXRpb25zIiwidHJhbnNpdGlvblRpbWVvdXQiLCJnZXRUaW1lb3V0IiwiYW5pbWF0aW9uRGVsYXlzIiwiYW5pbWF0aW9uRHVyYXRpb25zIiwiYW5pbWF0aW9uVGltZW91dCIsImhhc1RyYW5zZm9ybSIsImRlbGF5cyIsImQiLCJ0b01zIiwib2Zmc2V0SGVpZ2h0IiwicGF0Y2hDbGFzcyIsInRyYW5zaXRpb25DbGFzc2VzIiwicmVtb3ZlQXR0cmlidXRlIiwiY2xhc3NOYW1lIiwidlNob3dPbGRLZXkiLCJ2U2hvdyIsImRpc3BsYXkiLCJzZXREaXNwbGF5IiwiaW5pdFZTaG93Rm9yU1NSIiwiZ2V0U1NSUHJvcHMiLCJwYXRjaFN0eWxlIiwiaXNDc3NTdHJpbmciLCJzZXRTdHlsZSIsImN1cnJlbnREaXNwbGF5IiwiY3NzVGV4dCIsInNlbWljb2xvblJFIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wZXJ0eSIsInByZWZpeGVkIiwiYXV0b1ByZWZpeCIsInByZWZpeGVzIiwicHJlZml4Q2FjaGUiLCJyYXdOYW1lIiwieGxpbmtOUyIsInBhdGNoQXR0ciIsInJlbW92ZUF0dHJpYnV0ZU5TIiwic2V0QXR0cmlidXRlTlMiLCJwYXRjaERPTVByb3AiLCJnZXRBdHRyaWJ1dGUiLCJuZWVkUmVtb3ZlIiwidmVpS2V5IiwicGF0Y2hFdmVudCIsInByZXZWYWx1ZSIsIm5leHRWYWx1ZSIsImludm9rZXJzIiwiZXhpc3RpbmdJbnZva2VyIiwicGFyc2VOYW1lIiwiaW52b2tlciIsImNyZWF0ZUludm9rZXIiLCJvcHRpb25zTW9kaWZpZXJSRSIsImNhY2hlZE5vdyIsImdldE5vdyIsImluaXRpYWxWYWx1ZSIsIl92dHMiLCJhdHRhY2hlZCIsInBhdGNoU3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwib3JpZ2luYWxTdG9wIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiX3N0b3BwZWQiLCJuYXRpdmVPblJFIiwic2hvdWxkU2V0QXNQcm9wIiwiX3RydWVWYWx1ZSIsIl9mYWxzZVZhbHVlIiwiZGVmaW5lQ3VzdG9tRWxlbWVudCIsImh5ZHJhdGUyIiwiVnVlQ3VzdG9tRWxlbWVudCIsIlZ1ZUVsZW1lbnQiLCJpbml0aWFsUHJvcHMiLCJkZWZpbmVTU1JDdXN0b21FbGVtZW50IiwiQmFzZUNsYXNzIiwiX2RlZiIsIl9jb25uZWN0ZWQiLCJfcmVzb2x2ZWQiLCJfbnVtYmVyUHJvcHMiLCJfb2IiLCJzaGFkb3dSb290IiwiYXR0YWNoU2hhZG93IiwiX3Jlc29sdmVQcm9wcyIsImNvbm5lY3RlZENhbGxiYWNrIiwiX3VwZGF0ZSIsIl9yZXNvbHZlRGVmIiwiZGlzY29ubmVjdGVkQ2FsbGJhY2siLCJkaXNjb25uZWN0IiwiYXR0cmlidXRlcyIsIl9zZXRBdHRyIiwiTXV0YXRpb25PYnNlcnZlciIsIm11dGF0aW9ucyIsImF0dHJpYnV0ZU5hbWUiLCJvYnNlcnZlIiwiaXNBc3luYyIsIm51bWJlclByb3BzIiwiX2FwcGx5U3R5bGVzIiwiYXN5bmNEZWYiLCJkZWNsYXJlZFByb3BLZXlzIiwiX3NldFByb3AiLCJfZ2V0UHJvcCIsInNob3VsZFJlZmxlY3QiLCJzaG91bGRVcGRhdGUiLCJuZXdTdHlsZXMiLCJfc3R5bGVzIiwiZGlzcGF0Y2giLCJkaXNwYXRjaEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJob3N0IiwidXNlQ3NzTW9kdWxlIiwibW9kdWxlcyIsIm1vZCIsInVzZUNzc1ZhcnMiLCJ1cGRhdGVUZWxlcG9ydHMiLCJ2YXJzIiwicXVlcnlTZWxlY3RvckFsbCIsInNldFZhcnNPbk5vZGUiLCJzZXRWYXJzIiwic2V0VmFyc09uVk5vZGUiLCJvYiIsImNoaWxkTGlzdCIsInBvc2l0aW9uTWFwIiwibmV3UG9zaXRpb25NYXAiLCJtb3ZlQ2JLZXkiLCJUcmFuc2l0aW9uR3JvdXBJbXBsIiwibW92ZUNsYXNzIiwiaGFzQ1NTVHJhbnNmb3JtIiwiY2FsbFBlbmRpbmdDYnMiLCJyZWNvcmRQb3NpdGlvbiIsIm1vdmVkQ2hpbGRyZW4iLCJhcHBseVRyYW5zbGF0aW9uIiwidHJhbnNmb3JtIiwid2Via2l0VHJhbnNmb3JtIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwicHJvcGVydHlOYW1lIiwiY3NzVHJhbnNpdGlvblByb3BzIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicmVtb3ZlTW9kZSIsIlRyYW5zaXRpb25Hcm91cCIsIm9sZFBvcyIsIm5ld1BvcyIsImR4IiwibGVmdCIsImR5IiwidG9wIiwiZ2V0TW9kZWxBc3NpZ25lciIsIm9uQ29tcG9zaXRpb25TdGFydCIsImNvbXBvc2luZyIsIm9uQ29tcG9zaXRpb25FbmQiLCJFdmVudCIsImFzc2lnbktleSIsInZNb2RlbFRleHQiLCJjYXN0VG9OdW1iZXIiLCJkb21WYWx1ZSIsImFjdGl2ZUVsZW1lbnQiLCJ2TW9kZWxDaGVja2JveCIsIm1vZGVsVmFsdWUiLCJfbW9kZWxWYWx1ZSIsImVsZW1lbnRWYWx1ZSIsImdldFZhbHVlIiwiY2hlY2tlZCIsImZvdW5kIiwiZmlsdGVyZWQiLCJnZXRDaGVja2JveFZhbHVlIiwic2V0Q2hlY2tlZCIsInZNb2RlbFJhZGlvIiwidk1vZGVsU2VsZWN0IiwiaXNTZXRNb2RlbCIsInNlbGVjdGVkVmFsIiwic2VsZWN0ZWQiLCJzZXRTZWxlY3RlZCIsIl9iaW5kaW5nIiwiaXNNdWx0aXBsZSIsIm9wdGlvbiIsIm9wdGlvblZhbHVlIiwic2VsZWN0ZWRJbmRleCIsInZNb2RlbER5bmFtaWMiLCJjYWxsTW9kZWxIb29rIiwicmVzb2x2ZUR5bmFtaWNNb2RlbCIsIm1vZGVsVG9Vc2UiLCJpbml0Vk1vZGVsRm9yU1NSIiwic3lzdGVtTW9kaWZpZXJzIiwibW9kaWZpZXJHdWFyZHMiLCJzdG9wUHJvcGFnYXRpb24iLCJwcmV2ZW50IiwicHJldmVudERlZmF1bHQiLCJjdXJyZW50VGFyZ2V0IiwiY3RybCIsImN0cmxLZXkiLCJzaGlmdCIsInNoaWZ0S2V5IiwiYWx0IiwiYWx0S2V5IiwibWV0YSIsIm1ldGFLZXkiLCJidXR0b24iLCJyaWdodCIsImV4YWN0Iiwid2l0aE1vZGlmaWVycyIsImd1YXJkIiwia2V5TmFtZXMiLCJlc2MiLCJzcGFjZSIsInVwIiwiZG93biIsIndpdGhLZXlzIiwiZXZlbnRLZXkiLCJyZW5kZXJlck9wdGlvbnMiLCJlbmFibGVkSHlkcmF0aW9uIiwiZW5zdXJlUmVuZGVyZXIiLCJlbnN1cmVIeWRyYXRpb25SZW5kZXJlciIsImluamVjdE5hdGl2ZVRhZ0NoZWNrIiwiaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2siLCJjb250YWluZXJPclNlbGVjdG9yIiwibm9ybWFsaXplQ29udGFpbmVyIiwiRWxlbWVudCIsImNyZWF0ZVNTUkFwcCIsIlNoYWRvd1Jvb3QiLCJzc3JEaXJlY3RpdmVJbml0aWFsaXplZCIsImluaXREaXJlY3RpdmVzRm9yU1NSIiwiZXhwZWN0c0xvd2VyQ2FzZSIsIm9uUkUiLCJ0b1R5cGVTdHJpbmciLCJpc0RhdGUiLCJvYmplY3RUb1N0cmluZyIsImNhY2hlU3RyaW5nRnVuY3Rpb24iLCJoaXQiLCJjYW1lbGl6ZVJFIiwiaHlwaGVuYXRlUkUiLCJjaGFyQXQiLCJmbnMiLCJwYXJzZUZsb2F0IiwiTmFOIiwiX2dsb2JhbFRoaXMiLCJnbG9iYWxUaGlzIiwiaWRlbnRSRSIsImdlblByb3BzQWNjZXNzRXhwIiwiUGF0Y2hGbGFnTmFtZXMiLCJzbG90RmxhZ3NUZXh0IiwiR0xPQkFMU19BTExPV0VEIiwiaXNHbG9iYWxseVdoaXRlbGlzdGVkIiwicmFuZ2UiLCJnZW5lcmF0ZUNvZGVGcmFtZSIsImxpbmVzIiwibmV3bGluZVNlcXVlbmNlcyIsImlkeCIsImxpbmUiLCJyZXBlYXQiLCJsaW5lTGVuZ3RoIiwibmV3TGluZVNlcUxlbmd0aCIsInBhZCIsInBhcnNlU3RyaW5nU3R5bGUiLCJsaXN0RGVsaW1pdGVyUkUiLCJwcm9wZXJ0eURlbGltaXRlclJFIiwic3R5bGVDb21tZW50UkUiLCJ0bXAiLCJzdHJpbmdpZnlTdHlsZSIsIkhUTUxfVEFHUyIsIlNWR19UQUdTIiwiVk9JRF9UQUdTIiwiaXNWb2lkVGFnIiwic3BlY2lhbEJvb2xlYW5BdHRycyIsImlzQm9vbGVhbkF0dHIiLCJ1bnNhZmVBdHRyQ2hhclJFIiwiYXR0clZhbGlkYXRpb25DYWNoZSIsImlzU1NSU2FmZUF0dHJOYW1lIiwiaXNVbnNhZmUiLCJwcm9wc1RvQXR0ck1hcCIsImFjY2VwdENoYXJzZXQiLCJodG1sRm9yIiwiaHR0cEVxdWl2IiwiaXNLbm93bkh0bWxBdHRyIiwiaXNLbm93blN2Z0F0dHIiLCJlc2NhcGVSRSIsImVzY2FwZUh0bWwiLCJzdHJpbmciLCJleGVjIiwiaHRtbCIsImVzY2FwZWQiLCJsYXN0SW5kZXgiLCJjaGFyQ29kZUF0IiwiY29tbWVudFN0cmlwUkUiLCJlc2NhcGVIdG1sQ29tbWVudCIsInNyYyIsImxvb3NlQ29tcGFyZUFycmF5cyIsImVxdWFsIiwiYVZhbGlkVHlwZSIsImJWYWxpZFR5cGUiLCJnZXRUaW1lIiwiYUtleXNDb3VudCIsImJLZXlzQ291bnQiLCJhSGFzS2V5IiwiYkhhc0tleSIsInJlcGxhY2VyIiwiZW50cmllcyIsInZhbDIiLCJleHBvcnRzIiwic2ZjIiwiX2NyZWF0ZUVsZW1lbnRCbG9jayIsIl9jb21wb25lbnRfcm91dGVyX3ZpZXciLCJpbml0RGV2Il0sInNvdXJjZVJvb3QiOiIifQ==